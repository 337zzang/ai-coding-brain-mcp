# -*- coding: utf-8 -*-
"""
AST Parser Helper - Refactored Version
Python: ast.parse() 기반 파싱
JavaScript/TypeScript: Tree-sitter 지연 로딩 파싱  
"""

import ast
import os
import time
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, cast
import textwrap
import re

# ============================================================================
# 전역 설정 및 캐시
# ============================================================================

# Tree-sitter 지연 로딩
TREE_SITTER_AVAILABLE = False
_tree_sitter_modules = {}
_advanced_parser = None
_parser_lock = threading.Lock()

# 로깅 설정
VERBOSE = False

def set_verbose(flag: bool) -> None:
    """전역 verbose 모드 설정"""
    global VERBOSE
    VERBOSE = flag

def get_verbose() -> bool:
    """현재 verbose 모드 상태 반환"""
    return VERBOSE

def _log(msg: str, level: str = "INFO") -> None:
    """조건부 로깅"""
    if VERBOSE:
        print(f"[{level}] {msg}")

# ============================================================================
# 통합 캐시 시스템
# ============================================================================

class CacheManager:
    """모든 캐시를 중앙에서 관리"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.ast_cache: Dict[str, Any] = {}
            self.file_mtime_cache: Dict[str, float] = {}
            self.language_cache: Dict[str, Any] = {}
            self.parser_cache: Dict[str, Any] = {}
            self.initialized = True
    
    def get_cached_ast(self, file_path: str) -> Optional[Any]:
        """캐시된 AST 반환"""
        if file_path not in self.ast_cache:
            return None
            
        # 파일 수정 시간 확인
        try:
            current_mtime = os.path.getmtime(file_path)
            cached_mtime = self.file_mtime_cache.get(file_path, 0)
            
            if current_mtime > cached_mtime:
                # 캐시 무효화
                del self.ast_cache[file_path]
                return None
                
            return self.ast_cache[file_path]
        except:
            return None
    
    def set_cached_ast(self, file_path: str, ast_data: Any):
        """AST 캐시 저장"""
        self.ast_cache[file_path] = ast_data
        self.file_mtime_cache[file_path] = os.path.getmtime(file_path)
    
    def clear_all(self):
        """모든 캐시 초기화"""
        self.ast_cache.clear()
        self.file_mtime_cache.clear()
        self.language_cache.clear()
        self.parser_cache.clear()

# ============================================================================
# Tree-sitter 지연 로딩
# ============================================================================

def _lazy_import_tree_sitter() -> bool:
    """Tree-sitter 모듈 지연 임포트"""
    global TREE_SITTER_AVAILABLE, _tree_sitter_modules
    
    if _tree_sitter_modules:
        return True
        
    try:
        import tree_sitter
        import tree_sitter_python
        import tree_sitter_javascript
        
        _tree_sitter_modules['tree_sitter'] = tree_sitter
        _tree_sitter_modules['python'] = tree_sitter_python
        _tree_sitter_modules['javascript'] = tree_sitter_javascript
        
        TREE_SITTER_AVAILABLE = True
        _log("Tree-sitter 모듈 로드 성공")
        return True
    except ImportError as e:
        _log(f"Tree-sitter 로드 실패: {e}", "WARNING")
        return False

class TreeSitterManager:
    """Tree-sitter 파서 관리"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self._parsers = {}
            self.initialized = True
    
    def get_parser(self, language: str):
        """언어별 파서 반환"""
        if not _lazy_import_tree_sitter():
            return None
            
        if language not in self._parsers:
            self._parsers[language] = self._create_parser(language)
            
        return self._parsers[language]
    
    def _create_parser(self, language: str):
        """파서 생성"""
        tree_sitter = _tree_sitter_modules.get('tree_sitter')
        if not tree_sitter:
            return None
            
        parser = tree_sitter.Parser()
        
        lang_map = {
            'python': 'python',
            'javascript': 'javascript',
            'typescript': 'javascript'
        }
        
        lang_key = lang_map.get(language)
        if not lang_key:
            return None
            
        lang_module = _tree_sitter_modules.get(lang_key)
        if lang_module:
            parser.set_language(lang_module.Language())
            return parser
            
        return None

# ============================================================================
# AST Parser 메인 클래스
# ============================================================================

class FunctionReplacer(ast.NodeTransformer):
    """
    AST 트리에서 특정 이름을 가진 함수/메서드를 찾아
    새로운 코드 블록으로 교체하는 NodeTransformer입니다.
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        # 새로운 코드를 파싱하여 교체할 노드를 준비합니다.
        # 여러 문장이 포함될 수 있으므로 body에서 노드를 가져옵니다.
        self.new_nodes = ast.parse(new_code).body

    def visit_FunctionDef(self, node: ast.FunctionDef) -> Union[ast.FunctionDef, List[ast.AST]]:
        """일반 함수(def) 노드를 방문합니다."""
        # 자식 노드들도 계속 방문
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # 함수의 이름이 일치하면 준비된 새 노드들로 교체합니다.
            return self.new_nodes
        return node  # 일치하지 않으면 원래 노드를 그대로 반환합니다.

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Union[ast.AsyncFunctionDef, List[ast.AST]]:
        """비동기 함수(async def) 노드를 방문합니다."""
        # 자식 노드들도 계속 방문
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # 함수의 이름이 일치하면 준비된 새 노드들로 교체합니다.
            return self.new_nodes
        return node  # 일치하지 않으면 원래 노드를 그대로 반환합니다.


class EnhancedFunctionReplacer(ast.NodeTransformer):
    """
    클래스명.메서드명 형식을 지원하는 향상된 NodeTransformer
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        
        # ClassName.method_name 형식 파싱
        if '.' in target_name:
            parts = target_name.split('.')
            self.target_class = parts[0]
            self.target_method = parts[1]
            self.is_class_method = True
        else:
            self.target_class = None
            self.target_method = target_name
            self.is_class_method = False
            
        # 새로운 코드 준비
        self.new_nodes = ast.parse(new_code).body
        
        # 현재 클래스 컨텍스트 추적
        self.current_class = None
        self.found_and_replaced = False

    def visit_ClassDef(self, node: ast.ClassDef):
        """클래스 정의 방문"""
        # 현재 클래스 이름 저장
        old_class = self.current_class
        self.current_class = node.name
        
        # 클래스 내부 방문
        self.generic_visit(node)
        
        # 클래스 컨텍스트 복원
        self.current_class = old_class
        
        # 클래스 자체를 교체하는 경우
        if not self.is_class_method and node.name == self.target_name:
            self.found_and_replaced = True
            return self.new_nodes
            
        return node

    def visit_FunctionDef(self, node: ast.FunctionDef):
        """일반 함수(def) 노드 방문"""
        self.generic_visit(node)
        
        # 클래스 메서드를 찾는 경우
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # 일반 함수를 찾는 경우
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        """비동기 함수(async def) 노드 방문"""
        self.generic_visit(node)
        
        # 클래스 메서드를 찾는 경우
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # 일반 함수를 찾는 경우
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node



class ASTParser:
    """통합 AST 파서"""
    
    def __init__(self):
        self.cache_manager = CacheManager()
        self.ts_manager = TreeSitterManager()
        
    def _detect_language(self, file_path: str, language: str = 'auto') -> str:
        """파일 언어 감지"""
        if language != 'auto':
            return language
            
        ext = Path(file_path).suffix.lower()
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.ts': 'typescript',
            '.tsx': 'typescript'
        }
        
        return ext_map.get(ext, 'unknown')
    
    def _extract_docstring(self, node: ast.AST) -> Optional[str]:
        """Python docstring 추출"""
        # body 속성이 있는 노드 타입들만 처리
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module)):
            return None
            
        if not hasattr(node, 'body') or not node.body:
            return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, (ast.Str, ast.Constant)):
            # Python 3.8+에서는 ast.Constant 사용
            if isinstance(first.value, ast.Str):
                return textwrap.dedent(first.value.s).strip()
            elif isinstance(first.value, ast.Constant) and isinstance(first.value.value, str):
                return textwrap.dedent(first.value.value).strip()
                
        return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, ast.Str):
            return textwrap.dedent(first.value.s).strip()
            
        return None
    
    def _extract_function_info(self, node: ast.FunctionDef, source_lines: List[str]) -> Dict:
        """함수 정보 추출"""
        info = {
            'type': 'function',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'args': [arg.arg for arg in node.args.args],
            'docstring': self._extract_docstring(node),
            'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list if d],
            'is_async': isinstance(node, ast.AsyncFunctionDef)
        }
        
        # 코드 스니펫 추출
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def _extract_class_info(self, node: ast.ClassDef, source_lines: List[str]) -> Dict:
        """클래스 정보 추출"""
        info = {
            'type': 'class',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'bases': [base.id if isinstance(base, ast.Name) else str(base) for base in node.bases],
            'docstring': self._extract_docstring(node),
            'methods': []
        }
        
        # 메서드 추출
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                method_info = self._extract_function_info(item, source_lines)
                method_info['type'] = 'method'
                info['methods'].append(method_info)
        
        # 코드 스니펫 추출
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def parse_python(self, file_path: str, include_snippets: bool = True) -> Dict[str, Any]:
        """Python 파일 파싱"""
        try:
            # 캐시 확인
            cached = self.cache_manager.get_cached_ast(file_path)
            if cached and not include_snippets:
                return cached
                
            # 파일 읽기
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST 파싱
            tree = ast.parse(content, filename=file_path)
            source_lines = content.split('\n') if include_snippets else []
            
            # 결과 수집
            result = {
                'parsing_success': True,
                'language': 'python',
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # AST 순회
            for node in ast.walk(tree):  
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    result['functions'].append(self._extract_function_info(node, source_lines))
                elif isinstance(node, ast.ClassDef):
                    result['classes'].append(self._extract_class_info(node, source_lines))
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            result['imports'].append(alias.name)
                    else:
                        result['imports'].append(node.module or '')
            
            # 캐시 저장
            if not include_snippets:
                self.cache_manager.set_cached_ast(file_path, result)
                
            return result
            
        except Exception as e:
            _log(f"Python 파싱 오류: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': 'python',
                'error': str(e)
            }
    
    def parse_javascript(self, file_path: str, language: str = 'javascript', 
                        include_snippets: bool = True) -> Dict[str, Any]:
        """JavaScript/TypeScript 파일 파싱"""
        parser = self.ts_manager.get_parser(language)
        if not parser:
            return {
                'parsing_success': False,
                'language': language,
                'error': 'Tree-sitter not available'
            }
            
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
                
            tree = parser.parse(content)
            
            # 간단한 결과 반환 (실제 구현은 더 복잡함)
            result = {
                'parsing_success': True,
                'language': language,
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # Tree-sitter 노드 순회 로직 (간략화)
            # 실제로는 traverse_node 같은 복잡한 함수가 필요하지만
            # 여기서는 간단히 처리
            
            return result
            
        except Exception as e:
            _log(f"JavaScript 파싱 오류: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': language,
                'error': str(e)
            }
    
    def parse_with_snippets(self, file_path: str, language: str = 'auto', 
                          include_snippets: bool = True) -> Dict[str, Any]:
        """파일 파싱 메인 메서드"""
        # 언어 감지
        detected_lang = self._detect_language(file_path, language)
        
        if detected_lang == 'python':
            return self.parse_python(file_path, include_snippets)
        elif detected_lang in ['javascript', 'typescript']:
            return self.parse_javascript(file_path, detected_lang, include_snippets)
        else:
            return {
                'parsing_success': False,
                'language': detected_lang,
                'error': f'Unsupported language: {detected_lang}'
            }
    
    def get_snippet_preview(self, file_path: str, element_name: str, 
                          element_type: str = 'function', max_lines: int = 10) -> str:
        """코드 스니펫 미리보기"""
        result = self.parse_with_snippets(file_path, include_snippets=True)
        
        if not result.get('parsing_success'):
            return f"Error: {result.get('error', 'Unknown error')}"
            
        # 요소 찾기
        element_key = f'{element_type}s'
        if element_type == 'class':
            element_key = 'classes'
        elif element_type == 'function':
            element_key = 'functions'
            
        elements = result.get(element_key, [])
        for elem in elements:
            if elem.get('name') == element_name:
                snippet = elem.get('snippet', '')
                if not snippet:
                    # snippet이 없으면 기본 정보 반환
                    return f"{element_type} '{element_name}' found at line {elem.get('line_start', '?')}"
                    
                lines = snippet.split('\n')
                if len(lines) > max_lines:
                    return '\n'.join(lines[:max_lines]) + '\n...'
                return snippet
                

    def replace_block(self, file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
        """
        파일 내에서 이름이 일치하는 함수나 메서드를 찾아 새 코드로 교체합니다.
        
        지원 형식:
        - 'function_name' : 최상위 함수 또는 첫 번째 매칭되는 메서드
        - 'ClassName' : 클래스 전체
        - 'ClassName.method_name' : 특정 클래스의 메서드 (정확한 지정)

        Args:
            file_path (str): 수정할 파일의 경로.
            block_name (str): 교체할 블록의 이름.
            new_code (str): 교체할 새로운 코드 블록.
            output_path (str, optional): 결과를 저장할 파일 경로.

        Returns:
            str: 성공 시 "SUCCESS: ...", 실패 시 "ERROR: ..." 메시지
        """
        try:
            # 1. 파일을 읽고 AST를 생성합니다.
            with open(file_path, 'r', encoding='utf-8') as f:
                source = f.read()
            tree = ast.parse(source, filename=file_path)

            # 2. 적절한 Replacer 선택
            if '.' in block_name:
                # ClassName.method_name 형식인 경우
                transformer = EnhancedFunctionReplacer(block_name, new_code)
            else:
                # 단순 이름인 경우
                transformer = FunctionReplacer(block_name, new_code)
            
            # 3. AST 변환
            new_tree = transformer.visit(tree)

            # 4. 교체 성공 여부 확인
            if hasattr(transformer, 'found_and_replaced') and not transformer.found_and_replaced:
                return f"ERROR: 블록 '{block_name}'을 찾을 수 없습니다"

            # 5. 변경된 AST 후처리
            ast.fix_missing_locations(new_tree)

            # 6. 수정된 AST를 소스 코드로 변환
            modified_code = ast.unparse(new_tree)
            
            # 7. 결과 저장
            save_path = output_path or file_path
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(modified_code)
            
            return f"SUCCESS: 블록 '{block_name}' 교체 완료 (파일: {save_path})"

        except FileNotFoundError:
            return f"ERROR: 파일을 찾을 수 없습니다: {file_path}"
        except Exception as e:
            return f"ERROR: 코드 수정 중 오류 발생: {e}"

# ============================================================================
# 전역 파서 인스턴스
# ============================================================================

def _get_parser() -> ASTParser:
    """싱글톤 파서 인스턴스 반환"""
    global _advanced_parser, _parser_lock
    
    if _advanced_parser is None:
        with _parser_lock:
            if _advanced_parser is None:
                _advanced_parser = ASTParser()
                
    return _advanced_parser

# ============================================================================
# 공개 API
# ============================================================================

def parse_with_snippets(file_path: str, language: str = 'auto', 
                       include_snippets: bool = True) -> Dict[str, Any]:
    """파일 파싱 (공개 API)"""
    parser = _get_parser()
    return parser.parse_with_snippets(file_path, language, include_snippets)

def get_snippet_preview(file_path: str, element_name: str, 
                       element_type: str = 'function', max_lines: int = 10,
                       start_line: int = -1, end_line: int = -1) -> str:
    """코드 스니펫 미리보기 (공개 API)"""
    parser = _get_parser()
    return parser.get_snippet_preview(file_path, element_name, element_type, max_lines)

# ============================================================================
# 백그라운드 초기화 (선택적)
# ============================================================================

def init_background():
    """백그라운드에서 Tree-sitter 초기화"""
    def _init():
        _lazy_import_tree_sitter()
        _log("백그라운드 초기화 완료")
        
    thread = threading.Thread(target=_init, daemon=True)
    thread.start()

# 자동 백그라운드 초기화
init_background()

def replace_block(file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
    """
    파일 내에서 이름이 일치하는 함수나 메서드를 찾아 새 코드로 교체합니다.
    (클래스 내부 메서드도 지원)
    """
    parser = ASTParser()
    return parser.replace_block(file_path, block_name, new_code, output_path)


# ============================================================================
# 🔧 파일 시스템 통합 클래스
# ============================================================================

class FileSystemHelpers:
    """
    파일 시스템 레벨에서 AST 기반 코드 수정을 지원하는 헬퍼 클래스.
    file_system_helpers.py에서 이동됨.
    """
    
    def __init__(self):
        self.parser = ASTParser()
        self.line_delta_cache = {}  # 파일별 라인 변경 추적
    
    def _detect_language_from_path(self, file_path: str) -> str:
        """파일 확장자로 언어 감지"""
        ext = os.path.splitext(file_path)[1].lower()
        if ext in ['.py', '.pyw']:
            return 'python'
        elif ext in ['.js', '.jsx']:
            return 'javascript'
        elif ext in ['.ts', '.tsx']:
            return 'typescript'
        return 'unknown'
    
    def _validate_syntax_by_language(self, code: str, language: str, file_path: str) -> Tuple[bool, Optional[str]]:
        """언어별 구문 검증"""
        if language == 'python':
            try:
                ast.parse(code, filename=file_path)
                return True, None
            except SyntaxError as e:
                return False, f"Line {e.lineno}: {e.msg}"
        # JavaScript/TypeScript는 기본적으로 통과
        return True, None
    
    def _apply_indentation(self, code: str, base_indent: int) -> str:
        """코드에 기본 들여쓰기 적용"""
        indent_str = ' ' * base_indent
        lines = code.splitlines()
        return '\n'.join(indent_str + line if line.strip() else line for line in lines)
    
    def _record_line_delta(self, file_path: str, start_line: int, delta: int):
        """라인 변경사항 기록"""
        if file_path not in self.line_delta_cache:
            self.line_delta_cache[file_path] = []
        self.line_delta_cache[file_path].append({
            'start_line': start_line,
            'delta': delta,
            'timestamp': datetime.now().isoformat()
        })


    def find_blocks(self, file_path: str, block_name: str = None) -> dict:
    """
    파일에서 코드 블록(함수, 클래스, 메서드)을 찾습니다.
    
    Args:
        file_path (str): 검색할 파일 경로
        block_name (str, optional): 찾을 블록 이름. None이면 모든 블록 반환
                                   'ClassName.method' 형식 지원
    
    Returns:
        dict: 검색 결과를 담은 딕셔너리
        
        블록을 찾은 경우:
        {
            'found': True,
            'block': {                    # 찾은 블록 정보
                'name': str,              # 블록 이름
                'type': str,              # 'function', 'class', 'method'
                'line_start': int,        # 시작 라인 번호
                'line_end': int,          # 끝 라인 번호
                'col_start': int,         # 시작 컬럼 번호
                'col_end': int,           # 끝 컬럼 번호
                'class': str or None,     # 메서드인 경우 클래스명
                'language': str           # 언어 타입
            },
            'blocks': list,               # 파일의 모든 블록 리스트
            'functions': list,            # 함수만 필터링한 리스트
            'classes': list,              # 클래스만 필터링한 리스트
            'methods': list,              # 메서드만 필터링한 리스트
            'total_blocks': int,          # 전체 블록 수
            'matching_count': int         # 매칭된 블록 수
        }
        
        블록을 찾지 못한 경우:
        {
            'found': False,
            'error': str,                 # 오류 메시지
            'available_blocks': list      # 사용 가능한 블록 이름 리스트
        }
        
        모든 블록 조회 (block_name=None):
        {
            'found': bool,                # 블록이 하나라도 있는지
            'blocks': list,               # 모든 블록 리스트
            'functions': list,            # 함수만 필터링한 리스트
            'classes': list,              # 클래스만 필터링한 리스트
            'methods': list,              # 메서드만 필터링한 리스트
            'total_blocks': int           # 전체 블록 수
        }
    
    Examples:
        # 특정 함수 찾기
        result = find_blocks('app.py', 'process_data')
        if result['found']:
            block = result['block']
            print(f"함수 {block['name']}는 {block['line_start']}줄에서 시작")
        
        # 클래스의 메서드 찾기
        result = find_blocks('app.py', 'DataHandler.process')
        
        # 모든 블록 조회
        result = find_blocks('app.py')
        for block in result['blocks']:
            print(f"{block['type']}: {block['name']}")
    """
    
    if not os.path.exists(file_path):
        return {'found': False, 'error': f'파일이 존재하지 않음: {file_path}'}
    
    # 파일 내용 읽기
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        return {'found': False, 'error': f'파일 읽기 실패: {e}'}
    
    # 언어별 파싱 (Python v2.3 개선 적용)
    file_ext = os.path.splitext(file_path)[1].lower()
    if file_ext == '.py':
                # 외부 파서 사용 (JavaScript/TypeScript와 동일)
        if _external_parse_with_snippets:
            try:
                ast_result = _external_parse_with_snippets(file_path, include_snippets=True)
                if not ast_result.get('parsing_success'):
                    return {'found': False, 'error': f'Python 파싱 실패: {ast_result.get("error")}'}
            except Exception as parse_err:
                return {'found': False, 'error': f'Python 파싱 오류: {parse_err}'}
        else:
            return {'found': False, 'error': 'Python 파서를 찾을 수 없음'}
    else:
        # JavaScript/TypeScript는 외부 파서 사용 (안전한 방식)
        if _external_parse_with_snippets:
            try:
                ast_result = _external_parse_with_snippets(file_path, include_snippets=True)
            except:
                return {'found': False, 'error': 'JavaScript/TypeScript 파싱 실패'}
        else:
            return {'found': False, 'error': 'JavaScript/TypeScript 파서 없음'}
    
    if not ast_result.get('parsing_success'):
        return {'found': False, 'error': f'AST 파싱 실패: {ast_result.get("error")}'}
    
    # 모든 블록 수집
    all_blocks = []
    functions = []  # 함수만 저장
    classes = []    # 클래스만 저장
    methods = []    # 메서드만 저장
    
    # 함수들
    for func in ast_result.get('functions', []):
        block = {
            'name': func.get('name'),
            'type': 'function',
            'line_start': func.get('line_start'),
            'line_end': func.get('line_end'),
            'col_start': func.get('col_start', 1),
            'col_end': func.get('col_end', 1),
            'class': func.get('class'),
            'language': ast_result.get('language')
        }
        all_blocks.append(block)
        functions.append(block)
    
    # 클래스들
    for cls in ast_result.get('classes', []):
        block = {
            'name': cls.get('name'),
            'type': 'class',
            'line_start': cls.get('line_start'),
            'line_end': cls.get('line_end'),
            'col_start': cls.get('col_start', 1),
            'col_end': cls.get('col_end', 1),
            'class': None,
            'language': ast_result.get('language')
        }
        all_blocks.append(block)
        classes.append(block)
    
    # 메서드들
    for method in ast_result.get('methods', []):
        block = {
            'name': method.get('name'),
            'type': 'method',
            'line_start': method.get('line_start'),
            'line_end': method.get('line_end'),
            'col_start': method.get('col_start', 1),
            'col_end': method.get('col_end', 1),
            'class': method.get('class'),  # ✅ v2.3: 정확한 클래스 정보
            'language': ast_result.get('language')
        }
        all_blocks.append(block)
        methods.append(block)
    
    # 특정 블록 검색
    if block_name:
        # ✅ v2.3 FINAL 핵심: 정규화된 이름 파싱
        target_class_name = None
        target_func_name = block_name
        
        if '.' in block_name:
            # 'ClassName.method' 형태 파싱
            parts = block_name.rsplit('.', 1)
            if len(parts) == 2:
                target_class_name, target_func_name = parts
        
        # 블록 검색
        matching_blocks = []
        for block in all_blocks:
            if block['name'] == target_func_name:
                if target_class_name:
                    # 클래스명이 지정된 경우: 정확한 클래스 일치 확인
                    if block.get('class') == target_class_name:
                        matching_blocks.append(block)
                else:
                    # 클래스명이 없는 경우: 전역 함수/클래스만 매치
                    if not block.get('class'):
                        matching_blocks.append(block)
        
        if matching_blocks:
            return {
                'found': True,
                'block': matching_blocks[0],
                'blocks': all_blocks,
                'functions': functions,  # 추가
                'classes': classes,      # 추가
                'methods': methods,      # 추가
                'total_blocks': len(all_blocks),
                'matching_count': len(matching_blocks)
            }
        else:
            available_names = [f"{b.get('class', '')}.{b['name']}" if b.get('class') else b['name'] 
                             for b in all_blocks]
            return {
                'found': False, 
                'error': f'블록 "{block_name}"을 찾을 수 없음',
                'available_blocks': available_names
            }
    
    # 모든 블록 반환
    return {
        'found': len(all_blocks) > 0,
        'blocks': all_blocks,
        'functions': functions,  # 추가
        'classes': classes,      # 추가
        'methods': methods,      # 추가
        'total_blocks': len(all_blocks)
    }

    def replace_block_fs(self, file_path: str, block_name: str, new_content: str) -> str:
    """
    파일의 특정 코드 블록(함수, 클래스, 메서드)을 새로운 내용으로 교체합니다.
    
    자동으로 백업을 생성하고, 구문 검증을 수행하며, 실패 시 자동 복원됩니다.
    정규화된 이름(ClassName.method) 형식을 지원하며, 원본 블록의 들여쓰기를 유지합니다.
    
    Args:
        file_path (str): 수정할 파일의 전체 경로
        block_name (str): 교체할 블록의 이름
                         - 함수: 'function_name'
                         - 클래스: 'ClassName'
                         - 메서드: 'ClassName.method_name'
        new_content (str): 새로운 코드 내용
                          - 빈 문자열이면 블록 삭제
                          - 들여쓰기는 자동으로 조정됨
    
    Returns:
        str: 작업 결과 메시지
             성공: "SUCCESS: 블록 '{block_name}' 교체 완료 (백업: backup_filename)"
             실패: "ERROR: 구체적인 오류 메시지"
    
    Examples:
        # 함수 교체
        result = replace_block('app.py', 'process_data', 
                             'def process_data(x):\n    return x * 2')
        
        # 클래스 메서드 교체
        result = replace_block('models.py', 'DataHandler.validate',
                             'def validate(self, data):\n    return True')
        
        # 블록 삭제
        result = replace_block('utils.py', 'deprecated_function', '')
    """
    # 1. 파일 존재 확인
    if not os.path.exists(file_path):
        return f"ERROR: 파일이 존재하지 않습니다: {file_path}"
    
    # 2. 백업 생성
    backup_path = backup_file(file_path, f"before_replace_{block_name}")
    if "ERROR" in backup_path:
        return backup_path
    
    # 3. ✅ v2.3 핵심: 정규화된 이름으로 정확한 블록 찾기
    blocks_result = find_blocks(file_path, block_name)
    if not blocks_result.get('found'):
        error_msg = blocks_result.get('error', f'블록 "{block_name}"을 찾을 수 없음')
        return f"ERROR: {error_msg}"
    
    block_info = blocks_result['block']
    start_line = block_info['line_start']
    end_line = block_info['line_end']
    
    # 4. 파일 읽기
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception as e:
        return f"ERROR: 파일 읽기 실패: {e}"
    
    # 5. ✅ v2.3 핵심: AST 기반 정확한 들여쓰기 적용
    base_indent_col = block_info.get('col_start', 1)
    
    if new_content.strip():
        processed_content = _apply_indentation_from_col(new_content, base_indent_col)
        new_lines = processed_content.splitlines(keepends=True)
        if new_lines and not new_lines[-1].endswith('\n'):
            new_lines[-1] += '\n'
    else:
        new_lines = []
    
    # 블록 교체
    original_line_count = end_line - start_line + 1
    new_line_count = len(new_lines)
    lines[start_line-1:end_line] = new_lines
    
    # 6. 구문 검증
    new_file_content = ''.join(lines)
    language = _detect_language_from_path(file_path)
    is_valid, error = _validate_syntax_by_language(new_file_content, language, file_path)
    
    if not is_valid:
        try:
            shutil.copy2(backup_path, file_path) # 백업에서 복원
            _record_line_delta(file_path, start_line, 0) # 실패 시 델타 원복
        except Exception as restore_err:
            return f"ERROR: 구문 오류로 복원 중 추가 오류 발생: {restore_err}"
        return f"ERROR: 구문 오류로 편집 실패 (자동 복원됨): {error}"
    
    # 7. 파일 쓰기 및 후처리
    try:
        _atomic_write(file_path, new_file_content)
        line_delta = new_line_count - original_line_count
        if line_delta != 0:
            # ✅ 성공 시에만 Delta Tracking 정보 기록
            _record_line_delta(file_path, start_line, line_delta)
        _invalidate_and_refresh_cache(file_path)
    except Exception as e:
        return f"ERROR: 파일 쓰기 실패: {e}"
    
    action = "삭제" if not new_content.strip() else "교체"
    return f"SUCCESS: 블록 '{block_name}' {action} 완료 (백업: {os.path.basename(backup_path)})"

    def insert_block(self, file_path: str, target_block: str, position: str, new_content: str) -> str:
    """
    파일의 특정 블록 주변이나 내부에 새로운 코드를 삽입합니다.
    
    자동으로 백업을 생성하고, 구문 검증을 수행하며, 실패 시 자동 복원됩니다.
    대상 블록의 들여쓰기 수준에 맞춰 새 코드의 들여쓰기가 자동 조정됩니다.
    
    Args:
        file_path (str): 수정할 파일의 전체 경로
        target_block (str): 삽입 위치의 기준이 되는 블록 이름
                           - 함수: 'function_name'
                           - 클래스: 'ClassName'
                           - 메서드: 'ClassName.method_name'
        position (str): 삽입 위치 지정
                       - 'before': 블록 시작 전
                       - 'after': 블록 종료 후
                       - 'start': 블록 내부 시작 부분 (선언 직후)
                       - 'end': 블록 내부 끝 부분 (return 문 전)
        new_content (str): 삽입할 코드 내용
                          - 들여쓰기는 자동으로 조정됨
                          - 여러 줄 가능
    
    Returns:
        str: 작업 결과 메시지
             성공: "SUCCESS: 블록 '{target_block}'의 {position} 위치에 코드 삽입 완료"
             실패: "ERROR: 구체적인 오류 메시지"
    
    Examples:
        # 함수 앞에 주석 추가
        result = insert_block('app.py', 'process_data', 'before',
                            '# This function processes data\n')
        
        # 함수 내부 시작 부분에 로깅 추가
        result = insert_block('app.py', 'process_data', 'start',
                            'print("Processing started")')
        
        # 클래스 메서드 끝에 코드 추가
        result = insert_block('models.py', 'DataHandler.save', 'end',
                            'self.last_saved = datetime.now()')
    """
    if not os.path.exists(file_path):
        return f"ERROR: 파일이 존재하지 않습니다: {file_path}"
    
    valid_positions = ['before', 'after', 'start', 'end']
    if position not in valid_positions:
        return f"ERROR: 유효하지 않은 position: {position}"
    
    backup_path = backup_file(file_path, f"before_insert_{target_block}_{position}")
    if "ERROR" in backup_path:
        return backup_path

    blocks_result = find_blocks(file_path, target_block)
    if not blocks_result.get('found'):
        error_msg = blocks_result.get('error', f'블록 "{target_block}"을 찾을 수 없음')
        return f"ERROR: {error_msg}"
        
    block_info = blocks_result['block']
    start_line = block_info['line_start']
    end_line = block_info['line_end']
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception as e:
        return f"ERROR: 파일 읽기 실패: {e}"

    target_col = block_info.get('col_start', 1)
    if position in ['start', 'end']:
        final_col = target_col + 4 # 블록 내부는 4칸 추가
    else: # 'before', 'after'
        final_col = target_col

    processed_content = _apply_indentation_from_col(new_content, final_col)
    new_lines = processed_content.splitlines(keepends=True)
    if new_lines and not new_lines[-1].endswith('\n'):
        new_lines[-1] += '\n'
    
    if position == 'before':
        insert_line_idx = start_line - 1
    elif position == 'after':
        insert_line_idx = end_line
    elif position == 'start':
        # Docstring이나 다른 요소 바로 뒤에 삽입
        insert_line_idx = start_line
    else: # 'end'
        # return 문 바로 앞에 삽입
        insert_line_idx = end_line - 1

    lines[insert_line_idx:insert_line_idx] = new_lines
    
    new_file_content = ''.join(lines)
    language = _detect_language_from_path(file_path)
    is_valid, error = _validate_syntax_by_language(new_file_content, language, file_path)

    if not is_valid:
        shutil.copy2(backup_path, file_path)
        return f"ERROR: 구문 오류로 삽입 실패 (자동 복원됨): {error}"

    _atomic_write(file_path, new_file_content)
    _record_line_delta(file_path, insert_line_idx, len(new_lines))
    _invalidate_and_refresh_cache(file_path)
    
    return f"SUCCESS: 블록 '{target_block}'의 {position} 위치에 코드 삽입 완료"


# ============================================================================
# 🔧 File System Helpers - 전역 함수 (backward compatibility)
# ============================================================================

_fs_helpers = None

def _get_fs_helpers():
    """FileSystemHelpers 싱글톤 인스턴스 반환"""
    global _fs_helpers
    if _fs_helpers is None:
        _fs_helpers = FileSystemHelpers()
    return _fs_helpers

def find_blocks(file_path: str, block_name: str = None) -> dict:
    """파일에서 코드 블록을 찾습니다."""
    return _get_fs_helpers().find_blocks(file_path, block_name)

def replace_block_fs(file_path: str, block_name: str, new_content: str) -> str:
    """파일의 특정 코드 블록을 교체합니다. (파일시스템 기반)"""
    return _get_fs_helpers().replace_block_fs(file_path, block_name, new_content)

def insert_block(file_path: str, block_name: str, new_content: str, position: str = 'after') -> str:
    """파일에 새로운 코드 블록을 삽입합니다."""
    return _get_fs_helpers().insert_block(file_path, block_name, new_content, position)
