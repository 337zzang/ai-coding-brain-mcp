#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
🚀 JSON REPL Session for AI Coding Brain v4.0
==============================================

Claude Desktop과 통신하는 JSON REPL 세션 관리자
- 개선된 Bootstrap 시스템 v3.0 (UnifiedContextManager 통합)
- 통합된 Helper 보호 시스템 v10.0
- AI Coding Brain v3.0 완벽 통합
- 싱글톤 패턴 및 타입 안정성 강화

작성자: Claude + 사용자 협업
수정일: 2025-06-13 (v4.0 - 구조 개선)
"""

import sys
import os
import json
import io
import traceback
import time
import threading
import datetime as dt
import importlib
import platform
import subprocess
from pathlib import Path
from typing import Dict, Optional, Tuple, List, Any, Union, Callable
from contextlib import redirect_stdout, redirect_stderr
import logging

# ============================================================================
# 🔧 기본 설정 및 경로 초기화
# ============================================================================

# 전역 경로 설정
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

# ============================================================================
# 🔍 로깅 시스템
# ============================================================================

class Logger:
    """레벨별 로깅 시스템"""

    LEVELS = {
        'DEBUG': 0,
        'INFO': 1,
        'WARNING': 2,
        'ERROR': 3
    }

    def __init__(self, level='INFO'):
        self.level = self.LEVELS.get(level, 1)

    def log(self, message: str, level: str = 'INFO'):
        if self.LEVELS.get(level, 1) >= self.level:
            timestamp = time.strftime("%H:%M:%S")
            print(f"[{level} {timestamp}] {message}", file=sys.stderr, flush=True)

    def debug(self, message: str):
        self.log(message, 'DEBUG')

    def info(self, message: str):
        self.log(message, 'INFO')

    def warning(self, message: str):
        self.log(message, 'WARNING')

    def error(self, message: str):
        self.log(message, 'ERROR')

# 전역 로거 인스턴스
logger = Logger(level='INFO')

# ============================================================================
# 🔌 선택적 모듈 임포트
# ============================================================================

# Smart Print Utils
try:
    from smart_print import smart_print, enhanced_smart_print, sp, esp, compress_content
    SMART_PRINT_AVAILABLE = True
    logger.info("Smart Print Utils 연동 성공")
except ImportError:
    SMART_PRINT_AVAILABLE = False
    # Fallback 함수들
    def smart_print(content, **kwargs): return str(content)
    def enhanced_smart_print(content, **kwargs): return str(content)
    def sp(content, **kwargs): return str(content)
    def esp(content, **kwargs): return str(content)
    def compress_content(content, **kwargs):
        return str(content)[:15000] + "..." if len(str(content)) > 15000 else str(content)
    logger.info("Smart Print Utils 없음 - fallback 사용")

# ============================================================================
# 🔌 핵심 모듈 임포트 (개선된 구조)
# ============================================================================

# Context Manager v3.0
try:
    from context_manager import (
        initialize_context,
        save_context,
        update_cache,
        get_value,
        find_symbol,
        track_file_access,
        track_function_edit,
        get_work_tracking_summary,
        build_index,
        propose_next_steps
    )
    CONTEXT_MANAGER_AVAILABLE = True
    logger.info("✅ Context Manager v3.0 로드 성공")
except ImportError as e:
    CONTEXT_MANAGER_AVAILABLE = False
    logger.error(f"❌ Context Manager 로드 실패: {e}")

# Vibe Memory System
try:
    from vibe_memory_system import VibeMemoryManager, get_vibe_commands
    VIBE_MEMORY_AVAILABLE = True
    logger.info("✅ Vibe Memory System 로드 성공")
except ImportError as e:
    VIBE_MEMORY_AVAILABLE = False
    logger.warning(f"⚠️ Vibe Memory System 로드 실패: {e}")

# AI Coding Brain v3.0
try:
    import claude_code_ai_brain as ai_brain
    AI_BRAIN_AVAILABLE = True
    logger.info("✅ AI Coding Brain v3.0 로드 성공")
except ImportError as e:
    AI_BRAIN_AVAILABLE = False
    logger.warning(f"⚠️ AI Coding Brain 로드 실패: {e}")

# ============================================================================
# 🌍 전역 변수 및 상태 (싱글톤 패턴)
# ============================================================================

class GlobalReplState:
    """REPL 세션 전역 상태 관리 (싱글톤) - REPL 전용"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialized = False
        return cls._instance
    
    def __init__(self):
        if not self.initialized:
            # REPL 관련 상태만 관리
            self.repl_globals: Dict[str, Any] = {}
            self.session_id: str = f"session_{int(time.time())}"
            self.variable_count: int = 0
            self.execution_count: int = 0
            self.last_result: Any = None
            
            # AI Brain 모듈 참조 (lazy loading)
            self.ai_brain = None
            self.initialized = True
    
    @property
    def project_context(self):
        """AI Brain의 context를 프록시로 접근"""
        if self.ai_brain and hasattr(self.ai_brain, '_global_state'):
            state = self.ai_brain._global_state
            if state and hasattr(state, 'context'):
                return state.context
        return None
    
    @property
    def project_root(self):
        """AI Brain의 project_path를 프록시로 접근"""
        if self.ai_brain and hasattr(self.ai_brain, '_global_state'):
            state = self.ai_brain._global_state
            if state and hasattr(state, 'project_path') and state.project_path:
                return Path(state.project_path)
        return None

repl_state = GlobalReplState()

# ============================================================================
# 🚀 Bootstrap 시스템 v3.0 (UnifiedContextManager 통합)
# ============================================================================

class BootstrapSystem:
    """통합된 Bootstrap 시스템 v3.0"""

    def __init__(self):
        self.logger = logger
        self.state = repl_state

    def find_project_root(self) -> Optional[Path]:
        """프로젝트 루트를 찾는 통합 로직"""
        strategies = []

        # 1. 환경 변수
        if os.environ.get('AI_BRAIN_ROOT'):
            strategies.append(('ENV_VAR', Path(os.environ['AI_BRAIN_ROOT'])))

        # 2. 현재 파일 기준 탐색
        current_file = Path(__file__).resolve()
        for parent in current_file.parents:
            markers = ['.ai-brain-project', 'project_cache.json', 'roadmap.md', '.git', '.cache']
            if any((parent / marker).exists() for marker in markers):
                strategies.append(('MARKER_FILE', parent))
                break

        # 3. 프로젝트 이름 기반
        for parent in current_file.parents:
            if 'ai-coding-brain' in parent.name.lower():
                strategies.append(('PROJECT_NAME', parent))
                break

        # 가장 신뢰할 수 있는 전략 선택
        for strategy_name, path in strategies:
            if path.exists():
                self.logger.info(f"프로젝트 루트 발견 ({strategy_name}): {path}")
                return path

        return None

    def find_memory_bank(self, project_name: str = None) -> Optional[Tuple[Path, Path]]:
        """메모리 뱅크에서 프로젝트 찾기"""
        memory_bank_root = None

        # Claude Desktop 설정 확인
        config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                
                # mcpServers 섹션에서 메모리 뱅크 경로 찾기
                mcp_servers = config.get('mcpServers', {})
                for server_name, server_config in mcp_servers.items():
                    if 'memory' in server_name.lower():
                        env = server_config.get('env', {})
                        if 'MEMORY_BANK_PATH' in env:
                            memory_bank_root = Path(env['MEMORY_BANK_PATH'])
                            self.logger.info(f"✅ Claude Desktop 설정에서 메모리 루트 로드: {memory_bank_root}")
                            break
            except Exception as e:
                self.logger.error(f"Claude Desktop 설정 로드 실패: {e}")

        # 대체 경로들
        if not memory_bank_root or not memory_bank_root.exists():
            fallback_paths = [
                Path.home() / "Desktop" / "memory",
                Path("C:/Users/Administrator/Desktop/memory"),
                Path.home() / "memory",
                Path.home() / "Documents" / "memory"
            ]
            
            for path in fallback_paths:
                if path.exists():
                    memory_bank_root = path
                    self.logger.info(f"대체 메모리 뱅크 경로 사용: {memory_bank_root}")
                    break

        if memory_bank_root and project_name:
            project_path = memory_bank_root / project_name
            if project_path.exists():
                return memory_bank_root, project_path

        return memory_bank_root, None if memory_bank_root else (None, None)

    def run_bootstrap(self) -> bool:
        """Bootstrap 프로세스 실행 - AI Brain에 위임"""
        try:
            self.logger.info("=== Bootstrap System v3.0 시작 ===")

            # Phase 1: AI Brain 초기화 (모든 프로젝트 관리는 여기서!)
            if AI_BRAIN_AVAILABLE:
                try:
                    # 프로젝트 루트 찾기
                    project_root = self.find_project_root()
                    if project_root:
                        os.chdir(project_root)
                        self.logger.info(f"작업 디렉토리 변경: {project_root}")
                    
                    # AI Brain이 모든 초기화를 담당
                    project_path = str(project_root) if project_root else os.getcwd()
                    project_name = os.path.basename(project_path)
                    
                    # AI Brain은 이미 auto_initialize()를 통해 초기화됨
                    # 여기서는 REPL state에 참조만 저장
                    import claude_code_ai_brain as ai_brain
                    self.state.ai_brain = ai_brain
                    
                    self.logger.info("✅ AI Coding Brain 참조 연결 완료")
                    
                except Exception as e:
                    self.logger.warning(f"AI Brain 연결 중 경고: {e}")

            # Phase 2: Helper 함수 등록
            self._register_helpers()

            self.logger.info("=== Bootstrap 완료 ===")
            return True

        except Exception as e:
            self.logger.error(f"Bootstrap 실패: {e}")
            traceback.print_exc(file=sys.stderr)
            return False

    def _register_helpers(self):
        """헬퍼 함수들을 전역 네임스페이스에 등록"""
        helpers = {}

        # Auto-Tracking Wrapper에서 모든 헬퍼 함수 임포트
        # 이제 모든 작업이 자동으로 추적됩니다!
        try:
            from auto_tracking_wrapper import (
                # 파일 시스템 함수들
                create_file, read_file, backup_file, restore_backup,
                replace_block, insert_block,
                
                # AST 분석 함수들
                parse_with_snippets, get_snippet_preview,
                
                # Context Manager 함수들 (사용 가능한 경우)
                initialize_context, save_context, update_cache,
                get_work_tracking_summary,
                
                # 검색 관련 함수들
                scan_directory, search_files_advanced, search_code_content,
                integrated_search, search_by_date, search_by_file
            )
            
            # 기본 헬퍼들
            helpers.update({
                'create_file': create_file,
                'read_file': read_file,
                'backup_file': backup_file,
                'restore_backup': restore_backup,
                'replace_block': replace_block,
                'insert_block': insert_block,
                'parse_with_snippets': parse_with_snippets,
                'get_snippet_preview': get_snippet_preview
            })
            
            # Context Manager 함수들
            if CONTEXT_MANAGER_AVAILABLE:
                helpers.update({
                    'initialize_context': initialize_context,
                    'save_context': save_context,
                    'update_cache': update_cache,
                    'get_work_tracking_summary': get_work_tracking_summary
                })
                
                # 추가 Context Manager 함수들 (직접 임포트)
                from context_manager import (
                    get_value, find_symbol,
                    track_file_access, track_function_edit,
                    propose_next_steps
                )
                helpers.update({
                    'get_value': get_value,
                    'find_symbol': find_symbol,
                    'track_file_access': track_file_access,
                    'track_function_edit': track_function_edit,
                    'propose_next_steps': propose_next_steps
                })
            
            # 검색 관련 함수들
            helpers.update({
                'scan_directory': scan_directory,
                'search_files_advanced': search_files_advanced,
                'search_code_content': search_code_content,
                'integrated_search': integrated_search,
                'search_by_date': search_by_date,
                'search_by_file': search_by_file
            })
            
            self.logger.info("✅ Auto-Tracking Wrapper를 통한 헬퍼 함수 로드 성공")
            
        except ImportError as e:
            self.logger.error(f"Auto-Tracking Wrapper 로드 실패: {e}")
            self.logger.warning("원본 헬퍼 함수들을 직접 로드합니다 (추적 없음)")
            
            # Fallback: 원본 함수들 직접 임포트
          

     
        # 전역 네임스페이스에 추가
        repl_state.repl_globals.update(helpers)
        self.logger.info(f"✅ {len(helpers)}개의 헬퍼 함수 등록 완료")

# ============================================================================
# 💾 세션 관리자
# ============================================================================

class SessionManager:
    """REPL 세션 상태 관리"""

    def __init__(self):
        self.state = repl_state
        self.logger = logger
        self.sessions_dir = Path(".sessions")
        self.sessions_dir.mkdir(exist_ok=True)

    def save_session(self, session_name: str = None) -> bool:
        """세션 상태 저장"""
        if not session_name:
            session_name = f"session_{self.state.session_id}.json"
        
        session_path = self.sessions_dir / session_name
        
        try:
            session_data = {
                'session_id': self.state.session_id,
                'timestamp': dt.datetime.now().isoformat(),
                'variable_count': self.state.variable_count,
                'execution_count': self.state.execution_count,
                'project_root': str(self.state.project_root) if self.state.project_root else None,
                'context': self.state.project_context
            }
            
            with open(session_path, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"세션 저장: {session_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"세션 저장 실패: {e}")
            return False

    def load_session(self, session_name: str) -> bool:
        """세션 상태 로드"""
        session_path = self.sessions_dir / session_name
        
        if not session_path.exists():
            self.logger.error(f"세션 파일 없음: {session_path}")
            return False
        
        try:
            with open(session_path, 'r', encoding='utf-8') as f:
                session_data = json.load(f)
            
            # 상태 복원
            self.state.session_id = session_data.get('session_id', self.state.session_id)
            self.state.variable_count = session_data.get('variable_count', 0)
            self.state.execution_count = session_data.get('execution_count', 0)
            
            if session_data.get('project_root'):
                self.state.project_root = Path(session_data['project_root'])
            
            if session_data.get('context'):
                self.state.project_context = session_data['context']
            
            self.logger.info(f"세션 로드: {session_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"세션 로드 실패: {e}")
            return False

    def get_last_session_info(self) -> Optional[Dict[str, Any]]:
        """마지막 세션 정보 조회"""
        try:
            info_file = Path(".last_session_info.json")
            if info_file.exists():
                with open(info_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception:
            pass
        return None

    def save_last_session_info(self):
        """마지막 세션 정보 저장"""
        try:
            info_file = Path(".last_session_info.json")
            info = {
                'session_id': self.state.session_id,
                'timestamp': dt.datetime.now().isoformat(),
                'project_root': str(self.state.project_root) if self.state.project_root else None
            }
            with open(info_file, 'w', encoding='utf-8') as f:
                json.dump(info, f, indent=2)
        except Exception as e:
            self.logger.error(f"세션 정보 저장 실패: {e}")

# ============================================================================
# 🛡️ Helper 함수 보호 시스템 v10.0
# ============================================================================

class HelperProtectionSystem:
    """헬퍼 함수 보호 및 추적 시스템"""

    def __init__(self):
        self.protected_functions = set()
        self.function_categories = {
            'CORE': set(),
            'FILE': set(),
            'AST': set(),
            'SEARCH': set()
        }
        self.logger = logger

    def protect_helpers(self, repl_globals: Dict[str, Any]):
        """헬퍼 함수들을 보호"""
        # 카테고리별 함수 정의
        categories = {
            'CORE': [
                'initialize_context', 'save_context', 'update_cache',
                'get_value', 'find_symbol', 'track_file_access',
                'track_function_edit', 'get_work_tracking_summary',
                'propose_next_steps'
            ],
            'FILE': [
                'create_file', 'read_file', 'backup_file', 'restore_backup'
            ],
            'AST': [
                'parse_with_snippets', 'replace_block', 'insert_block', 
                'get_snippet_preview'
            ],
            'SEARCH': [
                'integrated_search', 'scan_directory', 'search_files_advanced',
                'search_code_content', 'search_by_date', 'search_by_file'
            ]
        }

        # 함수 보호
        for category, func_names in categories.items():
            for func_name in func_names:
                if func_name in repl_globals and callable(repl_globals[func_name]):
                    self.protected_functions.add(func_name)
                    self.function_categories[category].add(func_name)

        self.logger.info(f"✅ {len(self.protected_functions)}개의 헬퍼 함수 보호 설정")

    def verify_functions(self, repl_globals: Dict[str, Any]) -> Dict[str, List[str]]:
        """함수 상태 검증"""
        status = {
            'missing': [],
            'modified': [],
            'intact': []
        }

        for func_name in self.protected_functions:
            if func_name not in repl_globals:
                status['missing'].append(func_name)
            elif not callable(repl_globals[func_name]):
                status['modified'].append(func_name)
            else:
                status['intact'].append(func_name)

        return status

    def restore_if_needed(self, repl_globals: Dict[str, Any], bootstrap_system: BootstrapSystem):
        """필요시 헬퍼 함수 복원"""
        status = self.verify_functions(repl_globals)
        
        if status['missing'] or status['modified']:
            self.logger.warning(f"헬퍼 함수 문제 감지 - 복원 시작")
            if status['missing']:
                self.logger.warning(f"  누락: {status['missing']}")
            if status['modified']:
                self.logger.warning(f"  변경: {status['modified']}")
            
            # 헬퍼 재등록
            bootstrap_system._register_helpers()
            
            # 보호 재설정
            self.protect_helpers(repl_globals)
            
            self.logger.info("✅ 헬퍼 함수 복원 완료")

# ============================================================================
# 💻 코드 실행 시스템
# ============================================================================

def execute_code_block(code: str, repl_globals: Dict[str, Any]) -> Dict[str, Any]:
    """코드 블록 실행"""
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    execution_start = time.time()

    try:
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            # 코드 컴파일
            compiled_code = compile(code, '<string>', 'exec')
            
            # 실행
            exec(compiled_code, repl_globals)
            
            # 변수 개수 업데이트
            repl_state.variable_count = len([k for k in repl_globals.keys() 
                                           if not k.startswith('_') and k not in ['__builtins__']])
            repl_state.execution_count += 1

        execution_time = time.time() - execution_start
        
        # 자동 저장 (Context Manager 사용 가능한 경우)
        if CONTEXT_MANAGER_AVAILABLE and repl_state.execution_count % 10 == 0:
            try:
                save_context()
                logger.debug("자동 저장 완료")
            except Exception as e:
                logger.warning(f"자동 저장 실패: {e}")

        return {
            "success": True,
            "stdout": stdout_capture.getvalue(),
            "stderr": stderr_capture.getvalue(),
            "execution_time": execution_time,
            "variable_count": repl_state.variable_count,
            "execution_count": repl_state.execution_count,
            "session_id": repl_state.session_id,
            "note": "JSON REPL Session - Variables persist between executions",
            "debug_info": {
                "repl_process_active": True,
                "repl_ready": True,
                "execution": "success"
            }
        }

    except Exception as e:
        return {
            "success": False,
            "stdout": stdout_capture.getvalue(),
            "stderr": stderr_capture.getvalue() + f"\n{type(e).__name__}: {str(e)}\n{traceback.format_exc()}",
            "execution_time": time.time() - execution_start,
            "variable_count": repl_state.variable_count,
            "execution_count": repl_state.execution_count,
            "session_id": repl_state.session_id,
            "error": str(e),
            "error_type": type(e).__name__,
            "note": "JSON REPL Session - Error occurred during execution",
            "debug_info": {
                "repl_process_active": True,
                "repl_ready": True,
                "execution": "error"
            }
        }

# ============================================================================
# 🔌 EOT 프레이밍 통신
# ============================================================================

def read_json_input() -> Optional[str]:
    """JSON 입력 읽기 (EOT 문자로 종료)"""
    try:
        input_data = ""
        while True:
            char = sys.stdin.read(1)
            if not char:  # EOF
                return None
            if char == '\x04':  # EOT 문자
                break
            input_data += char
        
        return input_data.strip()
    except Exception as e:
        logger.error(f"입력 읽기 오류: {e}")
        return None

def send_json_response(response: Dict[str, Any]):
    """JSON 응답 전송 (EOT 문자로 종료)"""
    try:
        response_json = json.dumps(response, ensure_ascii=False)
        sys.stdout.write(response_json)
        sys.stdout.write('\x04')  # EOT 문자
        sys.stdout.flush()
    except Exception as e:
        logger.error(f"응답 전송 오류: {e}")
        error_response = {
            "success": False,
            "error": f"Response encoding error: {str(e)}",
            "error_type": "ResponseError"
        }
        sys.stdout.write(json.dumps(error_response))
        sys.stdout.write('\x04')
        sys.stdout.flush()

# ============================================================================
# 🔄 메인 루프
# ============================================================================

def main_loop():
    """메인 실행 루프"""
    logger.info("=== JSON REPL Session v4.0 시작 ===")
    
    # 시스템 초기화
    bootstrap_system = BootstrapSystem()
    session_manager = SessionManager()
    protection_system = HelperProtectionSystem()
    
    # Bootstrap 실행
    if not bootstrap_system.run_bootstrap():
        logger.error("Bootstrap 실패 - 기본 모드로 실행")
    
    # 헬퍼 보호 설정
    protection_system.protect_helpers(repl_state.repl_globals)
    
    # 기본 모듈 임포트
    default_imports = """
import os
import sys
import json
import datetime
from pathlib import Path
import numpy as np
import pandas as pd
"""
    
    try:
        exec(default_imports, repl_state.repl_globals)
        logger.info("기본 모듈 임포트 완료")
    except Exception as e:
        logger.warning(f"일부 모듈 임포트 실패: {e}")
    
    # 프로젝트 컨텍스트를 전역에 추가
    if repl_state.project_context:
            if repl_state.ai_brain and hasattr(repl_state.ai_brain, '_global_state'):
                context = repl_state.ai_brain._global_state.context
                if context:
                    repl_state.repl_globals['context'] = context
    
    logger.info("REPL 준비 완료 - 입력 대기 중...")
    
    # 핸들러에게 준비 완료 신호 전송
    print("__READY__", flush=True)
    
    # 초기 상태 응답은 보내지 않음 (핸들러가 혼란스러워함)
    # initial_response = {
    #     "success": True,
    #     "session_mode": "JSON_REPL",
    #     "session_id": repl_state.session_id,
    #     "project_root": str(repl_state.project_root) if repl_state.project_root else None,
    #     "context_available": CONTEXT_MANAGER_AVAILABLE,
    #     "ai_brain_available": AI_BRAIN_AVAILABLE,
    #     "helpers_count": len(protection_system.protected_functions),
    #     "note": "JSON REPL Session Ready",
    #     "timestamp": dt.datetime.now().isoformat()
    # }
    # send_json_response(initial_response)
    
    # 메인 루프
    try:
        while True:
            # 입력 읽기
            code_input = read_json_input()
            if code_input is None:
                logger.info("EOF 감지 - 종료")
                break
            
            # 코드 파싱
            try:
                request = json.loads(code_input)
                request_id = request.get('id', None)  # 요청 ID 저장
                code = request.get('code', '')
                language = request.get('language', 'python')
                
                if language != 'python':
                    response = {
                        "success": False,
                        "error": f"Unsupported language: {language}",
                        "error_type": "LanguageError"
                    }
                    if request_id:
                        response['id'] = request_id
                else:
                    # 헬퍼 함수 상태 확인 및 복원
                    protection_system.restore_if_needed(repl_state.repl_globals, bootstrap_system)
                    
                    # 코드 실행
                    response = execute_code_block(code, repl_state.repl_globals)
                    response['language'] = language
                    response['session_mode'] = 'JSON_REPL'
                    response['timestamp'] = dt.datetime.now().isoformat()
                    if request_id:
                        response['id'] = request_id  # 요청 ID를 응답에 포함
                
            except json.JSONDecodeError as e:
                response = {
                    "success": False,
                    "error": f"Invalid JSON: {str(e)}",
                    "error_type": "JSONDecodeError"
                }
            except Exception as e:
                response = {
                    "success": False,
                    "error": str(e),
                    "error_type": type(e).__name__,
                    "traceback": traceback.format_exc()
                }
            
            # 응답 전송
            send_json_response(response)
    
    except KeyboardInterrupt:
        logger.info("KeyboardInterrupt - 종료")
    except Exception as e:
        logger.error(f"메인 루프 오류: {e}")
        traceback.print_exc(file=sys.stderr)
    finally:
        # 종료 처리
        cleanup()

# ============================================================================
# 🚀 초기화 및 시작
# ============================================================================

def cleanup():
    """종료 시 정리 작업"""
    logger.info("=== 정리 작업 시작 ===")
    
    # 세션 저장
    session_manager = SessionManager()
    session_manager.save_session()
    session_manager.save_last_session_info()
    
    # Context 저장
    if CONTEXT_MANAGER_AVAILABLE and repl_state.project_context:
        try:
            save_context()
            logger.info("✅ 최종 컨텍스트 저장 완료")
        except Exception as e:
            logger.error(f"최종 컨텍스트 저장 실패: {e}")
    
    logger.info("=== JSON REPL Session 종료 ===")

def initialize_system():
    """시스템 초기화"""
    # 플랫폼별 설정
    if platform.system() == 'Windows':
        # Windows 콘솔 UTF-8 설정
        try:
            subprocess.run(['chcp', '65001'], shell=True, capture_output=True)
        except:
            pass
    
    # 표준 스트림 인코딩 설정
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(encoding='utf-8')
    if hasattr(sys.stderr, 'reconfigure'):
        sys.stderr.reconfigure(encoding='utf-8')
    
    # 버퍼링 비활성화
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', line_buffering=True)
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', line_buffering=True)

# ============================================================================
# 🎯 메인 실행
# ============================================================================

if __name__ == "__main__":
    try:
        # 시스템 초기화
        initialize_system()
        
        # 메인 루프 실행
        main_loop()
        
    except Exception as e:
        logger.error(f"치명적 오류: {e}")
        traceback.print_exc(file=sys.stderr)
        
        # 오류 응답
        error_response = {
            "success": False,
            "error": str(e),
            "error_type": "FatalError",
            "traceback": traceback.format_exc()
        }
        send_json_response(error_response)
        
        sys.exit(1)
