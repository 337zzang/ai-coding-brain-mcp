# ===========================================
# Public API - Only these 7 functions are exposed
# ===========================================
__all__ = [
    'sync_to_files',          # ìºì‹œ â†’ íŒŒì¼ ë™ê¸°í™”
    'sync_from_files',        # íŒŒì¼ â†’ ìºì‹œ ë™ê¸°í™”
    'auto_save',              # ìë™ ì €ì¥
    'force_sync',             # ê°•ì œ ì–‘ë°©í–¥ ë™ê¸°í™”
    'save_coding_experience', # ê°œë°œ ê²½í—˜ ì €ì¥
    'search_coding_solutions',# ê³¼ê±° í•´ê²°ì±… ê²€ìƒ‰
    'get_coding_insights'     # í”„ë¡œì íŠ¸ ì¸ì‚¬ì´íŠ¸
]

"""
ğŸ”¥ ë°”ì´ë¸Œ ì½”ë”© ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ
========================

ë°”ì´ë¸Œì½”ë”©ì— ìµœì í™”ëœ ë©”ëª¨ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ
- VibeMemoryManager: ë°”ì´ë¸Œ ë©”ëª¨ë¦¬ ê´€ë¦¬ í•µì‹¬
- VibeCommandSystem: ë°”ì´ë¸Œ ëª…ë ¹ì–´ ì‹œìŠ¤í…œ (/task, /flow ë“±)
- VibeAutoSync: ì‹¤ì‹œê°„ ìë™ ë™ê¸°í™”

ì‘ì„±ì: Claude + ì‚¬ìš©ì í˜‘ì—…  
ìƒì„±ì¼: 2025-06-04
ì¦‰ì‹œ êµ¬í˜„ ì™„ë£Œ: Phase 1-5 ëª¨ë“  ë‹¨ê³„ ì™„ì„±
"""

import os
import json
import datetime as dt
from typing import Dict, List, Any, Optional
import sys


import json
from datetime import datetime

def __get_memory_bank_root_from_claude_config():
    """Claude Desktop ì„¤ì •ì—ì„œ MEMORY_BANK_ROOT ë™ì  ì½ê¸°"""
    import os
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        # ai-coding-brain-mcp ì„œë²„ ì„¤ì •ì—ì„œ MEMORY_BANK_ROOT ì¶”ì¶œ
        memory_root = config['mcpServers']['ai-coding-brain-mcp']['env']['MEMORY_BANK_ROOT']
        print(f"âœ… Claude Desktop ì„¤ì •ì—ì„œ ë©”ëª¨ë¦¬ ë£¨íŠ¸ ë¡œë“œ: {memory_root}")
        return memory_root
    except Exception as e:
        print(f"âš ï¸ Claude ì„¤ì • ì½ê¸° ì‹¤íŒ¨: {e}")
        # í´ë°± ê²½ë¡œ
        fallback_path = r"C:\Users\Administrator\Desktop\memory"
        print(f"ğŸ“ í´ë°± ê²½ë¡œ ì‚¬ìš©: {fallback_path}")
        return fallback_path

def _sync_project_context_with_memory_bank(project_context):
    """project_contextë¥¼ ë©”ëª¨ë¦¬ ë±…í¬ì™€ ë™ê¸°í™”"""
    memory_root = __get_memory_bank_root_from_claude_config()
    project_name = project_context.get('name', 'common')
    project_memory_path = os.path.join(memory_root, project_name)
    
    # í”„ë¡œì íŠ¸ ë©”ëª¨ë¦¬ í´ë” ìƒì„±
    os.makedirs(project_memory_path, exist_ok=True)
    
    # project_contextì— ë©”ëª¨ë¦¬ ê²½ë¡œ ì •ë³´ ì €ì¥
    project_context['memory_bank'] = {
        'root': memory_root,
        'project_path': project_memory_path,
        'project_name': project_name,
        'last_sync': datetime.now().isoformat(),
        'sync_enabled': True
    }
    
    # sync_status ì´ˆê¸°í™”
    if 'sync_status' not in project_context:
        project_context['sync_status'] = {
            'last_sync': datetime.now().isoformat(),
            'pending_changes': [],
            'auto_sync': True
        }
    
    return project_memory_path




def _ensure_data_compatibility(project_context):
    """ë‘ ì‹œìŠ¤í…œì˜ ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥"""
    # AI Coding Brain êµ¬ì¡° -> Vibe System êµ¬ì¡° ë§¤í•‘
    if 'vibe_system' not in project_context:
        project_context['vibe_system'] = {}
    
    vibe_sys = project_context['vibe_system']
    
    # current_focus ë™ê¸°í™”
    if 'current_focus' in project_context and project_context['current_focus']:
        vibe_sys['current_focus'] = project_context['current_focus']
    elif 'current_focus' not in vibe_sys:
        vibe_sys['current_focus'] = ''
    
    # next_tasks ë™ê¸°í™”
    if 'next_tasks' in project_context and project_context['next_tasks']:
        # AI Brainì˜ ë‹¨ìˆœ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ë¥¼ Vibe í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        vibe_tasks = []
        for task in project_context['next_tasks']:
            if isinstance(task, str):
                vibe_tasks.append({
                    'description': task,
                    'added_time': datetime.now().strftime("%H:%M"),
                    'status': 'pending'
                })
            else:
                vibe_tasks.append(task)
        vibe_sys['next_tasks'] = vibe_tasks
    elif 'next_tasks' not in vibe_sys:
        vibe_sys['next_tasks'] = []
    
    # work_tracking ì •ë³´ë„ í™œìš©
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        if 'current_focus' in wt and wt['current_focus']:
            vibe_sys['current_focus'] = wt['current_focus']
        if 'next_tasks' in wt and wt['next_tasks']:
            # work_trackingì˜ tasksë„ ë³‘í•©
            for task in wt['next_tasks']:
                if isinstance(task, str) and task not in [t.get('description', t) for t in vibe_sys['next_tasks']]:
                    vibe_sys['next_tasks'].append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
    
    # completed_tasks ì´ˆê¸°í™”
    if 'completed_tasks' not in vibe_sys:
        vibe_sys['completed_tasks'] = []
    
    # session_activities ì´ˆê¸°í™”
    if 'session_activities' not in vibe_sys:
        vibe_sys['session_activities'] = []
    
    return project_context

def _parse_coding_flow_md(file_path):
    """coding_flow.md íŒŒì¼ì„ íŒŒì‹±í•´ì„œ ë”•ì…”ë„ˆë¦¬ë¡œ ë°˜í™˜"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        coding_flow = {
            'current_focus': '',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }
        
        lines = content.split('\n')
        current_section = None
        
        for line in lines:
            line_stripped = line.strip()
            
            # ì„¹ì…˜ ê°ì§€
            if any(marker in line for marker in ['ğŸ”¥ Current Focus', 'Current Focus', '## ğŸ¯ Current Focus']):
                current_section = 'focus'
            elif any(marker in line for marker in ['â­ï¸ Next Up', 'Next Up', '## ğŸ“‹ Next Tasks']):
                current_section = 'next_up'
            elif any(marker in line for marker in ['âœ… Completed', 'Completed']):
                current_section = 'completed'
            elif any(marker in line for marker in ['ğŸ“ Quick Notes', 'Quick Notes']):
                current_section = 'notes'
            elif any(marker in line for marker in ['ğŸš« Blockers', 'Blockers']):
                current_section = 'blockers'
            elif any(marker in line for marker in ['ğŸ“ Working Files', 'Working Files']):
                current_section = 'files'
            elif any(marker in line for marker in ['ğŸ• Session Activity', 'Session Activity']):
                current_section = 'activity'
            
            # ë‚´ìš© íŒŒì‹±
            elif current_section == 'focus' and line_stripped and not line_stripped.startswith('#') and not line_stripped.startswith('*'):
                if not coding_flow['current_focus']:
                    coding_flow['current_focus'] = line_stripped
            
            elif current_section == 'next_up':
                # ë‹¤ì–‘í•œ ì²´í¬ë°•ìŠ¤ í˜•ì‹ ì§€ì›
                if line_stripped.startswith('- [ ]') or line_stripped.startswith('â€¢ [ ]'):
                    task = line_stripped[5:].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
                elif line_stripped.startswith('-') and '[' not in line_stripped:
                    # ì²´í¬ë°•ìŠ¤ ì—†ëŠ” í•­ëª©ë„ ì§€ì›
                    task = line_stripped[1:].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
                elif line_stripped and line_stripped[0].isdigit() and '.' in line_stripped:
                    # ë²ˆí˜¸ í˜•ì‹ (1. task) ì§€ì›
                    task = line_stripped.split('.', 1)[1].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
            
            elif current_section == 'completed' and (line_stripped.startswith('- [x]') or line_stripped.startswith('â€¢ [x]')):
                task = line_stripped[5:].strip()
                if task and task not in coding_flow['completed']:
                    coding_flow['completed'].append(task)
            
            elif current_section == 'notes' and line_stripped and not line_stripped.startswith('#'):
                coding_flow['quick_notes'] += line_stripped + '\n'
        
        # quick_notes ì •ë¦¬
        coding_flow['quick_notes'] = coding_flow['quick_notes'].strip()
        
        return coding_flow
        
    except Exception as e:
        print(f"âš ï¸ coding_flow.md íŒŒì‹± ì‹¤íŒ¨: {e}")
        return {
            'current_focus': 'memory_cache_persistence_system',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }

def __generate_coding_flow_md(coding_flow_data, memory_path):
    """coding_flow ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ coding_flow.md ìƒì„±"""
    try:
        content = f"""# ğŸ”¥ Current Focus
*ì§€ê¸ˆ ë­í•˜ê³  ìˆëŠ”ì§€*

{coding_flow_data.get('current_focus', 'memory_cache_persistence_system')}

## â­ï¸ Next Up ({len(coding_flow_data.get('next_up', []))}) tasks)
*ë°”ë¡œ ë‹¤ìŒì— í•  ì¼ë“¤*

"""
        
        for task in coding_flow_data.get('next_up', []):
            content += f"- [ ] {task}\n"
        
        content += f"""
## âœ… Completed ({len(coding_flow_data.get('completed', []))}) tasks)
*ì™„ë£Œëœ ì‘ì—…ë“¤*

"""
        
        for task in coding_flow_data.get('completed', []):
            content += f"- [x] {task}\n"
        
        content += f"""
## ğŸ“ Quick Notes
*ë¹ ë¥¸ ë©”ëª¨*

{coding_flow_data.get('quick_notes', '')}

## ğŸ“ Working Files
*ìµœê·¼ ì£¼ë¡œ ì‘ì—…í•œ íŒŒì¼ë“¤*

"""
        # Working Files ì„¹ì…˜ ì¶”ê°€
        working_files = coding_flow_data.get('working_files', [])
        if working_files:
            for file_info in working_files:
                content += f"- {file_info.get('name', 'N/A')} ({file_info.get('count', 0)}íšŒ ì ‘ê·¼)\n"
        else:
            content += "- (ì¶”ì ëœ ì‘ì—… íŒŒì¼ ì—†ìŒ)\n"
        
        content += f"""
## ğŸ• Session Activity Log
*ìµœê·¼ 10ê°œ í™œë™ ìš”ì•½*

"""
        # Session Activity Log ì„¹ì…˜ ì¶”ê°€
        activity_log = coding_flow_data.get('activity_log', [])
        if activity_log:
            for log in activity_log[:10]:  # ìµœê·¼ 10ê°œë§Œ
                content += f"- {log.get('time', '')}: {log.get('op', '')} - {log.get('target', '')}\n"
        else:
            content += "- (ê¸°ë¡ëœ í™œë™ ì—†ìŒ)\n"
        
        content += f"""
ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
ë™ê¸°í™” ë°©ì‹: ì‹¤ì‹œê°„ ìë™ ë™ê¸°í™”

## ğŸ”§ System Status
- Cache items: {len(coding_flow_data)}
- Auto sync: True
- Base path: {memory_path}
"""
        
        coding_flow_file = os.path.join(memory_path, 'coding_flow.md')
        with open(coding_flow_file, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"âœ… coding_flow.md ì—…ë°ì´íŠ¸: {coding_flow_file}")
        return True
        
    except Exception as e:
        print(f"âŒ coding_flow.md ìƒì„± ì‹¤íŒ¨: {e}")
        return False

def _load_live_context_from_memory(project_context):
    """ë©”ëª¨ë¦¬ í´ë”ì—ì„œ live_context ìºì‹œë¡œ ë¡œë“œ ë° vibe_system ë™ê¸°í™”"""
    try:
        memory_path = project_context['memory_bank']['project_path']
        live_context = {}
        
        # coding_flow.md íŒŒì‹±
        coding_flow_file = os.path.join(memory_path, 'coding_flow.md')
        if os.path.exists(coding_flow_file):
            live_context['coding_flow'] = _parse_coding_flow_md(coding_flow_file)
            print(f"âœ… coding_flow.md ë¡œë“œ ì™„ë£Œ")
            
            # vibe_systemì— ë™ê¸°í™” (ì¤‘ìš”!)
            if 'vibe_system' in project_context:
                coding_flow = live_context['coding_flow']
                
                # Current Focus ë™ê¸°í™”
                if coding_flow.get('current_focus'):
                    project_context['vibe_system']['current_focus'] = coding_flow['current_focus']
                
                # Next Tasks ë™ê¸°í™”
                if coding_flow.get('next_up'):
                    tasks = []
                    for task_text in coding_flow['next_up']:
                        tasks.append({
                            'task': task_text,
                            'description': task_text,
                            'added_time': datetime.now().strftime("%H:%M"),
                            'status': 'pending',
                            'completed': False
                        })
                    project_context['vibe_system']['next_tasks'] = tasks
                
                # Completed Tasks ë™ê¸°í™”
                if coding_flow.get('completed'):
                    completed = []
                    for task_text in coding_flow['completed']:
                        completed.append({
                            'task': task_text,
                            'description': task_text,
                            'completed_time': datetime.now().strftime("%H:%M"),
                            'status': 'completed',
                            'completed': True
                        })
                    project_context['vibe_system']['completed_tasks'] = completed
                
                print(f"âœ… vibe_system ë™ê¸°í™” ì™„ë£Œ: Focus={coding_flow.get('current_focus', 'None')}, Tasks={len(coding_flow.get('next_up', []))}")
        else:
            live_context['coding_flow'] = {
                'current_focus': 'memory_cache_persistence_system',
                'next_up': [],
                'completed': [],
                'quick_notes': '',
                'last_updated': datetime.now().isoformat()
            }
            print(f"ğŸ“ coding_flow.md ê¸°ë³¸ê°’ ìƒì„±")
        
        # ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ë“¤ë„ ê¸°ë³¸ê°’ ì„¤ì •
        live_context['feature_roadmap'] = {'features': [], 'priorities': []}
        live_context['code_analysis'] = {'recent_files': [], 'insights': []}
        live_context['decision_log'] = {'decisions': []}
        live_context['project_vision'] = {'goals': [], 'principles': []}
        
        project_context['live_context'] = live_context
        print(f"âœ… live_context ë¡œë“œ ì™„ë£Œ: {len(live_context)}ê°œ ì»¨í…ìŠ¤íŠ¸")
        
        return live_context
        
    except Exception as e:
        print(f"âŒ live_context ë¡œë“œ ì‹¤íŒ¨: {e}")
        project_context['live_context'] = {
            'coding_flow': {
                'current_focus': 'memory_cache_persistence_system',
                'next_up': [],
                'completed': [],
                'quick_notes': '',
                'last_updated': datetime.now().isoformat()
            }
        }
        return project_context['live_context']

def _sync_live_context_to_memory(project_context, changed_keys=None):
    """live_context ë³€ê²½ì‚¬í•­ì„ ë©”ëª¨ë¦¬ í´ë”ì— ì¦‰ì‹œ ë°˜ì˜"""
    try:
        memory_path = project_context['memory_bank']['project_path']
        live_context = project_context.get('live_context', {})
        
        # ë³€ê²½ëœ í‚¤ë§Œ ë™ê¸°í™” (ì„±ëŠ¥ ìµœì í™”)
        keys_to_sync = changed_keys or live_context.keys()
        
        synced_count = 0
        for key in keys_to_sync:
            if key == 'coding_flow' and 'coding_flow' in live_context:
                if __generate_coding_flow_md(live_context['coding_flow'], memory_path):
                    synced_count += 1
            # ì¶”í›„ ë‹¤ë¥¸ íŒŒì¼ë“¤ë„ ì¶”ê°€ ì˜ˆì •
        
        # ë™ê¸°í™” ìƒíƒœ ì—…ë°ì´íŠ¸
        project_context['sync_status']['last_sync'] = datetime.now().isoformat()
        if changed_keys:
            project_context['sync_status']['pending_changes'] = []
        
        print(f"ğŸ”„ Live context ë™ê¸°í™” ì™„ë£Œ: {synced_count}ê°œ íŒŒì¼")
        return True
        
    except Exception as e:
        print(f"âŒ Live context ë™ê¸°í™” ì‹¤íŒ¨: {e}")
        return False

def _auto_sync_hook(project_context, trigger='unknown'):
    """execute_code í—¬í¼ í•¨ìˆ˜ ì‹¤í–‰ í›„ ìë™ ë™ê¸°í™”"""
    try:
        if project_context.get('sync_status', {}).get('auto_sync', True):
            _sync_live_context_to_memory(project_context)
            print(f"ğŸ”„ Auto-sync triggered by: {trigger}")
            return True
        else:
            print(f"â¸ï¸ Auto-sync disabled (trigger: {trigger})")
            return False
    except Exception as e:
        print(f"âŒ Auto-sync ì‹¤íŒ¨: {e}")
        return False



def _ensure_vibe_memory_structure(memory_path: str) -> bool:
    """ë°”ì´ë¸Œ ë©”ëª¨ë¦¬ êµ¬ì¡° í™•ì¸ ë° ìƒì„±"""
    try:
        os.makedirs(memory_path, exist_ok=True)
        return True
    except Exception as e:
        print(f"âŒ Error ensuring vibe memory structure: {e}")
        return False


def get_vibe_coding_flow_template() -> str:
    """coding_flow.md í…œí”Œë¦¿ ìƒì„±"""
    timestamp = dt.datetime.now().strftime("%Y-%m-%d %H:%M")
    return f"""# ğŸ”¥ Current Focus
*ì§€ê¸ˆ ë­í•˜ê³  ìˆëŠ”ì§€*

í˜„ì¬ ì„¸ì…˜ ì‹œì‘: {timestamp}

## â­ï¸ Next Up (1-3 items)
*ë°”ë¡œ ë‹¤ìŒì— í•  ì¼ë“¤*

- [ ] 


## ğŸ“ Quick Notes
*ë¹ ë¥¸ ë©”ëª¨ë‚˜ ìƒê°ë“¤*



## ğŸš« Blockers
*ë§‰íˆê±°ë‚˜ í•´ê²°í•´ì•¼ í•  ê²ƒë“¤*



## ğŸ“ Working Files
*í˜„ì¬ ì‘ì—…ì¤‘ì¸ íŒŒì¼ë“¤*



## ğŸ• Session Activity Log
*ì´ ì„¸ì…˜ì—ì„œ í•œ ì¼ë“¤*

- {timestamp[:5]} Session started
"""


def get_vibe_feature_roadmap_template() -> str:
    """feature_roadmap.md í…œí”Œë¦¿ ìƒì„±"""
    return """# ğŸš§ In Progress
*ì§€ê¸ˆ ë§Œë“¤ê³  ìˆëŠ” ê¸°ëŠ¥ë“¤*



## ğŸ“‹ Planned Features  
*ì´ë²ˆì— ë§Œë“¤ ì˜ˆì •ì¸ ê¸°ëŠ¥ë“¤*



## âœ… Completed
*ì™„ë£Œëœ ê¸°ëŠ¥ë“¤*



## ğŸ”— Dependencies
*ê¸°ëŠ¥ê°„ ì˜ì¡´ì„±ì´ë‚˜ ìˆœì„œ*



## ğŸ§ª Testing Notes
*í…ŒìŠ¤íŠ¸ ê´€ë ¨ ë©”ëª¨*

"""


def get_vibe_project_vision_template() -> str:
    """project_vision.md í…œí”Œë¦¿ ìƒì„±"""
    return """# ğŸ¯ Project Overview
*ì´ í”„ë¡œì íŠ¸ê°€ ë­”ì§€*

## AI-Coding-Brain-MCP
execute_code ê¸°ë°˜ 24ê°œ í—¬í¼ í•¨ìˆ˜ì™€ ì§€ì†ì  ì„¸ì…˜ì„ í™œìš©í•œ ì§€ëŠ¥í˜• ê°œë°œ ì–´ì‹œìŠ¤í„´íŠ¸

## ğŸ—ï¸ Architecture
*ì „ì²´ êµ¬ì¡°ì™€ ì„¤ê³„*

### Core Components
- execute_code ì‹œìŠ¤í…œ (24ê°œ í—¬í¼ í•¨ìˆ˜)
- parse_with_snippets ì¤‘ì‹¬ ë¶„ì„
- ì—°ì† ì„¸ì…˜ ìƒíƒœ ê´€ë¦¬
- í”¼ë“œë°± ê¸°ë°˜ í•™ìŠµ

## ğŸ› ï¸ Tech Stack
*ì‚¬ìš©í•˜ëŠ” ê¸°ìˆ ë“¤*

- Python (core logic)
- JavaScript/TypeScript (MCP)
- JSON (data storage)
- Markdown (documentation)

## ğŸ—‚ï¸ Major Milestones
*ì£¼ìš” ë§ˆì¼ìŠ¤í†¤ë“¤*

- [x] Basic helper functions
- [x] parse_with_snippets êµ¬í˜„
- [x] í”¼ë“œë°± ì‹œìŠ¤í…œ
- [x] Vibe Memory System êµ¬í˜„

## ğŸ”® Future Direction
*ì•ìœ¼ë¡œì˜ ë°©í–¥*

- ë” ì§€ëŠ¥ì ì¸ ì½”ë“œ ë¶„ì„
- ìë™í™” í™•ëŒ€
- ê°œë°œì ê²½í—˜ ê°œì„ 
"""


def vibe_task_capture(description: str, project_context: dict) -> str:
    """'/task "ì„¤ëª…"' - ì¦‰ì‹œ íƒœìŠ¤í¬ ì¶”ê°€ (ëª¨ë“  êµ¬ì¡° ì§€ì›)"""
    if not description.strip():
        return "âŒ Task description required"
    
    # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥
    _ensure_data_compatibility(project_context)
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    task_entry = {
        'description': description.strip(),
        'added_time': timestamp,
        'status': 'pending'
    }
    
    # ì—¬ëŸ¬ ìœ„ì¹˜ì— ì¶”ê°€ (í˜¸í™˜ì„±)
    # 1. vibe_systemì— ì¶”ê°€
    if 'vibe_system' in project_context:
        project_context['vibe_system']['next_tasks'].append(task_entry)
    
    # 2. ìµœìƒìœ„ next_tasksì—ë„ ì¶”ê°€ (AI Brain í˜¸í™˜)
    if 'next_tasks' not in project_context:
        project_context['next_tasks'] = []
    project_context['next_tasks'].append(description.strip())
    
    # 3. work_trackingì—ë„ ì¶”ê°€
    if 'work_tracking' in project_context:
        if 'next_tasks' not in project_context['work_tracking']:
            project_context['work_tracking']['next_tasks'] = []
        if description.strip() not in project_context['work_tracking']['next_tasks']:
            project_context['work_tracking']['next_tasks'].append(description.strip())
    
    return f"âœ… Task added: {description.strip()}"


def vibe_task_complete(task_description: str, project_context: dict) -> str:
    """'/done "íƒœìŠ¤í¬"' - íƒœìŠ¤í¬ ì™„ë£Œ ì²˜ë¦¬ (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
    if not task_description.strip():
        return "âŒ Task description required"
    
    if 'vibe_system' not in project_context:
        return "âŒ Vibe system not initialized"
    
    task_desc = task_description.strip()
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    # ì§„í–‰ì¤‘ì¸ íƒœìŠ¤í¬ì—ì„œ ì œê±°
    vibe_sys = project_context['vibe_system']
    remaining_tasks = []
    task_found = False
    
    for task in vibe_sys.get('next_tasks', []):
        if task.get('description', '') == task_desc:
            task_found = True
            # ì™„ë£Œëœ íƒœìŠ¤í¬ë¡œ ì´ë™
            completed_task = task.copy()
            completed_task['completed_time'] = timestamp
            completed_task['status'] = 'completed'
            
            if 'completed_tasks' not in vibe_sys:
                vibe_sys['completed_tasks'] = []
            vibe_sys['completed_tasks'].append(completed_task)
        else:
            remaining_tasks.append(task)
    
    vibe_sys['next_tasks'] = remaining_tasks
    
    if task_found:
        return f"âœ… Task completed: {task_desc}"
    else:
        return f"âŒ Task not found: {task_desc}"


def vibe_update_focus(new_focus: str, project_context: dict) -> str:
    """'/focus "ìƒˆí¬ì»¤ìŠ¤"' - í˜„ì¬ ì§‘ì¤‘ ì˜ì—­ ë³€ê²½ (ëª¨ë“  êµ¬ì¡° ì§€ì›)"""
    if not new_focus.strip():
        return "âŒ Focus description required"
    
    # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥
    _ensure_data_compatibility(project_context)
    
    # ì—¬ëŸ¬ ìœ„ì¹˜ì— ì—…ë°ì´íŠ¸ (í˜¸í™˜ì„±)
    # 1. vibe_system
    if 'vibe_system' in project_context:
        project_context['vibe_system']['current_focus'] = new_focus.strip()
    
    # 2. ìµœìƒìœ„ current_focus (AI Brain í˜¸í™˜)
    project_context['current_focus'] = new_focus.strip()
    
    # 3. work_tracking
    if 'work_tracking' in project_context:
        project_context['work_tracking']['current_focus'] = new_focus.strip()
    
    return f"âœ… Focus updated: {new_focus.strip()}"


def vibe_get_current_flow(project_context: dict) -> str:
    """'/flow' - í˜„ì¬ ì½”ë”© í”Œë¡œìš° ë³´ê¸° (ìºì‹œì™€ íŒŒì¼ ëª¨ë‘ í™•ì¸)"""
    # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥
    _ensure_data_compatibility(project_context)
    
    # vibe_systemì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    vibe_sys = project_context.get('vibe_system', {})
    
    # í˜„ì¬ focus í™•ì¸ (ì—¬ëŸ¬ ì†ŒìŠ¤ì—ì„œ)
    current_focus = (
        vibe_sys.get('current_focus') or 
        project_context.get('current_focus') or 
        project_context.get('work_tracking', {}).get('current_focus') or
        'No current focus set'
    )
    
    # next_tasks í†µí•©
    all_tasks = []
    seen_tasks = set()
    
    # vibe_systemì˜ tasks
    for task in vibe_sys.get('next_tasks', []):
        desc = task.get('description', task) if isinstance(task, dict) else str(task)
        if desc not in seen_tasks:
            all_tasks.append(task)
            seen_tasks.add(desc)
    
    # project_contextì˜ tasks
    for task in project_context.get('next_tasks', []):
        desc = task if isinstance(task, str) else task.get('description', str(task))
        if desc not in seen_tasks:
            all_tasks.append({
                'description': desc,
                'added_time': datetime.now().strftime("%H:%M"),
                'status': 'pending'
            } if isinstance(task, str) else task)
            seen_tasks.add(desc)
    
    # work_trackingì˜ tasks
    for task in project_context.get('work_tracking', {}).get('next_tasks', []):
        desc = task if isinstance(task, str) else task.get('description', str(task))
        if desc not in seen_tasks:
            all_tasks.append({
                'description': desc,
                'added_time': datetime.now().strftime("%H:%M"),
                'status': 'pending'
            } if isinstance(task, str) else task)
            seen_tasks.add(desc)
    
    # íŒŒì¼ì—ì„œë„ ì½ê¸° ì‹œë„
    try:
        memory_path = project_context.get('memory_bank', {}).get('project_path')
        if not memory_path:
            # ê²½ë¡œ ìë™ ê°ì§€
            memory_root = __get_memory_bank_root_from_claude_config()
            project_name = project_context.get('name', 'common')
            memory_path = os.path.join(memory_root, project_name)
        
        flow_file = os.path.join(memory_path, 'coding_flow.md')
        if os.path.exists(flow_file):
            file_data = _parse_coding_flow_md(flow_file)
            
            # íŒŒì¼ì˜ focusê°€ ë” êµ¬ì²´ì ì´ë©´ ì‚¬ìš©
            if file_data.get('current_focus') and current_focus == 'No current focus set':
                current_focus = file_data['current_focus']
            
            # íŒŒì¼ì˜ tasks ì¶”ê°€
            for task in file_data.get('next_up', []):
                if task not in seen_tasks:
                    all_tasks.append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
                    seen_tasks.add(task)
    except Exception as e:
        print(f"âš ï¸ íŒŒì¼ ì½ê¸° ì¤‘ ì˜¤ë¥˜: {e}")
    
    # ê²°ê³¼ ìƒì„±
    result = "ğŸ“‹ CURRENT CODING FLOW:\n" + "="*40 + "\n"
    result += f"\nğŸ”¥ Current Focus: {current_focus}\n"
    result += f"\nâ­ï¸ Next Up ({len(all_tasks)} tasks):\n"
    
    for i, task in enumerate(all_tasks[:10], 1):  # ìµœê·¼ 10ê°œë§Œ
        desc = task.get('description', task) if isinstance(task, dict) else str(task)
        time = task.get('added_time', '') if isinstance(task, dict) else ''
        result += f"  {i}. {desc}"
        if time:
            result += f" (added {time})"
        result += "\n"
    
    if len(all_tasks) > 10:
        result += f"  ... and {len(all_tasks) - 10} more tasks\n"
    
    # ì‘ì—… í†µê³„ ì¶”ê°€
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        file_access = wt.get('file_access_count', {})
        if file_access:
            result += "\nğŸ“Š Recent Activity:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:3]
            for file_path, count in sorted_files:
                file_name = os.path.basename(file_path)
                result += f"  â€¢ {file_name} ({count} times)\n"
    
    return result


def vibe_execute_code_hook(func_name: str, result: dict, project_context: dict):
    """execute_code ì‹¤í–‰ í›„ ìë™ í˜¸ì¶œ í›… (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
    if 'vibe_system' not in project_context:
        return
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    # í™œë™ ë¡œê·¸ ê¸°ë¡
    activity = {
        'function': func_name,
        'timestamp': timestamp,
        'summary': f"Executed {func_name}"
    }
    
    # í•¨ìˆ˜ë³„ íŠ¹ë³„ ì²˜ë¦¬
    if func_name == 'parse_with_snippets' and isinstance(result, dict):
        file_path = result.get('file_path', 'unknown')
        functions_count = len(result.get('functions', []))
        activity['summary'] = f"Analyzed {functions_count} functions in {os.path.basename(file_path)}"
        
        # í¬ì»¤ìŠ¤ ìë™ ì—…ë°ì´íŠ¸
        project_context['vibe_system']['current_focus'] = f"Analyzing: {os.path.basename(file_path)}"
    
    elif func_name in ['safe_replace', 'insert_line', 'delete_lines']:
        file_path = result.get('file_path', 'unknown')
        activity['summary'] = f"Code modification: {func_name}"
        project_context['vibe_system']['current_focus'] = f"Modifying: {os.path.basename(file_path)}"
    
    # ì„¸ì…˜ í™œë™ì— ì¶”ê°€
    if 'session_activities' not in project_context['vibe_system']:
        project_context['vibe_system']['session_activities'] = []
    
    project_context['vibe_system']['session_activities'].append(activity)
    
    # ìµœê·¼ 20ê°œë§Œ ìœ ì§€
    if len(project_context['vibe_system']['session_activities']) > 20:
        project_context['vibe_system']['session_activities'] = project_context['vibe_system']['session_activities'][-20:]


class VibeMemoryManager:
    """ë°”ì´ë¸Œì½”ë”© ë©”ëª¨ë¦¬ ê´€ë¦¬ì (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
    
    def __init__(self, project_context: dict, project_name: str = None):
        """Claude Desktop ì„¤ì • ê¸°ë°˜ VibeMemoryManager ì´ˆê¸°í™”"""
        self.project_context = project_context

        # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥ (ì¤‘ìš”!)
        _ensure_data_compatibility(self.project_context)

        # project_contextì—ì„œ í”„ë¡œì íŠ¸ëª… ê°€ì ¸ì˜¤ê¸°
        self.project_name = project_name or project_context.get("name", "ai-coding-brain-mcp")

        # Claude Desktop ì„¤ì • ê¸°ë°˜ ê²½ë¡œ ì„¤ì •
        self.memory_bank_root = globals()['__get_memory_bank_root_from_claude_config']()
        self.memory_path = os.path.join(self.memory_bank_root, self.project_name)

        # project_contextì™€ ì—°ë™
        _sync_project_context_with_memory_bank(self.project_context)

        # live_context ë¡œë“œ
        _load_live_context_from_memory(self.project_context)

        # ê¸°ì¡´ í…œí”Œë¦¿ ì„¤ì •
        self.templates = {
            "coding_flow.md": get_vibe_coding_flow_template(),
            "feature_roadmap.md": get_vibe_feature_roadmap_template(),
            "project_vision.md": get_vibe_project_vision_template(),
            "decision-log.md": "# ğŸ§  Decision Log\n*ì¤‘ìš”í•œ ì„¤ê³„ ê²°ì •ë“¤ê³¼ ë°°ê²½*\n\n",
            "system-patterns.md": "# ğŸ”§ System Patterns\n*ì•„í‚¤í…ì²˜ íŒ¨í„´ê³¼ ì½”ë”© íŒ¨í„´ë“¤*\n\n"
        }

        # ë©”ëª¨ë¦¬ ë±…í¬ ì´ˆê¸°í™”
        self.initialize()

        print(f"âœ… VibeMemoryManager ì´ˆê¸°í™” ì™„ë£Œ: {self.memory_path}")
    def initialize(self) -> bool:
        """ë°”ì´ë¸Œ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
        try:
            # ë©”ëª¨ë¦¬ í´ë” ìƒì„±
            _ensure_vibe_memory_structure(self.memory_path)
            
            # project_contextì— vibe_system ì´ˆê¸°í™”
            if 'vibe_system' not in self.project_context:
                self.project_context['vibe_system'] = {
                    'next_tasks': [],
                    'completed_tasks': [],
                    'current_focus': 'Vibe Memory System activated',
                    'session_activities': [],
                    'status': 'active',
                    'initialized_at': dt.datetime.now().isoformat()
                }
            
            # ë§ˆí¬ë‹¤ìš´ íŒŒì¼ë“¤ ìƒì„±
            created_files = []
            for filename, template in self.templates.items():
                filepath = os.path.join(self.memory_path, filename)
                if not os.path.exists(filepath):
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(template)
                    created_files.append(filename)
            
            print(f"âœ… Vibe Memory System initialized")
            print(f"   ğŸ“ Path: {self.memory_path}")
            print(f"   ğŸ“„ Files: {len(self.templates)} markdown files")
            if created_files:
                print(f"   ğŸ†• Created: {', '.join(created_files)}")
            
            return True
            
        except Exception as e:
            print(f"âŒ Vibe initialization error: {e}")
            return False
    
    def get_status(self) -> dict:
        """í˜„ì¬ ë°”ì´ë¸Œ ì‹œìŠ¤í…œ ìƒíƒœ ë°˜í™˜ (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
        if 'vibe_system' not in self.project_context:
            return {'status': 'not_initialized'}
        
        vibe_sys = self.project_context['vibe_system']
        return {
            'status': vibe_sys.get('status', 'unknown'),
            'current_focus': vibe_sys.get('current_focus', ''),
            'pending_tasks': len(vibe_sys.get('next_tasks', [])),
            'completed_tasks': len(vibe_sys.get('completed_tasks', [])),
            'recent_activities': len(vibe_sys.get('session_activities', [])),
            'memory_path': self.memory_path
        }

    def sync_to_files(self):
        """ìºì‹œë©”ëª¨ë¦¬ â†’ .md íŒŒì¼ ë™ê¸°í™” (ê¸°ì¡´ íŒŒì¼ ë‚´ìš© ë³´ì¡´)"""
        try:
            # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥
            _ensure_data_compatibility(self.project_context)
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            sync_results = []
            
            # coding_flow.md ì—…ë°ì´íŠ¸ - ê¸°ì¡´ íŒŒì¼ ë‚´ìš© ë¨¼ì € ì½ê¸°
            flow_path = os.path.join(self.memory_path, 'coding_flow.md')
            if os.path.exists(flow_path):
                # ê¸°ì¡´ íŒŒì¼ íŒŒì‹±
                existing_data = _parse_coding_flow_md(flow_path)
                
                # ë°ì´í„° ë³‘í•© (ìºì‹œ ìš°ì„ , í•˜ì§€ë§Œ ë¹ˆ ê°’ì€ ê¸°ì¡´ ê°’ ìœ ì§€)
                if not vibe_sys.get('current_focus') and existing_data.get('current_focus'):
                    vibe_sys['current_focus'] = existing_data['current_focus']
                
                # ê¸°ì¡´ tasksì™€ ìºì‹œ tasks ë³‘í•© (ì¤‘ë³µ ì œê±°)
                existing_tasks = existing_data.get('next_up', [])
                for task in existing_tasks:
                    if task not in [t.get('description', t) for t in vibe_sys.get('next_tasks', [])]:
                        if 'next_tasks' not in vibe_sys:
                            vibe_sys['next_tasks'] = []
                        vibe_sys['next_tasks'].append({
                            'description': task,
                            'added_time': datetime.now().strftime("%H:%M"),
                            'status': 'pending'
                        })
            
            # ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ íŒŒì¼ ì—…ë°ì´íŠ¸
            if vibe_sys.get('next_tasks') or vibe_sys.get('current_focus') or os.path.exists(flow_path):
                flow_content = self._generate_flow_content(vibe_sys)
                
                with open(flow_path, 'w', encoding='utf-8') as f:
                    f.write(flow_content)
                sync_results.append(f"âœ… Updated coding_flow.md")
            
            # feature_roadmap.md ì—…ë°ì´íŠ¸ (completed_tasks ë°˜ì˜)
            if vibe_sys.get('completed_tasks'):
                roadmap_content = self._generate_roadmap_content(vibe_sys)
                roadmap_path = os.path.join(self.memory_path, 'feature_roadmap.md')
                
                with open(roadmap_path, 'w', encoding='utf-8') as f:
                    f.write(roadmap_content)
                sync_results.append(f"âœ… Updated feature_roadmap.md")
            
            # ë™ê¸°í™” ì‹œê°„ ê¸°ë¡
            vibe_sys['last_sync_to_files'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'synced_files': len(sync_results),
                'results': sync_results,
                'timestamp': vibe_sys['last_sync_to_files']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_from_files(self):
        """.md íŒŒì¼ì„ ìºì‹œë©”ëª¨ë¦¬ë¡œ ë™ê¸°í™” (v1.1ë¶€í„° ë¹„í™œì„±í™”ë¨)"""
        print("âš ï¸ [DEPRECATED] sync_from_files: ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        print("   ë°ì´í„° íë¦„ì€ í•­ìƒ 'Context Manager -> .mdíŒŒì¼' ë‹¨ë°©í–¥ìœ¼ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.")
        print("   .md íŒŒì¼ì€ ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ë³´ì—¬ì£¼ëŠ” ë·°(View) ì—­í• ë§Œ í•©ë‹ˆë‹¤.")
        return {
            'status': 'deprecated', 
            'message': 'Unidirectional data flow enforced. This function is disabled.'
        }
    def auto_save(self, interval=300):
        """ìë™ ì €ì¥ (ê¸°ë³¸ 5ë¶„ ê°„ê²©)"""
        try:
            # í˜„ì¬ëŠ” ì¦‰ì‹œ ë™ê¸°í™”, ë‚˜ì¤‘ì— ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ í™•ì¥ ê°€ëŠ¥
            sync_result = self.sync_to_files()
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            vibe_sys['auto_save_interval'] = interval
            vibe_sys['last_auto_save'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'message': f'Auto-save completed (interval: {interval}s)',
                'sync_result': sync_result,
                'timestamp': vibe_sys['last_auto_save']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def force_sync(self):
        """ê°•ì œ ë™ê¸°í™” (ìºì‹œ -> íŒŒì¼) - v1.1 ë‹¨ë°©í–¥"""
        try:
            print("ğŸ”„ ê°•ì œ ë™ê¸°í™” (Cache -> Files) ì‹¤í–‰...")
            
            # sync_from_files í˜¸ì¶œì„ ì œê±°í•˜ê³  sync_to_filesë§Œ ì‹¤í–‰
            to_files_result = self.sync_to_files()
            
            if to_files_result:
                print("âœ… ë‹¨ë°©í–¥ ë™ê¸°í™” ì™„ë£Œ (Cache â†’ Files)")
                return {
                    'status': 'success',
                    'message': 'Unidirectional sync completed (cache to files)',
                    'direction': 'cache_to_files',
                    'to_files': to_files_result,
                    'timestamp': dt.datetime.now().isoformat()
                }
            else:
                return {'status': 'failed', 'message': 'sync_to_files failed'}
                
        except Exception as e:
            print(f"âŒ ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return {'status': 'error', 'message': str(e)}
    
    def sync_status(self):
        """ë™ê¸°í™” ìƒíƒœ ë° ì°¨ì´ì  í™•ì¸"""
        try:
            if 'vibe_system' not in self.project_context:
                return {'status': 'not_initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            
            # ë§ˆì§€ë§‰ ë™ê¸°í™” ì‹œê°„ë“¤
            last_sync_to = vibe_sys.get('last_sync_to_files', 'Never')
            last_sync_from = vibe_sys.get('last_sync_from_files', 'Never')
            last_auto_save = vibe_sys.get('last_auto_save', 'Never')
            
            # íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
            file_status = {}
            for filename in self.templates.keys():
                filepath = os.path.join(self.memory_path, filename)
                file_status[filename] = {
                    'exists': os.path.exists(filepath),
                    'modified': dt.datetime.fromtimestamp(os.path.getmtime(filepath)).isoformat() if os.path.exists(filepath) else 'N/A'
                }
            
            return {
                'status': 'active',
                'cache_items': {
                    'next_tasks': len(vibe_sys.get('next_tasks', [])),
                    'completed_tasks': len(vibe_sys.get('completed_tasks', [])),
                    'current_focus': bool(vibe_sys.get('current_focus'))
                },
                'sync_history': {
                    'last_sync_to_files': last_sync_to,
                    'last_sync_from_files': last_sync_from,
                    'last_auto_save': last_auto_save
                },
                'file_status': file_status,
                'auto_save_interval': vibe_sys.get('auto_save_interval', 'Not set')
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def enable_auto_sync(self, enabled=True, interval=300):
        """ìë™ ë™ê¸°í™” í™œì„±í™”/ë¹„í™œì„±í™”"""
        try:
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            vibe_sys['auto_sync_enabled'] = enabled
            vibe_sys['auto_sync_interval'] = interval
            vibe_sys['auto_sync_modified'] = dt.datetime.now().isoformat()
            
            if enabled:
                # í™œì„±í™”ì‹œ ì¦‰ì‹œ í•œë²ˆ ë™ê¸°í™”
                sync_result = self.sync_to_files()
                return {
                    'status': 'success',
                    'message': f'Auto-sync enabled (interval: {interval}s)',
                    'initial_sync': sync_result,
                    'timestamp': vibe_sys['auto_sync_modified']
                }
            else:
                return {
                    'status': 'success',
                    'message': 'Auto-sync disabled',
                    'timestamp': vibe_sys['auto_sync_modified']
                }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def _generate_flow_content(self, vibe_sys):
        """coding_flow.md ë‚´ìš© ìƒì„± í—¬í¼ (work_tracking ì •ë³´ë„ í™œìš©)"""
        # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± í™•ì¸
        _ensure_data_compatibility(self.project_context)
        
        current_focus = vibe_sys.get('current_focus', '')
        
        # work_trackingì—ì„œë„ focus ê°€ì ¸ì˜¤ê¸°
        if not current_focus and 'work_tracking' in self.project_context:
            wt_focus = self.project_context['work_tracking'].get('current_focus', '')
            if wt_focus:
                current_focus = wt_focus
        
        if not current_focus:
            current_focus = 'No current focus set'
            
        next_tasks = vibe_sys.get('next_tasks', [])
        
        # work_trackingì—ì„œë„ tasks ê°€ì ¸ì˜¤ê¸°
        if 'work_tracking' in self.project_context:
            wt_tasks = self.project_context['work_tracking'].get('next_tasks', [])
            for task in wt_tasks:
                if isinstance(task, str) and task not in [t.get('description', t) for t in next_tasks]:
                    next_tasks.append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
        

    # ===========================================
    # Claude Memory Integration (from claude_memory_helpers.py)
    # ===========================================
    
        def save(self, key: str, content: str, metadata: Dict[str, Any] = None) -> Dict[str, Any]:
            """ğŸ’¾ ChromaDB ê¸°ë°˜ ê²½í—˜ ì €ì¥ (save_coding_experience ë˜í•‘)"""
            if not self.claude_memory:
                return {'status': 'error', 'message': 'Claude Memory not initialized'}
        
            try:
                # keyë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê²½í—˜ ë°ì´í„° êµ¬ì„±
                experience_data = {
                    'key': key,
                    'content': content,
                    'timestamp': None,  # ìë™ ìƒì„±
                    'project_context': os.path.basename(os.getcwd()),
                    'tech_stack': self._detect_tech_stack(content),
                    'metadata': metadata or {}
                }
            
                # ê¸°ì¡´ save_coding_experience í˜¸ì¶œ
                result = self.save_coding_experience(
                    experience_data=experience_data,
                    project_context=experience_data['project_context'],
                    tech_stack=experience_data['tech_stack'],
                    auto_categorize=True
                )
            
                return {
                    'status': 'success',
                    'key': key,
                    'result': result
                }
            
            except Exception as e:
                return {'status': 'error', 'message': str(e)}
    
        def search(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:
            """ğŸ” ChromaDB ê¸°ë°˜ ê²€ìƒ‰ (search_coding_solutions ë˜í•‘)"""
            if not self.claude_memory:
                return [{'error': 'Claude Memory not initialized'}]
        
            try:
                # ê¸°ì¡´ search_coding_solutions í˜¸ì¶œ
                results = self.search_coding_solutions(
                    error_signature=query,
                    project_context=os.path.basename(os.getcwd()),
                    tech_stack=["Python", "TypeScript", "JavaScript"],
                    top_k=limit
                )
            
                return results
            
            except Exception as e:
                return [{'error': f'Search failed: {str(e)}'}]
    
        def delete(self, pattern: str, confirm: bool = False) -> Dict[str, Any]:
            """ğŸ—‘ï¸ ChromaDB ê¸°ë°˜ ì •ë¦¬ (cleanup_coding_memory ë˜í•‘)"""
            if not self.claude_memory:
                return {'status': 'error', 'message': 'Claude Memory not initialized'}
        
            if not confirm:
                return {
                    'status': 'confirmation_required',
                    'message': f'ì •ë¦¬ íŒ¨í„´: {pattern}. confirm=Trueë¡œ ì¬ì‹¤í–‰í•˜ì„¸ìš”.',
                    'pattern': pattern
                }
        
            try:
                # íŒ¨í„´ ê¸°ë°˜ ì •ë¦¬ ì„¤ì •
                if pattern.startswith('old:'):
                    days = int(pattern.split(':')[1].replace('days', ''))
                    max_age_days = days
                    min_importance = 0.0
                elif pattern.startswith('low:'):
                    threshold = float(pattern.split(':')[1])
                    max_age_days = 180
                    min_importance = threshold
                else:
                    # ê¸°ë³¸ ì •ë¦¬
                    max_age_days = 30
                    min_importance = 0.3
            
                # ê¸°ì¡´ cleanup_coding_memory í˜¸ì¶œ
                result = self.cleanup_coding_memory(
                    auto_mode=True,
                    dry_run=False,
                    max_age_days=max_age_days,
                    min_importance=min_importance
                )
            
                return {
                    'status': 'success',
                    'pattern': pattern,
                    'result': result
                }
            
            except Exception as e:
                return {'status': 'error', 'message': str(e)}
    
        def insights(self, time_range_days: int = 30) -> Dict[str, Any]:
            """ğŸ“Š ChromaDB ê¸°ë°˜ ì¸ì‚¬ì´íŠ¸ (get_coding_insights ë˜í•‘)"""
            if not self.claude_memory:
                return {'error': 'Claude Memory not initialized'}
        
            try:
                return self.get_coding_insights(
                    insight_types=["errors", "patterns", "suggestions"],
                    project_context=os.path.basename(os.getcwd()),
                    tech_stack=["Python", "TypeScript", "JavaScript"],
                    time_range_days=time_range_days
                )
            except Exception as e:
                return {'error': f'Insights failed: {str(e)}'}
    
        def analyze(self, code_result: Dict[str, Any]) -> Dict[str, Any]:
            """ğŸ” ì½”ë“œ ê²°ê³¼ ë¶„ì„ (analyze_coding_context ë˜í•‘)"""
            if not self.claude_memory:
                return {'error': 'Claude Memory not initialized'}
        
            try:
                return self.analyze_coding_context(
                    code_result=code_result,
                    project_context=os.path.basename(os.getcwd()),
                    tech_stack=["Python", "TypeScript", "JavaScript"]
                )
            except Exception as e:
                return {'error': f'Analysis failed: {str(e)}'}
    
        def _detect_tech_stack(self, content: str) -> List[str]:
            """ê¸°ìˆ  ìŠ¤íƒ ìë™ ê°ì§€"""
            tech_stack = []
            content_lower = content.lower()
        
            if any(keyword in content_lower for keyword in ['python', 'import ', 'def ', 'class ']):
                tech_stack.append("Python")
            if any(keyword in content_lower for keyword in ['typescript', 'interface', 'enum', '.ts']):
                tech_stack.append("TypeScript")
            if any(keyword in content_lower for keyword in ['javascript', 'function', 'const ', '.js']):
                tech_stack.append("JavaScript")
            if any(keyword in content_lower for keyword in ['react', 'jsx', 'component']):
                tech_stack.append("React")
            if any(keyword in content_lower for keyword in ['mcp', 'claude', 'anthropic']):
                tech_stack.append("MCP")
            
            return tech_stack if tech_stack else ["General"]
        content = f"""# ğŸ”¥ Current Focus
*ì§€ê¸ˆ ë­í•˜ê³  ìˆëŠ”ì§€*

{current_focus}

## â­ï¸ Next Up ({len(next_tasks)} tasks)
*ë°”ë¡œ ë‹¤ìŒì— í•  ì¼ë“¤*

"""
        
        for task in next_tasks:
            title = task.get('description', task.get('title', 'Untitled task')) if isinstance(task, dict) else str(task)
            added_time = task.get('added_at', '') if isinstance(task, dict) else ''
            time_str = f" (added {added_time[11:16]})" if added_time else ""
            content += f"- [ ] {title}{time_str}\n"
        
        content += """

## ğŸ“ Quick Notes
*ë¹ ë¥¸ ë©”ëª¨ë‚˜ ìƒê°ë“¤*



## ğŸš« Blockers
*ë§‰íˆê±°ë‚˜ í•´ê²°í•´ì•¼ í•  ê²ƒë“¤*



## ğŸ“ Working Files
*í˜„ì¬ ì‘ì—…ì¤‘ì¸ íŒŒì¼ë“¤*



## ğŸ• Session Activity Log
*ì´ ì„¸ì…˜ì—ì„œ í•œ ì¼ë“¤*

"""
        
        # ì„¸ì…˜ í™œë™ë“¤ ì¶”ê°€
        activities = vibe_sys.get('session_activities', [])
        for activity in activities[-10:]:  # ìµœê·¼ 10ê°œë§Œ
            content += f"- {activity}\n"
        
        return content
    
    def _generate_roadmap_content(self, vibe_sys):
        """feature_roadmap.md ë‚´ìš© ìƒì„± í—¬í¼"""
        completed_tasks = vibe_sys.get('completed_tasks', [])
        
        content = """# ğŸ—ºï¸ Feature Roadmap
*ì¥ê¸° ê³„íšê³¼ ì™„ë£Œëœ ê¸°ëŠ¥ë“¤*

## âœ… Completed Features

"""
        
        for task in completed_tasks[-20:]:  # ìµœê·¼ 20ê°œë§Œ
            title = task.get('description', task.get('title', 'Untitled task')) if isinstance(task, dict) else str(task)
            completed_time = task.get('completed_at', '') if isinstance(task, dict) else ''
            time_str = f" (completed {completed_time[:10]})" if completed_time else ""
            content += f"- [x] {title}{time_str}\n"
        
        content += """

## ğŸš€ Upcoming Features
*ê³„íšëœ ê¸°ëŠ¥ë“¤*

- [ ] Advanced auto-sync scheduler
- [ ] File change detection
- [ ] Multi-project support
- [ ] Real-time collaboration

## ğŸ’¡ Ideas & Backlog
*ì•„ì´ë””ì–´ ë°±ë¡œê·¸*

"""
        
        return content



    
    def save(self, data, importance=0.5):
        """ì½”ë”© ê²½í—˜ì„ Claude Memoryì— ì €ì¥"""
        try:
            return save_coding_experience(data, self.project_context, importance=importance)
        except Exception as e:
            print(f"âŒ save ì‹¤íŒ¨: {e}")
            return False
    
    def search(self, query, tech_stack=None):
        """ì½”ë”© í•´ê²°ì±… ê²€ìƒ‰"""
        try:
            return search_coding_solutions(query, self.project_context, tech_stack)
        except Exception as e:
            print(f"âŒ search ì‹¤íŒ¨: {e}")
            return []
    
    def insights(self, tech_stack=None, time_range=None):
        """í”„ë¡œì íŠ¸ ì¸ì‚¬ì´íŠ¸ ì¡°íšŒ"""
        try:
            return get_coding_insights(self.project_context, tech_stack, time_range)
        except Exception as e:
            print(f"âŒ insights ì‹¤íŒ¨: {e}")
            return {}
    
    def delete(self, query=None, confirm=False):
        """ë©”ëª¨ë¦¬ ì •ë¦¬ (ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©)"""
        try:
            if not confirm:
                print("âš ï¸ delete í˜¸ì¶œì‹œ confirm=True í•„ìš”")
                return False
            return cleanup_coding_memory(dry_run=False, max_age=30, min_importance=0.3)
        except Exception as e:
            print(f"âŒ delete ì‹¤íŒ¨: {e}")
            return False

class VibeCommandSystem:
    """ë°”ì´ë¸Œ ëª…ë ¹ì–´ ì‹œìŠ¤í…œ (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
    
    def __init__(self, project_context: dict):
        self.project_context = project_context
        self.commands = {
            '/task': self._cmd_task,
            '/flow': self._cmd_flow,
            '/done': self._cmd_done,
            '/focus': self._cmd_focus,
            '/roadmap': self._cmd_roadmap,
            '/vision': self._cmd_vision,
            '/accept': self._cmd_accept,
            'help': self._cmd_help
        }
    
    def execute(self, command_line: str) -> str:
        """ëª…ë ¹ì–´ ì‹¤í–‰ (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„) - íƒ€ì… ê²€ì¦ ê°•í™”"""
        # íƒ€ì… ê²€ì¦ ì¶”ê°€ (iterable ë¬¸ì œ í•´ê²°)
        if not isinstance(command_line, str):
            return f"âŒ Invalid command type: expected str, got {type(command_line).__name__}"
        
        if not command_line.strip():
            return "âŒ Command required. Type 'help' for usage."
        
        command_line = command_line.strip()
        
        # ëª…ë ¹ì–´ íŒŒì‹±
        if command_line == 'help':
            return self._cmd_help()
        elif command_line.startswith('/'):
            parts = command_line.split(' ', 1)
            cmd = parts[0]
            arg = parts[1].strip('\"') if len(parts) > 1 else ""
            
            if cmd in self.commands:
                try:
                    return self.commands[cmd](arg)
                except Exception as e:
                    return f"âŒ Error executing {cmd}: {e}"
            else:
                return f"âŒ Unknown command: {cmd}. Type 'help' for available commands."
        else:
            return f"âŒ Commands must start with '/'. Type 'help' for usage."
    
    def _cmd_task(self, description: str) -> str:
        """'/task "ì„¤ëª…"' ëª…ë ¹ì–´"""
        return vibe_task_capture(description, self.project_context)
    
    def _cmd_flow(self, _: str = "") -> str:
        """'/flow' ëª…ë ¹ì–´ - ìºì‹œ/ë©”ëª¨ë¦¬ë±…í¬ ì •ë³´ ì¤‘ì‹¬"""
        flow_text = "\nğŸ”¥ AI Coding Brain - Project Status\n"
        flow_text += "=" * 70 + "\n"
        
        # 1. í”„ë¡œì íŠ¸ ìƒíƒœ ìš”ì•½
        flow_text += "\nğŸ“Œ í”„ë¡œì íŠ¸ ìƒíƒœ\n"
        flow_text += "-" * 60 + "\n"
        flow_text += f"í”„ë¡œì íŠ¸: {self.project_context.get('project_name', 'Unknown')}\n"
        flow_text += f"í˜„ì¬ Focus: {self.project_context.get('current_focus', 'Not set')}\n"
        
        # ì‘ì—… ì§„í–‰ë¥  ê³„ì‚°
        tasks = self.project_context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total_count = done_count + next_count
        progress = (done_count / total_count * 100) if total_count > 0 else 0
        
        flow_text += f"ì‘ì—… ì§„í–‰ë¥ : {progress:.1f}% ({done_count}/{total_count})\n"
        
        # 2. ë¶„ì„ëœ ì½”ë“œ êµ¬ì¡°
        flow_text += "\nğŸ“Š ë¶„ì„ëœ ì½”ë“œ êµ¬ì¡°\n"
        flow_text += "-" * 60 + "\n"
        
        analyzed_files = self.project_context.get('analyzed_files', {})
        if analyzed_files:
            total_functions = 0
            total_classes = 0
            
            for file_path, info in list(analyzed_files.items())[:5]:  # ìµœëŒ€ 5ê°œ íŒŒì¼
                file_name = os.path.basename(file_path)
                functions = info.get('functions', [])
                classes = info.get('classes', [])
                
                total_functions += len(functions)
                total_classes += len(classes)
                
                flow_text += f"\nğŸ“„ {file_name}\n"
                flow_text += f"   â€¢ í•¨ìˆ˜: {len(functions)}ê°œ"
                if functions[:3]:
                    flow_text += " (" + ", ".join(functions[:3])
                    if len(functions) > 3:
                        flow_text += f", ... +{len(functions)-3}"
                    flow_text += ")"
                flow_text += "\n"
                
                if classes:
                    flow_text += f"   â€¢ í´ë˜ìŠ¤: {len(classes)}ê°œ ({', '.join(classes)})\n"
            
            flow_text += f"\nğŸ“ˆ ì „ì²´ í†µê³„:\n"
            flow_text += f"   â€¢ ë¶„ì„ëœ íŒŒì¼: {len(analyzed_files)}ê°œ\n"
            flow_text += f"   â€¢ ì´ í•¨ìˆ˜: {total_functions}ê°œ\n"
            flow_text += f"   â€¢ ì´ í´ë˜ìŠ¤: {total_classes}ê°œ\n"
        else:
            flow_text += "   âš ï¸ ì•„ì§ ë¶„ì„ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.\n"
        
        # 3. ì‘ì—… ì¶”ì  ì •ë³´
        flow_text += "\nğŸ”„ ì‘ì—… ì¶”ì  ì •ë³´\n"
        flow_text += "-" * 60 + "\n"
        
        work_tracking = self.project_context.get('work_tracking', {})
        if work_tracking:
            # íŒŒì¼ í¸ì§‘ í†µê³„
            file_edits = work_tracking.get('file_edits', {})
            if file_edits:
                flow_text += "ìµœê·¼ í¸ì§‘í•œ íŒŒì¼:\n"
                sorted_files = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)
                for file_path, count in sorted_files[:5]:
                    flow_text += f"   â€¢ {os.path.basename(file_path)}: {count}íšŒ í¸ì§‘\n"
            
            # í•¨ìˆ˜ í¸ì§‘ í†µê³„
            function_edits = work_tracking.get('function_edits', {})
            if function_edits:
                flow_text += "\nìµœê·¼ í¸ì§‘í•œ í•¨ìˆ˜:\n"
                sorted_funcs = sorted(function_edits.items(), 
                                    key=lambda x: x[1].get('count', 0), reverse=True)
                for func_key, info in sorted_funcs[:5]:
                    count = info.get('count', 0)
                    flow_text += f"   â€¢ {func_key}: {count}íšŒ í¸ì§‘\n"
        
        # 4. ë©”ëª¨ë¦¬ë±…í¬ ì •ë³´
        flow_text += "\nğŸ’¾ ë©”ëª¨ë¦¬ë±…í¬ ì •ë³´\n"
        flow_text += "-" * 60 + "\n"
        
        # ì €ì¥ëœ ê²½í—˜
        experiences = self.project_context.get('coding_experiences', [])
        if experiences:
            flow_text += f"ì €ì¥ëœ ê²½í—˜: {len(experiences)}ê°œ\n"
            for exp in experiences[-3:]:
                task = exp.get('task', 'Unknown')
                solution = exp.get('solution', 'N/A')[:50]
                flow_text += f"   â€¢ {task}: {solution}...\n"
        
        # 5. ë¡œë“œë§µê³¼ ë‹¤ìŒ ë‹¨ê³„
        flow_text += "\nğŸ¯ ë¡œë“œë§µê³¼ ë‹¤ìŒ ë‹¨ê³„\n"
        flow_text += "-" * 60 + "\n"
        
        if self.project_context.get('current_focus'):
            flow_text += f"í˜„ì¬ Focus: {self.project_context['current_focus']}\n"
        
        # ë‹¤ìŒ ì‘ì—…ë“¤
        next_tasks = tasks.get('next', [])
        if next_tasks:
            flow_text += "\nğŸ“‹ ë‹¤ìŒ ì‘ì—…ë“¤:\n"
            for i, task in enumerate(next_tasks[:5], 1):
                flow_text += f"   {i}. {task}\n"
        else:
            flow_text += "\n   â„¹ï¸ ë‹¤ìŒ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤. /task ëª…ë ¹ìœ¼ë¡œ ì¶”ê°€í•˜ì„¸ìš”.\n"
        
        # ì™„ë£Œëœ ì‘ì—…ë“¤ (ìµœê·¼ 3ê°œ)
        done_tasks = tasks.get('done', [])
        if done_tasks:
            flow_text += "\nâœ… ìµœê·¼ ì™„ë£Œ:\n"
            for task in done_tasks[-3:]:
                flow_text += f"   â€¢ {task}\n"
        
        return flow_text
    

    def _cmd_accept(self, args: str) -> str:
        """'/accept' ëª…ë ¹ì–´ - ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ"""
        return "â„¹ï¸ /accept ëª…ë ¹ì–´ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. /flowë¡œ í˜„ì¬ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”."

    def _cmd_done(self, task_description: str) -> str:
        """'/done "íƒœìŠ¤í¬"' ëª…ë ¹ì–´"""
        return vibe_task_complete(task_description, self.project_context)
    
    def _cmd_focus(self, new_focus: str) -> str:
        """'/focus "ìƒˆí¬ì»¤ìŠ¤"' ëª…ë ¹ì–´"""
        return vibe_update_focus(new_focus, self.project_context)
    
    def _cmd_roadmap(self, _: str = "") -> str:
        """'/roadmap' ëª…ë ¹ì–´"""
        if 'vibe_system' not in self.project_context:
            return "âŒ Vibe system not initialized"
        
        completed = self.project_context['vibe_system'].get('completed_tasks', [])
        result = "ğŸ—‚ï¸ FEATURE ROADMAP:\n" + "="*40 + "\n"
        result += f"\nâœ… Completed ({len(completed)} items):\n"
        
        for task in completed[-10:]:  # ìµœê·¼ 10ê°œë§Œ
            desc = task.get('description', '')
            time = task.get('completed_time', '')
            result += f"  â€¢ {desc} (completed {time})\n"
        
        return result
    
    def _cmd_vision(self, _: str = "") -> str:
        """'/vision' ëª…ë ¹ì–´"""
        return "ğŸ¯ PROJECT VISION:\nAI-Coding-Brain-MCP with Vibe Memory System\nOptimized for natural coding workflow\n"
    
    def _cmd_help(self) -> str:
        """ë„ì›€ë§ ëª…ë ¹ì–´"""
        return """ğŸ”¥ VIBE CODING MEMORY SYSTEM - ì‚¬ìš©ë²•
================================================================

ğŸ“‹ ë°”ì´ë¸Œ ëª…ë ¹ì–´:
  /task "ì„¤ëª…"        â†’ ì¦‰ì‹œ íƒœìŠ¤í¬ ì¶”ê°€ (5ì´ˆ ë‚´ ì™„ë£Œ)
  /flow              â†’ í˜„ì¬ ì½”ë”© í”Œë¡œìš° ë³´ê¸°
  /done "íƒœìŠ¤í¬"      â†’ íƒœìŠ¤í¬ ì™„ë£Œ ì²˜ë¦¬
  /focus "ìƒˆí¬ì»¤ìŠ¤"   â†’ í˜„ì¬ ì§‘ì¤‘ ì˜ì—­ ë³€ê²½
  /roadmap           â†’ ê¸°ëŠ¥ ë¡œë“œë§µ ë³´ê¸° 
  /vision            â†’ í”„ë¡œì íŠ¸ ë¹„ì „ ë³´ê¸°
  help               â†’ ì´ ë„ì›€ë§

âš¡ ìë™í™” ê¸°ëŠ¥:
  â€¢ execute_code ì‹¤í–‰ â†’ ìë™ìœ¼ë¡œ í™œë™ ê¸°ë¡
  â€¢ parse_with_snippets â†’ ìë™ìœ¼ë¡œ í¬ì»¤ìŠ¤ ì—…ë°ì´íŠ¸
  â€¢ ëª¨ë“  íƒœìŠ¤í¬ì™€ í™œë™ì´ project_contextì— ì €ì¥

ğŸš€ ì‹œì‘í•˜ê¸°: vibe_system.initialize() ì‹¤í–‰ í›„ ì‚¬ìš©!
================================================================"""


# ì „ì—­ í•¨ìˆ˜ë“¤ (ê¸°ì¡´ íŒ¨í„´ì— ë§ì¶¤)
def initialize_vibe_system(project_context: dict, project_name: str = 'ai-coding-brain-mcp') -> tuple:
    """ë°”ì´ë¸Œ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ë° ë°˜í™˜ (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)"""
    vibe_manager = VibeMemoryManager(project_context, project_name)
    vibe_commands = VibeCommandSystem(project_context)
    
    success = globals()['vibe_manager'].initialize()
    
    return vibe_manager, vibe_commands, success


def register_vibe_helpers():
    """ë°”ì´ë¸Œ í—¬í¼ í•¨ìˆ˜ë“¤ì„ ì „ì—­ì— ë“±ë¡ (ê¸°ì¡´ register_all_helpers íŒ¨í„´ ë”°ë¦„)"""
    global vibe_task_capture, vibe_task_complete, vibe_update_focus
    global vibe_get_current_flow, vibe_execute_code_hook
    global initialize_vibe_system, VibeMemoryManager, VibeCommandSystem
    global _ensure_data_compatibility, _parse_coding_flow_md
    
    # í—¬í¼ í•¨ìˆ˜ë“¤ì„ globalsì— ì¶”ê°€
    globals()['_ensure_data_compatibility'] = _ensure_data_compatibility
    globals()['_parse_coding_flow_md'] = _parse_coding_flow_md
    
    # ì´ë¯¸ ì „ì—­ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì¶”ê°€ ë“±ë¡ ë¶ˆí•„ìš”
    print("âœ… Vibe helper functions registered globally", file=sys.stderr)
    return True

def enable_auto_sync_for_project_context(project_context):
    """project_contextì— auto_sync_hook í™œì„±í™”"""
    try:
        if 'sync_status' not in project_context:
            project_context['sync_status'] = {
                'last_sync': datetime.now().isoformat(),
                'pending_changes': [],
                'auto_sync': True
            }
        
        project_context['sync_status']['auto_sync'] = True
        print("âœ… Auto-sync í™œì„±í™”ë¨")
        
        # ì¦‰ì‹œ í•œë²ˆ ë™ê¸°í™” ì‹¤í–‰
        _auto_sync_hook(project_context, trigger='auto_sync_enabled')
        
        return True
    except Exception as e:
        print(f"âŒ Auto-sync í™œì„±í™” ì‹¤íŒ¨: {e}")
        return False

def update_live_context_task(project_context, action, task_data):
    """live_contextì˜ ì‘ì—… ëª©ë¡ ì—…ë°ì´íŠ¸ ë° ìë™ ë™ê¸°í™”"""
    try:
        if 'live_context' not in project_context:
            _load_live_context_from_memory(project_context)
        
        coding_flow = project_context['live_context']['coding_flow']
        
        if action == 'add_task':
            coding_flow['next_up'].append(task_data)
            print(f"âœ… ìƒˆ ì‘ì—… ì¶”ê°€: {task_data}")
            
        elif action == 'complete_task':
            if task_data in coding_flow['next_up']:
                coding_flow['next_up'].remove(task_data)
                coding_flow['completed'].append(task_data)
                print(f"âœ… ì‘ì—… ì™„ë£Œ: {task_data}")
            
        elif action == 'set_focus':
            coding_flow['current_focus'] = task_data
            print(f"ğŸ¯ í¬ì»¤ìŠ¤ ë³€ê²½: {task_data}")
            
        elif action == 'add_note':
            coding_flow['quick_notes'] += f"\n{datetime.now().strftime('%H:%M')} - {task_data}"
            print(f"ğŸ“ ë…¸íŠ¸ ì¶”ê°€: {task_data}")
        
        # ìë™ ë™ê¸°í™”
        _auto_sync_hook(project_context, trigger=f'task_{action}')
        
        return True
        
    except Exception as e:
        print(f"âŒ Live context ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
        return False




# ìë™ ë“±ë¡ (ê¸°ì¡´ íŒ¨í„´ ë”°ë¦„)
if __name__ == "__main__":
    register_vibe_helpers()
    print("ğŸ”¥ Vibe Memory System module loaded and ready!")

# ===========================================
# Global Claude Memory Functions
# ===========================================

def save_coding_experience(data, project_context=None, tech_stack=None, importance=0.7):
    """ê°œë°œ ê²½í—˜ ìë™ ì €ì¥ (VibeMemoryManager ì—°ë™)"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        vibe_manager = VibeMemoryManager(project_context)
        
        # ë°ì´í„° êµ¬ì¡°í™”
        if isinstance(data, str):
            structured_data = {
                'task': data,
                'tech_stack': tech_stack or 'unknown',
                'importance': importance,
                'timestamp': datetime.now().isoformat()
            }
        else:
            structured_data = data
            structured_data['importance'] = importance
            structured_data['timestamp'] = datetime.now().isoformat()
        
        # VibeMemoryManagerì˜ save ë©”ì„œë“œ ì‚¬ìš©
        key = f"coding_exp_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        return globals()['vibe_manager'].save(structured_data, importance)
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def search_coding_solutions(query, project_context=None, tech_stack=None, limit=10):
    """ê³¼ê±° í•´ê²°ì±… ê²€ìƒ‰ (VibeMemoryManager ì—°ë™)"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        vibe_manager = VibeMemoryManager(project_context)
        
        # VibeMemoryManagerì˜ search ë©”ì„œë“œ ì‚¬ìš©
        return globals()['vibe_manager'].search(query)
        
    except Exception as e:
        return {"status": "error", "message": str(e), "results": []}

def get_coding_insights(project_context=None, tech_stack=None, time_range=30):
    """í”„ë¡œì íŠ¸ë³„ ì¸ì‚¬ì´íŠ¸ (VibeMemoryManager ì—°ë™)"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        vibe_manager = VibeMemoryManager(project_context)
        
        # VibeMemoryManagerì˜ insights ë©”ì„œë“œ ì‚¬ìš©
        return globals()['vibe_manager'].insights(time_range=time_range)
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def get_claude_memory():
    """Claude Memory ì§ì ‘ ì ‘ê·¼ (VibeMemoryManager ì—°ë™)"""
    try:
        project_context = globals().get('project_context', {})
        vibe_manager = VibeMemoryManager(project_context)
        
        # ê°„ë‹¨í•œ ë©”ëª¨ë¦¬ ìƒíƒœ ë°˜í™˜
        status = globals()['vibe_manager'].get_status()
        return {
            "status": "success",
            "memory_system": "VibeMemoryManager",
            "vibe_status": status
        }
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def cleanup_coding_memory(dry_run=True, max_age=90, min_importance=0.3):
    """ë©”ëª¨ë¦¬ ìµœì í™” (VibeMemoryManager ì—°ë™)"""
    try:
        project_context = globals().get('project_context', {})
        vibe_manager = VibeMemoryManager(project_context)
        
        # VibeMemoryManagerì˜ delete ë©”ì„œë“œ ì‚¬ìš©
        if not dry_run:
            pattern = f"importance:<{min_importance}"
            return globals()['vibe_manager'].delete(pattern, confirm=True)
        else:
            return {
                "status": "success", 
                "message": f"Dry run - would clean items older than {max_age} days with importance < {min_importance}",
                "dry_run": True
            }
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

# =============================================================================
# __all__ ì„ ì–¸ëœ í•¨ìˆ˜ë“¤ êµ¬í˜„ (VibeMemoryManager ë˜í¼)
# =============================================================================

def sync_to_files():
    """ìºì‹œë©”ëª¨ë¦¬ë¥¼ .md íŒŒì¼ë¡œ ë™ê¸°í™”"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].sync_to_files()
    else:
        print('âš ï¸ vibe_managerê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ')
        return False

def sync_from_files(self):
        """.md íŒŒì¼ì„ ìºì‹œë©”ëª¨ë¦¬ë¡œ ë™ê¸°í™” (v1.1ë¶€í„° ë¹„í™œì„±í™”ë¨)"""
        print("âš ï¸ [DEPRECATED] sync_from_files: ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        print("   ë°ì´í„° íë¦„ì€ í•­ìƒ 'Context Manager -> .mdíŒŒì¼' ë‹¨ë°©í–¥ìœ¼ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.")
        print("   .md íŒŒì¼ì€ ì‹œìŠ¤í…œ ìƒíƒœë¥¼ ë³´ì—¬ì£¼ëŠ” ë·°(View) ì—­í• ë§Œ í•©ë‹ˆë‹¤.")
        return {
            'status': 'deprecated', 
            'message': 'Unidirectional data flow enforced. This function is disabled.'
        }

def auto_save(interval=300):
    """ìë™ ì €ì¥ í™œì„±í™” (ê¸°ë³¸ 5ë¶„ ê°„ê²©)"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].auto_save(interval)
    else:
        print('âš ï¸ vibe_managerê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ')
        return False
def force_sync():
    """ê°•ì œ ë™ê¸°í™” (ìºì‹œ -> íŒŒì¼) - v1.1 ë‹¨ë°©í–¥ + ë°ì´í„° ë³´ì¡´"""
    print("ğŸ”„ ê°•ì œ ë™ê¸°í™” (Cache -> Files) ì‹¤í–‰...")
    
    # project_context ê°€ì ¸ì˜¤ê¸°
    project_context = globals().get('project_context', {})
    if not project_context:
        return {'status': 'error', 'message': 'project_context not found'}
    
    # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥
    _ensure_data_compatibility(project_context)
    
    # vibe_managerê°€ ì—†ìœ¼ë©´ ìƒì„±
    if 'vibe_manager' not in globals():
        globals()['vibe_manager'] = VibeMemoryManager(project_context)
    
    # sync_to_filesë§Œ ì‹¤í–‰ (ê¸°ì¡´ ë°ì´í„° ë³´ì¡´ ë¡œì§ í¬í•¨)
    return globals()['vibe_manager'].force_sync()