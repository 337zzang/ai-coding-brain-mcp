# ===========================================
# Public API - Only these 8 functions are exposed
# ===========================================
__all__ = [
    'initialize_context',      # 프로젝트 컨텍스트 초기화
    'save_context',           # 컨텍스트 저장
    'update_cache',           # 캐시 업데이트
    'get_value',              # 캐시 값 조회
    'find_symbol',            # 심볼 찾기
    'track_file_access',      # 파일 접근 추적
    'track_function_edit',    # 함수 수정 추적
    'get_work_tracking_summary' # 작업 추적 요약
]

"""
🧠 스마트 컨텍스트 관리자 v2.0 - 메모리 뱅크 기반 구조
==========================================

project_context의 생성, 관리, 접근을 전담하는 모듈.
메모리 뱅크 기반 구조: 코드와 데이터 분리

v2.0 변경사항:
- vibe_memory_system과 통합 개선
- 클래스 기반 구조로 리팩토링
- 중복 코드 제거 및 구조 정리
"""

import os
import json
import datetime as dt
from datetime import datetime
from typing import Dict, Any, Optional, List
import sys

# Vibe Memory System 동적 import
try:
    import vibe_memory_system
    VIBE_MEMORY_AVAILABLE = True
except ImportError:
    VIBE_MEMORY_AVAILABLE = False
    print("⚠️ Vibe Memory System을 찾을 수 없습니다.")

# ===========================================
# Helper Functions (Private)
# ===========================================

def _ensure_cache_structure(context: dict) -> dict:
    """캐시 구조 확인 및 초기화"""
    if 'cache' not in context:
        context['cache'] = {
            'files': {},
            'analyzed_files': {},
            'symbol_index': {},
            'file_summaries': {},
            'work_tracking': {},
            'vibe_synced': {},
            'last_sync': None
        }
    
    if 'stats' not in context:
        context['stats'] = {
            'total_operations': 0,
            'cache_hits': 0,
            'cache_misses': 0,
            'files_analyzed': 0,
            'cache_evictions': 0
        }
    
    return context

def _calculate_session_duration(tracking: dict) -> str:
    """세션 지속 시간 계산"""
    if 'session_start' in tracking:
        try:
            start = dt.datetime.fromisoformat(tracking['session_start'])
            duration = dt.datetime.now() - start
            return str(duration).split('.')[0]  # 마이크로초 제거
        except:
            pass
    return "Unknown"

def _normalize_context_structure(context: dict) -> dict:
    """Context 구조를 정규화하여 일관된 접근 보장"""
    # cache_data가 중첩되어 있으면 평탄화
    if 'cache_data' in context and isinstance(context['cache_data'], dict):
        cache_data = context['cache_data']
        
        # 주요 필드들을 최상위로 복사 (덮어쓰지 않음)
        for key in ['analyzed_files', 'symbol_index', 'work_tracking', 
                    'current_focus', 'tasks', 'active_file']:
            if key in cache_data and key not in context:
                context[key] = cache_data[key]
    
    # 필수 필드 초기화
    context.setdefault('analyzed_files', {})
    context.setdefault('symbol_index', {})
    context.setdefault('work_tracking', {})
    context.setdefault('tasks', {'next': [], 'done': []})
    
    return context

def _validate_memory_bank_structure(memory_dir: str) -> List[str]:
    """메모리뱅크 디렉토리 구조 검증 및 수정"""
    issues_fixed = []
    
    # .cache 디렉토리 확인/생성
    cache_dir = os.path.join(memory_dir, '.cache')
    if not os.path.exists(cache_dir):
        os.makedirs(cache_dir, exist_ok=True)
        issues_fixed.append('Created .cache directory')
    
    # 레거시 캐시 파일 마이그레이션
    project_name = os.path.basename(memory_dir)
    cache_filename = f'cache_{project_name}.json'
    
    old_cache = os.path.join(memory_dir, cache_filename)
    new_cache = os.path.join(cache_dir, cache_filename)
    
    if os.path.exists(old_cache) and not os.path.exists(new_cache):
        import shutil
        shutil.move(old_cache, new_cache)
        issues_fixed.append(f'Migrated {cache_filename} to .cache/')
    
    return issues_fixed

def _try_load_cached_context(project_path: str, project_name: str) -> Optional[dict]:
    """캐시된 컨텍스트 로드 시도"""
    # .cache 디렉토리 경로
    cache_dir = os.path.join(project_path, '.cache')
    cache_filename = f'cache_{project_name}.json'
    
    # 우선순위: .cache/ > 프로젝트 루트 (레거시)
    cache_file = os.path.join(cache_dir, cache_filename)
    legacy_cache_file = os.path.join(project_path, cache_filename)
    
    # 레거시 캐시 파일 마이그레이션
    if not os.path.exists(cache_file) and os.path.exists(legacy_cache_file):
        print(f"🔄 레거시 캐시 파일 발견, .cache/로 마이그레이션")
        os.makedirs(cache_dir, exist_ok=True)
        import shutil
        shutil.copy2(legacy_cache_file, cache_file)
    
    if os.path.exists(cache_file):
        try:
            with open(cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            print(f"✅ 캐시 로드 성공: .cache/{cache_filename}")
            
            # 캐시 데이터 구조 확인 및 평탄화
            result = {}
            
            # 중첩된 구조 처리
            if 'cache' in cache_data:
                cache_inner = cache_data.get('cache', {})
                result['symbol_index'] = cache_inner.get('symbol_index', {})
                result['analyzed_files'] = cache_inner.get('analyzed_files', {})
                result['work_tracking'] = cache_inner.get('work_tracking', {})
            
            # 최상위 레벨 데이터 병합
            for key in ['symbol_index', 'analyzed_files', 'work_tracking', 'tasks', 
                       'current_focus', 'modification_log', 'project_insights']:
                if key in cache_data and key not in result:
                    result[key] = cache_data[key]
            
            # 기타 메타데이터
            result['project_id'] = cache_data.get('project_id', project_name)
            result['project_path'] = cache_data.get('project_path', project_path)
            result['cache_dir'] = cache_dir
            
            # 통계 출력
            print(f"   • symbol_index: {len(result.get('symbol_index', {}))}개")
            print(f"   • analyzed_files: {len(result.get('analyzed_files', {}))}개")
            print(f"   • work_tracking: {len(result.get('work_tracking', {}))}개")
            
            return result
            
        except Exception as e:
            print(f"❌ 캐시 로드 실패: {str(e)}")
            return None
    else:
        print(f"ℹ️ 캐시 파일 없음: .cache/{cache_filename}")
        os.makedirs(cache_dir, exist_ok=True)
        return None

# ===========================================
# CacheManager 클래스
# ===========================================

class CacheManager:
    """캐시 관리 전담 클래스"""
    
    def __init__(self, context: dict):
        self.context = _ensure_cache_structure(context)
        self.cache = self.context['cache']
        self.stats = self.context['stats']
        
        # 캐시 설정
        self.cache_config = {
            'max_size': 20,
            'mtime_check': True,
            'auto_save': True
        }
        self.cache['cache_config'] = self.cache_config
    
    def update(self, key: str, value: Any) -> bool:
        """캐시 업데이트"""
        self.cache[key] = value
        self.stats['total_operations'] += 1
        
        # 특정 키에 대한 추가 처리
        if key == 'active_file':
            print(f"✅ 활성 파일 변경: {value}")
        
        # Vibe 동기화 (VIBE_MEMORY_AVAILABLE 체크)
        if VIBE_MEMORY_AVAILABLE:
            important_keys = ['current_focus', 'active_file', 'analyzed_files', 'symbol_index']
            if key in important_keys:
                try:
                    # vibe_memory_system의 auto_save 호출
                    vibe_memory_system.auto_save()
                except Exception as e:
                    print(f"⚠️ Vibe 동기화 실패: {e}")
        
        return True
    
    def get(self, key: str, default: Any = None) -> Any:
        """캐시에서 값 가져오기"""
        value = self.cache.get(key, default)
        
        if value != default:
            self.stats['cache_hits'] += 1
        else:
            self.stats['cache_misses'] += 1
        
        return value
    
    def validate_entry(self, file_path: str) -> bool:
        """캐시 엔트리 유효성 검증"""
        analyzed_files = self.cache.get('analyzed_files', {})
        
        if file_path not in analyzed_files:
            return False
        
        # mtime 검사가 비활성화된 경우
        if not self.cache_config.get('mtime_check', True):
            return True
        
        cached_entry = analyzed_files[file_path]
        cached_mtime = cached_entry.get('mtime', 0)
        
        try:
            current_mtime = os.path.getmtime(file_path)
            if current_mtime > cached_mtime:
                print(f"⚠️ 파일 변경 감지: {os.path.basename(file_path)}")
                return False
        except Exception as e:
            print(f"⚠️ mtime 확인 실패: {e}")
            return False
        
        return True
    
    def update_file_cache(self, file_path: str, analysis_data: dict) -> None:
        """파일 캐시 업데이트"""
        analyzed_files = self.cache.get('analyzed_files', {})
        
        try:
            mtime = os.path.getmtime(file_path)
            
            # 캐시 엔트리 생성
            cache_entry = {
                'data': analysis_data,
                'mtime': mtime,
                'access_time': datetime.now().timestamp(),
                'file_size': os.path.getsize(file_path),
                'cached_at': datetime.now().isoformat()
            }
            
            analyzed_files[file_path] = cache_entry
            self.stats['files_analyzed'] += 1
            
            print(f"✅ 캐시 업데이트: {os.path.basename(file_path)}")
            
            # LRU 캐시 크기 관리
            self._manage_cache_size()
            
            # symbol_index 업데이트
            self._update_symbol_index(file_path, analysis_data)
            
        except Exception as e:
            print(f"❌ 캐시 업데이트 실패: {e}")
    
    def _update_symbol_index(self, file_path: str, analysis_data: dict) -> None:
        """심볼 인덱스 업데이트"""
        if 'symbol_index' not in self.cache:
            self.cache['symbol_index'] = {}
        
        symbol_index = self.cache['symbol_index']
        language = analysis_data.get('language', 'python')
        
        # 함수 정보 추가
        for func in analysis_data.get('functions', []):
            func_key = f"{os.path.basename(file_path)}:{func}"
            symbol_index[func_key] = {
                'file': file_path,
                'type': 'function',
                'name': func,
                'language': language
            }
        
        # 클래스 정보 추가
        for cls in analysis_data.get('classes', []):
            class_key = f"{os.path.basename(file_path)}:{cls}"
            symbol_index[class_key] = {
                'file': file_path,
                'type': 'class',
                'name': cls,
                'language': language
            }
    
    def _manage_cache_size(self) -> None:
        """LRU 정책으로 캐시 크기 관리"""
        analyzed_files = self.cache.get('analyzed_files', {})
        max_size = self.cache_config.get('max_size', 20)
        
        current_size = len(analyzed_files)
        if current_size <= max_size:
            return
        
        # access_time 기준으로 정렬
        sorted_files = sorted(
            analyzed_files.items(),
            key=lambda x: x[1].get('access_time', 0)
        )
        
        # 제거할 항목 수
        to_remove = current_size - max_size
        
        print(f"⚠️ 캐시 크기 초과: {current_size}/{max_size}")
        
        # 가장 오래된 항목들 제거
        for file_path, _ in sorted_files[:to_remove]:
            del analyzed_files[file_path]
            self.stats['cache_evictions'] += 1
            print(f"  🗑️ LRU 제거: {os.path.basename(file_path)}")

# ===========================================
# WorkTracker 클래스
# ===========================================

class WorkTracker:
    """작업 추적 전담 클래스"""
    
    def __init__(self, context: dict):
        self.context = context
        self._initialize()
    
    def _initialize(self) -> None:
        """작업 추적 시스템 초기화"""
        if 'cache' not in self.context:
            self.context['cache'] = {}
        
        if 'work_tracking' not in self.context['cache']:
            self.context['cache']['work_tracking'] = {
                'current_file': None,
                'current_function': None,
                'current_class': None,
                'last_accessed': None,
                'work_history': [],
                'file_access_count': {},
                'function_edit_count': {},
                'session_start': datetime.now().isoformat()
            }
    
    def track_file_access(self, file_path: str, operation: str = 'read') -> dict:
        """파일 접근 추적"""
        self._initialize()
        tracking = self.context['cache']['work_tracking']
        
        # 현재 파일 업데이트
        tracking['current_file'] = file_path
        tracking['last_accessed'] = datetime.now().isoformat()
        
        # 파일 접근 횟수 증가
        if file_path not in tracking['file_access_count']:
            tracking['file_access_count'][file_path] = 0
        tracking['file_access_count'][file_path] += 1
        
        # 작업 히스토리에 추가
        history_entry = {
            'timestamp': datetime.now().isoformat(),
            'file': file_path,
            'operation': operation,
            'function': tracking.get('current_function'),
            'class': tracking.get('current_class')
        }
        
        tracking['work_history'].append(history_entry)
        
        # 히스토리 크기 제한
        if len(tracking['work_history']) > 100:
            tracking['work_history'] = tracking['work_history'][-100:]
        
        # Vibe 동기화
        if VIBE_MEMORY_AVAILABLE and tracking['file_access_count'][file_path] % 3 == 0:
            self._sync_to_vibe()
        
        return self.context
    
    def track_function_edit(self, file_path: str, function_name: str, 
                           class_name: Optional[str] = None, operation: str = 'edit') -> dict:
        """함수/메서드 수정 추적"""
        self._initialize()
        tracking = self.context['cache']['work_tracking']
        
        # 현재 작업 중인 함수/클래스 업데이트
        tracking['current_function'] = function_name
        tracking['current_class'] = class_name
        
        # 함수 수정 횟수 추적
        function_key = f"{file_path}::{class_name or ''}.{function_name}"
        if function_key not in tracking['function_edit_count']:
            tracking['function_edit_count'][function_key] = 0
        tracking['function_edit_count'][function_key] += 1
        
        # 파일 접근도 함께 추적
        self.track_file_access(file_path, operation)
        
        # Vibe 즉시 동기화
        if VIBE_MEMORY_AVAILABLE:
            self._sync_to_vibe()
        
        return self.context
    
    def get_summary(self) -> dict:
        """작업 추적 요약 정보"""
        self._initialize()
        tracking = self.context['cache']['work_tracking']
        
        # 가장 많이 접근한 파일
        file_counts = tracking.get('file_access_count', {})
        sorted_files = sorted(file_counts.items(), key=lambda x: x[1], reverse=True)
        most_accessed_files = [(f, {'access_count': c}) for f, c in sorted_files[:5]]
        
        # 가장 많이 수정한 함수
        function_counts = tracking.get('function_edit_count', {})
        sorted_functions = sorted(function_counts.items(), key=lambda x: x[1], reverse=True)
        most_edited_functions = [(f, c) for f, c in sorted_functions[:10]]
        
        return {
            'current_context': self._get_current_context(),
            'most_accessed_files': most_accessed_files,
            'most_edited_functions': most_edited_functions,
            'recent_history': tracking.get('work_history', [])[-5:],
            'total_files_accessed': len(file_counts),
            'total_functions_edited': len(function_counts),
            'total_operations': len(tracking.get('work_history', []))
        }
    
    def _get_current_context(self) -> dict:
        """현재 작업 컨텍스트"""
        tracking = self.context['cache']['work_tracking']
        
        return {
            'current_file': tracking.get('current_file'),
            'current_function': tracking.get('current_function'),
            'current_class': tracking.get('current_class'),
            'last_accessed': tracking.get('last_accessed'),
            'session_duration': _calculate_session_duration(tracking)
        }
    
    def _sync_to_vibe(self) -> None:
        """Vibe Memory로 동기화"""
        if not VIBE_MEMORY_AVAILABLE:
            return
        
        try:
            # vibe_memory_system의 auto_save 호출
            vibe_memory_system.auto_save()
        except Exception as e:
            print(f"⚠️ WorkTracker Vibe 동기화 실패: {e}")

# ===========================================
# ContextManager 클래스
# ===========================================


    def _generate_coding_flow_content(self) -> str:
        """coding_flow.md 내용 생성"""
        from datetime import datetime
        
        content = f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

현재 세션 시작: {datetime.now().strftime('%Y-%m-%d %H:%M')}
**현재 Focus**: {self.context.get('current_focus', 'Not set')}

## ⏭️ Next Up (1-3 items)
*바로 다음에 할 일들*

"""
        # Next tasks
        tasks = self.context.get('tasks', {})
        for task in tasks.get('next', [])[:3]:
            content += f"- [ ] {task}\n"
        
        content += "\n\n## ✅ Done (Recent)\n*최근 완료한 것들*\n\n"
        
        # Done tasks
        for task in tasks.get('done', [])[-5:]:
            content += f"- [x] {task}\n"
        
        # Progress
        done_count = len(tasks.get('done', []))
        total_count = done_count + len(tasks.get('next', []))
        progress = (done_count / total_count * 100) if total_count > 0 else 0
        
        content += f"\n\n## 📊 Progress\n전체 진행률: {progress:.1f}% ({done_count}/{total_count})\n"
        
        return content

class ContextManager:
    """프로젝트 컨텍스트 관리 핵심 클래스"""
    
    def __init__(self, project_path: str, project_name: str):
        self.project_path = project_path
        self.project_name = project_name
        self.context = self._initialize_context()
        self.cache_manager = CacheManager(self.context)
        self.work_tracker = WorkTracker(self.context)
    
    def _initialize_context(self) -> dict:
        """프로젝트 컨텍스트 초기화"""
        # 기본 구조
        context = {
            'project_id': self.project_name,
            'project_name': self.project_name,
            'project_path': self.project_path,
            'version': 'context_manager_v2.0',
            'created_at': datetime.now().isoformat(),
            'session_id': None,
            
            # 핵심 데이터 구조
            'analyzed_files': {},
            'symbol_index': {},
            'work_tracking': {},
            'tasks': {'next': [], 'done': []},
            'current_focus': None,
            'modification_log': [],
            'project_insights': {},
            
            # 캐시 관련
            'cache': {
                'active_file': None,
                'current_focus': None,
                'last_result': None,
                'error_count': 0
            },
            
            # 통계
            'stats': {
                'total_operations': 0,
                'cache_hits': 0,
                'cache_misses': 0,
                'files_analyzed': 0
            }
        }
        
        # Vibe Memory 통합
        if VIBE_MEMORY_AVAILABLE:
            try:
                memory_root = vibe_memory_system.__get_memory_bank_root_from_claude_config()
                context['memory_path'] = os.path.join(memory_root, self.project_name)
                
                # 메모리뱅크 구조 검증
                issues_fixed = _validate_memory_bank_structure(context['memory_path'])
                if issues_fixed:
                    print(f"✅ 메모리뱅크 구조 수정: {', '.join(issues_fixed)}")
                
                # Vibe 데이터 호환성 보장
                vibe_memory_system._ensure_data_compatibility(context)
                
            except Exception as e:
                print(f"⚠️ Vibe Memory 통합 실패: {e}")
        
        # 캐시 로드 시도
        cached_data = _try_load_cached_context(self.project_path, self.project_name)
        if cached_data:
            # 캐시 데이터 병합
            for key in ['analyzed_files', 'symbol_index', 'work_tracking', 'tasks', 
                       'current_focus', 'modification_log', 'project_insights']:
                if key in cached_data and cached_data[key]:
                    context[key] = cached_data[key]
        
        # 세션 ID 생성
        import uuid
        context['session_id'] = str(uuid.uuid4())
        
        # 동기화 설정
        context['sync_status'] = {
            'realtime_enabled': True,
            'auto_sync': True,
            'last_sync': datetime.now().isoformat()
        }
        
        # 캐시 디렉토리 설정
        cache_dir = os.path.join(self.project_path, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        
        context['memory_bank'] = {
            'project_path': cache_dir,
            'cache_file': os.path.join(cache_dir, f'cache_{self.project_name}.json')
        }
        
        # 글로벌 변수 업데이트
        globals()['project_context'] = context
        
        print(f"\n📊 초기화 완료:")
        print(f"   • 프로젝트: {context['project_name']}")
        print(f"   • 분석된 파일: {len(context.get('analyzed_files', {}))}개")
        print(f"   • 심볼 인덱스: {len(context.get('symbol_index', {}))}개")
        print(f"   • 현재 포커스: {context.get('current_focus', 'None')}")
        
        return context
    
    def save(self) -> bool:
        """컨텍스트 저장"""
        cache_dir = self.context['memory_bank']['project_path']
        cache_file = self.context['memory_bank']['cache_file']
        
        # 저장할 데이터 구성
        cache_data = {
            'project_id': self.context['project_id'],
            'project_name': self.context['project_name'],
            'project_path': self.context['project_path'],
            'analyzed_files': self.context.get('analyzed_files', {}),
            'symbol_index': self.context.get('symbol_index', {}),
            'work_tracking': self.context.get('work_tracking', {}),
            'tasks': self.context.get('tasks', {'next': [], 'done': []}),
            'current_focus': self.context.get('current_focus'),
            'modification_log': self.context.get('modification_log', []),
            'project_insights': self.context.get('project_insights', {}),
            'last_updated': datetime.now().isoformat(),
            'sync_status': self.context.get('sync_status', {}),
            'memory_bank': self.context.get('memory_bank', {})
        }
        
        try:
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, indent=2, ensure_ascii=False)
            
            print(f"✅ 프로젝트 캐시 저장: {os.path.basename(cache_file)}")
            
            # Vibe 동기화
            if VIBE_MEMORY_AVAILABLE:
                try:
                    vibe_memory_system.sync_to_files()
                except Exception as e:
                    print(f"⚠️ Vibe 동기화 실패: {e}")
            
            
            # 문서 자동 저장 추가
            try:
                memory_path = r"C:\Users\82106\Desktop\memory\ai-coding-brain-mcp"
                
                if os.path.exists(memory_path):
                    # coding_flow.md 업데이트
                    flow_content = self._generate_coding_flow_content()
                    flow_path = os.path.join(memory_path, 'coding_flow.md')
                    
                    with open(flow_path, 'w', encoding='utf-8') as f:
                        f.write(flow_content)
                    
                    print("   ✅ coding_flow.md 자동 업데이트됨")
                    
            except Exception as e:
                print(f"   ⚠️ 문서 업데이트 실패: {e}")
                # 문서 업데이트 실패해도 캐시 저장은 성공으로 처리
            
            return True
            
        except Exception as e:
            print(f"❌ 캐시 저장 실패: {str(e)}")
            return False

# ===========================================
# 글로벌 인스턴스
# ===========================================

_context_manager_instance = None

def _get_context_manager() -> ContextManager:
    """ContextManager 싱글톤 인스턴스 반환"""
    global _context_manager_instance
    if _context_manager_instance is None:
        # 기본값으로 초기화
        _context_manager_instance = ContextManager(os.getcwd(), 'default_project')
    return _context_manager_instance

# ===========================================
# Public API Implementation
# ===========================================

def initialize_context(project_path: str, project_name: str) -> dict:
    """프로젝트 컨텍스트 초기화"""
    global _context_manager_instance
    _context_manager_instance = ContextManager(project_path, project_name)
    return _context_manager_instance.context

def save_context() -> bool:
    """컨텍스트 저장"""
    cm = _get_context_manager()
    return cm.save()

def update_cache(context: dict, key: str, value: Any) -> bool:
    """캐시 업데이트"""
    # context가 전달되면 해당 context의 cache_manager 사용
    if context and 'cache' in context:
        cache_manager = CacheManager(context)
        return cache_manager.update(key, value)
    else:
        # 글로벌 인스턴스 사용
        cm = _get_context_manager()
        return cm.cache_manager.update(key, value)

def get_value(context: dict, key: str, default: Any = None) -> Any:
    """캐시에서 값 가져오기"""
    if context and 'cache' in context:
        cache_manager = CacheManager(context)
        return cache_manager.get(key, default)
    else:
        cm = _get_context_manager()
        return cm.cache_manager.get(key, default)

def find_symbol(context: dict, symbol_name: str) -> Optional[str]:
    """심볼의 파일 위치 찾기"""
    symbol_index = get_value(context, "symbol_index", {})
    return symbol_index.get(symbol_name)

def track_file_access(context: dict, file_path: str, operation: str = 'read') -> dict:
    """파일 접근 추적"""
    if context:
        work_tracker = WorkTracker(context)
        return work_tracker.track_file_access(file_path, operation)
    else:
        cm = _get_context_manager()
        return cm.work_tracker.track_file_access(file_path, operation)

def track_function_edit(context: dict, file_path: str, function_name: str, 
                       class_name: Optional[str] = None, operation: str = 'edit') -> dict:
    """함수/메서드 수정 추적"""
    if context:
        work_tracker = WorkTracker(context)
        return work_tracker.track_function_edit(file_path, function_name, class_name, operation)
    else:
        cm = _get_context_manager()
        return cm.work_tracker.track_function_edit(file_path, function_name, class_name, operation)

def get_work_tracking_summary(context: dict) -> dict:
    """작업 추적 요약 정보"""
    if context:
        work_tracker = WorkTracker(context)
        return work_tracker.get_summary()
    else:
        cm = _get_context_manager()
        return cm.work_tracker.get_summary()

# ===========================================
# 추가 유틸리티 함수들 (하위 호환성)
# ===========================================

def build_index(context: dict, analyzed_files: Optional[dict] = None) -> bool:
    """심볼 인덱스 구축 (하위 호환성)"""
    print("✅ 심볼 인덱스 구축 시작...")
    
    # CacheManager 사용
    cache_manager = CacheManager(context)
    files_to_index = analyzed_files or context.get("cache", {}).get("analyzed_files", {})
    
    if not files_to_index:
        print("⚠️ 인덱싱할 파일이 없습니다.")
        return False
    
    for file_path, analysis_data in files_to_index.items():
        if isinstance(analysis_data, dict):
            cache_manager._update_symbol_index(file_path, analysis_data)
    
    print(f"✅ 심볼 인덱스 구축 완료.")
    return True

def propose_next_steps(context: dict, limit: int = 3) -> list:
    """다음 작업 제안"""
    suggestions = []
    
    # work_tracking이 있는지 확인
    if 'cache' not in context or 'work_tracking' not in context.get('cache', {}):
        return []
    
    work_summary = get_work_tracking_summary(context)
    
    # 1. 가장 많이 접근한 파일 기반 제안
    most_accessed = work_summary.get('most_accessed_files', [])
    if most_accessed:
        file_path, access_data = most_accessed[0]
        # access_data가 dict인 경우와 int인 경우 모두 처리
        access_count = access_data.get('access_count', 0) if isinstance(access_data, dict) else access_data
        
        if access_count > 5:  # 5회 이상 접근한 파일
            suggestions.append({
                'type': 'focus',
                'text': f"'{os.path.basename(file_path)}' 관련 작업 계속하기",
                'priority': 0.9,
                'rationale': f"최근 {access_count}회 접근한 파일"
            })
    
    # 2. 가장 많이 수정한 함수 기반 제안
    most_edited = work_summary.get('most_edited_functions', [])
    if most_edited and len(most_edited) > 0:
        func_key, edit_count = most_edited[0]
        if edit_count > 3:  # 3회 이상 수정한 함수
            func_name = func_key.split('::')[-1] if '::' in func_key else func_key
            suggestions.append({
                'type': 'task',
                'text': f"'{func_name}' 함수 리팩토링 또는 테스트 작성",
                'priority': 0.8,
                'rationale': f"최근 {edit_count}회 수정됨"
            })
    
    # 3. 현재 작업 중인 파일 기반 제안
    current_context = work_summary.get('current_context', {})
    if current_context.get('current_file'):
        current_file = current_context['current_file']
        suggestions.append({
            'type': 'continue',
            'text': f"'{os.path.basename(current_file)}' 작업 계속하기",
            'priority': 0.7,
            'rationale': "현재 작업 중인 파일"
        })
    
    # 우선순위로 정렬하여 상위 N개 반환
    suggestions.sort(key=lambda x: x['priority'], reverse=True)
    return suggestions[:limit]

# 글로벌 함수들 (하위 호환성)
def save_project_cache(project_context: dict) -> bool:
    """프로젝트 캐시 저장 (하위 호환성)"""
    if project_context:
        cm = ContextManager(
            project_context.get('project_path', os.getcwd()),
            project_context.get('project_name', 'unknown')
        )
        cm.context = project_context
        return cm.save()
    return False

# ===========================================
# 초기화 코드
# ===========================================

    
    def _generate_coding_flow_content(self) -> str:
        """coding_flow.md 내용 생성"""
        from datetime import datetime
        
        content = f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

현재 세션 시작: {datetime.now().strftime('%Y-%m-%d %H:%M')}
**현재 Focus**: {self.context.get('current_focus', 'Not set')}

## ⏭️ Next Up (1-3 items)
*바로 다음에 할 일들*

"""
        # Next tasks
        tasks = self.context.get('tasks', {})
        for task in tasks.get('next', [])[:3]:
            content += f"- [ ] {task}\n"
        
        content += "\n\n## ✅ Done (Recent)\n*최근 완료한 것들*\n\n"
        
        # Done tasks  
        for task in tasks.get('done', [])[-5:]:
            content += f"- [x] {task}\n"
        
        # Progress
        done_count = len(tasks.get('done', []))
        total_count = done_count + len(tasks.get('next', []))
        progress = (done_count / total_count * 100) if total_count > 0 else 0
        
        content += f"\n\n## 📊 Progress\n전체 진행률: {progress:.1f}% ({done_count}/{total_count})\n"
        
        return content

if __name__ == "__main__":
    # 테스트 실행
    test_context = initialize_context(os.getcwd(), 'test_project')
    print("\n--- 생성된 컨텍스트 구조 ---")
    print(json.dumps({
        'project_name': test_context['project_name'],
        'version': test_context['version'],
        'cache_keys': list(test_context.get('cache', {}).keys()),
        'stats': test_context.get('stats', {})
    }, indent=2, ensure_ascii=False))
