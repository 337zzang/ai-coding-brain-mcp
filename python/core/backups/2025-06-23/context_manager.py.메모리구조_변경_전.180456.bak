#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Context Manager - AI Coding Brain MCP
ë¶„ë¦¬ëœ Context ê´€ë¦¬ ëª¨ë“ˆ

ìž‘ì„±ì¼: 2025-06-20
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy

class UnifiedContextManager:
    """í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ìž - ì‹±ê¸€í†¤ íŒ¨í„´"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None
            self.base_path = None
            self.memory_path = None
            self.cache_dir = None
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str = None, memory_root: str = None,
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
        self.project_path = project_path
        
        # project_nameì´ Noneì´ë©´ ê²½ë¡œì—ì„œ ìžë™ ì¶”ì¶œ
        if project_name is None:
            project_name = os.path.basename(os.path.abspath(project_path))
            print(f"âœ… í”„ë¡œì íŠ¸ ì´ë¦„ ìžë™ ì¶”ì¶œ: {project_name}")
        
        self.project_name = project_name
        self.base_path = project_path
        
        # ë©”ëª¨ë¦¬ ë£¨íŠ¸ ì„¤ì •
        if memory_root:
            self.memory_root = memory_root
        else:
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # ë©”ëª¨ë¦¬ ê²½ë¡œ ì„¤ì •
        self.memory_path = os.path.join(self.memory_root, self.project_name)
        self.cache_dir = os.path.join(self.memory_path, '.cache')
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # ê¸°ì¡´ contextê°€ ìžˆìœ¼ë©´ ì‚¬ìš©
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"âœ… ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©: {project_name}")
        else:
            # ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"âœ… ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"âœ… ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±: {project_name}")
        
        # êµ¬ì¡° ì •ê·œí™”
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_paths(self) -> Dict[str, str]:
        """ê° ìºì‹œ íŒŒì¼ ê²½ë¡œ ë°˜í™˜"""
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        
        return {
            'core': os.path.join(cache_dir, 'cache_core.json'),
            'analyzed_files': os.path.join(cache_dir, 'cache_analyzed_files.json'),
            'work_tracking': os.path.join(cache_dir, 'cache_work_tracking.json'),
            'tasks': os.path.join(cache_dir, 'cache_tasks.json'),
            'plan': os.path.join(cache_dir, 'cache_plan.json')
        }
    
    def _create_new_context(self) -> Dict[str, Any]:
        """ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ìƒì„± (ê°œì„ ëœ êµ¬ì¡°)"""
        return {
            # ê¸°ë³¸ ì •ë³´ (cache_core.json)
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '7.0',
            'current_focus': '',
            'current_task': None,
            
            # ë¶„ì„ íŒŒì¼ ì •ë³´ (cache_analyzed_files.json)
            'analyzed_files': {},
            
            # ìž‘ì—… ì¶”ì  (cache_work_tracking.json)
            'work_tracking': {
                'file_access': {},
                'file_edits': {},
                'function_edits': {},
                'session_start': dt.datetime.now().isoformat(),
                'total_operations': 0,
                'task_tracking': {},
                'current_task_work': {
                    'task_id': None,
                    'start_time': None,
                    'files_accessed': [],
                    'functions_edited': [],
                    'operations': []
                }
            },
            
            # ìž‘ì—… ê´€ë¦¬ (cache_tasks.json)
            'tasks': {'next': [], 'done': []},
            
            # ê³„íš ê´€ë¦¬ (cache_plan.json)
            'plan': None,
            'plan_history': [],
            
            # ê¸°íƒ€ ë°ì´í„°
            'coding_experiences': [],
            'progress': {
                'completed_tasks': 0,
                'total_tasks': 0,
                'percentage': 0.0
            },
            'phase_reports': {},
            'error_log': [],
            'file_access_history': [],
            'metadata': {
                'version': '7.0',
                'last_saved': dt.datetime.now().isoformat()
            }
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ (ì—¬ëŸ¬ íŒŒì¼ì—ì„œ)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_paths = self._get_cache_file_paths()
        
        # í•µì‹¬ íŒŒì¼ì´ ìžˆëŠ”ì§€ í™•ì¸
        if not os.path.exists(cache_paths['core']):
            return None
        
        try:
            # 1. í•µì‹¬ ì •ë³´ ë¡œë“œ
            with open(cache_paths['core'], 'r', encoding='utf-8') as f:
                context = json.load(f)
            
            # 2. ê° ë¶€ë¶„ë³„ íŒŒì¼ ë¡œë“œ
            # analyzed_files
            if os.path.exists(cache_paths['analyzed_files']):
                with open(cache_paths['analyzed_files'], 'r', encoding='utf-8') as f:
                    context['analyzed_files'] = json.load(f)
            else:
                context['analyzed_files'] = {}
            
            # work_tracking
            if os.path.exists(cache_paths['work_tracking']):
                with open(cache_paths['work_tracking'], 'r', encoding='utf-8') as f:
                    context['work_tracking'] = json.load(f)
            else:
                context['work_tracking'] = self._create_new_context()['work_tracking']
            
            # tasks
            if os.path.exists(cache_paths['tasks']):
                with open(cache_paths['tasks'], 'r', encoding='utf-8') as f:
                    context['tasks'] = json.load(f)
            else:
                context['tasks'] = {'next': [], 'done': []}
            
            # plan
            if os.path.exists(cache_paths['plan']):
                with open(cache_paths['plan'], 'r', encoding='utf-8') as f:
                    plan_data = json.load(f)
                    context['plan'] = plan_data.get('plan')
                    context['plan_history'] = plan_data.get('plan_history', [])
            else:
                context['plan'] = None
                context['plan_history'] = []
            
            # ê²½ë¡œ ì—…ë°ì´íŠ¸
            context['project_path'] = self.project_path
            context['memory_root'] = self.memory_root
            
            return context
            
        except Exception as e:
            print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
            return None
    
    def _normalize_context_structure(self):
        """ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ì •ê·œí™”"""
        if not self.context:
            return
        
        # í•„ìˆ˜ í‚¤ í™•ì¸
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('plan', None)
        self.context.setdefault('plan_history', [])
        self.context.setdefault('file_access_history', [])
        self.context.setdefault('progress', {
            'completed_tasks': 0,
            'total_tasks': 0,
            'percentage': 0.0
        })
        
        # work_tracking êµ¬ì¡°
        work_tracking = self.context.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        work_tracking.setdefault('task_tracking', {})
        work_tracking.setdefault('current_task_work', {
            'task_id': None,
            'start_time': None,
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        })
        
        # ê²½ë¡œ ì •ë³´ ì—…ë°ì´íŠ¸
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root

    def save(self) -> bool:
        """ì»¨í…ìŠ¤íŠ¸ ì €ìž¥ (ì—¬ëŸ¬ íŒŒì¼ë¡œ ë¶„ë¦¬)"""
        # ë²„ì „ íŒ¨í„´ í”„ë¡œì íŠ¸ëŠ” ì €ìž¥í•˜ì§€ ì•ŠìŒ
        import re
        if self.project_name:
            version_patterns = [
                r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
                r'^app-\d+\.\d+\.\d+$',
                r'^project-\d+\.\d+\.\d+$',
                r'^v\d+\.\d+\.\d+$'
            ]
            for pattern in version_patterns:
                if re.match(pattern, self.project_name):
                    print(f"âš ï¸ ë²„ì „ íŒ¨í„´ í”„ë¡œì íŠ¸ '{self.project_name}'ëŠ” ì €ìž¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
                    return False
        
        if not self.context:
            print("âš ï¸ ì €ìž¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        try:
            # ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
            self.context['updated_at'] = dt.datetime.now().isoformat()
            self.context.setdefault('metadata', {})['last_saved'] = dt.datetime.now().isoformat()
            
            # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            self._update_progress()
            
            cache_paths = self._get_cache_file_paths()
            
            # 1. í•µì‹¬ ì •ë³´ ì €ìž¥ (cache_core.json)
            core_data = {
                'project_name': self.context.get('project_name'),
                'project_id': self.context.get('project_id'),
                'project_path': self.context.get('project_path'),
                'memory_root': self.context.get('memory_root'),
                'created_at': self.context.get('created_at'),
                'updated_at': self.context.get('updated_at'),
                'version': self.context.get('version', '7.0'),
                'current_focus': self.context.get('current_focus', ''),
                'current_task': self.context.get('current_task'),
                'coding_experiences': self.context.get('coding_experiences', []),
                'progress': self.context.get('progress', {}),
                'phase_reports': self.context.get('phase_reports', {}),
                'error_log': self.context.get('error_log', []),
                'file_access_history': self.context.get('file_access_history', []),
                'metadata': self.context.get('metadata', {})
            }
            
            with open(cache_paths['core'], 'w', encoding='utf-8') as f:
                json.dump(core_data, f, indent=2, ensure_ascii=False)
            
            # 2. ë¶„ì„ íŒŒì¼ ì €ìž¥ (cache_analyzed_files.json)
            with open(cache_paths['analyzed_files'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('analyzed_files', {}), f, indent=2, ensure_ascii=False)
            
            # 3. ìž‘ì—… ì¶”ì  ì €ìž¥ (cache_work_tracking.json)
            with open(cache_paths['work_tracking'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('work_tracking', {}), f, indent=2, ensure_ascii=False)
            
            # 4. ìž‘ì—… ì €ìž¥ (cache_tasks.json)
            with open(cache_paths['tasks'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('tasks', {}), f, indent=2, ensure_ascii=False)
            
            # 5. ê³„íš ì €ìž¥ (cache_plan.json)
            plan_data = {
                'plan': self.context.get('plan'),
                'plan_history': self.context.get('plan_history', [])
            }
            with open(cache_paths['plan'], 'w', encoding='utf-8') as f:
                json.dump(plan_data, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… ìºì‹œ ì €ìž¥ ì™„ë£Œ:")
            for name, path in cache_paths.items():
                if os.path.exists(path):
                    size = os.path.getsize(path)
                    print(f"   â€¢ {name}: {size:,} bytes")
            
            # í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹œë„
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"âš ï¸ í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            return True
            
        except Exception as e:
            print(f"âŒ ìºì‹œ ì €ìž¥ ì‹¤íŒ¨: {e}")
            return False

    def _update_progress(self):
        """ì§„í–‰ë¥  ì—…ë°ì´íŠ¸"""
        if not self.context:
            return
        
        # í˜„ìž¬ ê³„íšì—ì„œ ìž‘ì—… ìˆ˜ ê³„ì‚°
        plan = self.context.get('plan')
        if plan:
            total_tasks = 0
            completed_tasks = 0
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    total_tasks += 1
                    if task.get('status') == 'completed':
                        completed_tasks += 1
            
            progress = self.context.setdefault('progress', {})
            progress['total_tasks'] = total_tasks
            progress['completed_tasks'] = completed_tasks
            progress['percentage'] = (completed_tasks / max(1, total_tasks)) * 100
    
    def _update_project_docs(self):
        """í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸"""
        if not self.context or not self.project_path:
            return
        
        if not self.memory_root or not self.project_name:
            print("âš ï¸ memory_root ë˜ëŠ” project_nameì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return
            
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(str(self.memory_root), str(self.project_name), filename)
            try:
                os.makedirs(os.path.dirname(doc_path), exist_ok=True)
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"âš ï¸ {filename} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = len(self.context.get('analyzed_files', {}))
        progress = self.context.get('progress', {})
        
        content = f"""# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „

## ðŸŽ¯ í”„ë¡œì íŠ¸ ê°œìš”
MCP (Model Context Protocol) ê¸°ë°˜ í†µí•© ê°œë°œ ì§€ì› ì‹œìŠ¤í…œ

## ðŸ“Š í˜„ìž¬ ìƒíƒœ
- ë¶„ì„ëœ íŒŒì¼: {analyzed}ê°œ
- ì™„ë£Œëœ ìž‘ì—…: {progress.get('completed_tasks', 0)}ê°œ
- ì „ì²´ ìž‘ì—…: {progress.get('total_tasks', 0)}ê°œ
- ì§„í–‰ë¥ : {progress.get('percentage', 0):.1f}%

## ðŸ”§ í•µì‹¬ ê¸°ëŠ¥
1. **ìžë™ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬**: ìž‘ì—… ìƒíƒœ ìžë™ ì €ìž¥/ë³µì›
2. **í†µí•© ê²€ìƒ‰ ì‹œìŠ¤í…œ**: ì½”ë“œ, ë©”ëª¨ë¦¬, ìºì‹œ í†µí•© ê²€ìƒ‰
3. **Phase ê¸°ë°˜ ìž‘ì—… ê´€ë¦¬**: ì²´ê³„ì ì¸ í”„ë¡œì íŠ¸ ì§„í–‰
4. **SimplEdit ì•ˆì „ ìˆ˜ì •**: ë°±ì—…ê³¼ í•¨ê»˜í•˜ëŠ” ì•ˆì „í•œ ì½”ë“œ ìˆ˜ì •
"""
        
        plan = self.context.get('plan')
        if plan:
            content += f"""
## ðŸ“‹ í˜„ìž¬ ê³„íš: {plan.get('name', 'N/A')}
{plan.get('description', '')}

### Phase êµ¬ì¡°:
"""
            for phase_id, phase in plan.get('phases', {}).items():
                task_count = len(phase.get('tasks', []))
                completed = sum(1 for t in phase.get('tasks', []) if t.get('status') == 'completed')
                content += f"- **{phase.get('name', phase_id)}** ({completed}/{task_count} ì™„ë£Œ)\n"
        
        content += f"""
ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í˜„ìž¬ ìž‘ì—…\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        focus = self.context.get('current_focus', '')
        current_task_id = self.context.get('current_task')
        current_task = None
        current_phase = None
        
        plan = self.context.get('plan')
        if current_task_id and plan:
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        current_task = task
                        current_phase = phase
                        break
                if current_task:
                    break
        
        content = f"""# AI Coding Brain - í˜„ìž¬ ìž‘ì—…

## ðŸŽ¯ í˜„ìž¬ Focus
{focus or 'ì„¤ì •ë˜ì§€ ì•ŠìŒ'}

## ðŸ”„ ì§„í–‰ ì¤‘ì¸ ìž‘ì—…
"""
        
        if current_task:
            content += f"""### [{current_task['id']}] {current_task['title']}
- ìƒíƒœ: {current_task.get('status', 'pending')}
- Phase: {current_phase.get('name', 'N/A')}
- ì„¤ëª…: {current_task.get('description', 'N/A')}
"""
        else:
            content += "í˜„ìž¬ ì§„í–‰ ì¤‘ì¸ ìž‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.\n"
        
        content += f"""
ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_file_directory(self) -> str:
        """file_directory.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = self.context.get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## ðŸ“ Python ëª¨ë“ˆ ëª©ë¡

| ê²½ë¡œ | ì„¤ëª… | ìˆ˜ì •ì¼ |
|------|------|--------|
"""
        
        def to_relative_path(path):
            path = path.replace('\\', '/')
            if self.project_path:
                project_path = self.project_path.replace('\\', '/')
                if path.startswith(project_path):
                    return path[len(project_path):].lstrip('/')
            return path
        
        sorted_files = sorted(analyzed.items(), key=lambda x: to_relative_path(x[0]))
        
        for file_path, info in sorted_files:
            display_path = to_relative_path(file_path)
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            mod_time = info.get('last_modified', 'Unknown')
            
            description = ""
            if func_count > 0 or class_count > 0:
                parts = []
                if func_count > 0:
                    parts.append(f"{func_count}ê°œ í•¨ìˆ˜")
                if class_count > 0:
                    parts.append(f"{class_count}ê°œ í´ëž˜ìŠ¤")
                description = ", ".join(parts)
            else:
                description = "-"
                
            content += f"| {display_path} | {description} | {mod_time} |\n"
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - ì§„í–‰ ìƒí™©\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        progress = self.context.get('progress', {})
        done_count = progress.get('completed_tasks', 0)
        total_count = progress.get('total_tasks', 0)
        percentage = progress.get('percentage', 0)
        
        content = f"""# AI Coding Brain - ì§„í–‰ ìƒí™©

## ðŸ“Š ì „ì²´ ì§„í–‰ë¥ 
- ì™„ë£Œ: {done_count}ê°œ
- ì „ì²´: {total_count}ê°œ
- ì§„í–‰ë¥ : {percentage:.1f}%

### ì§„í–‰ë¥  ì°¨íŠ¸
[{'â–ˆ' * int(percentage / 5)}{'â–‘' * (20 - int(percentage / 5))}] {percentage:.1f}%

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    # ===========================================
    # ìºì‹œ ê´€ë¦¬ ë©”ì„œë“œ (ê°œì„ ë¨)
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """ìºì‹œ ì—…ë°ì´íŠ¸ (cache í‚¤ ì—†ì´ ì§ì ‘ ì ‘ê·¼)"""
        if not self.context:
            return
        
        keys = key.split('.')
        current = self.context
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """ê°’ ì¡°íšŒ (cache í‚¤ ì—†ì´ ì§ì ‘ ì ‘ê·¼)"""
        if not self.context:
            return default
        
        keys = key.split('.')
        current = self.context
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # ìž‘ì—… ì¶”ì  ë©”ì„œë“œë“¤
    # ===========================================
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.setdefault('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        work_tracking['file_access_count'] = work_tracking.get('file_access_count', 0) + 1
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        if file_path not in file_access:
            file_access[file_path] = {
                'read_count': 0,
                'write_count': 0,
                'first_access': dt.datetime.now().isoformat(),
                'last_read': None,
                'last_write': None
            }
        
        if operation == 'read':
            file_access[file_path]['read_count'] += 1
            file_access[file_path]['last_read'] = dt.datetime.now().isoformat()
        elif operation in ['write', 'modify']:
            file_access[file_path]['write_count'] += 1
            file_access[file_path]['last_write'] = dt.datetime.now().isoformat()
            
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # í˜„ìž¬ task ìž‘ì—…ì—ë„ ì¶”ê°€
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            files_accessed = current_task_work.setdefault('files_accessed', [])
            if file_path not in files_accessed:
                files_accessed.append(file_path)
            
            self.track_task_operation('file_access', {
                'file': file_path,
                'operation': operation
            })
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.setdefault('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        if func_key not in function_edits:
            function_edits[func_key] = {
                'file_path': file_path,
                'edit_count': 0,
                'first_edit': dt.datetime.now().isoformat(),
                'last_edit': None
            }
        
        function_edits[func_key]['edit_count'] += 1
        function_edits[func_key]['last_edit'] = dt.datetime.now().isoformat()
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # í˜„ìž¬ task ìž‘ì—…ì—ë„ ì¶”ê°€
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            functions_edited = current_task_work.setdefault('functions_edited', [])
            if func_key not in functions_edited:
                functions_edited.append(func_key)
            
            self.track_task_operation('function_edit', {
                'file': file_path,
                'function': func_key,
                'class': class_name
            })
    
    def get_work_tracking_summary(self) -> str:
        """ìž‘ì—… ì¶”ì  ìš”ì•½"""
        if not self.context:
            return "ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        
        work_tracking = self.context.get('work_tracking', {})
        
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        task_tracking = work_tracking.get('task_tracking', {})
        
        summary = f"""
ðŸ“Š ìž‘ì—… ì¶”ì  ìš”ì•½
================
â€¢ í”„ë¡œì íŠ¸: {self.project_name}
â€¢ ìž‘ì—… ê²½ë¡œ: {self.project_path}
â€¢ ìºì‹œ ê²½ë¡œ: {self.memory_root}
â€¢ ì„¸ì…˜ ì‹œê°„: {duration_str}
â€¢ ì „ì²´ ìž‘ì—…: {total_ops}íšŒ
â€¢ ì ‘ê·¼í•œ íŒŒì¼: {len(file_access)}ê°œ
â€¢ ìˆ˜ì •í•œ íŒŒì¼: {len(file_edits)}ê°œ
â€¢ ìˆ˜ì •í•œ í•¨ìˆ˜: {len(function_edits)}ê°œ
â€¢ ìˆ˜í–‰í•œ Task: {len(task_tracking)}ê°œ
"""
        
        if file_access:
            summary += "\nðŸ”¥ ê°€ìž¥ ë§Žì´ ì ‘ê·¼í•œ íŒŒì¼:\n"
            sorted_files = sorted(file_access.items(), 
                                key=lambda x: x[1].get('read_count', 0) + x[1].get('write_count', 0), 
                                reverse=True)[:5]
            for file_path, info in sorted_files:
                total_access = info.get('read_count', 0) + info.get('write_count', 0)
                summary += f"  â€¢ {file_path}: {total_access}íšŒ\n"
        
        return summary
    
    def start_task_tracking(self, task_id: str):
        """Task ìž‘ì—… ì¶”ì  ì‹œìž‘"""
        if not self.context:
            return
        
        work_tracking = self.context.get('work_tracking', {})
        
        # ì´ì „ task ìž‘ì—… ì €ìž¥
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_work['task_id']] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
        
        # ìƒˆ task ìž‘ì—… ì‹œìž‘
        work_tracking['current_task_work'] = {
            'task_id': task_id,
            'start_time': dt.datetime.now().isoformat(),
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        }
    
    def track_task_operation(self, operation_type: str, details: dict = None):
        """í˜„ìž¬ Taskì˜ ìž‘ì—… ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        
        if current_task_work and current_task_work.get('task_id'):
            operation = {
                'type': operation_type,
                'timestamp': dt.datetime.now().isoformat(),
                'details': details or {}
            }
            current_task_work.setdefault('operations', []).append(operation)


# ===========================================
# ê¸€ë¡œë²Œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ìž
# ===========================================
_context_manager = UnifiedContextManager()



# ===========================================
# ê¸€ë¡œë²Œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ìž
# ===========================================
_context_manager = UnifiedContextManager()

# ===========================================
# ì‹±ê¸€í†¤ ì ‘ê·¼ í•¨ìˆ˜
# ===========================================
def get_context_manager() -> UnifiedContextManager:
    """Get singleton instance of Context Manager"""
    return _context_manager
