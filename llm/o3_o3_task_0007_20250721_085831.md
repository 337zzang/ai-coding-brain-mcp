# o3 Analysis Result

## Task ID: o3_task_0007

### Question

    WorkflowManager에 다음 기능을 추가하는 구체적인 구현 코드를 작성해주세요:

    1. delete_task(task_id) 메서드
       - 태스크 삭제
       - 히스토리에 기록
       - dict 응답 반환

    2. search_tasks(keyword) 메서드
       - 태스크 이름/설명에서 검색
       - 대소문자 구분 없음
       - 검색 결과 dict 반환

    3. filter_tasks(status=None, date_range=None) 메서드
       - 상태별 필터링
       - 날짜 범위 필터링
       - 결과 dict 반환

    각 메서드의 완전한 구현 코드를 제공해주세요.
    

### Context

=== Flow Project 워크플로우 시스템 상세 컨텍스트 ===

시스템 구조:
1. flow_project_wrapper.py (127줄)
   - flow_project_with_workflow(project_name) 함수
   - 바탕화면에서 프로젝트 검색
   - WorkflowManager 인스턴스 생성/전환

2. WorkflowManager 클래스 (ai_helpers_new/workflow_manager.py, 275줄)
   - 16개 메서드로 구성
   - 프로젝트별 .ai-brain/workflow.json 관리
   - 주요 메서드:
     * add_task(name)
     * update_task(id, status, summary)  
     * list_tasks()
     * wf_command(command)
     * _handle_task_command(args)

3. workflow_wrapper.py (26줄)
   - wf() 함수: WorkflowManager.wf_command() 래퍼
   - dict 형태로 표준화된 응답 반환

현재 명령어 체계:
- /status: 상태 확인
- /task add [name]: 태스크 추가
- /task list: 목록
- /task start [id]: 시작 (하위 명령)
- /task complete [id]: 완료 (하위 명령)

문제점:
1. /start, /complete가 최상위 명령어가 아님
2. _show_status()가 문자열 반환 (dict 필요)
3. 태스크 삭제 기능 없음
4. 검색/필터링 기능 없음
5. 에러 처리 미흡


### Answer
아래 코드는 ai_helpers_new/workflow_manager.py 의 WorkflowManager 클래스 내부에 그대로 복사-붙여넣기 하면 바로 동작하도록 설계된 신규 3개 메서드의 “완전한 구현”입니다.  

필요한 표준 모듈(datetime, typing.Optional)을 상단 import 영역에 이미 존재하지 않을 경우 함께 추가해 주세요.

```python
from datetime import datetime
from typing import Optional, Tuple, List, Dict  # 파일 상단 import 구역에 추가
```

그리고 WorkflowManager 클래스 안에 다음 코드를 삽입해 주세요.
(기존 _load_workflow, _save_workflow, _generate_id 같은 내부 유틸리티 메서드는 그대로 재사용합니다)

```python
    # ------------------------------------------------------------------
    # NEW PUBLIC APIs
    # ------------------------------------------------------------------
    def delete_task(self, task_id: str) -> Dict:
        """
        태스크를 식별자(task_id)로 삭제한다.
        1) 존재하지 않으면 오류 dict 반환
        2) 삭제 성공 시 history 항목에 남긴 뒤 파일 저장
        3) 최종 결과를 dict 로 표준화하여 반환

        Returns
        -------
        dict
            {
              "ok": bool,            # 성공 여부
              "msg": str,            # 사용자용 메시지
              "data": {...} | None,  # 삭제된 태스크 정보
              "error": str | None    # 오류 메시지(실패 시)
            }
        """
        wf_data = self._load_workflow()

        tasks: List[Dict] = wf_data.get("tasks", [])
        # 태스크 위치 찾기
        index: Optional[int] = next(
            (i for i, t in enumerate(tasks) if str(t.get("id")) == str(task_id)), None
        )

        if index is None:
            return {
                "ok": False,
                "msg": f"Task {task_id} not found",
                "data": None,
                "error": "TASK_NOT_FOUND",
            }

        # pop 으로 실제 삭제
        removed_task: Dict = tasks.pop(index)

        # history 기록
        history_item = {
            "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
            "action": "delete",
            "task_id": removed_task.get("id"),
            "snapshot": removed_task,
        }
        wf_data.setdefault("history", []).append(history_item)

        # 저장
        wf_data["tasks"] = tasks
        self._save_workflow(wf_data)

        return {
            "ok": True,
            "msg": f"Task {task_id} deleted",
            "data": removed_task,
            "error": None,
        }

    # ------------------------------------------------------------------
    def search_tasks(self, keyword: str) -> Dict:
        """
        태스크의 name 또는 summary(설명) 에서 keyword(대소문자 구분 X)를
        포함하고 있는 항목들을 찾아 반환한다.

        Returns
        -------
        dict
            {
              "ok": True,
              "count": int,
              "tasks": [ {...}, ... ]
            }
        """
        if not keyword:
            return {"ok": True, "count": 0, "tasks": []}

        key_lower = keyword.lower()

        wf_data = self._load_workflow()
        tasks: List[Dict] = wf_data.get("tasks", [])

        matched: List[Dict] = [
            t
            for t in tasks
            if key_lower in str(t.get("name", "")).lower()
            or key_lower in str(t.get("summary", "")).lower()
        ]

        return {"ok": True, "count": len(matched), "tasks": matched}

    # ------------------------------------------------------------------
    def filter_tasks(
        self,
        status: Optional[str] = None,
        date_range: Optional[Tuple[Optional[str], Optional[str]]] = None,
    ) -> Dict:
        """
        status 와 created_at 기준(iso8601 문자열)으로 태스크를 필터링한다.

        Parameters
        ----------
        status : str | None
            - 예: "pending", "in_progress", "complete" 등
            - None 이면 상태 필터 미적용
        date_range : (start, end) | None
            - start, end 둘 다 None 이면 날짜 필터 미적용
            - 각 항목은 iso8601 문자열('2024-01-31T15:20:00') 또는 datetime 객체
            - open interval 지원: (start, None) / (None, end)

        Returns
        -------
        dict
            {
              "ok": True,
              "count": int,
              "tasks": [ {...}, ... ]
            }
        """
        wf_data = self._load_workflow()
        tasks: List[Dict] = wf_data.get("tasks", [])

        # status 필터 ----------------------------------------------------
        if status is not None:
            tasks = [t for t in tasks if t.get("status") == status]

        # 날짜 필터 -------------------------------------------------------
        if date_range is not None:
            start_raw, end_raw = date_range

            def _to_dt(val):
                if val is None:
                    return None
                if isinstance(val, datetime):
                    return val
                # fromisoformat 은 3.7+
                return datetime.fromisoformat(str(val))

            start_dt = _to_dt(start_raw)
            end_dt = _to_dt(end_raw)

            def _in_range(task_dict) -> bool:
                created_at_raw = task_dict.get("created_at") or task_dict.get(
                    "timestamp"
                )
                if created_at_raw is None:
                    return False  # created_at 없으면 날짜 필터 탈락
                created_dt = _to_dt(created_at_raw)
                if start_dt and created_dt < start_dt:
                    return False
                if end_dt and created_dt > end_dt:
                    return False
                return True

            tasks = [t for t in tasks if _in_range(t)]

        return {"ok": True, "count": len(tasks), "tasks": tasks}
```

동작 방식 요약
1. delete_task  
   • tasks 리스트에서 ID 매칭 후 pop → history 에 action=delete 기록 → 저장 → 표준 dict 반환  
2. search_tasks  
   • name 또는 summary 에 keyword(소문자 변환) 포함 여부로 검색 → dict(개수, 목록) 반환  
3. filter_tasks  
   • status, 날짜(start/end) 두 조건을 순차적으로 적용. 날짜는 ISO8601 문자열 또는 datetime 객체 모두 허용. 최종 dict 반환

이 세 메서드는 모두 기존 `_load_workflow()` / `_save_workflow()` 를 그대로 사용하므로 파일 I/O 로직은 일관성을 유지합니다.

### Metadata
- Reasoning Effort: medium

- Start Time: 2025-07-21 08:57:25.650852
- End Time: 2025-07-21 08:58:10.072187
- Duration: 44.4초

### Token Usage
- Prompt Tokens: 468
- Completion Tokens: 2,285
- Reasoning Tokens: 0
- Total Tokens: 2,753
