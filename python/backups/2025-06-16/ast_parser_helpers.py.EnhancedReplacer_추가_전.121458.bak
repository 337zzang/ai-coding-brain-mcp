# -*- coding: utf-8 -*-
"""
AST Parser Helper - Refactored Version
Python: ast.parse() 기반 파싱
JavaScript/TypeScript: Tree-sitter 지연 로딩 파싱  
"""

import ast
import os
import time
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, cast
import textwrap
import re

# ============================================================================
# 전역 설정 및 캐시
# ============================================================================

# Tree-sitter 지연 로딩
TREE_SITTER_AVAILABLE = False
_tree_sitter_modules = {}
_advanced_parser = None
_parser_lock = threading.Lock()

# 로깅 설정
VERBOSE = False

def set_verbose(flag: bool) -> None:
    """전역 verbose 모드 설정"""
    global VERBOSE
    VERBOSE = flag

def get_verbose() -> bool:
    """현재 verbose 모드 상태 반환"""
    return VERBOSE

def _log(msg: str, level: str = "INFO") -> None:
    """조건부 로깅"""
    if VERBOSE:
        print(f"[{level}] {msg}")

# ============================================================================
# 통합 캐시 시스템
# ============================================================================

class CacheManager:
    """모든 캐시를 중앙에서 관리"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.ast_cache: Dict[str, Any] = {}
            self.file_mtime_cache: Dict[str, float] = {}
            self.language_cache: Dict[str, Any] = {}
            self.parser_cache: Dict[str, Any] = {}
            self.initialized = True
    
    def get_cached_ast(self, file_path: str) -> Optional[Any]:
        """캐시된 AST 반환"""
        if file_path not in self.ast_cache:
            return None
            
        # 파일 수정 시간 확인
        try:
            current_mtime = os.path.getmtime(file_path)
            cached_mtime = self.file_mtime_cache.get(file_path, 0)
            
            if current_mtime > cached_mtime:
                # 캐시 무효화
                del self.ast_cache[file_path]
                return None
                
            return self.ast_cache[file_path]
        except:
            return None
    
    def set_cached_ast(self, file_path: str, ast_data: Any):
        """AST 캐시 저장"""
        self.ast_cache[file_path] = ast_data
        self.file_mtime_cache[file_path] = os.path.getmtime(file_path)
    
    def clear_all(self):
        """모든 캐시 초기화"""
        self.ast_cache.clear()
        self.file_mtime_cache.clear()
        self.language_cache.clear()
        self.parser_cache.clear()

# ============================================================================
# Tree-sitter 지연 로딩
# ============================================================================

def _lazy_import_tree_sitter() -> bool:
    """Tree-sitter 모듈 지연 임포트"""
    global TREE_SITTER_AVAILABLE, _tree_sitter_modules
    
    if _tree_sitter_modules:
        return True
        
    try:
        import tree_sitter
        import tree_sitter_python
        import tree_sitter_javascript
        
        _tree_sitter_modules['tree_sitter'] = tree_sitter
        _tree_sitter_modules['python'] = tree_sitter_python
        _tree_sitter_modules['javascript'] = tree_sitter_javascript
        
        TREE_SITTER_AVAILABLE = True
        _log("Tree-sitter 모듈 로드 성공")
        return True
    except ImportError as e:
        _log(f"Tree-sitter 로드 실패: {e}", "WARNING")
        return False

class TreeSitterManager:
    """Tree-sitter 파서 관리"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self._parsers = {}
            self.initialized = True
    
    def get_parser(self, language: str):
        """언어별 파서 반환"""
        if not _lazy_import_tree_sitter():
            return None
            
        if language not in self._parsers:
            self._parsers[language] = self._create_parser(language)
            
        return self._parsers[language]
    
    def _create_parser(self, language: str):
        """파서 생성"""
        tree_sitter = _tree_sitter_modules.get('tree_sitter')
        if not tree_sitter:
            return None
            
        parser = tree_sitter.Parser()
        
        lang_map = {
            'python': 'python',
            'javascript': 'javascript',
            'typescript': 'javascript'
        }
        
        lang_key = lang_map.get(language)
        if not lang_key:
            return None
            
        lang_module = _tree_sitter_modules.get(lang_key)
        if lang_module:
            parser.set_language(lang_module.Language())
            return parser
            
        return None

# ============================================================================
# AST Parser 메인 클래스
# ============================================================================

class FunctionReplacer(ast.NodeTransformer):
    """
    AST 트리에서 특정 이름을 가진 함수/메서드를 찾아
    새로운 코드 블록으로 교체하는 NodeTransformer입니다.
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        # 새로운 코드를 파싱하여 교체할 노드를 준비합니다.
        # 여러 문장이 포함될 수 있으므로 body에서 노드를 가져옵니다.
        self.new_nodes = ast.parse(new_code).body

    def visit_FunctionDef(self, node: ast.FunctionDef) -> Union[ast.FunctionDef, List[ast.AST]]:
        """일반 함수(def) 노드를 방문합니다."""
        # 자식 노드들도 계속 방문
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # 함수의 이름이 일치하면 준비된 새 노드들로 교체합니다.
            return self.new_nodes
        return node  # 일치하지 않으면 원래 노드를 그대로 반환합니다.

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Union[ast.AsyncFunctionDef, List[ast.AST]]:
        """비동기 함수(async def) 노드를 방문합니다."""
        # 자식 노드들도 계속 방문
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # 함수의 이름이 일치하면 준비된 새 노드들로 교체합니다.
            return self.new_nodes
        return node  # 일치하지 않으면 원래 노드를 그대로 반환합니다.



class ASTParser:
    """통합 AST 파서"""
    
    def __init__(self):
        self.cache_manager = CacheManager()
        self.ts_manager = TreeSitterManager()
        
    def _detect_language(self, file_path: str, language: str = 'auto') -> str:
        """파일 언어 감지"""
        if language != 'auto':
            return language
            
        ext = Path(file_path).suffix.lower()
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.ts': 'typescript',
            '.tsx': 'typescript'
        }
        
        return ext_map.get(ext, 'unknown')
    
    def _extract_docstring(self, node: ast.AST) -> Optional[str]:
        """Python docstring 추출"""
        # body 속성이 있는 노드 타입들만 처리
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module)):
            return None
            
        if not hasattr(node, 'body') or not node.body:
            return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, (ast.Str, ast.Constant)):
            # Python 3.8+에서는 ast.Constant 사용
            if isinstance(first.value, ast.Str):
                return textwrap.dedent(first.value.s).strip()
            elif isinstance(first.value, ast.Constant) and isinstance(first.value.value, str):
                return textwrap.dedent(first.value.value).strip()
                
        return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, ast.Str):
            return textwrap.dedent(first.value.s).strip()
            
        return None
    
    def _extract_function_info(self, node: ast.FunctionDef, source_lines: List[str]) -> Dict:
        """함수 정보 추출"""
        info = {
            'type': 'function',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'args': [arg.arg for arg in node.args.args],
            'docstring': self._extract_docstring(node),
            'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list if d],
            'is_async': isinstance(node, ast.AsyncFunctionDef)
        }
        
        # 코드 스니펫 추출
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def _extract_class_info(self, node: ast.ClassDef, source_lines: List[str]) -> Dict:
        """클래스 정보 추출"""
        info = {
            'type': 'class',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'bases': [base.id if isinstance(base, ast.Name) else str(base) for base in node.bases],
            'docstring': self._extract_docstring(node),
            'methods': []
        }
        
        # 메서드 추출
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                method_info = self._extract_function_info(item, source_lines)
                method_info['type'] = 'method'
                info['methods'].append(method_info)
        
        # 코드 스니펫 추출
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def parse_python(self, file_path: str, include_snippets: bool = True) -> Dict[str, Any]:
        """Python 파일 파싱"""
        try:
            # 캐시 확인
            cached = self.cache_manager.get_cached_ast(file_path)
            if cached and not include_snippets:
                return cached
                
            # 파일 읽기
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST 파싱
            tree = ast.parse(content, filename=file_path)
            source_lines = content.split('\n') if include_snippets else []
            
            # 결과 수집
            result = {
                'parsing_success': True,
                'language': 'python',
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # AST 순회
            for node in ast.walk(tree):  
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    result['functions'].append(self._extract_function_info(node, source_lines))
                elif isinstance(node, ast.ClassDef):
                    result['classes'].append(self._extract_class_info(node, source_lines))
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            result['imports'].append(alias.name)
                    else:
                        result['imports'].append(node.module or '')
            
            # 캐시 저장
            if not include_snippets:
                self.cache_manager.set_cached_ast(file_path, result)
                
            return result
            
        except Exception as e:
            _log(f"Python 파싱 오류: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': 'python',
                'error': str(e)
            }
    
    def parse_javascript(self, file_path: str, language: str = 'javascript', 
                        include_snippets: bool = True) -> Dict[str, Any]:
        """JavaScript/TypeScript 파일 파싱"""
        parser = self.ts_manager.get_parser(language)
        if not parser:
            return {
                'parsing_success': False,
                'language': language,
                'error': 'Tree-sitter not available'
            }
            
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
                
            tree = parser.parse(content)
            
            # 간단한 결과 반환 (실제 구현은 더 복잡함)
            result = {
                'parsing_success': True,
                'language': language,
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # Tree-sitter 노드 순회 로직 (간략화)
            # 실제로는 traverse_node 같은 복잡한 함수가 필요하지만
            # 여기서는 간단히 처리
            
            return result
            
        except Exception as e:
            _log(f"JavaScript 파싱 오류: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': language,
                'error': str(e)
            }
    
    def parse_with_snippets(self, file_path: str, language: str = 'auto', 
                          include_snippets: bool = True) -> Dict[str, Any]:
        """파일 파싱 메인 메서드"""
        # 언어 감지
        detected_lang = self._detect_language(file_path, language)
        
        if detected_lang == 'python':
            return self.parse_python(file_path, include_snippets)
        elif detected_lang in ['javascript', 'typescript']:
            return self.parse_javascript(file_path, detected_lang, include_snippets)
        else:
            return {
                'parsing_success': False,
                'language': detected_lang,
                'error': f'Unsupported language: {detected_lang}'
            }
    
    def get_snippet_preview(self, file_path: str, element_name: str, 
                          element_type: str = 'function', max_lines: int = 10) -> str:
        """코드 스니펫 미리보기"""
        result = self.parse_with_snippets(file_path, include_snippets=True)
        
        if not result.get('parsing_success'):
            return f"Error: {result.get('error', 'Unknown error')}"
            
        # 요소 찾기
        element_key = f'{element_type}s'
        if element_type == 'class':
            element_key = 'classes'
        elif element_type == 'function':
            element_key = 'functions'
            
        elements = result.get(element_key, [])
        for elem in elements:
            if elem.get('name') == element_name:
                snippet = elem.get('snippet', '')
                if not snippet:
                    # snippet이 없으면 기본 정보 반환
                    return f"{element_type} '{element_name}' found at line {elem.get('line_start', '?')}"
                    
                lines = snippet.split('\n')
                if len(lines) > max_lines:
                    return '\n'.join(lines[:max_lines]) + '\n...'
                return snippet
                

    def replace_block(self, file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
        """
        파일 내에서 이름이 일치하는 함수나 메서드를 찾아 새 코드로 교체합니다.
        (클래스 내부 메서드도 지원)

        Args:
            file_path (str): 수정할 파일의 경로.
            block_name (str): 교체할 함수 또는 메서드의 이름.
            new_code (str): 교체할 새로운 코드 블록.
            output_path (str, optional): 결과를 저장할 파일 경로. 지정하지 않으면 원본 파일을 수정.

        Returns:
            str: 성공 시 "SUCCESS: ...", 실패 시 "ERROR: ..." 메시지
        """
        try:
            # 1. 파일을 읽고 AST를 생성합니다.
            with open(file_path, 'r', encoding='utf-8') as f:
                source = f.read()
            tree = ast.parse(source, filename=file_path)

            # 2. FunctionReplacer를 사용하여 AST를 변환합니다.
            transformer = FunctionReplacer(block_name, new_code)
            new_tree = transformer.visit(tree)

            # 3. 변경된 AST에 대해 필수적인 후처리를 수행합니다.
            ast.fix_missing_locations(new_tree)

            # 4. 수정된 AST를 다시 소스 코드로 변환합니다.
            # Python 3.9+ 에서는 ast.unparse() 사용이 권장됩니다.
            modified_code = ast.unparse(new_tree)
            
            # 5. 결과 저장
            save_path = output_path or file_path
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(modified_code)
            
            return f"SUCCESS: 블록 '{block_name}' 교체 완료 (파일: {save_path})"

        except FileNotFoundError:
            return f"ERROR: 파일을 찾을 수 없습니다: {file_path}"
        except Exception as e:
            return f"ERROR: 코드 수정 중 오류 발생: {e}"
        return f"{element_type} '{element_name}' not found"

# ============================================================================
# 전역 파서 인스턴스
# ============================================================================

def _get_parser() -> ASTParser:
    """싱글톤 파서 인스턴스 반환"""
    global _advanced_parser, _parser_lock
    
    if _advanced_parser is None:
        with _parser_lock:
            if _advanced_parser is None:
                _advanced_parser = ASTParser()
                
    return _advanced_parser

# ============================================================================
# 공개 API
# ============================================================================

def parse_with_snippets(file_path: str, language: str = 'auto', 
                       include_snippets: bool = True) -> Dict[str, Any]:
    """파일 파싱 (공개 API)"""
    parser = _get_parser()
    return parser.parse_with_snippets(file_path, language, include_snippets)

def get_snippet_preview(file_path: str, element_name: str, 
                       element_type: str = 'function', max_lines: int = 10,
                       start_line: int = -1, end_line: int = -1) -> str:
    """코드 스니펫 미리보기 (공개 API)"""
    parser = _get_parser()
    return parser.get_snippet_preview(file_path, element_name, element_type, max_lines)

# ============================================================================
# 백그라운드 초기화 (선택적)
# ============================================================================

def init_background():
    """백그라운드에서 Tree-sitter 초기화"""
    def _init():
        _lazy_import_tree_sitter()
        _log("백그라운드 초기화 완료")
        
    thread = threading.Thread(target=_init, daemon=True)
    thread.start()

# 자동 백그라운드 초기화
init_background()

def replace_block(file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
    """
    파일 내에서 이름이 일치하는 함수나 메서드를 찾아 새 코드로 교체합니다.
    (클래스 내부 메서드도 지원)
    """
    parser = ASTParser()
    return parser.replace_block(file_path, block_name, new_code, output_path)
