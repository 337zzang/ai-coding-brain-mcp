#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
🧠 AI Coding Brain - 통합 버전 v6.3
==========================================

claude_code_ai_brain.py와 context_manager.py를 통합한 단일 파일.
핵심 기능만 유지하고 간소화함.

주요 기능:
- /flow 명령어로 프로젝트 전환
- /plan, /task, /next 명령어로 작업 관리
- 메모리 루트에 캐시 중앙 저장
- 프로젝트 루트에서 작업 수행
- MD 파일 자동 생성 및 동기화

v6.3 변경사항:
- 캐시 구조를 MD 파일 구조에 맞게 개선
- plan 구조 정규화 (dict 형태로 통일)
- MD 생성 함수들이 plan 정보를 제대로 읽도록 수정
- /plan, /next 명령 작동 개선

작성일: 2025-06-15
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy


# ===========================================
# 통합 컨텍스트 관리자
# ===========================================

class UnifiedContextManager:
    """통합 컨텍스트 관리자 - 싱글톤 패턴"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None  # 캐시 저장 위치
            self.base_path = None    # 프로젝트 루트
            self.memory_path = None  # 메모리 경로
            self.cache_dir = None    # 캐시 디렉토리
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str, memory_root: str = None, 
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """프로젝트 컨텍스트 초기화
        
        Args:
            project_path: 프로젝트 작업 경로
            project_name: 프로젝트 이름
            memory_root: 캐시 저장 루트 (기본값: ~/Desktop/memory)
            existing_context: 기존 context (execute_code 환경용)
        """
        self.project_path = project_path
        self.project_name = project_name
        self.base_path = project_path  # AIHelpers 호환성
        
        # 메모리 루트 설정 (없으면 기본값 사용)
        if memory_root:
            self.memory_root = memory_root
        else:
            # 기본값: 홈/Desktop/memory
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # 메모리 경로 설정
        self.memory_path = os.path.join(self.memory_root, self.project_name)
        self.cache_dir = os.path.join(self.memory_path, '.cache')
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # 기존 context가 있으면 사용 (execute_code 환경)
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"✅ 기존 컨텍스트 사용: {project_name}")
        else:
            # 캐시된 컨텍스트 로드 시도
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"✅ 캐시된 컨텍스트 로드: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"✅ 새 컨텍스트 생성: {project_name}")
        
        # 구조 정규화
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_path(self) -> str:
        """캐시 파일 경로 반환 (메모리 루트 기준)"""
        # 메모리/{프로젝트명}/.cache/cache_{프로젝트명}.json
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        return os.path.join(cache_dir, f'cache_{self.project_name}.json')
    
    def _create_new_context(self) -> Dict[str, Any]:
        """새로운 컨텍스트 생성"""
        return {
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '6.3',
            
            # 캐시 구조 - MD 파일 구조에 맞춤
            'cache': {
                'analyzed_files': {},
                'symbol_index': {},
                'work_tracking': {
                    'file_access': {},
                    'file_edits': {},
                    'function_edits': {},
                    'session_start': dt.datetime.now().isoformat(),
                    'total_operations': 0
                },
                'metadata': {
                    'version': '6.3',
                    'last_saved': dt.datetime.now().isoformat()
                }
            },
            
            # 계획 관리 구조 (개선됨)
            'current_plan': None,  # 현재 계획 정보
            'plans': [],  # 모든 계획 히스토리
            
            # 작업 관리 (레거시 호환)
            'tasks': {'next': [], 'done': []},
            'current_focus': '',
            'current_task': None,
            
            # AI 학습 데이터
            'coding_experiences': [],
            
            # 진행률 추적
            'progress': {
                'completed_tasks': 0,
                'total_tasks': 0,
                'percentage': 0.0
            },
            
            # Phase 관리 (execute_code 호환)
            'phase_reports': {},
            'error_log': [],
            
            # 기타 필드들
            'analyzed_files': {},
            'work_tracking': {},
            'symbol_index': {}
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """캐시된 컨텍스트 로드 (메모리 루트에서)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_file = self._get_cache_file_path()
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    loaded_context = json.load(f)
                
                # 프로젝트 경로 업데이트 (경로가 변경되었을 수 있음)
                loaded_context['project_path'] = self.project_path
                loaded_context['memory_root'] = self.memory_root
                
                return loaded_context
            except Exception as e:
                print(f"⚠️ 캐시 로드 실패: {e}")
        return None
    
    def _normalize_context_structure(self):
        """컨텍스트 구조 정규화"""
        if not self.context:
            return
            
        # 필수 키 확인
        self.context.setdefault('cache', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('work_tracking', {})
        self.context.setdefault('symbol_index', {})
        self.context.setdefault('current_plan', None)
        self.context.setdefault('plans', [])
        self.context.setdefault('progress', {
            'completed_tasks': 0,
            'total_tasks': 0,
            'percentage': 0.0
        })
        
        # 경로 정보 업데이트
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root
        
        # 캐시 구조 확인
        cache = self.context['cache']
        cache.setdefault('analyzed_files', {})
        cache.setdefault('symbol_index', {})
        cache.setdefault('metadata', {
            'version': '6.3',
            'last_saved': dt.datetime.now().isoformat()
        })
        
        # work_tracking 구조
        work_tracking = cache.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        
        # task_tracking 구조 추가 (v6.4)
        work_tracking.setdefault('task_tracking', {})
        work_tracking.setdefault('current_task_work', {
            'task_id': None,
            'start_time': None,
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        })
        
        # 레거시 필드 마이그레이션
        if 'analyzed_files' in self.context and self.context['analyzed_files']:
            cache['analyzed_files'].update(self.context['analyzed_files'])
        
        if 'work_tracking' in self.context and isinstance(self.context['work_tracking'], dict):
            cache['work_tracking'].update(self.context['work_tracking'])
        
        if 'symbol_index' in self.context and self.context['symbol_index']:
            cache['symbol_index'].update(self.context['symbol_index'])
    
    def save(self) -> bool:
        """컨텍스트 저장 (메모리 루트에)"""
        if not self.context:
            print("⚠️ 저장할 컨텍스트가 없습니다")
            return False
        
        try:
            # 업데이트 시간 갱신
            self.context['updated_at'] = dt.datetime.now().isoformat()
            self.context['cache']['metadata']['last_saved'] = dt.datetime.now().isoformat()
            
            # 진행률 업데이트
            self._update_progress()
            
            # 캐시 파일 경로
            cache_file = self._get_cache_file_path()
            
            # JSON 직렬화 가능한 형태로 변환
            serializable_context = self._prepare_serializable_context()
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            print(f"✅ 캐시 저장: {cache_file}")
            
            # 프로젝트 문서 업데이트 시도
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"⚠️ 프로젝트 문서 업데이트 실패: {e}")
            
            return True
            
        except Exception as e:
            print(f"❌ 캐시 저장 실패: {e}")
            return False
    
    def _update_progress(self):
        """진행률 업데이트"""
        if not self.context:
            return
        
        # 현재 계획에서 작업 수 계산
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            total_tasks = 0
            completed_tasks = 0
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    total_tasks += 1
                    if task.get('status') == 'completed':
                        completed_tasks += 1
            
            progress = self.context.setdefault('progress', {})
            progress['total_tasks'] = total_tasks
            progress['completed_tasks'] = completed_tasks
            progress['percentage'] = (completed_tasks / max(1, total_tasks)) * 100
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON 직렬화 가능한 형태로 변환 (강화된 버전)"""
        # context가 없거나 dict가 아닌 경우 빈 dict 반환
        if not self.context or not isinstance(self.context, dict):
            return {}
        
        def is_serializable(obj):
            """객체가 JSON 직렬화 가능한지 확인"""
            try:
                json.dumps(obj)
                return True
            except:
                return False
        
        def convert(obj):
            """재귀적으로 객체를 직렬화 가능한 형태로 변환"""
            # 이미 직렬화 가능한 기본 타입
            if obj is None or isinstance(obj, (bool, int, float, str)):
                return obj
            
            # 날짜/시간 타입
            elif isinstance(obj, (dt.datetime, dt.date)):
                return obj.isoformat()
            
            # defaultdict -> dict
            elif isinstance(obj, defaultdict):
                return dict(obj)
            
            # set -> list
            elif isinstance(obj, set):
                return list(obj)
            
            # dict 처리
            elif isinstance(obj, dict):
                result = {}
                for k, v in obj.items():
                    # 키도 문자열로 변환
                    key = str(k) if not isinstance(k, str) else k
                    # 직렬화 불가능한 값은 제외
                    if is_serializable(v):
                        result[key] = convert(v)
                    else:
                        # 객체 타입이면 타입명만 저장
                        if hasattr(v, '__class__'):
                            result[key] = f"<{v.__class__.__name__} object>"
                        else:
                            # 그 외는 건너뛰기
                            pass
                return result
            
            # list/tuple 처리
            elif isinstance(obj, (list, tuple)):
                return [convert(item) for item in obj if is_serializable(item)]
            
            # 커스텀 객체들은 문자열로 표현
            elif hasattr(obj, '__class__'):
                return f"<{obj.__class__.__name__} object>"
            
            # 그 외의 경우
            else:
                return str(obj)
        
        # 컨텍스트 복사 후 변환
        serializable = convert(copy.deepcopy(self.context))
        
        # 특정 필드 제거 (직렬화 불가능한 것들) - dict인 경우에만
        if isinstance(serializable, dict):
            fields_to_remove = ['error_tracker', 'phase_reporter', 'change_tracker', 'flow_options']
            for field in fields_to_remove:
                if field in serializable:
                    del serializable[field]
        
        return serializable
    
    def _update_project_docs(self):
        """프로젝트 문서 업데이트"""
        if not self.context or not self.project_path:
            return
        
        # None 체크 추가
        if not self.memory_root or not self.project_name:
            print("⚠️ memory_root 또는 project_name이 설정되지 않았습니다.")
            return
            
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(str(self.memory_root), str(self.project_name), filename)
            try:
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"⚠️ {filename} 업데이트 실패: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md 생성"""
        if not self.context:
            return "# AI Coding Brain MCP - 프로젝트 비전\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        analyzed = len(self.context.get('cache', {}).get('analyzed_files', {}))
        symbols = len(self.context.get('cache', {}).get('symbol_index', {}))
        progress = self.context.get('progress', {})
        
        content = f"""# AI Coding Brain MCP - 프로젝트 비전

## 🎯 프로젝트 개요
MCP (Model Context Protocol) 기반 통합 개발 지원 시스템

## 📊 현재 상태
- 분석된 파일: {analyzed}개
- 심볼 인덱스: {symbols}개
- 완료된 작업: {progress.get('completed_tasks', 0)}개
- 전체 작업: {progress.get('total_tasks', 0)}개
- 진행률: {progress.get('percentage', 0):.1f}%

## 🔧 핵심 기능
1. **자동 컨텍스트 관리**: 작업 상태 자동 저장/복원
2. **통합 검색 시스템**: 코드, 메모리, 캐시 통합 검색
3. **Phase 기반 작업 관리**: 체계적인 프로젝트 진행
4. **SimplEdit 안전 수정**: 백업과 함께하는 안전한 코드 수정
"""
        
        # 현재 계획 정보 추가
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            content += f"""
## 📋 현재 계획: {plan.get('name', 'N/A')}
{plan.get('description', '')}

### Phase 구조:
"""
            for phase_id, phase in plan.get('phases', {}).items():
                task_count = len(phase.get('tasks', []))
                completed = sum(1 for t in phase.get('tasks', []) if t.get('status') == 'completed')
                content += f"- **{phase.get('name', phase_id)}** ({completed}/{task_count} 완료)\n"
        
        # project_path가 있을 때만 파일 통계 추가
        if self.project_path and os.path.exists(self.project_path):
            try:
                py_files = []
                for root, dirs, files in os.walk(self.project_path):
                    py_files.extend([f for f in files if f.endswith('.py')])
                py_count = len(py_files)
                completion_rate = (analyzed / max(1, py_count)) * 100
                
                content += f"""
## 📈 프로젝트 통계
- 전체 Python 파일: {py_count}개
- 분석 완료율: {completion_rate:.1f}%
"""
            except Exception:
                pass
        
        content += f"""
최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 현재 작업\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        focus = self.context.get('current_focus', '')
        current_task_id = self.context.get('current_task')
        current_task = None
        current_phase = None
        
        # 현재 작업 찾기
        if current_task_id and self.context.get('current_plan'):
            plan = self.context['current_plan']
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        current_task = task
                        current_phase = phase
                        break
                if current_task:
                    break
        
        content = f"""# AI Coding Brain - 현재 작업

## 🎯 현재 Focus
{focus or '설정되지 않음'}

## 🔄 진행 중인 작업
"""
        
        if current_task:
            content += f"""### [{current_task['id']}] {current_task['title']}
- 상태: {current_task.get('status', 'pending')}
- Phase: {current_phase.get('name', 'N/A')}
- 설명: {current_task.get('description', 'N/A')}
"""
            if current_task.get('subtasks'):
                content += "\n#### 서브태스크:\n"
                for subtask in current_task['subtasks']:
                    content += f"- [ ] {subtask}\n"
        else:
            content += "현재 진행 중인 작업이 없습니다.\n"
        
        # 다음 대기 작업들
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            pending_tasks = []
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('status') == 'pending':
                        pending_tasks.append((phase, task))
                        if len(pending_tasks) >= 5:
                            break
                if len(pending_tasks) >= 5:
                    break
            
            if pending_tasks:
                content += "\n## 📋 대기 중인 작업 (다음 5개)\n"
                for phase, task in pending_tasks:
                    content += f"- [{task['id']}] {task['title']} (Phase: {phase['name']})\n"
        
        content += f"""
## 💡 다음 단계
- `/next` 명령으로 다음 작업 진행
- `/task add` 명령으로 새 작업 추가
- `/save` 명령으로 현재 상태 저장

## 📝 메모
- save_context() 호출 시 4개 문서 자동 업데이트
- 백업 없이 직접 저장

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_file_directory(self) -> str:
        """file_directory.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 프로젝트 구조\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        analyzed = self.context.get('cache', {}).get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - 프로젝트 구조

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## 📁 Python 모듈 목록

| 경로 | 설명 | 수정일 |
|------|------|--------|
"""
        
        # 상대 경로로 변환하는 헬퍼 함수
        def to_relative_path(path):
            """절대 경로를 프로젝트 기준 상대 경로로 변환"""
            # Windows 백슬래시를 슬래시로 통일
            path = path.replace('\\', '/')
            
            # 프로젝트 경로도 슬래시로 통일
            if self.project_path:
                project_path = self.project_path.replace('\\', '/')
                
                # 여러 가능한 프로젝트 경로 패턴 처리
                possible_prefixes = [
                    project_path,
                    f"{project_path}/",
                    # memory_coding 경로도 처리
                    project_path.replace('/ai-coding-brain-mcp', '/memory_coding/ai-coding-brain-mcp'),
                ]
                
                for prefix in possible_prefixes:
                    if path.startswith(prefix):
                        # prefix 제거 후 남은 경로
                        relative = path[len(prefix):].lstrip('/')
                        # 빈 문자열이면 루트
                        return '/' + relative if relative else '/'
            
            # 이미 상대 경로인 경우 슬래시 추가
            if not path.startswith('C:') and not path.startswith('/'):
                return '/' + path
                
            # 변환 실패시 원본 반환
            return path
        
        # 경로별로 정렬
        sorted_files = sorted(analyzed.items(), key=lambda x: to_relative_path(x[0]))
        
        for file_path, info in sorted_files:
            mod_time = info.get('last_modified', 'Unknown')
            if isinstance(mod_time, str):
                try:
                    # ISO 형식 날짜를 더 읽기 쉬운 형태로
                    mod_dt = dt.datetime.fromisoformat(mod_time.replace('Z', '+00:00'))
                    mod_time = mod_dt.strftime('%Y-%m-%d %H:%M')
                except:
                    pass
            
            # 상대 경로로 변환
            display_path = to_relative_path(file_path)
            
            # 분석된 코드 정보 추출
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            line_count = info.get('lines', 0)
            
            # 설명 생성
            description = ""
            if func_count > 0 or class_count > 0:
                parts = []
                if func_count > 0:
                    parts.append(f"{func_count}개 함수")
                if class_count > 0:
                    parts.append(f"{class_count}개 클래스")
                description = ", ".join(parts)
            else:
                description = "-"
                
            content += f"| {display_path} | {description} | {mod_time} |\n"
        
        # 작업 추적 정보에서 가장 많이 접근한 파일
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.get('file_access', {})
        
        if file_access:
            content += f"""

## 🔥 자주 접근하는 파일 (Top 10)
"""
            sorted_access = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:10]
            for file_path, count in sorted_access:
                # 자주 접근하는 파일도 상대 경로로 표시
                display_path = to_relative_path(file_path)
                content += f"- {display_path}: {count}회\n"
        
        # 코드 분석 통계
        total_functions = 0
        total_classes = 0
        total_lines = 0
        
        for info in analyzed.values():
            total_functions += len(info.get('functions', []))
            total_classes += len(info.get('classes', []))
            total_lines += info.get('lines', 0)
        
        # 심볼 인덱스 정보
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        
        content += f"""

## 📊 코드 분석 통계
- 전체 파일: {len(analyzed)}개
- 총 함수: {total_functions}개
- 총 클래스: {total_classes}개
- 총 코드 라인: {total_lines:,}줄
- 심볼 인덱스: {len(symbol_index)}개
- 총 파일 접근: {sum(file_access.values())}회

## 🔍 주요 심볼 (Top 10)
"""
        # 심볼 인덱스에서 주요 항목 표시
        if symbol_index:
            sorted_symbols = sorted(symbol_index.items(), key=lambda x: x[0])[:10]
            for symbol_name, symbol_info in sorted_symbols:
                symbol_type = symbol_info.get('type', 'unknown')
                symbol_file = symbol_info.get('file', 'unknown')
                symbol_icon = "📦" if symbol_type == 'class' else "🔧" if symbol_type == 'function' else "❓"
                content += f"- {symbol_icon} `{symbol_name}` ({symbol_type}) - {symbol_file}\n"
        
        content += f"""

## 📌 주요 디렉토리
- `/python/` - 핵심 Python 모듈들
- `/src/` - TypeScript/JavaScript 소스
- `/backups/` - 백업 파일들
- `/dist/` - 빌드 결과물
- `/.cache/` - 캐시 파일들

## 📝 최근 분석된 파일
"""
        # 최근 분석된 파일 (수정 시간 기준)
        recent_files = []
        for file_path, info in analyzed.items():
            mod_time = info.get('last_modified', '')
            if mod_time and mod_time != 'Unknown':
                recent_files.append((file_path, mod_time, info))
        
        recent_files.sort(key=lambda x: x[1], reverse=True)
        
        for file_path, mod_time, info in recent_files[:5]:
            display_path = to_relative_path(file_path)
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            content += f"- {display_path} ({func_count}개 함수, {class_count}개 클래스)\n"
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 진행 상황\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        progress = self.context.get('progress', {})
        done_count = progress.get('completed_tasks', 0)
        total_count = progress.get('total_tasks', 0)
        percentage = progress.get('percentage', 0)
        
        content = f"""# AI Coding Brain - 진행 상황

## 📊 전체 진행률
- 완료: {done_count}개
- 전체: {total_count}개
- 진행률: {percentage:.1f}%

### 진행률 차트
[{'█' * int(percentage / 5)}{'░' * (20 - int(percentage / 5))}] {percentage:.1f}%
"""
        
        # Phase별 진행 상황
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            content += "\n## 🎯 Phase 진행 상황\n"
            
            for phase_id, phase in plan.get('phases', {}).items():
                tasks = phase.get('tasks', [])
                completed = sum(1 for t in tasks if t.get('status') == 'completed')
                in_progress = sum(1 for t in tasks if t.get('status') == 'in_progress')
                total = len(tasks)
                
                if total > 0:
                    phase_percentage = (completed / total) * 100
                    content += f"\n### {phase.get('name', phase_id)}\n"
                    content += f"- 완료: {completed}개, 진행중: {in_progress}개, 대기: {total - completed - in_progress}개\n"
                    content += f"- 진행률: [{phase_percentage:.1f}%] "
                    content += f"[{'█' * int(phase_percentage / 10)}{'░' * (10 - int(phase_percentage / 10))}]\n"
        
        # 최근 완료 작업
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            completed_tasks = []
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('status') == 'completed':
                        completed_tasks.append({
                            'task': task,
                            'phase': phase.get('name', phase_id)
                        })
            
            if completed_tasks:
                content += "\n## 📋 최근 완료 작업\n"
                # 최근 5개만 표시 (실제로는 완료 시간으로 정렬해야 하지만 현재는 순서대로)
                for item in completed_tasks[-5:]:
                    task = item['task']
                    content += f"- [{task['id']}] {task['title']} (Phase: {item['phase']})\n"
        
        # 작업 통계
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        content += f"""
## 📈 작업 통계
- 총 작업 수행: {work_tracking.get('total_operations', 0)}회
- 파일 편집: {len(work_tracking.get('file_edits', {}))}개
- 함수 수정: {len(work_tracking.get('function_edits', {}))}개

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    # ===========================================
    # 캐시 관리 메서드
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """캐시 업데이트 (중첩 키 지원)"""
        if not self.context:
            return
        
        cache = self.context.setdefault('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """캐시 값 조회"""
        if not self.context:
            return default
        
        cache = self.context.get('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # 심볼 및 작업 추적
    # ===========================================
    
    def find_symbol(self, symbol_name: str) -> Optional[Dict[str, Any]]:
        """심볼 검색"""
        if not self.context:
            return None
        
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        return symbol_index.get(symbol_name)
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """파일 접근 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        # 상대 경로로 정규화
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        file_access[file_path] = file_access.get(file_path, 0) + 1
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # 현재 task 작업에도 추가
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            files_accessed = current_task_work.setdefault('files_accessed', [])
            if file_path not in files_accessed:
                files_accessed.append(file_path)
            
            # 작업 내역 추가
            self.track_task_operation('file_access', {
                'file': file_path,
                'operation': operation
            })
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """함수 수정 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        # 함수 키 생성
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        # 상대 경로로 정규화
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        # 편집 정보 업데이트
        if func_key not in function_edits:
            function_edits[func_key] = {'count': 0, 'operations': []}
        
        function_edits[func_key]['count'] += 1
        function_edits[func_key]['operations'].append({
            'timestamp': dt.datetime.now().isoformat(),
            'file': file_path
        })
        
        # 파일 편집도 추적
        file_edits = work_tracking.setdefault('file_edits', {})
        file_edits[file_path] = file_edits.get(file_path, 0) + 1
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # 현재 task 작업에도 추가
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            functions_edited = current_task_work.setdefault('functions_edited', [])
            if func_key not in functions_edited:
                functions_edited.append(func_key)
            
            # 작업 내역 추가
            self.track_task_operation('function_edit', {
                'file': file_path,
                'function': func_key,
                'class': class_name
            })
    
    def get_work_tracking_summary(self) -> str:
        """작업 추적 요약"""
        if not self.context:
            return "컨텍스트가 초기화되지 않았습니다."
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # 세션 시간 계산
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        # 통계 수집
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        task_tracking = work_tracking.get('task_tracking', {})
        
        # 요약 생성
        summary = f"""
📊 작업 추적 요약
================
• 프로젝트: {self.project_name}
• 작업 경로: {self.project_path}
• 캐시 경로: {self.memory_root}
• 세션 시간: {duration_str}
• 전체 작업: {total_ops}회
• 접근한 파일: {len(file_access)}개
• 수정한 파일: {len(file_edits)}개
• 수정한 함수: {len(function_edits)}개
• 수행한 Task: {len(task_tracking)}개
"""
        
        # 현재 작업 중인 Task
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            summary += f"\n🎯 현재 작업 중인 Task: {current_task_work['task_id']}\n"
            summary += f"  • 시작 시간: {current_task_work.get('start_time', 'N/A')}\n"
            summary += f"  • 접근 파일: {len(current_task_work.get('files_accessed', []))}개\n"
            summary += f"  • 수정 함수: {len(current_task_work.get('functions_edited', []))}개\n"
        
        # Top 5 파일
        if file_access:
            summary += "\n🔥 가장 많이 접근한 파일:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:5]
            for file_path, count in sorted_files:
                summary += f"  • {file_path}: {count}회\n"
        
        # Top 5 함수
        if function_edits:
            summary += "\n✏️ 가장 많이 수정한 함수:\n"
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1]['count'], reverse=True)[:5]
            for func_name, info in sorted_funcs:
                summary += f"  • {func_name}: {info['count']}회\n"
        
        # Task별 작업 이력
        if task_tracking:
            summary += "\n📋 Task별 작업 이력:\n"
            for task_id, task_work in list(task_tracking.items())[-5:]:
                summary += f"  • [{task_id}]: 파일 {len(task_work.get('files_accessed', []))}개, "
                summary += f"함수 {len(task_work.get('functions_edited', []))}개 수정\n"
        
        return summary
    
    def start_task_tracking(self, task_id: str):
        """Task 작업 추적 시작"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # 이전 task 작업 저장
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            # task_tracking에 저장
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_work['task_id']] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
        
        # 새 task 작업 시작
        work_tracking['current_task_work'] = {
            'task_id': task_id,
            'start_time': dt.datetime.now().isoformat(),
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        }
    
    def track_task_operation(self, operation_type: str, details: dict = None):
        """현재 Task의 작업 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        
        if current_task_work.get('task_id'):
            operation = {
                'type': operation_type,
                'timestamp': dt.datetime.now().isoformat(),
                'details': details or {}
            }
            current_task_work.setdefault('operations', []).append(operation)


# ===========================================
# 글로벌 컨텍스트 관리자
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str, memory_root: str = None,
                      existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """프로젝트 컨텍스트 초기화"""
    return _context_manager.initialize(project_path, project_name, memory_root, existing_context)

def save_context() -> bool:
    """컨텍스트 저장"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """캐시 업데이트"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """캐시 값 조회"""
    return _context_manager.get_value(key, default)

def find_symbol(symbol_name: str) -> Optional[Dict[str, Any]]:
    """심볼 찾기"""
    return _context_manager.find_symbol(symbol_name)

def track_file_access(file_path: str, operation: str = 'read'):
    """파일 접근 추적"""
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """함수 수정 추적"""
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """작업 추적 요약"""
    return _context_manager.get_work_tracking_summary()

def start_task_tracking(task_id: str):
    """Task 작업 추적 시작"""
    _context_manager.start_task_tracking(task_id)

def track_task_operation(operation_type: str, details: dict = None):
    """현재 Task의 작업 추적"""
    _context_manager.track_task_operation(operation_type, details)

def get_current_context() -> Optional[Dict[str, Any]]:
    """현재 context 반환 (auto_tracking_wrapper용)"""
    return _context_manager.context if _context_manager else None


# ===========================================
# Claude Desktop 설정 및 명령어 처리
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop 설정에서 경로 가져오기"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_root': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_root'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"⚠️ 설정 로드 실패: {e}")
    
    return paths


def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> None:
    """/flow 명령어 - 프로젝트 전환
    
    Args:
        project_name: 전환할 프로젝트명
        existing_context: 기존 context (execute_code 환경용)
    """
    
    if not project_name:
        # 현재 상태 표시
        if _context_manager.project_name:
            print(f"\n🔥 현재 프로젝트: {_context_manager.project_name}")
            print(f"📁 작업 경로: {_context_manager.project_path}")
            print(f"💾 캐시 경로: {_context_manager.memory_root}")
            print(get_work_tracking_summary())
        else:
            print("\n⚠️ 프로젝트가 선택되지 않았습니다")
            print("사용법: /flow [프로젝트명]")
        return
    
    # 이전 컨텍스트 저장
    if _context_manager.context:
        save_context()
    
    # 경로 가져오기
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    # execute_code 환경에서는 Desktop 직속 경로 우선 확인
    if existing_context:
        # Desktop 직속 경로 먼저 확인
        desktop_path = paths['project_root'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            project_path = os.getcwd()
            location = 'current'
    else:
        # 프로젝트 경로 찾기 (Desktop 우선, 그 다음 메모리)
        project_path = paths['project_root'] / project_name
        location = 'desktop'
        
        if not project_path.exists():
            # 메모리 루트 확인
            project_path = paths['memory_root'] / project_name
            location = 'memory'
            
            if not project_path.exists():
                # 현재 디렉토리에서 찾기
                if os.path.basename(os.getcwd()) == project_name:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\n❌ 프로젝트 '{project_name}'를 찾을 수 없습니다")
                    print(f"   • Desktop: {paths['project_root'] / project_name}")
                    print(f"   • Memory: {paths['memory_root'] / project_name}")
                    return
    
    # 작업 디렉토리 변경 (execute_code 환경이 아닌 경우에만)
    if not existing_context:
        os.chdir(project_path)
    
    # Context 초기화 (메모리 루트와 기존 context 전달)
    context = initialize_context(str(project_path), project_name, memory_root, existing_context)
    
    print(f"\n✅ 프로젝트 '{project_name}'로 전환 완료!")
    print(f"📁 작업 경로: {project_path} ({location})")
    print(f"💾 캐시 경로: {memory_root}/{project_name}/.cache/")
    print(f"📊 캐시 버전: {context.get('version', 'Unknown')}")
    
    # 간단한 통계 표시
    analyzed_files = context.get('cache', {}).get('analyzed_files', {})
    progress = context.get('progress', {})
    print(f"📈 분석된 파일: {len(analyzed_files)}개")
    print(f"📋 남은 작업: {progress.get('total_tasks', 0) - progress.get('completed_tasks', 0)}개")
    print(f"✅ 완료된 작업: {progress.get('completed_tasks', 0)}개")


# ===========================================
# 작업 관리 명령어
# ===========================================

def cmd_plan(plan_name: str = None, description: str = None) -> Dict[str, Any]:
    """/plan 명령어 - 새로운 계획 생성
    
    Args:
        plan_name: 계획 이름
        description: 계획 설명
    """
    if not _context_manager.context:
        print("❌ 프로젝트가 선택되지 않았습니다. 먼저 /flow [프로젝트명]을 실행하세요.")
        return None
    
    if not plan_name:
        # 현재 계획 표시
        current_plan = _context_manager.context.get('current_plan')
        if current_plan:
            print(f"\n📋 현재 계획: {current_plan['name']}")
            print(f"   설명: {current_plan.get('description', 'N/A')}")
            print(f"   생성: {current_plan.get('created_at', 'N/A')}")
            print(f"   Phase 수: {len(current_plan.get('phases', {}))}개")
            
            for phase_id, phase in current_plan.get('phases', {}).items():
                tasks = phase.get('tasks', [])
                completed = sum(1 for t in tasks if t.get('status') == 'completed')
                print(f"\n   📌 {phase.get('name', phase_id)} ({completed}/{len(tasks)} 완료)")
        else:
            print("\n⚠️ 현재 설정된 계획이 없습니다.")
            print("사용법: /plan [계획명] [설명]")
        return None
    
    # 새 계획 생성
    timestamp = dt.datetime.now().isoformat()
    
    new_plan = {
        'name': plan_name,
        'description': description or f"{_context_manager.project_name} 작업 계획",
        'created_at': timestamp,
        'updated_at': timestamp,
        'phases': {},
        'current_phase': None,
        'current_task': None
    }
    
    # 기본 Phase 3개 생성
    default_phases = [
        ('phase-1', 'Phase 1: 분석 및 설계', '현재 상태 분석과 개선 방향 설계'),
        ('phase-2', 'Phase 2: 핵심 구현', '주요 기능 구현 및 개선'),
        ('phase-3', 'Phase 3: 테스트 및 문서화', '테스트 작성 및 문서 정리')
    ]
    
    for phase_id, phase_name, phase_desc in default_phases:
        new_plan['phases'][phase_id] = {
            'id': phase_id,
            'name': phase_name,
            'description': phase_desc,
            'status': 'pending',
            'tasks': []
        }
    
    # 첫 번째 Phase를 현재 Phase로
    new_plan['current_phase'] = 'phase-1'
    
    # 컨텍스트에 저장
    _context_manager.context['current_plan'] = new_plan
    _context_manager.context['plans'].append({
        'name': plan_name,
        'created_at': timestamp,
        'id': f"plan-{len(_context_manager.context['plans']) + 1}"
    })
    
    save_context()
    print(f"\n✅ 새 계획 '{plan_name}' 생성 완료!")
    print(f"   설명: {new_plan['description']}")
    print(f"\n   3개의 기본 Phase가 생성되었습니다:")
    for phase_id, phase_name, _ in default_phases:
        print(f"   - {phase_name}")
    print(f"\n   /task add {default_phases[0][0]} [작업명]으로 작업을 추가하세요.")
    
    return new_plan


def cmd_task(action: str, *args) -> None:
    """/task 명령어 - 작업 관리
    
    Args:
        action: add, edit, delete, list 등
        args: 액션별 인자
    """
    if not _context_manager.context:
        print("❌ 프로젝트가 선택되지 않았습니다.")
        return
        
    current_plan = _context_manager.context.get('current_plan')
    if not current_plan:
        print("❌ 계획이 없습니다. 먼저 /plan [계획명]을 실행하세요.")
        return
    
    if action == 'add':
        # /task add [phase-id] [task-title] [description]
        if len(args) < 2:
            print("사용법: /task add [phase-id] [작업명] [설명(선택)]")
            return
            
        phase_id = args[0]
        task_title = args[1]
        task_desc = ' '.join(args[2:]) if len(args) > 2 else ""
        
        # Phase 찾기
        phase = current_plan['phases'].get(phase_id)
        if not phase:
            print(f"❌ Phase '{phase_id}'를 찾을 수 없습니다.")
            print(f"   사용 가능한 Phase: {', '.join(current_plan['phases'].keys())}")
            return
        
        # 새 Task ID 생성
        phase_num = phase_id.split('-')[1]
        task_num = len(phase['tasks']) + 1
        new_task = {
            'id': f'{phase_num}-{task_num}',
            'title': task_title,
            'description': task_desc,
            'status': 'pending',
            'created_at': dt.datetime.now().isoformat(),
            'subtasks': []
        }
        
        phase['tasks'].append(new_task)
        current_plan['updated_at'] = dt.datetime.now().isoformat()
        
        # 진행률 업데이트
        _context_manager._update_progress()
        save_context()
        
        print(f"✅ Task 추가됨: [{new_task['id']}] {task_title}")
        print(f"   Phase: {phase['name']}")
        
    elif action == 'edit':
        # /task edit [task-id] status|title|desc [new-value]
        if len(args) < 3:
            print("사용법: /task edit [task-id] status|title|desc [새값]")
            print("   status 값: pending, in_progress, completed, blocked")
            return
            
        task_id = args[0]
        field = args[1]
        new_value = ' '.join(args[2:])
        
        # Task 찾기
        task_found = False
        for phase_id, phase in current_plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if field == 'status':
                        if new_value not in ['pending', 'in_progress', 'completed', 'blocked']:
                            print(f"❌ 잘못된 상태값: {new_value}")
                            print("   가능한 값: pending, in_progress, completed, blocked")
                            return
                        task['status'] = new_value
                        
                        # 현재 작업 업데이트
                        if new_value == 'in_progress':
                            _context_manager.context['current_task'] = task_id
                            current_plan['current_phase'] = phase_id
                            phase['status'] = 'in_progress'
                        elif new_value == 'completed' and _context_manager.context.get('current_task') == task_id:
                            _context_manager.context['current_task'] = None
                            
                    elif field == 'title':
                        task['title'] = new_value
                    elif field in ['desc', 'description']:
                        task['description'] = new_value
                    else:
                        print(f"❌ 알 수 없는 필드: {field}")
                        return
                    
                    task['updated_at'] = dt.datetime.now().isoformat()
                    task_found = True
                    current_plan['updated_at'] = dt.datetime.now().isoformat()
                    
                    # 진행률 업데이트
                    _context_manager._update_progress()
                    save_context()
                    
                    print(f"✅ Task [{task_id}] {field} 수정됨")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"❌ Task '{task_id}'를 찾을 수 없습니다.")
    
    elif action == 'list':
        # 현재 모든 task 표시
        print(f"\n📋 계획: {current_plan['name']}")
        print(f"진행률: {_context_manager.context['progress']['percentage']:.1f}%")
        print("\n전체 Task 목록:")
        
        for phase_id, phase in current_plan['phases'].items():
            tasks = phase['tasks']
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            
            status_emoji = "✅" if phase['status'] == 'completed' else "🔄" if phase['status'] == 'in_progress' else "⏳"
            print(f"\n{status_emoji} {phase['name']} ({completed}/{len(tasks)} 완료)")
            
            if phase.get('description'):
                print(f"   📝 {phase['description']}")
            
            for task in tasks:
                task_emoji = "✅" if task['status'] == 'completed' else "🔄" if task['status'] == 'in_progress' else "🚫" if task['status'] == 'blocked' else "⏳"
                current = " 👈 현재" if _context_manager.context.get('current_task') == task['id'] else ""
                print(f"   {task_emoji} [{task['id']}] {task['title']}{current}")
                if task.get('description'):
                    print(f"      📝 {task['description']}")
    
    else:
        print(f"❌ 알 수 없는 액션: {action}")
        print("사용 가능한 액션: add, edit, list")


def cmd_next() -> None:
    """/next 명령어 - 다음 작업으로 진행"""
    if not _context_manager.context:
        print("❌ 프로젝트가 선택되지 않았습니다.")
        return
        
    current_plan = _context_manager.context.get('current_plan')
    if not current_plan:
        print("❌ 계획이 없습니다. 먼저 /plan [계획명]을 실행하세요.")
        return
    
    # 현재 작업이 있으면 완료로 표시
    current_task_id = _context_manager.context.get('current_task')
    if current_task_id:
        # 현재 task 작업 추적 종료
        work_tracking = _context_manager.context.get('cache', {}).get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id') == current_task_id:
            # task_tracking에 저장
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_id] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
            
            # 작업 요약 출력
            print(f"\n📊 Task [{current_task_id}] 작업 요약:")
            print(f"   • 접근 파일: {len(current_task_work.get('files_accessed', []))}개")
            print(f"   • 수정 함수: {len(current_task_work.get('functions_edited', []))}개")
            print(f"   • 총 작업: {len(current_task_work.get('operations', []))}회")
        
        for phase_id, phase in current_plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == current_task_id:
                    if task['status'] != 'completed':
                        task['status'] = 'completed'
                        task['completed_at'] = dt.datetime.now().isoformat()
                        # 작업 추적 정보 task에 저장
                        task['work_summary'] = {
                            'files_accessed': len(current_task_work.get('files_accessed', [])),
                            'functions_edited': len(current_task_work.get('functions_edited', [])),
                            'operations': len(current_task_work.get('operations', []))
                        }
                        print(f"✅ Task [{task['id']}] {task['title']} 완료!")
                    break
    
    # 다음 pending 작업 찾기
    next_task = None
    next_phase = None
    
    # 현재 Phase부터 확인
    if current_plan.get('current_phase'):
        phase = current_plan['phases'].get(current_plan['current_phase'])
        if phase:
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
    
    # 없으면 전체 Phase에서 찾기
    if not next_task:
        for phase_id, phase in current_plan['phases'].items():
            if phase['status'] == 'completed':
                continue
                
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
            
            if next_task:
                break
    
    if next_task:
        # 현재 작업 설정
        _context_manager.context['current_task'] = next_task['id']
        current_plan['current_phase'] = next_phase['id']
        next_task['status'] = 'in_progress'
        next_task['started_at'] = dt.datetime.now().isoformat()
        next_phase['status'] = 'in_progress'
        
        # 새 task 작업 추적 시작
        _context_manager.start_task_tracking(next_task['id'])
        
        current_plan['updated_at'] = dt.datetime.now().isoformat()
        
        # 진행률 업데이트
        _context_manager._update_progress()
        save_context()
        
        print(f"\n🎯 다음 작업: [{next_task['id']}] {next_task['title']}")
        if next_task['description']:
            print(f"   📝 설명: {next_task['description']}")
        print(f"   📍 Phase: {next_phase['name']}")
        
        # 서브태스크가 있으면 표시
        if next_task.get('subtasks'):
            print(f"\n   📌 서브태스크:")
            for subtask in next_task['subtasks']:
                print(f"      - {subtask}")
        
        print(f"\n💡 작업 추적이 시작되었습니다. 모든 파일 접근과 함수 수정이 자동으로 기록됩니다.")
    else:
        # 모든 작업 완료 확인
        all_done = True
        blocked_tasks = []
        
        for phase_id, phase in current_plan['phases'].items():
            for task in phase['tasks']:
                if task['status'] == 'blocked':
                    blocked_tasks.append(task)
                elif task['status'] != 'completed':
                    all_done = False
        
        if all_done and not blocked_tasks:
            print("\n🎉 모든 작업이 완료되었습니다!")
            
            # 모든 Phase도 완료로 표시
            for phase in current_plan['phases'].values():
                phase['status'] = 'completed'
            
            _context_manager._update_progress()
            save_context()
        else:
            if blocked_tasks:
                print(f"\n⚠️ 진행 가능한 작업이 없습니다. {len(blocked_tasks)}개의 작업이 blocked 상태입니다:")
                for task in blocked_tasks[:3]:
                    print(f"   - [{task['id']}] {task['title']}")
            else:
                print("\n⚠️ 진행 가능한 작업이 없습니다.")


def process_command(command: str, existing_context: Dict[str, Any] = None) -> Any:
    """명령어 처리
    
    Args:
        command: 처리할 명령어
        existing_context: 기존 context (execute_code 환경용)
        
    Returns:
        명령어 실행 결과
    """
    parts = command.strip().split()
    if not parts:
        return None
    
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    if cmd == '/flow':
        project_name = args[0] if args else None
        return cmd_flow(project_name, existing_context)
    
    elif cmd == '/plan':
        if len(args) == 0:
            return cmd_plan()
        elif len(args) == 1:
            return cmd_plan(args[0])
        else:
            # 첫 번째 인자는 계획명, 나머지는 설명
            return cmd_plan(args[0], ' '.join(args[1:]))
    
    elif cmd == '/task':
        if not args:
            print("사용법: /task add|edit|list [인자...]")
            return None
        return cmd_task(args[0], *args[1:])
    
    elif cmd == '/next':
        return cmd_next()
    
    elif cmd == '/save':
        return save_context()
    
    else:
        print(f"알 수 없는 명령어: {cmd}")
        print("사용 가능한 명령어: /flow, /plan, /task, /next, /save")
        return None


# ===========================================
# 메인 진입점
# ===========================================

if __name__ == "__main__":
    import sys
    
    # 인자가 있으면 명령어로 처리
    if len(sys.argv) > 1:
        command = ' '.join(sys.argv[1:])
        process_command(command)
    else:
        print("AI Coding Brain v6.3")
        print("사용법: python claude_code_ai_brain.py [명령어]")
        print("명령어: /flow, /plan, /task, /next, /save")
