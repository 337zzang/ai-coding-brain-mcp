"""
Auto-Tracking Wrapper v3.2 - 중앙화된 작업 추적 시스템
======================================================
이 모듈은 모든 핵심 헬퍼 함수들을 래핑(wrapping)하여,
함수 호출 시 자동으로 context_manager의 추적 함수를 호출합니다.

v3.2 개선사항:
- propose_next_steps 제거 (AI의 불필요한 개입 방지)
- 최종 13개의 핵심 함수만 유지
- 사용자 중심의 자연스러운 작업 흐름
"""
import functools
from typing import Callable, Any, Optional
import os
import sys
from pathlib import Path

# Add python directory to path
python_dir = Path(__file__).parent
if str(python_dir) not in sys.path:
    sys.path.insert(0, str(python_dir))

# ============================================================================
# 1. 원본 헬퍼 함수들을 임포트합니다.
# ============================================================================

# 파일 시스템 헬퍼들
from file_system_helpers import (
      create_file as original_create_file,
    read_file as original_read_file,
    backup_file as original_backup_file,
    restore_backup as original_restore_backup,
    find_blocks as original_find_blocks,
    replace_block as original_replace_block,
    insert_block as original_insert_block
)
# 검색 헬퍼들
from search_helpers import (
    scan_directory as original_scan_directory,
    search_files_advanced as original_search_files_advanced,
    search_code_content as original_search_code_content
)
from integrated_search import (
    integrated_search as original_integrated_search,
    search_by_date as original_search_by_date,
    search_by_file as original_search_by_file
)

  

# AST 파서 헬퍼들
from ast_parser_helpers import (
    parse_with_snippets as original_parse_with_snippets,
    get_snippet_preview as original_get_snippet_preview
)

# Context Manager 함수들 (선택적 래핑)
try:
    from context_manager import (
        initialize_context as original_initialize_context,
        save_context as original_save_context,
        update_cache as original_update_cache,
        get_work_tracking_summary as original_get_work_tracking_summary
    )
    CONTEXT_FUNCTIONS_AVAILABLE = True
except ImportError:
    CONTEXT_FUNCTIONS_AVAILABLE = False

# ============================================================================
# 2. 실제 추적 로직이 담긴 context_manager의 함수들을 임포트합니다.
# ============================================================================

try:
    from context_manager import (
        track_file_access, 
        track_function_edit
    )
    TRACKING_AVAILABLE = True
except ImportError:
    # context_manager가 없는 비상 상황을 위한 더미 함수
    def track_file_access(context, file_path, operation): pass
    def track_function_edit(context, file_path, func_name, class_name=None): pass
    TRACKING_AVAILABLE = False

# track_code_analysis와 analyze_and_cache_file은 별도로 정의
def track_code_analysis(context, file_path, analysis):
    """코드 분석 결과를 캐시에 저장"""
    if TRACKING_AVAILABLE and context:
        try:
            from context_manager import update_cache
            # analyzed_files 캐시 업데이트
            analyzed_files = context.get('cache', {}).get('analyzed_files', {})
            analyzed_files[file_path] = analysis
            update_cache('analyzed_files', analyzed_files)
        except:
            pass

def analyze_and_cache_file(file_path, language='auto'):
    """파일을 분석하고 캐시에 저장"""
    result = original_parse_with_snippets(file_path, language)
    
    # 성공한 경우 캐시 업데이트
    if result.get('parsing_success'):
        context = _get_project_context()
        if context:
            track_code_analysis(context, file_path, result)
    
    return result

# ============================================================================
# 3. 프로젝트 컨텍스트를 안전하게 가져오는 함수
# ============================================================================

def _get_project_context():
    """실행 컨텍스트에서 project_context를 안전하게 가져옵니다."""
    try:
        # JSON REPL 환경
        import builtins
        if hasattr(builtins, 'global_project_context'):
            return getattr(builtins, 'global_project_context')
        
        # 전역 변수에서 context 찾기
        if 'context' in globals():
            return globals()['context']
            
        # 일반 Python 환경
        frame = sys._getframe()
        while frame:
            if 'context' in frame.f_globals:
                return frame.f_globals['context']
            if 'project_context' in frame.f_globals:
                return frame.f_globals['project_context']
            frame = frame.f_back
        return None
    except:
        return None

# ============================================================================
# 4. 래퍼 함수 생성기 (Decorator)
# ============================================================================

def track_file_operation(operation_type: str) -> Callable:
    """파일 경로를 첫 번째 인자로 받는 함수를 위한 추적 데코레이터"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            context = _get_project_context()
            
            # 파일 경로 추출 (첫 번째 인자)
            file_path = args[0] if args else kwargs.get('file_path', None)
            
            # 함수 실행 전에 추적
            if context and TRACKING_AVAILABLE and file_path:
                try:
                    track_file_access(context, file_path, f"{func.__name__}_{operation_type}")
                except Exception:
                    pass  # 추적 실패해도 원본 함수는 실행
            
            # 원본 함수 실행
            result = func(*args, **kwargs)
            
            # 특정 작업의 경우 실행 후 추가 추적
            if operation_type == 'analyze' and context and TRACKING_AVAILABLE:
                try:
                    if isinstance(result, dict) and result.get('parsing_success'):
                        track_code_analysis(context, file_path, result)
                except Exception:
                    pass
                    
            return result
        return wrapper
    return decorator

def track_block_operation(operation_type: str) -> Callable:
    """블록(함수/클래스)을 다루는 함수를 위한 추적 데코레이터"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(file_path: str, block_name: str, *args, **kwargs) -> Any:
            context = _get_project_context()
            
            # 함수 실행 전에 추적
            if context and TRACKING_AVAILABLE:
                try:
                    track_function_edit(context, file_path, block_name, class_name=None)
                except Exception:
                    pass
            
            # 원본 함수 실행
            return func(file_path, block_name, *args, **kwargs)
        return wrapper
    return decorator

def track_context_operation(operation_type: str) -> Callable:
    """컨텍스트 관련 작업을 추적하는 데코레이터"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            # 컨텍스트 작업은 별도 추적 없이 실행
            # 나중에 필요시 추가 가능
            return func(*args, **kwargs)
        return wrapper
    return decorator

# ============================================================================
# 5. 래핑된 헬퍼 함수들을 정의하고 export 합니다.
# ============================================================================

# === 파일 시스템 함수들 ===

@track_file_operation('create')
def create_file(file_path: str, content: str = "") -> str:
    return original_create_file(file_path, content)

@track_file_operation('read')
def read_file(file_path: str) -> str:
    return original_read_file(file_path)

@track_file_operation('backup')
def backup_file(file_path: str, reason: str = "") -> str:
    return original_backup_file(file_path, reason)

@track_file_operation('restore')
def restore_backup(backup_path: str, target_path: str = None) -> str:
    return original_restore_backup(backup_path, target_path)


@track_block_operation('replace')
def replace_block(file_path: str, block_name: str, new_content: str) -> str:
    return original_replace_block(file_path, block_name, new_content)

@track_block_operation('insert')
def insert_block(file_path: str, target_block: str, position: str, new_content: str) -> str:
    return original_insert_block(file_path, target_block, position, new_content)

# === AST 분석 함수들 ===

def parse_with_snippets(file_path: str, language: str = 'auto') -> dict:
    """특별 처리: context_manager의 analyze_and_cache_file 사용"""
    if TRACKING_AVAILABLE:
        try:
            return analyze_and_cache_file(file_path, language)
        except:
            # 실패시 원본 함수 사용
            return original_parse_with_snippets(file_path, language)
    else:
        return original_parse_with_snippets(file_path, language)

@track_file_operation('preview')
def get_snippet_preview(file_path: str, element_name: str = None, element_type: str = None) -> str:
    return original_get_snippet_preview(file_path, element_name, element_type)

# === Context Manager 함수들 (선택적) ===

if CONTEXT_FUNCTIONS_AVAILABLE:
    @track_context_operation('init')
    def initialize_context(project_path: str, project_name: str) -> dict:
        return original_initialize_context(project_path, project_name)
    
    @track_context_operation('save')
    def save_context() -> None:
        return original_save_context()
    
    @track_context_operation('update')
    def update_cache(key: str, value: Any) -> None:
        return original_update_cache(key, value)
    
    @track_context_operation('summary')
    def get_work_tracking_summary(context: dict = None) -> str:
        return original_get_work_tracking_summary(context)

# ============================================================================
# 6. 공개할 함수 목록
# ============================================================================

# 기본 함수들 (항상 사용 가능)
__all__ = [
    # 파일 시스템 함수들
    'create_file', 
    'read_file', 
    'backup_file', 
    'restore_backup',
    'replace_block', 
    'insert_block',
    
    # AST 분석 함수들
    'parse_with_snippets', 
    'get_snippet_preview',
    'scan_directory',
    'search_files_advanced',
    'search_code_content',
    'integrated_search',
    'search_by_date',
    'search_by_file',
]

# Context Manager 함수들 추가 (사용 가능한 경우)
if CONTEXT_FUNCTIONS_AVAILABLE:
    __all__.extend([
        'initialize_context',
        'save_context', 
        'update_cache',
        'get_work_tracking_summary'
    ])

# ============================================================================
# 7. 디버그 정보
# ============================================================================

if __name__ != '__main__':
    print(f"✅ Auto-tracking wrapper v3.2 로드됨 - {len(__all__)}개 함수 래핑")
    if TRACKING_AVAILABLE:
        print("   • 작업 추적 활성화됨")
    else:
        print("   • 작업 추적 비활성화 (context_manager 없음)")


# === 검색 헬퍼 래퍼 함수들 ===

@track_file_operation('scan')
def scan_directory(path: str = '.', level: int = 1) -> list:
    """디렉토리 스캔 (추적 기능 포함)"""
    return original_scan_directory(path, level)

@track_file_operation('search')
def search_files_advanced(path: str = '.', pattern: str = '*',
                         recursive: bool = True, max_results: int = 100,
                         include_dirs: bool = False, 
                         project_context: Optional[dict] = None) -> dict:
    """고급 파일 검색 (추적 기능 포함)"""
    # Context 자동 전달
    if project_context is None and 'context' in globals():
        project_context = globals()['context']
    
    return original_search_files_advanced(
        path, pattern, recursive, max_results, 
        include_dirs, project_context
    )

@track_file_operation('search')
def search_code_content(path: str = '.', pattern: str = '',
                       file_pattern: str = '*', max_results: int = 50,
                       case_sensitive: bool = False, whole_word: bool = False,
                       project_context: Optional[dict] = None) -> dict:
    """코드 내용 검색 (추적 기능 포함)"""
    # Context 자동 전달
    if project_context is None and 'context' in globals():
        project_context = globals()['context']
    
    return original_search_code_content(
        path, pattern, file_pattern, max_results,
        case_sensitive, whole_word, project_context
    )

def integrated_search(query: str, search_type: str = 'all',
                     limit: int = 20,
                     project_context: Optional[dict] = None) -> dict:
    """통합 검색 (추적 기능 포함)"""
    # Context 자동 전달
    if project_context is None and 'context' in globals():
        project_context = globals()['context']
    
    # 검색 추적
    if TRACKING_AVAILABLE:
        track_operation('search', {
            'query': query,
            'search_type': search_type,
            'limit': limit
        })
    
    return original_integrated_search(query, search_type, limit, project_context)

def search_by_date(date_range: str, 
                  project_context: Optional[dict] = None) -> dict:
    """날짜 기반 검색 (추적 기능 포함)"""
    # Context 자동 전달
    if project_context is None and 'context' in globals():
        project_context = globals()['context']
    
    # 검색 추적
    if TRACKING_AVAILABLE:
        track_operation('search', {
            'type': 'by_date',
            'date_range': date_range
        })
    
    return original_search_by_date(date_range, project_context)

def search_by_file(file_pattern: str,
                  project_context: Optional[dict] = None) -> dict:
    """파일 패턴 기반 검색 (추적 기능 포함)"""
    # Context 자동 전달
    if project_context is None and 'context' in globals():
        project_context = globals()['context']
    
    # 검색 추적
    if TRACKING_AVAILABLE:
        track_operation('search', {
            'type': 'by_file',
            'file_pattern': file_pattern
        })
    
    return original_search_by_file(file_pattern, project_context)
