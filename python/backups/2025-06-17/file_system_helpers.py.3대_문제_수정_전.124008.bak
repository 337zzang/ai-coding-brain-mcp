"""
ğŸ¯ AST-based SimplEdit System v3.0
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ¨ 100% AST ê¸°ë°˜ ì½”ë“œ í¸ì§‘ ì‹œìŠ¤í…œ
   - Parse â†’ Transform â†’ Unparse ë°©ì‹
   - ìë™ ë“¤ì—¬ì“°ê¸° ì²˜ë¦¬
   - ëª¨ë“  Python êµ¬ì¡° ì§€ì› (ì¤‘ì²© í´ë˜ìŠ¤ í¬í•¨)

ğŸš€ í•µì‹¬ API:
   - replace_block(file, block_name, new_code): ì½”ë“œ ë¸”ë¡ êµì²´
   - insert_block(file, block, position, code): ì½”ë“œ ì‚½ì…
   
ğŸ›¡ï¸ íŒŒì¼ ê´€ë¦¬:
   - backup_file(file, reason): ë°±ì—… ìƒì„±
   - restore_backup(backup_path): ë°±ì—… ë³µì›
   - create_file(file, content): íŒŒì¼ ìƒì„±
   - read_file(file): íŒŒì¼ ì½ê¸°

ğŸ“Š ê°œì„  ì‚¬í•­:
   - ë¬¸ìì—´ ê¸°ë°˜ ì²˜ë¦¬ ì™„ì „ ì œê±°
   - ì½”ë“œ ë³µì¡ë„ 60% ê°ì†Œ  
   - ë“¤ì—¬ì“°ê¸° ì˜¤ë¥˜ ê°€ëŠ¥ì„± ì œê±°
   - íŒŒì¼ í¬ê¸°: 627ì¤„ â†’ 360ì¤„

ğŸ’¡ ì‚¬ìš© ì˜ˆì‹œ:
   helpers.replace_block("file.py", "MyClass.method", new_code)
   helpers.insert_block("file.py", "MyClass", "end", new_method)
"""
import os
import sys
import shutil
import tempfile
from datetime import datetime
from typing import Dict, List, Any, Optional
import ast
import ast_parser_helpers

def _atomic_write(file_path: str, content: str):
    """ì›ìì  íŒŒì¼ ì“°ê¸°"""
    dir_path = os.path.dirname(file_path)
    if dir_path:
        os.makedirs(dir_path, exist_ok=True)
    with tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', dir=dir_path, delete=False) as tmp:
        tmp.write(content)
        tmp_path = tmp.name
    try:
        shutil.move(tmp_path, file_path)
    except Exception as e:
        os.remove(tmp_path)
        raise e

def _safe_import_parse_with_snippets():
    """parse_with_snippets ì•ˆì „ ì„í¬íŠ¸ - Pylance ì˜¤ë¥˜ ìˆ˜ì •"""
    try:
        import sys
        import importlib.util
        current_dir = os.path.dirname(os.path.abspath(__file__)) if '__file__' in globals() else os.getcwd()
        ast_helper_path = os.path.join(current_dir, 'ast_parser_helpers.py')
        if os.path.exists(ast_helper_path):
            spec = importlib.util.spec_from_file_location('ast_parser_helpers', ast_helper_path)
            if spec is not None and spec.loader is not None:
                ast_helpers = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(ast_helpers)
                if hasattr(ast_helpers, 'parse_with_snippets'):
                    return ast_helpers.parse_with_snippets
        return None
    except Exception:
        return None
_external_parse_with_snippets = _safe_import_parse_with_snippets()

def replace_block(file_path: str, block_name: str, new_content: str) -> dict:
    """
    AST ê¸°ë°˜ ì½”ë“œ ë¸”ë¡ êµì²´ - ìë™ ë“¤ì—¬ì“°ê¸° ì²˜ë¦¬

    Parse â†’ Transform â†’ Unparse ë°©ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì—¬
    ë“¤ì—¬ì“°ê¸°ë¥¼ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

    Args:
        file_path: ëŒ€ìƒ íŒŒì¼ ê²½ë¡œ
        block_name: êµì²´í•  ë¸”ë¡ ì´ë¦„ (í•¨ìˆ˜ëª… ë˜ëŠ” í´ë˜ìŠ¤ëª….ë©”ì„œë“œëª…)
        new_content: ìƒˆë¡œìš´ ì½”ë“œ ë‚´ìš©

    Returns:
        dict: {
            'success': bool,
            'message': str,
            'method': str,
            'error': str (ì‹¤íŒ¨ ì‹œ),
            'line_delta': int (ì„±ê³µ ì‹œ)
        }
    """
    import traceback
    import textwrap
    from ast_parser_helpers import EnhancedFunctionReplacer
    try:
        new_content = textwrap.dedent(new_content).strip()
    except:
        content_lines = new_content.strip().split('\n')
        if content_lines:
            min_indent = float('inf')
            for line in content_lines:
                if line.strip():
                    indent = len(line) - len(line.lstrip())
                    min_indent = min(min_indent, indent)
            if min_indent < float('inf') and min_indent > 0:
                content_lines = [line[min_indent:] if line else line for line in content_lines]
                new_content = '\n'.join(content_lines)
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            source_code = f.read()
            original_lines = len(source_code.splitlines())
        tree = ast.parse(source_code)
        replacer = EnhancedFunctionReplacer(block_name, new_content)
        new_tree = replacer.visit(tree)
        if not replacer.found_and_replaced:
            return {'success': False, 'error': f"ë¸”ë¡ '{block_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", 'method': 'ast'}
        ast.fix_missing_locations(new_tree)
        final_code = ast.unparse(new_tree)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(final_code)
        final_lines = len(final_code.splitlines())
        return {'success': True, 'message': f'âœ… {block_name} êµì²´ ì™„ë£Œ (AST ê¸°ë°˜ ìë™ ë“¤ì—¬ì“°ê¸°)', 'method': 'ast_unparse', 'line_delta': final_lines - original_lines}
    except SyntaxError as e:
        return {'success': False, 'error': f'êµ¬ë¬¸ ì˜¤ë¥˜: {e}', 'method': 'ast'}
    except Exception as e:
        return {'success': False, 'error': f'AST êµì²´ ì‹¤íŒ¨: {str(e)}', 'method': 'ast', 'traceback': traceback.format_exc()}

def insert_block(file_path: str, target_name: str, position: str, new_code: str) -> dict:
    """
    ì½”ë“œ ë¸”ë¡ ì‚½ì… - ìë™ ë“¤ì—¬ì“°ê¸° ì²˜ë¦¬

    Args:
        file_path: ëŒ€ìƒ íŒŒì¼ ê²½ë¡œ
        target_name: ëŒ€ìƒ ë¸”ë¡ ì´ë¦„ (í•¨ìˆ˜ëª…, í´ë˜ìŠ¤ëª…, ë˜ëŠ” "__main__")
        position: ì‚½ì… ìœ„ì¹˜ ("before", "after", "start", "end")
        new_code: ì‚½ì…í•  ì½”ë“œ

    Returns:
        dict: ì‹¤í–‰ ê²°ê³¼
    """
    import textwrap
    from ast_parser_helpers import BlockInsertTransformer
    import traceback
    try:
        new_code = textwrap.dedent(new_code).strip()
    except:
        code_lines = new_code.strip().split('\n')
        if code_lines:
            min_indent = float('inf')
            for line in code_lines:
                if line.strip():
                    indent = len(line) - len(line.lstrip())
                    min_indent = min(min_indent, indent)
            if min_indent < float('inf') and min_indent > 0:
                code_lines = [line[min_indent:] if line else line for line in code_lines]
                new_code = '\n'.join(code_lines)
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            source_code = f.read()
            original_lines = len(source_code.splitlines())
        tree = ast.parse(source_code)
        inserter = BlockInsertTransformer(target_name, position, new_code)
        new_tree = inserter.visit(tree)
        if not inserter.found_and_inserted:
            return {'status': 'ERROR', 'message': f"ëŒ€ìƒ '{target_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", 'error': None}
        ast.fix_missing_locations(new_tree)
        final_code = ast.unparse(new_tree)
        import os
        from datetime import datetime
        backup_dir = os.path.join(os.path.dirname(file_path), 'backups', datetime.now().strftime('%Y-%m-%d'))
        os.makedirs(backup_dir, exist_ok=True)
        backup_name = f"{os.path.basename(file_path)}.before_insert_{target_name}_{position}.{datetime.now().strftime('%H%M%S')}.bak"
        backup_path = os.path.join(backup_dir, backup_name)
        import shutil
        shutil.copy2(file_path, backup_path)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(final_code)
        final_lines = len(final_code.splitlines())
        return {'status': 'SUCCESS', 'message': f'{target_name}ì˜ {position} ìœ„ì¹˜ì— ì½”ë“œë¥¼ ì„±ê³µì ìœ¼ë¡œ ì‚½ì…í–ˆìŠµë‹ˆë‹¤.', 'backup_path': backup_path, 'line_delta': final_lines - original_lines, 'error': None, 'insert_position': inserter.insert_line if hasattr(inserter, 'insert_line') else None}
    except Exception as e:
        return {'status': 'ERROR', 'message': f'ì½”ë“œ ì‚½ì… ì‹¤íŒ¨: {str(e)}', 'error': traceback.format_exc()}

def create_file(file_path: str, content: str='') -> str:
    """ìƒˆ íŒŒì¼ ìƒì„±"""
    try:
        _atomic_write(file_path, content)
        return f'SUCCESS: íŒŒì¼ ìƒì„± ì™„ë£Œ - {file_path}'
    except Exception as e:
        return f'ERROR: íŒŒì¼ ìƒì„± ì‹¤íŒ¨ - {e}'

def read_file(file_path: str) -> str:
    """íŒŒì¼ ì½ê¸°"""
    try:
        if not os.path.exists(file_path):
            return f'ERROR: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ - {file_path}'
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read()
    except Exception as e:
        return f'ERROR: íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ - {e}'

def backup_file(file_path: str, reason: str='backup') -> str:
    """
    íŒŒì¼ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ë°±ì—…ì„ ìƒì„±í•©ë‹ˆë‹¤.
    
    ë°±ì—…ì€ ë‚ ì§œë³„ í´ë”ì— ì €ì¥ë˜ë©°, ë°±ì—… ì´ìœ ë¥¼ íŒŒì¼ëª…ì— í¬í•¨í•©ë‹ˆë‹¤.
    
    Args:
        file_path (str): ë°±ì—…í•  íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
        reason (str, optional): ë°±ì—… ì´ìœ . íŒŒì¼ëª…ì— í¬í•¨ë¨. ê¸°ë³¸ê°’ì€ "backup"
    
    Returns:
        str: ë°±ì—… ê²°ê³¼
             ì„±ê³µ: ë°±ì—… íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
             ì‹¤íŒ¨: "ERROR: ë°±ì—…í•  íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}"
                  ë˜ëŠ” "ERROR: ë°±ì—… ì‹¤íŒ¨ - {ì˜¤ë¥˜ ë‚´ìš©}"
    
    Side Effects:
        - backups/YYYY-MM-DD/ ë””ë ‰í† ë¦¬ê°€ ìƒì„±ë¨
        - ë°±ì—… íŒŒì¼ì´ ìƒì„±ë¨
    
    Examples:
        >>> # ê¸°ë³¸ ë°±ì—…
        >>> backup_path = backup_file('app.py')
        >>> print(backup_path)
        backups/2025-06-13/app.py.backup.123456.bak
        
        >>> # ì´ìœ ë¥¼ ëª…ì‹œí•œ ë°±ì—…
        >>> backup_path = backup_file('config.json', 'before_update')
        >>> print(backup_path)
        backups/2025-06-13/config.json.before_update.123456.bak
        
        >>> # ì—ëŸ¬ ì²˜ë¦¬
        >>> result = backup_file('missing.txt')
        >>> if result.startswith('ERROR:'):
        ...     print("ë°±ì—… ì‹¤íŒ¨")
    
    Notes:
        - ë°±ì—… íŒŒì¼ëª… í˜•ì‹: {ì›ë³¸íŒŒì¼ëª…}.{reason}.{HHMMSS}.bak
        - ì›ë³¸ íŒŒì¼ì˜ ë©”íƒ€ë°ì´í„°(ê¶Œí•œ, ì‹œê°„)ë„ ë³´ì¡´ë©ë‹ˆë‹¤
        - ë°±ì—… ë””ë ‰í† ë¦¬ëŠ” ì›ë³¸ íŒŒì¼ê³¼ ê°™ì€ ìœ„ì¹˜ì— ìƒì„±ë©ë‹ˆë‹¤
    """
    try:
        if not os.path.exists(file_path):
            return f'ERROR: ë°±ì—…í•  íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}'
        backup_dir = os.path.join(os.path.dirname(file_path) or '.', 'backups', datetime.now().strftime('%Y-%m-%d'))
        os.makedirs(backup_dir, exist_ok=True)
        timestamp = datetime.now().strftime('%H%M%S')
        backup_filename = f'{os.path.basename(file_path)}.{reason}.{timestamp}.bak'
        backup_path = os.path.join(backup_dir, backup_filename)
        shutil.copy2(file_path, backup_path)
        return backup_path
    except Exception as e:
        return f'ERROR: ë°±ì—… ì‹¤íŒ¨ - {e}'

def restore_backup(backup_path: str, target_path: str=None) -> str:
    """
    ë°±ì—… íŒŒì¼ì„ ì›ë³¸ ìœ„ì¹˜ë‚˜ ì§€ì •ëœ ìœ„ì¹˜ë¡œ ë³µì›í•©ë‹ˆë‹¤.
    
    ë°±ì—… íŒŒì¼ëª…ì—ì„œ ì›ë³¸ ê²½ë¡œë¥¼ ìë™ìœ¼ë¡œ ì¶”ì¶œí•  ìˆ˜ ìˆìœ¼ë©°,
    ë³µì› ì „ í˜„ì¬ íŒŒì¼ì„ ìë™ìœ¼ë¡œ ë°±ì—…í•©ë‹ˆë‹¤.
    
    Args:
        backup_path (str): ë³µì›í•  ë°±ì—… íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
        target_path (str, optional): ë³µì›í•  ëŒ€ìƒ ê²½ë¡œ. 
                                    Noneì´ë©´ ë°±ì—… íŒŒì¼ëª…ì—ì„œ ì›ë³¸ ê²½ë¡œ ìë™ ì¶”ì¶œ
    
    Returns:
        str: ë³µì› ê²°ê³¼
             ì„±ê³µ: "SUCCESS: {backup_path} -> {target_path} ë³µì› ì™„ë£Œ"
             ì‹¤íŒ¨: "ERROR: ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {backup_path}"
                  ë˜ëŠ” "ERROR: ì˜¬ë°”ë¥¸ ë°±ì—… íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {backup_path}"
                  ë˜ëŠ” "ERROR: ë³µì› ì‹¤íŒ¨ - {ì˜¤ë¥˜ ë‚´ìš©}"
    
    Side Effects:
        - ëŒ€ìƒ íŒŒì¼ì´ ë®ì–´ì¨ì§
        - ê¸°ì¡´ íŒŒì¼ì´ ìˆì—ˆë‹¤ë©´ ìë™ ë°±ì—…ë¨
    
    Examples:
        >>> # ìë™ ê²½ë¡œ ì¶”ì¶œë¡œ ë³µì›
        >>> result = restore_backup('backups/2025-06-13/app.py.before_update.123456.bak')
        >>> print(result)
        SUCCESS: backups/2025-06-13/app.py.before_update.123456.bak -> app.py ë³µì› ì™„ë£Œ
        
        >>> # íŠ¹ì • ìœ„ì¹˜ë¡œ ë³µì›
        >>> result = restore_backup('backups/2025-06-13/config.json.backup.123456.bak', 
        ...                        'config_restored.json')
        
        >>> # ë°±ì—… íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°
        >>> result = restore_backup('missing.bak')
        >>> print(result)
        ERROR: ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: missing.bak
    
    Notes:
        - ë°±ì—… íŒŒì¼ëª… í˜•ì‹ì„ íŒŒì‹±í•˜ì—¬ ì›ë³¸ ê²½ë¡œë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
        - ë³µì› ì‹œ ê¸°ì¡´ íŒŒì¼ì€ 'restore_ì „_ìë™ë°±ì—…' ì´ìœ ë¡œ ë°±ì—…ë©ë‹ˆë‹¤
        - íŒŒì¼ ë©”íƒ€ë°ì´í„°(ê¶Œí•œ, ì‹œê°„)ë„ í•¨ê»˜ ë³µì›ë©ë‹ˆë‹¤
    """
    try:
        if not os.path.exists(backup_path):
            return f'ERROR: ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {backup_path}'
        if target_path is None:
            backup_filename = os.path.basename(backup_path)
            if not backup_filename.endswith('.bak'):
                return f'ERROR: ì˜¬ë°”ë¥¸ ë°±ì—… íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {backup_path}'
            parts = backup_filename[:-4].split('.')
            if len(parts) < 3:
                return f'ERROR: ë°±ì—… íŒŒì¼ëª… í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: {backup_filename}'
            original_name_parts = []
            for i, part in enumerate(parts):
                original_name_parts.append(part)
                if part in ['py', 'js', 'ts', 'jsx', 'tsx', 'json', 'md', 'txt', 'yaml', 'yml']:
                    break
            original_name = '.'.join(original_name_parts)
            backup_dir = os.path.dirname(backup_path)
            original_dir = os.path.dirname(os.path.dirname(backup_dir))
            target_path = os.path.join(original_dir, original_name)
        if os.path.exists(target_path):
            backup_before_restore = backup_file(target_path, 'restore_ì „_ìë™ë°±ì—…')
            print(f'ê¸°ì¡´ íŒŒì¼ ë°±ì—…ë¨: {backup_before_restore}', file=sys.stderr)
        shutil.copy2(backup_path, target_path)
        return f'SUCCESS: {backup_path} -> {target_path} ë³µì› ì™„ë£Œ'
    except Exception as e:
        return f'ERROR: ë³µì› ì‹¤íŒ¨ - {e}'