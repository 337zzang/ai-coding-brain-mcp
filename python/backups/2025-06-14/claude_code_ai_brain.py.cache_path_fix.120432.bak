#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  AI Coding Brain - í†µí•© ë²„ì „ v6.1
==========================================

claude_code_ai_brain.pyì™€ context_manager.pyë¥¼ í†µí•©í•œ ë‹¨ì¼ íŒŒì¼.
í•µì‹¬ ê¸°ëŠ¥ë§Œ ìœ ì§€í•˜ê³  ê°„ì†Œí™”í•¨.

ì£¼ìš” ê¸°ëŠ¥:
- /flow ëª…ë ¹ì–´ë¡œ í”„ë¡œì íŠ¸ ì „í™˜
- ë©”ëª¨ë¦¬ ë£¨íŠ¸ì— ìºì‹œ ì¤‘ì•™ ì €ì¥
- í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‘ì—… ìˆ˜í–‰
- ì‘ì—… ì¶”ì  ë° ì‹¬ë³¼ ì¸ë±ì‹±
- ì‹±ê¸€í†¤ íŒ¨í„´ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬

v6.1 ë³€ê²½ì‚¬í•­:
- ìºì‹œë¥¼ ë©”ëª¨ë¦¬ ë£¨íŠ¸ì— ì¤‘ì•™ ì €ì¥
- ì‘ì—…ì€ í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ìˆ˜í–‰

ì‘ì„±ì¼: 2025-06-14
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List
from collections import defaultdict
import copy

# ===========================================
# í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================

class UnifiedContextManager:
    """í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì - ì‹±ê¸€í†¤ íŒ¨í„´"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None  # ìºì‹œ ì €ì¥ ìœ„ì¹˜
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str, memory_root: str = None) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
        self.project_path = project_path
        self.project_name = project_name
        
        # ë©”ëª¨ë¦¬ ë£¨íŠ¸ ì„¤ì • (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
        if memory_root:
            self.memory_root = memory_root
        else:
            # ê¸°ë³¸ê°’: í™ˆ/Desktop/memory
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„
        cached_context = self._try_load_cached_context()
        if cached_context:
            self.context = cached_context
            print(f"âœ… ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ: {project_name}")
        else:
            self.context = self._create_new_context()
            print(f"âœ… ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±: {project_name}")
        
        # êµ¬ì¡° ì •ê·œí™”
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_path(self) -> str:
        """ìºì‹œ íŒŒì¼ ê²½ë¡œ ë°˜í™˜ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ ê¸°ì¤€)"""
        cache_dir = os.path.join(self.memory_root, '.cache', self.project_name)
        os.makedirs(cache_dir, exist_ok=True)
        return os.path.join(cache_dir, 'cache.json')
    
    def _create_new_context(self) -> Dict[str, Any]:
        """ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        return {
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '6.1',
            
            # ìºì‹œ êµ¬ì¡°
            'cache': {
                'analyzed_files': {},
                'symbol_index': {},
                'work_tracking': {
                    'file_access': {},
                    'file_edits': {},
                    'function_edits': {},
                    'session_start': dt.datetime.now().isoformat(),
                    'total_operations': 0
                }
            },
            
            # ì‘ì—… ê´€ë¦¬
            'tasks': {'next': [], 'done': []},
            'current_focus': '',
            
            # AI í•™ìŠµ ë°ì´í„°
            'coding_experiences': []
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì—ì„œ)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_file = self._get_cache_file_path()
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    loaded_context = json.load(f)
                
                # í”„ë¡œì íŠ¸ ê²½ë¡œ ì—…ë°ì´íŠ¸ (ê²½ë¡œê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
                loaded_context['project_path'] = self.project_path
                loaded_context['memory_root'] = self.memory_root
                
                return loaded_context
            except Exception as e:
                print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
        return None
    
    def _normalize_context_structure(self):
        """ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ì •ê·œí™”"""
        if not self.context:
            return
            
        # í•„ìˆ˜ í‚¤ í™•ì¸
        self.context.setdefault('cache', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        
        # ê²½ë¡œ ì •ë³´ ì—…ë°ì´íŠ¸
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root
        
        # ìºì‹œ êµ¬ì¡° í™•ì¸
        cache = self.context['cache']
        cache.setdefault('analyzed_files', {})
        cache.setdefault('symbol_index', {})
        
        # work_tracking êµ¬ì¡°
        work_tracking = cache.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
    
    def save(self) -> bool:
        """ì»¨í…ìŠ¤íŠ¸ ì €ì¥ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì—)"""
        if not self.context:
            print("âš ï¸ ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        try:
            # ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
            self.context['updated_at'] = dt.datetime.now().isoformat()
            
            # ìºì‹œ íŒŒì¼ ê²½ë¡œ
            cache_file = self._get_cache_file_path()
            
            # JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜
            serializable_context = self._prepare_serializable_context()
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… ìºì‹œ ì €ì¥: {cache_file}")
            return True
            
        except Exception as e:
            print(f"âŒ ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜"""
        def convert(obj):
            if isinstance(obj, defaultdict):
                return dict(obj)
            elif isinstance(obj, set):
                return list(obj)
            elif isinstance(obj, (dt.datetime, dt.date)):
                return obj.isoformat()
            elif isinstance(obj, dict):
                return {k: convert(v) for k, v in obj.items()}
            elif isinstance(obj, (list, tuple)):
                return [convert(item) for item in obj]
            else:
                return obj
        
        return convert(self.context)
    
    # ===========================================
    # ìºì‹œ ê´€ë¦¬ ë©”ì„œë“œ
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """ìºì‹œ ì—…ë°ì´íŠ¸ (ì¤‘ì²© í‚¤ ì§€ì›)"""
        if not self.context:
            return
        
        cache = self.context.setdefault('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """ìºì‹œ ê°’ ì¡°íšŒ"""
        if not self.context:
            return default
        
        cache = self.context.get('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # ì‹¬ë³¼ ë° ì‘ì—… ì¶”ì 
    # ===========================================
    
    def find_symbol(self, symbol_name: str) -> Optional[Dict[str, Any]]:
        """ì‹¬ë³¼ ê²€ìƒ‰"""
        if not self.context:
            return None
        
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        return symbol_index.get(symbol_name)
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        file_access[file_path] = file_access.get(file_path, 0) + 1
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        # í•¨ìˆ˜ í‚¤ ìƒì„±
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        # í¸ì§‘ ì •ë³´ ì—…ë°ì´íŠ¸
        if func_key not in function_edits:
            function_edits[func_key] = {'count': 0, 'operations': []}
        
        function_edits[func_key]['count'] += 1
        function_edits[func_key]['operations'].append({
            'timestamp': dt.datetime.now().isoformat(),
            'file': file_path
        })
        
        # íŒŒì¼ í¸ì§‘ë„ ì¶”ì 
        file_edits = work_tracking.setdefault('file_edits', {})
        file_edits[file_path] = file_edits.get(file_path, 0) + 1
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
    
    def get_work_tracking_summary(self) -> str:
        """ì‘ì—… ì¶”ì  ìš”ì•½"""
        if not self.context:
            return "ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # ì„¸ì…˜ ì‹œê°„ ê³„ì‚°
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        # í†µê³„ ìˆ˜ì§‘
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        
        # ìš”ì•½ ìƒì„±
        summary = f"""
ğŸ“Š ì‘ì—… ì¶”ì  ìš”ì•½
================
â€¢ í”„ë¡œì íŠ¸: {self.project_name}
â€¢ ì‘ì—… ê²½ë¡œ: {self.project_path}
â€¢ ìºì‹œ ê²½ë¡œ: {self.memory_root}
â€¢ ì„¸ì…˜ ì‹œê°„: {duration_str}
â€¢ ì „ì²´ ì‘ì—…: {total_ops}íšŒ
â€¢ ì ‘ê·¼í•œ íŒŒì¼: {len(file_access)}ê°œ
â€¢ ìˆ˜ì •í•œ íŒŒì¼: {len(file_edits)}ê°œ
â€¢ ìˆ˜ì •í•œ í•¨ìˆ˜: {len(function_edits)}ê°œ
"""
        
        # Top 5 íŒŒì¼
        if file_access:
            summary += "\nğŸ”¥ ê°€ì¥ ë§ì´ ì ‘ê·¼í•œ íŒŒì¼:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:5]
            for file_path, count in sorted_files:
                summary += f"  â€¢ {file_path}: {count}íšŒ\n"
        
        # Top 5 í•¨ìˆ˜
        if function_edits:
            summary += "\nâœï¸ ê°€ì¥ ë§ì´ ìˆ˜ì •í•œ í•¨ìˆ˜:\n"
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1]['count'], reverse=True)[:5]
            for func_name, info in sorted_funcs:
                summary += f"  â€¢ {func_name}: {info['count']}íšŒ\n"
        
        return summary


# ===========================================
# ê¸€ë¡œë²Œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str, memory_root: str = None) -> Dict[str, Any]:
    """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
    return _context_manager.initialize(project_path, project_name, memory_root)

def save_context() -> bool:
    """ì»¨í…ìŠ¤íŠ¸ ì €ì¥"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """ìºì‹œ ì—…ë°ì´íŠ¸"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """ìºì‹œ ê°’ ì¡°íšŒ"""
    return _context_manager.get_value(key, default)

def find_symbol(symbol_name: str) -> Optional[Dict[str, Any]]:
    """ì‹¬ë³¼ ì°¾ê¸°"""
    return _context_manager.find_symbol(symbol_name)

def track_file_access(file_path: str, operation: str = 'read'):
    """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """ì‘ì—… ì¶”ì  ìš”ì•½"""
    return _context_manager.get_work_tracking_summary()


# ===========================================
# Claude Desktop ì„¤ì • ë° ëª…ë ¹ì–´ ì²˜ë¦¬
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop ì„¤ì •ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_root': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_root'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"âš ï¸ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    return paths


def cmd_flow(project_name: str = None) -> None:
    """/flow ëª…ë ¹ì–´ - í”„ë¡œì íŠ¸ ì „í™˜"""
    
    if not project_name:
        # í˜„ì¬ ìƒíƒœ í‘œì‹œ
        if _context_manager.project_name:
            print(f"\nğŸ”¥ í˜„ì¬ í”„ë¡œì íŠ¸: {_context_manager.project_name}")
            print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {_context_manager.project_path}")
            print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {_context_manager.memory_root}")
            print(get_work_tracking_summary())
        else:
            print("\nâš ï¸ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            print("ì‚¬ìš©ë²•: /flow [í”„ë¡œì íŠ¸ëª…]")
        return
    
    # ì´ì „ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
    if _context_manager.context:
        save_context()
    
    # ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    # í”„ë¡œì íŠ¸ ê²½ë¡œ ì°¾ê¸° (ë©”ëª¨ë¦¬ ìš°ì„ , ê·¸ ë‹¤ìŒ í”„ë¡œì íŠ¸ ë£¨íŠ¸)
    project_path = paths['memory_root'] / project_name
    location = 'memory'
    
    if not project_path.exists():
        # í”„ë¡œì íŠ¸ ë£¨íŠ¸ í™•ì¸
        project_path = paths['project_root'] / project_name
        location = 'project'
        
        if not project_path.exists():
            print(f"\nâŒ í”„ë¡œì íŠ¸ '{project_name}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            print(f"   â€¢ ë©”ëª¨ë¦¬: {paths['memory_root'] / project_name}")
            print(f"   â€¢ í”„ë¡œì íŠ¸: {paths['project_root'] / project_name}")
            return
    
    # ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½ (ì½”ë“œ ì‘ì—…ì„ ìœ„í•´)
    os.chdir(project_path)
    
    # Context ì´ˆê¸°í™” (ë©”ëª¨ë¦¬ ë£¨íŠ¸ ì „ë‹¬)
    context = initialize_context(str(project_path), project_name, memory_root)
    
    print(f"\nâœ… í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì™„ë£Œ!")
    print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {project_path} ({location}_root)")
    print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {memory_root}/.cache/{project_name}/")
    print(f"ğŸ“Š ìºì‹œ ë²„ì „: {context.get('version', 'Unknown')}")
    
    # ê°„ë‹¨í•œ í†µê³„ í‘œì‹œ
    analyzed_files = context.get('cache', {}).get('analyzed_files', {})
    tasks = context.get('tasks', {})
    print(f"ğŸ“ˆ ë¶„ì„ëœ íŒŒì¼: {len(analyzed_files)}ê°œ")
    print(f"ğŸ“‹ ë‚¨ì€ ì‘ì—…: {len(tasks.get('next', []))}ê°œ")
    print(f"âœ… ì™„ë£Œëœ ì‘ì—…: {len(tasks.get('done', []))}ê°œ")


# ===========================================
# ë©”ì¸ ì§„ì…ì 
# ===========================================

def process_command(command: str, *args):
    """ëª…ë ¹ì–´ ì²˜ë¦¬"""
    if command == '/flow':
        return cmd_flow(args[0] if args else None)
    elif command == '/save':
        return save_context()
    elif command == '/summary':
        return get_work_tracking_summary()
    return f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {command}"


if __name__ == "__main__":
    print("ğŸ§  AI Coding Brain v6.1 (í†µí•© ë²„ì „) ì¤€ë¹„ ì™„ë£Œ!")
    print("ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´:")
    print("  â€¢ /flow [í”„ë¡œì íŠ¸ëª…] - í”„ë¡œì íŠ¸ ì „í™˜")
    print("  â€¢ /save - ì»¨í…ìŠ¤íŠ¸ ì €ì¥")
    print("  â€¢ /summary - ì‘ì—… ìš”ì•½ ë³´ê¸°")
