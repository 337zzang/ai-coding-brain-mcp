#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  AI Coding Brain ì‹œìŠ¤í…œ v3.0 - í†µí•© ì§€ëŠ¥í˜• ê°œë°œ í™˜ê²½
=====================================================

Claude Desktop execute_code í™˜ê²½ì„ ìœ„í•œ ì™„ì „ í†µí•© AI ë¸Œë ˆì¸ ì‹œìŠ¤í…œ

v3.0 ì£¼ìš” íŠ¹ì§•:
- UnifiedContextManagerì™€ VibeMemoryManager ì™„ì „ í†µí•©
- ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ì•ˆì •ì ì¸ ì¸ìŠ¤í„´ìŠ¤ ê´€ë¦¬
- ìë™ ì„¸ì…˜ ë³µì› ë° ì§€ì†ì„±
- ì§€ëŠ¥í˜• ì½”ë“œ ë¶„ì„ ë° ì¶”ì 
- í†µí•© ë©”ëª¨ë¦¬ ë±…í¬ ì‹œìŠ¤í…œ

ì‘ì„±ì: Claude + ì‚¬ìš©ì í˜‘ì—…
ìƒì„±ì¼: 2025-06-04
ìˆ˜ì •ì¼: 2025-06-13 (v3.0 - ì™„ì „ í†µí•© êµ¬ì¡°)
"""

import os
import json
import logging
import datetime as dt
from pathlib import Path
from typing import Union, Optional, Dict, Any, List, Callable
import sys
import traceback
from collections import defaultdict

# ============================================
# ë¡œê¹… ì„¤ì •
# ============================================
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s %(asctime)s] %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# ============================================
# ëª¨ë“ˆ ì„í¬íŠ¸ ë° ì´ˆê¸°í™”
# ============================================

# 1. Auto-tracking wrapper
try:
    from auto_tracking_wrapper import *
    logger.info("âœ… ìë™ ì¶”ì  ë˜í¼ ë¡œë“œ - ëª¨ë“  íŒŒì¼ ì‘ì—…ì´ ìë™ìœ¼ë¡œ ì¶”ì ë©ë‹ˆë‹¤")
    AUTO_TRACKING_ENABLED = True
except ImportError:
    logger.warning("âš ï¸ ìë™ ì¶”ì  ë˜í¼ ë¡œë“œ ì‹¤íŒ¨ - ì›ë³¸ ëª¨ë“ˆ ì‚¬ìš©")
    from file_system_helpers import *
    from ast_parser_helpers import *
    AUTO_TRACKING_ENABLED = False

# 2. Context Manager v3.0
try:
    from context_manager import (
        initialize_context,
        save_context,
        update_cache,
        get_value,
        find_symbol,
        track_file_access,
        track_function_edit,
        get_work_tracking_summary,
        build_index,
        propose_next_steps
    )
    CONTEXT_MANAGER_AVAILABLE = True
    logger.info("âœ… Context Manager v3.0 ë¡œë“œ ì™„ë£Œ")
except ImportError as e:
    CONTEXT_MANAGER_AVAILABLE = False
    logger.error(f"âŒ Context Manager ë¡œë“œ ì‹¤íŒ¨: {e}")

# 3. Vibe Memory System
try:
    from vibe_memory_system import VibeMemoryManager, get_vibe_commands
    VIBE_MEMORY_AVAILABLE = True
    logger.info("âœ… Vibe Memory System ë¡œë“œ ì™„ë£Œ")
except ImportError as e:
    VIBE_MEMORY_AVAILABLE = False
    logger.warning(f"âš ï¸ Vibe Memory System ë¡œë“œ ì‹¤íŒ¨: {e}")

# ============================================
# ê¸€ë¡œë²Œ ìƒíƒœ ê´€ë¦¬
# ============================================
class GlobalState:
    """ê¸€ë¡œë²Œ ìƒíƒœ ê´€ë¦¬ ì‹±ê¸€í†¤"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialized = False
        return cls._instance
    
    def __init__(self):
        if not self.initialized:
            self.context: Optional[Dict[str, Any]] = None
            self.project_path: Optional[str] = None
            self.project_name: Optional[str] = None
            self.session_start: dt.datetime = dt.datetime.now()
            self.initialized: bool = True

_global_state = GlobalState()

# ============================================
# í•µì‹¬ í—¬í¼ í•¨ìˆ˜
# ============================================

def initialize_ai_brain(project_path: str = None, project_name: str = None) -> Dict[str, Any]:
    """
    AI Brain ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    
    Args:
        project_path: í”„ë¡œì íŠ¸ ê²½ë¡œ (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)
        project_name: í”„ë¡œì íŠ¸ ì´ë¦„ (ê¸°ë³¸ê°’: ë””ë ‰í† ë¦¬ ì´ë¦„)
    
    Returns:
        ì´ˆê¸°í™”ëœ ì»¨í…ìŠ¤íŠ¸
    """
    global _global_state
    
    # ê¸°ë³¸ê°’ ì„¤ì •
    if project_path is None:
        project_path = os.getcwd()
    if project_name is None:
        project_name = os.path.basename(project_path)
    
    _global_state.project_path = project_path
    _global_state.project_name = project_name
    
    logger.info(f"ğŸš€ AI Brain ì´ˆê¸°í™” ì‹œì‘: {project_name}")
    
    # Context Manager ì´ˆê¸°í™”
    if CONTEXT_MANAGER_AVAILABLE:
        try:
            _global_state.context = initialize_context(project_path, project_name)
            logger.info("âœ… Context Manager ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ì´ˆê¸° í†µê³„ í‘œì‹œ
            analyzed = len(get_value(_global_state.context, 'analyzed_files', {}))
            symbols = len(get_value(_global_state.context, 'symbol_index', {}))
            logger.info(f"   â€¢ ë¶„ì„ëœ íŒŒì¼: {analyzed}ê°œ")
            logger.info(f"   â€¢ ì‹¬ë³¼ ì¸ë±ìŠ¤: {symbols}ê°œ")
            
        except Exception as e:
            logger.error(f"âŒ Context Manager ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            _global_state.context = _create_minimal_context()
    else:
        _global_state.context = _create_minimal_context()
    
    return _global_state.context

def _create_minimal_context() -> Dict[str, Any]:
    """ìµœì†Œí•œì˜ ì»¨í…ìŠ¤íŠ¸ ìƒì„± (í´ë°±ìš©)"""
    return {
        'project_name': _global_state.project_name,
        'project_path': _global_state.project_path,
        'created_at': dt.datetime.now().isoformat(),
        'version': 'minimal',
        'cache': {
            'analyzed_files': {},
            'symbol_index': {},
            'work_tracking': {}
        },
        'tasks': {'next': [], 'done': []},
        'current_focus': '',
        'coding_experiences': []
    }

# ============================================
# ì§€ëŠ¥í˜• ë¶„ì„ í•¨ìˆ˜
# ============================================

def analyze_project_structure(extensions: List[str] = None) -> Dict[str, Any]:
    """
    í”„ë¡œì íŠ¸ ì „ì²´ êµ¬ì¡° ë¶„ì„
    
    Args:
        extensions: ë¶„ì„í•  íŒŒì¼ í™•ì¥ì ë¦¬ìŠ¤íŠ¸ (ê¸°ë³¸: ['.py'])
    
    Returns:
        ë¶„ì„ ê²°ê³¼
    """
    if extensions is None:
        extensions = ['.py']
    
    logger.info("ğŸ” í”„ë¡œì íŠ¸ êµ¬ì¡° ë¶„ì„ ì‹œì‘")
    
    results = {
        'files_analyzed': 0,
        'total_functions': 0,
        'total_classes': 0,
        'errors': []
    }
    
    # í”„ë¡œì íŠ¸ ë‚´ ëª¨ë“  íŒŒì¼ ì°¾ê¸°
    for root, dirs, files in os.walk(_global_state.project_path):
        # ìˆ¨ê¹€ ë””ë ‰í† ë¦¬ ì œì™¸
        dirs[:] = [d for d in dirs if not d.startswith('.')]
        
        for file in files:
            if any(file.endswith(ext) for ext in extensions):
                file_path = os.path.join(root, file)
                
                try:
                    # íŒŒì¼ ë¶„ì„
                    analysis = parse_with_snippets(file_path)
                    if analysis:
                        results['files_analyzed'] += 1
                        results['total_functions'] += len(analysis.get('functions', []))
                        results['total_classes'] += len(analysis.get('classes', []))
                        
                        # ìºì‹œ ì—…ë°ì´íŠ¸
                        if _global_state.context:
                            update_cache(_global_state.context, 
                                       f'analyzed_files.{file_path}', 
                                       analysis)
                            
                except Exception as e:
                    error_msg = f"íŒŒì¼ ë¶„ì„ ì‹¤íŒ¨: {file_path} - {str(e)}"
                    logger.error(error_msg)
                    results['errors'].append(error_msg)
    
    # ì‹¬ë³¼ ì¸ë±ìŠ¤ êµ¬ì¶•
    if _global_state.context:
        analyzed_files = get_value(_global_state.context, 'analyzed_files', {})
        build_index(_global_state.context, analyzed_files)
    
    # ì €ì¥
    save_ai_brain_state()
    
    logger.info(f"âœ… ë¶„ì„ ì™„ë£Œ: {results['files_analyzed']}ê°œ íŒŒì¼")
    return results

def save_ai_brain_state() -> bool:
    """AI Brain ìƒíƒœ ì €ì¥"""
    if not _global_state.context:
        logger.warning("ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
        return False
    
    try:
        result = save_context()
        if result:
            logger.info("ğŸ’¾ AI Brain ìƒíƒœ ì €ì¥ ì™„ë£Œ")
        return result
    except Exception as e:
        logger.error(f"âŒ ì €ì¥ ì¤‘ ì˜¤ë¥˜: {e}")
        return False

# ============================================
# ì§€ëŠ¥í˜• ì œì•ˆ ì‹œìŠ¤í…œ
# ============================================

def get_ai_suggestions(limit: int = 5) -> List[Dict[str, Any]]:
    """AI ê¸°ë°˜ ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ"""
    if not _global_state.context:
        return []
    
    suggestions = propose_next_steps(_global_state.context, limit)
    
    # ì¶”ê°€ ì œì•ˆ ë¡œì§
    work_tracking = get_value(_global_state.context, 'work_tracking', {})
    
    # ì„¸ì…˜ ì‹œê°„ ê¸°ë°˜ ì œì•ˆ
    session_duration = (dt.datetime.now() - _global_state.session_start).total_seconds()
    if session_duration > 7200:  # 2ì‹œê°„ ì´ìƒ
        suggestions.insert(0, {
            'type': 'health',
            'priority': 'high',
            'text': '2ì‹œê°„ ì´ìƒ ì‘ì—…í•˜ì…¨ìŠµë‹ˆë‹¤. ì ì‹œ íœ´ì‹ì„ ì·¨í•˜ì„¸ìš”! â˜•',
            'action': 'take_break'
        })
    
    return suggestions

# ============================================
# ëª…ë ¹ì–´ ì‹œìŠ¤í…œ
# ============================================

def process_command(command: str, *args) -> Any:
    """
    ëª…ë ¹ì–´ ì²˜ë¦¬ ì‹œìŠ¤í…œ
    
    Args:
        command: ëª…ë ¹ì–´ ë¬¸ìì—´
        *args: ëª…ë ¹ì–´ ì¸ìë“¤
    
    Returns:
        ëª…ë ¹ì–´ ì‹¤í–‰ ê²°ê³¼
    """
    commands = {
        '/flow': cmd_flow,
        '/analyze': cmd_analyze,
        '/task': cmd_task,
        '/done': cmd_done,
        '/focus': cmd_focus,
        '/suggest': cmd_suggest,
        '/save': cmd_save,
        '/status': cmd_status,
        '/help': cmd_help
    }
    
    if command in commands:
        return commands[command](*args)
    else:
        return f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {command}\nğŸ’¡ /helpë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´ë¥¼ í™•ì¸í•˜ì„¸ìš”"

def cmd_flow(*args):
    """í”„ë¡œì íŠ¸ ìƒíƒœ ë° ì‘ì—… íë¦„ í‘œì‹œ"""
    if not _global_state.context:
        return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
    
    output = []
    output.append("\nğŸ”¥ AI Coding Brain - Project Flow")
    output.append("=" * 70)
    
    # í”„ë¡œì íŠ¸ ì •ë³´
    output.append(f"\nğŸ“Œ í”„ë¡œì íŠ¸: {_global_state.project_name}")
    output.append(f"ğŸ“ ê²½ë¡œ: {_global_state.project_path}")
    output.append(f"ğŸ¯ í˜„ì¬ í¬ì»¤ìŠ¤: {_global_state.context.get('current_focus', 'Not set')}")
    
    # ì‘ì—… ì§„í–‰ë¥ 
    tasks = _global_state.context.get('tasks', {})
    done = len(tasks.get('done', []))
    next = len(tasks.get('next', []))
    total = done + next
    progress = (done / total * 100) if total > 0 else 0
    
    output.append(f"\nğŸ“Š ì§„í–‰ë¥ : {progress:.1f}% ({done}/{total})")
    
    # ë¶„ì„ëœ íŒŒì¼
    analyzed = get_value(_global_state.context, 'analyzed_files', {})
    output.append(f"\nğŸ“ ë¶„ì„ëœ íŒŒì¼: {len(analyzed)}ê°œ")
    
    # ì‘ì—… ì¶”ì 
    output.append(f"\n{get_work_tracking_summary(_global_state.context)}")
    
    # AI ì œì•ˆ
    output.append("\nğŸ’¡ AI ì œì•ˆ:")
    suggestions = get_ai_suggestions(3)
    for i, suggestion in enumerate(suggestions, 1):
        output.append(f"   {i}. {suggestion['text']}")
    
    # ìë™ ì €ì¥
    save_ai_brain_state()
    
    return '\n'.join(output)

def cmd_analyze(*args):
    """í”„ë¡œì íŠ¸ íŒŒì¼ ë¶„ì„"""
    extensions = list(args) if args else ['.py']
    results = analyze_project_structure(extensions)
    
    output = [f"\nâœ… ë¶„ì„ ì™„ë£Œ:"]
    output.append(f"   â€¢ íŒŒì¼: {results['files_analyzed']}ê°œ")
    output.append(f"   â€¢ í•¨ìˆ˜: {results['total_functions']}ê°œ")
    output.append(f"   â€¢ í´ë˜ìŠ¤: {results['total_classes']}ê°œ")
    
    if results['errors']:
        output.append(f"\nâš ï¸ ì˜¤ë¥˜ {len(results['errors'])}ê°œ ë°œìƒ")
    
    return '\n'.join(output)

def cmd_task(*args):
    """ìƒˆ ì‘ì—… ì¶”ê°€"""
    if not args:
        return "âŒ ì‘ì—… ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"
    
    task = ' '.join(args)
    if _global_state.context:
        tasks = _global_state.context.setdefault('tasks', {})
        tasks.setdefault('next', []).append(task)
        save_ai_brain_state()
        return f"âœ… ì‘ì—… ì¶”ê°€ë¨: {task}"
    
    return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"

def cmd_done(*args):
    """ì‘ì—… ì™„ë£Œ ì²˜ë¦¬"""
    if not _global_state.context:
        return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
    
    tasks = _global_state.context.get('tasks', {})
    next_tasks = tasks.get('next', [])
    
    if not next_tasks:
        return "â„¹ï¸ ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤"
    
    if args and args[0].isdigit():
        idx = int(args[0]) - 1
        if 0 <= idx < len(next_tasks):
            task = next_tasks.pop(idx)
            tasks.setdefault('done', []).append(task)
            save_ai_brain_state()
            return f"âœ… ì™„ë£Œ: {task}"
    
    # ì²« ë²ˆì§¸ ì‘ì—… ì™„ë£Œ
    task = next_tasks.pop(0)
    tasks.setdefault('done', []).append(task)
    save_ai_brain_state()
    return f"âœ… ì™„ë£Œ: {task}"

def cmd_focus(*args):
    """í˜„ì¬ í¬ì»¤ìŠ¤ ì„¤ì •"""
    if not args:
        return f"ğŸ¯ í˜„ì¬ í¬ì»¤ìŠ¤: {_global_state.context.get('current_focus', 'Not set')}"
    
    focus = ' '.join(args)
    if _global_state.context:
        _global_state.context['current_focus'] = focus
        save_ai_brain_state()
        return f"ğŸ¯ í¬ì»¤ìŠ¤ ì„¤ì •: {focus}"
    
    return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"

def cmd_suggest(*args):
    """AI ì œì•ˆ í‘œì‹œ"""
    limit = int(args[0]) if args and args[0].isdigit() else 5
    suggestions = get_ai_suggestions(limit)
    
    if not suggestions:
        return "ğŸ’¡ í˜„ì¬ ì œì•ˆì´ ì—†ìŠµë‹ˆë‹¤"
    
    output = ["ğŸ’¡ AI ì œì•ˆ:"]
    for i, suggestion in enumerate(suggestions, 1):
        output.append(f"   {i}. [{suggestion['type']}] {suggestion['text']}")
    
    return '\n'.join(output)

def cmd_save(*args):
    """ìƒíƒœ ì €ì¥"""
    if save_ai_brain_state():
        return "ğŸ’¾ ì €ì¥ ì™„ë£Œ!"
    else:
        return "âŒ ì €ì¥ ì‹¤íŒ¨"

def cmd_status(*args):
    """ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ"""
    output = ["ğŸ”§ AI Brain System Status"]
    output.append("=" * 40)
    output.append(f"â€¢ Context Manager: {'âœ…' if CONTEXT_MANAGER_AVAILABLE else 'âŒ'}")
    output.append(f"â€¢ Vibe Memory: {'âœ…' if VIBE_MEMORY_AVAILABLE else 'âŒ'}")
    output.append(f"â€¢ Auto Tracking: {'âœ…' if AUTO_TRACKING_ENABLED else 'âŒ'}")
    output.append(f"â€¢ Project: {_global_state.project_name or 'Not initialized'}")
    
    session_time = dt.datetime.now() - _global_state.session_start
    output.append(f"â€¢ Session Time: {str(session_time).split('.')[0]}")
    
    return '\n'.join(output)

def cmd_help(*args):
    """ë„ì›€ë§ í‘œì‹œ"""
    help_text = """
ğŸ¤– AI Coding Brain ëª…ë ¹ì–´ ë„ì›€ë§
=====================================

ê¸°ë³¸ ëª…ë ¹ì–´:
  /flow       - í”„ë¡œì íŠ¸ ìƒíƒœ ë° ì‘ì—… íë¦„ í‘œì‹œ
  /analyze    - í”„ë¡œì íŠ¸ íŒŒì¼ ë¶„ì„
  /task       - ìƒˆ ì‘ì—… ì¶”ê°€
  /done       - ì‘ì—… ì™„ë£Œ ì²˜ë¦¬
  /focus      - í˜„ì¬ í¬ì»¤ìŠ¤ ì„¤ì •
  /suggest    - AI ì œì•ˆ í‘œì‹œ
  /save       - ìƒíƒœ ì €ì¥
  /status     - ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
  /help       - ì´ ë„ì›€ë§ í‘œì‹œ

ì‚¬ìš© ì˜ˆì‹œ:
  /task API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
  /done 1
  /focus ë¦¬íŒ©í† ë§ ì‘ì—…
  /analyze .py .js
  
ğŸ’¡ ìì—°ì–´ë¡œë„ ëª…ë ¹ ê°€ëŠ¥í•©ë‹ˆë‹¤!
"""
    return help_text

# ============================================
# ìë™ ì´ˆê¸°í™” (execute_code í™˜ê²½ìš©)
# ============================================

def auto_initialize():
    """execute_code ì‹¤í–‰ ì‹œ ìë™ ì´ˆê¸°í™”"""
    if _global_state.context is None:
        project_path = os.getcwd()
        project_name = os.path.basename(project_path)
        
        # .cache ë””ë ‰í† ë¦¬ì—ì„œ í”„ë¡œì íŠ¸ ì´ë¦„ ì¶”ë¡ 
        cache_dir = os.path.join(project_path, '.cache')
        if os.path.exists(cache_dir):
            for file in os.listdir(cache_dir):
                if file.startswith('cache_') and file.endswith('.json'):
                    project_name = file[6:-5]  # cache_NAME.jsonì—ì„œ NAME ì¶”ì¶œ
                    break
        
        initialize_ai_brain(project_path, project_name)

# ìë™ ì´ˆê¸°í™” ì‹¤í–‰
auto_initialize()

# ============================================
# ì „ì—­ í—¬í¼ í•¨ìˆ˜ ë“±ë¡
# ============================================

# ìì£¼ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ë“¤ì„ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
globals().update({
    'flow': lambda: process_command('/flow'),
    'analyze': lambda *args: process_command('/analyze', *args),
    'task': lambda *args: process_command('/task', *args),
    'done': lambda *args: process_command('/done', *args),
    'focus': lambda *args: process_command('/focus', *args),
    'suggest': lambda *args: process_command('/suggest', *args),
    'save': lambda: process_command('/save'),
    'status': lambda: process_command('/status'),
    'help': lambda: process_command('/help'),
    
    # ì»¨í…ìŠ¤íŠ¸ ì§ì ‘ ì ‘ê·¼
    'context': lambda: _global_state.context,
    'project_path': lambda: _global_state.project_path,
    'project_name': lambda: _global_state.project_name
})

# ============================================
# ì´ˆê¸°í™” ì™„ë£Œ ë©”ì‹œì§€
# ============================================

if _global_state.context:
    logger.info("ğŸ§  AI Coding Brain v3.0 ì¤€ë¹„ ì™„ë£Œ!")
    logger.info("ğŸ’¡ /help ë˜ëŠ” help()ë¡œ ì‚¬ìš©ë²•ì„ í™•ì¸í•˜ì„¸ìš”")
else:
    logger.warning("âš ï¸ AI Coding Brain ë¶€ë¶„ ì´ˆê¸°í™” - ì¼ë¶€ ê¸°ëŠ¥ ì œí•œ")

# ìë™ìœ¼ë¡œ /flow ì‹¤í–‰ (ì„ íƒì‚¬í•­)
if _global_state.context and AUTO_TRACKING_ENABLED:
    print(process_command('/flow'))
