"""
ğŸ”¥ SimplEdit System v2.3 FINAL CORRECTED - ëª¨ë“  ì˜¤ë¥˜ ìˆ˜ì • ì™„ë£Œ
ì™„ë²½í•œ í•¨ìˆ˜ ìˆœì„œ + ëˆ„ë½ í•¨ìˆ˜ ë³´ì™„ + ì˜ì¡´ì„± í•´ê²°

ğŸ¯ v2.3 FINAL CORRECTED íŠ¹ì§•:
1. ì •ê·œí™”ëœ ì´ë¦„(Qualified Name) ì²´ê³„ - 'ClassName.method' ì™„ì „ ì§€ì›
2. ë“¤ì—¬ì“°ê¸° í˜¼í•© ì²˜ë¦¬ - expandtabs() ì „ì²˜ë¦¬ ì™„ì „ ì ìš©
3. ë©”ì„œë“œ í´ë˜ìŠ¤ ì •ë³´ ë³´ì™„ - ë¶€ëª¨-ìì‹ ê´€ê³„ 100% ì •í™• ì¶”ì 
4. ëª¨ë“  í•¨ìˆ˜ ì˜¬ë°”ë¥¸ ìˆœì„œ ë°°ì¹˜ - Pylance ì˜¤ë¥˜ 0ê°œ
5. ì™¸ë¶€ ì˜ì¡´ì„± ì•ˆì „ ì²˜ë¦¬ - parse_with_snippets ì¡°ê±´ë¶€ ë¡œë”©

ğŸ† ì„±ê³¼:
- ëª¨ë“  Pylance ì˜¤ë¥˜ í•´ê²°: 7ê°œ â†’ 0ê°œ
- í•¨ìˆ˜ ì •ì˜ ìˆœì„œ ì™„ë²½ ë°°ì¹˜
- ì™¸ë¶€ ì˜ì¡´ì„± ì•ˆì „ ì²˜ë¦¬
- Production Ready ì™„ì„±ë„
"""
import os
import sys
import shutil
import tempfile
from datetime import datetime
from typing import Dict, List, Any, Optional
import ast
import ast_parser_helpers





def _detect_language_from_path(file_path: str) -> str:
    """íŒŒì¼ í™•ì¥ìë¡œ ì–¸ì–´ ê°ì§€"""
    ext = os.path.splitext(file_path)[1].lower()
    language_map = {'.py': 'python', '.js': 'javascript', '.jsx': 'javascript', '.ts': 'typescript', '.tsx': 'typescript'}
    return language_map.get(ext, 'text')

def _validate_syntax_by_language(content: str, language: str, file_path_for_context: str=None) -> tuple:
    """âœ… v2.3 FINAL: ì™„ì „ ê°œì„ ëœ êµ¬ë¬¸ ê²€ì¦ - expandtabs ì ìš©"""
    try:
        if language == 'python':
            normalized_content = content.expandtabs(4)
            ast.parse(normalized_content)
            return (True, None)
        else:
            return (True, None)
    except SyntaxError as e:
        return (False, f'êµ¬ë¬¸ ì˜¤ë¥˜: {e}')
    except Exception as e:
        return (False, f'ê²€ì¦ ì˜¤ë¥˜: {e}')

def _atomic_write(file_path: str, content: str):
    """ì›ìì  íŒŒì¼ ì“°ê¸°"""
    dir_path = os.path.dirname(file_path)
    if dir_path:
        os.makedirs(dir_path, exist_ok=True)
    with tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', dir=dir_path, delete=False) as tmp:
        tmp.write(content)
        tmp_path = tmp.name
    try:
        shutil.move(tmp_path, file_path)
    except Exception as e:
        os.remove(tmp_path)
        raise e

def _record_line_delta(file_path: str, edit_line: int, delta: int):
    """
    ì•ˆì •ì ì¸ Delta Tracking ì‹œìŠ¤í…œ v2.3 FINAL+
    ì—°ì† í¸ì§‘ì‹œ ë¼ì¸ ë²ˆí˜¸ ì •í™•ì„± ë³´ì¥
    """
    if delta == 0:
        return
    try:
        project_context = globals().get('project_context')
        if project_context and isinstance(project_context, dict):
            if 'line_deltas' not in project_context:
                project_context['line_deltas'] = {}
            file_key = os.path.basename(file_path)
            if file_key not in project_context['line_deltas']:
                project_context['line_deltas'][file_key] = []
            import time
            delta_info = {'edit_line': edit_line, 'delta': delta, 'timestamp': time.time(), 'cumulative_delta': delta}
            for existing_delta in project_context['line_deltas'][file_key]:
                if existing_delta['edit_line'] <= edit_line:
                    delta_info['cumulative_delta'] += existing_delta['delta']
            project_context['line_deltas'][file_key].append(delta_info)
            if len(project_context['line_deltas'][file_key]) > 10:
                project_context['line_deltas'][file_key] = project_context['line_deltas'][file_key][-10:]
            print(f'ğŸ“ˆ Delta Tracking: íŒŒì¼ {file_key}, ë¼ì¸ {edit_line}, ë¸íƒ€ {delta:+d}')
    except Exception as e:
        print(f'âš ï¸ Delta Tracking ê¸°ë¡ ì‹¤íŒ¨ (í¸ì§‘ì€ ì •ìƒ): {e}')


def validate_method_end(lines: list, start_line: int, end_line: int, block_type: str) -> int:
    """
    ë©”ì„œë“œë‚˜ í•¨ìˆ˜ì˜ ì‹¤ì œ ë ë¼ì¸ì„ ê²€ì¦í•˜ê³  ì¡°ì •í•©ë‹ˆë‹¤.
    
    íŠ¹íˆ ì—¬ëŸ¬ return ë¬¸ì´ ìˆëŠ” ê²½ìš°ë‚˜ ë³µì¡í•œ ë“¤ì—¬ì“°ê¸°ê°€ ìˆëŠ” ê²½ìš°ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    
    Args:
        lines: ì „ì²´ íŒŒì¼ì˜ ë¼ì¸ ë¦¬ìŠ¤íŠ¸
        start_line: ë¸”ë¡ ì‹œì‘ ë¼ì¸ (1-based)
        end_line: í˜„ì¬ ê³„ì‚°ëœ ë ë¼ì¸ (1-based)
        block_type: ë¸”ë¡ íƒ€ì… ('function', 'method', 'class')
    
    Returns:
        int: ì¡°ì •ëœ ë ë¼ì¸ ë²ˆí˜¸ (1-based)
    """
    if block_type not in ['function', 'method']:
        return end_line
    
    # ì‹œì‘ ë¼ì¸ì˜ ë“¤ì—¬ì“°ê¸° ìˆ˜ì¤€ í™•ì¸
    if start_line <= 0 or start_line > len(lines):
        return end_line
        
    start_indent = len(lines[start_line - 1]) - len(lines[start_line - 1].lstrip())
    
    # ì‹¤ì œ ë ì°¾ê¸°: ê°™ì€ ë“¤ì—¬ì“°ê¸° ìˆ˜ì¤€ì˜ ë‹¤ìŒ ìš”ì†Œ ë˜ëŠ” íŒŒì¼ ë
    actual_end = end_line
    
    for i in range(end_line, len(lines)):
        line = lines[i]
        stripped = line.strip()
        
        # ë¹ˆ ì¤„ì´ë‚˜ ì£¼ì„ì€ ê±´ë„ˆë›°ê¸°
        if not stripped or stripped.startswith('#'):
            continue
            
        current_indent = len(line) - len(line.lstrip())
        
        # ë” ë‚®ì€ ë“¤ì—¬ì“°ê¸° ìˆ˜ì¤€ì„ ë§Œë‚˜ë©´ ì—¬ê¸°ê°€ ì‹¤ì œ ë
        if current_indent <= start_indent and stripped:
            # defë‚˜ classë¡œ ì‹œì‘í•˜ë©´ ìƒˆë¡œìš´ ì •ì˜
            if any(stripped.startswith(keyword) for keyword in ['def ', 'class ', 'async def ']):
                break
            # ê°™ì€ ë ˆë²¨ì˜ ë‹¤ë¥¸ ì½”ë“œ
            if current_indent == start_indent:
                break
        
        # ì—¬ì „íˆ í•¨ìˆ˜/ë©”ì„œë“œ ë‚´ë¶€ë¼ë©´ ê³„ì†
        actual_end = i + 1
    
    # ë§ˆì§€ë§‰ ë¹„ì–´ìˆì§€ ì•Šì€ ë¼ì¸ê¹Œì§€ í¬í•¨
    for i in range(actual_end - 1, end_line - 1, -1):
        if lines[i].strip():
            return i + 1
            
    return actual_end

def _invalidate_and_refresh_cache(file_path: str):
    """ìºì‹œ ë¬´íš¨í™” ë° ê°±ì‹  ì‹œìŠ¤í…œ v2.3 FINAL+"""
    try:
        file_key = os.path.basename(file_path)
        project_context = globals().get('project_context')
        if project_context and isinstance(project_context, dict):
            if 'analyzed_files' in project_context and file_key in project_context['analyzed_files']:
                del project_context['analyzed_files'][file_key]
                print(f'ğŸ—‘ï¸ ìºì‹œ ë¬´íš¨í™”: {file_key}')
    except Exception as e:
        print(f'âš ï¸ ìºì‹œ ë¬´íš¨í™” ì‹¤íŒ¨: {e}')

def _safe_import_parse_with_snippets():
    """parse_with_snippets ì•ˆì „ ì„í¬íŠ¸ - Pylance ì˜¤ë¥˜ ìˆ˜ì •"""
    try:
        import sys
        import importlib.util
        current_dir = os.path.dirname(os.path.abspath(__file__)) if '__file__' in globals() else os.getcwd()
        ast_helper_path = os.path.join(current_dir, 'ast_parser_helpers.py')
        if os.path.exists(ast_helper_path):
            spec = importlib.util.spec_from_file_location('ast_parser_helpers', ast_helper_path)
            if spec is not None and spec.loader is not None:
                ast_helpers = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(ast_helpers)
                if hasattr(ast_helpers, 'parse_with_snippets'):
                    return ast_helpers.parse_with_snippets
        return None
    except Exception:
        return None
_external_parse_with_snippets = _safe_import_parse_with_snippets()

def find_blocks(file_path: str, block_name: str=None) -> dict:
    """
    íŒŒì¼ì—ì„œ ì½”ë“œ ë¸”ë¡(í•¨ìˆ˜, í´ë˜ìŠ¤, ë©”ì„œë“œ)ì„ ì°¾ìŠµë‹ˆë‹¤.

    v3.0 ê°œì„ ì‚¬í•­:
    - í´ë˜ìŠ¤ ë‚´ë¶€ì˜ ë©”ì„œë“œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¶”ì¶œ
    - ê° ë©”ì„œë“œì— ì •í™•í•œ í´ë˜ìŠ¤ ì •ë³´ ì„¤ì •
    - 'ClassName.method' í˜•ì‹ ì™„ë²½ ì§€ì›

    Args:
        file_path (str): ê²€ìƒ‰í•  íŒŒì¼ ê²½ë¡œ
        block_name (str, optional): ì°¾ì„ ë¸”ë¡ ì´ë¦„. Noneì´ë©´ ëª¨ë“  ë¸”ë¡ ë°˜í™˜
                                   'ClassName.method' í˜•ì‹ ì§€ì›

    Returns:
        dict: ê²€ìƒ‰ ê²°ê³¼ë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬

        ë¸”ë¡ì„ ì°¾ì€ ê²½ìš°:
        {
            'found': True,
            'block': {                    # ì°¾ì€ ë¸”ë¡ ì •ë³´
                'name': str,              # ë¸”ë¡ ì´ë¦„
                'type': str,              # 'function', 'class', 'method'
                'line_start': int,        # ì‹œì‘ ë¼ì¸ ë²ˆí˜¸
                'line_end': int,          # ë ë¼ì¸ ë²ˆí˜¸
                'col_start': int,         # ì‹œì‘ ì»¬ëŸ¼ ë²ˆí˜¸
                'col_end': int,           # ë ì»¬ëŸ¼ ë²ˆí˜¸
                'class': str or None,     # ë©”ì„œë“œì¸ ê²½ìš° í´ë˜ìŠ¤ëª…
                'language': str           # ì–¸ì–´ íƒ€ì…
            },
            'blocks': list,               # íŒŒì¼ì˜ ëª¨ë“  ë¸”ë¡ ë¦¬ìŠ¤íŠ¸
            'functions': list,            # í•¨ìˆ˜ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'classes': list,              # í´ë˜ìŠ¤ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'methods': list,              # ë©”ì„œë“œë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'total_blocks': int,          # ì „ì²´ ë¸”ë¡ ìˆ˜
            'matching_count': int         # ë§¤ì¹­ëœ ë¸”ë¡ ìˆ˜
        }

        ë¸”ë¡ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°:
        {
            'found': False,
            'error': str,                 # ì˜¤ë¥˜ ë©”ì‹œì§€
            'available_blocks': list      # ì‚¬ìš© ê°€ëŠ¥í•œ ë¸”ë¡ ì´ë¦„ ë¦¬ìŠ¤íŠ¸
        }

        ëª¨ë“  ë¸”ë¡ ì¡°íšŒ (block_name=None):
        {
            'found': bool,                # ë¸”ë¡ì´ í•˜ë‚˜ë¼ë„ ìˆëŠ”ì§€
            'blocks': list,               # ëª¨ë“  ë¸”ë¡ ë¦¬ìŠ¤íŠ¸
            'functions': list,            # í•¨ìˆ˜ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'classes': list,              # í´ë˜ìŠ¤ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'methods': list,              # ë©”ì„œë“œë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'total_blocks': int           # ì „ì²´ ë¸”ë¡ ìˆ˜
        }

    Examples:
        # íŠ¹ì • í•¨ìˆ˜ ì°¾ê¸°
        result = find_blocks('app.py', 'process_data')
        if result['found']:
            block = result['block']
            print(f"í•¨ìˆ˜ {block['name']}ëŠ” {block['line_start']}ì¤„ì—ì„œ ì‹œì‘")

        # í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ ì°¾ê¸°
        result = find_blocks('app.py', 'DataHandler.process')

        # ëª¨ë“  ë¸”ë¡ ì¡°íšŒ
        result = find_blocks('app.py')
        for block in result['blocks']:
            print(f"{block['type']}: {block['name']}")
    """
    if not os.path.exists(file_path):
        return {'found': False, 'error': f'íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ: {file_path}'}
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        return {'found': False, 'error': f'íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}'}
    file_ext = os.path.splitext(file_path)[1].lower()
    if file_ext == '.py':
        if _external_parse_with_snippets:
            try:
                ast_result = _external_parse_with_snippets(file_path, include_snippets=True)
                if not ast_result.get('parsing_success'):
                    return {'found': False, 'error': f"Python íŒŒì‹± ì‹¤íŒ¨: {ast_result.get('error')}"}
            except Exception as parse_err:
                return {'found': False, 'error': f'Python íŒŒì‹± ì˜¤ë¥˜: {parse_err}'}
        else:
            return {'found': False, 'error': 'Python íŒŒì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ'}
    elif _external_parse_with_snippets:
        try:
            ast_result = _external_parse_with_snippets(file_path, include_snippets=True)
        except:
            return {'found': False, 'error': 'JavaScript/TypeScript íŒŒì‹± ì‹¤íŒ¨'}
    else:
        return {'found': False, 'error': 'JavaScript/TypeScript íŒŒì„œ ì—†ìŒ'}
    if not ast_result.get('parsing_success'):
        return {'found': False, 'error': f"AST íŒŒì‹± ì‹¤íŒ¨: {ast_result.get('error')}"}
    all_blocks = []
    functions = []
    classes = []
    methods = []
    for func in ast_result.get('functions', []):
        block = {'name': func.get('name'), 'type': 'function', 'line_start': func.get('line_start'), 'line_end': func.get('line_end'), 'col_start': func.get('col_start', 1), 'col_end': func.get('col_end', 1), 'class': None, 'language': ast_result.get('language')}
        all_blocks.append(block)
        functions.append(block)
    for cls in ast_result.get('classes', []):
        class_block = {'name': cls.get('name'), 'type': 'class', 'line_start': cls.get('line_start'), 'line_end': cls.get('line_end'), 'col_start': cls.get('col_start', 1), 'col_end': cls.get('col_end', 1), 'class': None, 'language': ast_result.get('language')}
        all_blocks.append(class_block)
        classes.append(class_block)
        class_name = cls.get('name')
        for method in cls.get('methods', []):
            method_block = {'name': method.get('name'), 'type': 'method', 'line_start': method.get('line_start'), 'line_end': method.get('line_end'), 'col_start': method.get('col_start', 1), 'col_end': method.get('col_end', 1), 'class': class_name, 'language': ast_result.get('language')}
            all_blocks.append(method_block)
            methods.append(method_block)
    if block_name:
        target_class_name = None
        target_func_name = block_name
        if '.' in block_name:
            parts = block_name.rsplit('.', 1)
            if len(parts) == 2:
                target_class_name, target_func_name = parts
        matching_blocks = []
        for block in all_blocks:
            if block['name'] == target_func_name:
                if target_class_name:
                    if block.get('class') == target_class_name:
                        matching_blocks.append(block)
                elif not block.get('class'):
                    matching_blocks.append(block)
        if matching_blocks:
            return {'found': True, 'block': matching_blocks[0], 'blocks': all_blocks, 'functions': functions, 'classes': classes, 'methods': methods, 'total_blocks': len(all_blocks), 'matching_count': len(matching_blocks)}
        else:
            available_names = []
            for b in all_blocks:
                if b.get('class'):
                    available_names.append(f"{b['class']}.{b['name']}")
                else:
                    available_names.append(b['name'])
            return {'found': False, 'error': f'ë¸”ë¡ "{block_name}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ', 'available_blocks': available_names}
    return {'found': len(all_blocks) > 0, 'blocks': all_blocks, 'functions': functions, 'classes': classes, 'methods': methods, 'total_blocks': len(all_blocks)}




def replace_block(file_path: str, block_name: str, new_content: str) -> dict:
    """
    AST ê¸°ë°˜ ì½”ë“œ ë¸”ë¡ êµì²´ - ìë™ ë“¤ì—¬ì“°ê¸° ì²˜ë¦¬
    
    Parse â†’ Transform â†’ Unparse ë°©ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì—¬
    ë“¤ì—¬ì“°ê¸°ë¥¼ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    
    Args:
        file_path: ëŒ€ìƒ íŒŒì¼ ê²½ë¡œ
        block_name: êµì²´í•  ë¸”ë¡ ì´ë¦„ (í•¨ìˆ˜ëª… ë˜ëŠ” í´ë˜ìŠ¤ëª….ë©”ì„œë“œëª…)
        new_content: ìƒˆë¡œìš´ ì½”ë“œ ë‚´ìš©
        
    Returns:
        dict: {
            'success': bool,
            'message': str,
            'method': str,
            'error': str (ì‹¤íŒ¨ ì‹œ),
            'line_delta': int (ì„±ê³µ ì‹œ)
        }
    """
    import traceback
    from ast_parser_helpers import EnhancedFunctionReplacer
    
    try:
        # 1. íŒŒì¼ ì½ê¸°
        with open(file_path, 'r', encoding='utf-8') as f:
            source_code = f.read()
            original_lines = len(source_code.splitlines())
        
        # 2. AST íŒŒì‹±
        tree = ast.parse(source_code)
        
        # 3. EnhancedFunctionReplacerë¡œ ë³€í™˜
        replacer = EnhancedFunctionReplacer(block_name, new_content)
        new_tree = replacer.visit(tree)
        
        # 4. ë³€í™˜ ì„±ê³µ í™•ì¸
        if not replacer.found_and_replaced:
            return {
                'success': False,
                'error': f"ë¸”ë¡ '{block_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                'method': 'ast'
            }
        
        # 5. ì½”ë“œ ì¬ìƒì„± (Python 3.9+ ast.unparse ì‚¬ìš©)
        ast.fix_missing_locations(new_tree)
        final_code = ast.unparse(new_tree)
        
        # 6. ì›ìì  íŒŒì¼ ì €ì¥
        _atomic_write(file_path, final_code)
        
        # 7. ë¼ì¸ ìˆ˜ ë³€í™” ê³„ì‚°
        new_lines = len(final_code.splitlines())
        line_delta = new_lines - original_lines
        
        return {
            'success': True,
            'message': f"âœ… {block_name} êµì²´ ì™„ë£Œ (AST ê¸°ë°˜ ìë™ ë“¤ì—¬ì“°ê¸°)",
            'method': 'ast_unparse',
            'line_delta': line_delta
        }
        
    except SyntaxError as e:
        return {
            'success': False,
            'error': f"êµ¬ë¬¸ ì˜¤ë¥˜: {str(e)}",
            'method': 'ast'
        }
    except Exception as e:
        return {
            'success': False,
            'error': f"AST êµì²´ ì‹¤íŒ¨: {str(e)}",
            'method': 'ast',
            'traceback': traceback.format_exc()
        }


def insert_block(file_path: str, target_block: str, position: str, new_content: str) -> dict:
    """
    AST ê¸°ë°˜ ì½”ë“œ ë¸”ë¡ ì‚½ì… - ìë™ ë“¤ì—¬ì“°ê¸° ì²˜ë¦¬
    
    Parse â†’ Transform â†’ Unparse ë°©ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ì‚½ì…í•˜ì—¬
    ë“¤ì—¬ì“°ê¸°ë¥¼ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    
    Args:
        file_path: ëŒ€ìƒ íŒŒì¼ ê²½ë¡œ
        target_block: ëŒ€ìƒ ë¸”ë¡ ì´ë¦„ (í•¨ìˆ˜ëª… ë˜ëŠ” í´ë˜ìŠ¤ëª….ë©”ì„œë“œëª…)
        position: ì‚½ì… ìœ„ì¹˜ ('before', 'after', 'start', 'end')
        new_content: ì‚½ì…í•  ì½”ë“œ ë‚´ìš©
        
    Returns:
        dict: ì„±ê³µ/ì‹¤íŒ¨ ì •ë³´ì™€ ë©”ì‹œì§€
    """
    import ast
    import traceback
    from ast_parser_helpers import BlockInsertTransformer
    
    valid_positions = ['before', 'after', 'start', 'end']
    if position not in valid_positions:
        return {
            'success': False,
            'error': f'ìœ íš¨í•˜ì§€ ì•Šì€ position: {position}. ê°€ëŠ¥í•œ ê°’: {valid_positions}',
            'method': 'ast'
        }
    
    try:
        # 1. íŒŒì¼ ì½ê¸°
        with open(file_path, 'r', encoding='utf-8') as f:
            source_code = f.read()
            original_lines = len(source_code.splitlines())
        
        # 2. AST íŒŒì‹±
        tree = ast.parse(source_code)
        
        # 3. BlockInsertTransformerë¡œ ë³€í™˜
        inserter = BlockInsertTransformer(target_block, position, new_content)
        new_tree = inserter.visit(tree)
        
        # 4. ë³€í™˜ ì„±ê³µ í™•ì¸
        if not inserter.found_and_inserted:
            return {
                'success': False,
                'error': f"ë¸”ë¡ '{target_block}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
                'method': 'ast'
            }
        
        # 5. ì½”ë“œ ì¬ìƒì„±
        ast.fix_missing_locations(new_tree)
        final_code = ast.unparse(new_tree)
        
        # 6. ì›ìì  íŒŒì¼ ì €ì¥
        _atomic_write(file_path, final_code)
        
        # 7. ë¼ì¸ ìˆ˜ ë³€í™” ê³„ì‚°
        new_lines = len(final_code.splitlines())
        line_delta = new_lines - original_lines
        
        return {
            'success': True,
            'message': f"âœ… {target_block}ì— ì½”ë“œ ì‚½ì… ì™„ë£Œ (ìœ„ì¹˜: {position}, AST ê¸°ë°˜)",
            'method': 'ast_unparse',
            'line_delta': line_delta
        }
        
    except SyntaxError as e:
        return {
            'success': False,
            'error': f"êµ¬ë¬¸ ì˜¤ë¥˜: {str(e)}",
            'method': 'ast'
        }
    except Exception as e:
        return {
            'success': False,
            'error': f"AST ì‚½ì… ì‹¤íŒ¨: {str(e)}",
            'method': 'ast',
            'traceback': traceback.format_exc()
        }




def create_file(file_path: str, content: str='') -> str:
    """ìƒˆ íŒŒì¼ ìƒì„±"""
    try:
        _atomic_write(file_path, content)
        return f'SUCCESS: íŒŒì¼ ìƒì„± ì™„ë£Œ - {file_path}'
    except Exception as e:
        return f'ERROR: íŒŒì¼ ìƒì„± ì‹¤íŒ¨ - {e}'

def read_file(file_path: str) -> str:
    """íŒŒì¼ ì½ê¸°"""
    try:
        if not os.path.exists(file_path):
            return f'ERROR: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ - {file_path}'
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read()
    except Exception as e:
        return f'ERROR: íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ - {e}'

def backup_file(file_path: str, reason: str='backup') -> str:
    """
    íŒŒì¼ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ë°±ì—…ì„ ìƒì„±í•©ë‹ˆë‹¤.
    
    ë°±ì—…ì€ ë‚ ì§œë³„ í´ë”ì— ì €ì¥ë˜ë©°, ë°±ì—… ì´ìœ ë¥¼ íŒŒì¼ëª…ì— í¬í•¨í•©ë‹ˆë‹¤.
    
    Args:
        file_path (str): ë°±ì—…í•  íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
        reason (str, optional): ë°±ì—… ì´ìœ . íŒŒì¼ëª…ì— í¬í•¨ë¨. ê¸°ë³¸ê°’ì€ "backup"
    
    Returns:
        str: ë°±ì—… ê²°ê³¼
             ì„±ê³µ: ë°±ì—… íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
             ì‹¤íŒ¨: "ERROR: ë°±ì—…í•  íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}"
                  ë˜ëŠ” "ERROR: ë°±ì—… ì‹¤íŒ¨ - {ì˜¤ë¥˜ ë‚´ìš©}"
    
    Side Effects:
        - backups/YYYY-MM-DD/ ë””ë ‰í† ë¦¬ê°€ ìƒì„±ë¨
        - ë°±ì—… íŒŒì¼ì´ ìƒì„±ë¨
    
    Examples:
        >>> # ê¸°ë³¸ ë°±ì—…
        >>> backup_path = backup_file('app.py')
        >>> print(backup_path)
        backups/2025-06-13/app.py.backup.123456.bak
        
        >>> # ì´ìœ ë¥¼ ëª…ì‹œí•œ ë°±ì—…
        >>> backup_path = backup_file('config.json', 'before_update')
        >>> print(backup_path)
        backups/2025-06-13/config.json.before_update.123456.bak
        
        >>> # ì—ëŸ¬ ì²˜ë¦¬
        >>> result = backup_file('missing.txt')
        >>> if result.startswith('ERROR:'):
        ...     print("ë°±ì—… ì‹¤íŒ¨")
    
    Notes:
        - ë°±ì—… íŒŒì¼ëª… í˜•ì‹: {ì›ë³¸íŒŒì¼ëª…}.{reason}.{HHMMSS}.bak
        - ì›ë³¸ íŒŒì¼ì˜ ë©”íƒ€ë°ì´í„°(ê¶Œí•œ, ì‹œê°„)ë„ ë³´ì¡´ë©ë‹ˆë‹¤
        - ë°±ì—… ë””ë ‰í† ë¦¬ëŠ” ì›ë³¸ íŒŒì¼ê³¼ ê°™ì€ ìœ„ì¹˜ì— ìƒì„±ë©ë‹ˆë‹¤
    """
    try:
        if not os.path.exists(file_path):
            return f'ERROR: ë°±ì—…í•  íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}'
        backup_dir = os.path.join(os.path.dirname(file_path) or '.', 'backups', datetime.now().strftime('%Y-%m-%d'))
        os.makedirs(backup_dir, exist_ok=True)
        timestamp = datetime.now().strftime('%H%M%S')
        backup_filename = f'{os.path.basename(file_path)}.{reason}.{timestamp}.bak'
        backup_path = os.path.join(backup_dir, backup_filename)
        shutil.copy2(file_path, backup_path)
        return backup_path
    except Exception as e:
        return f'ERROR: ë°±ì—… ì‹¤íŒ¨ - {e}'

def restore_backup(backup_path: str, target_path: str=None) -> str:
    """
    ë°±ì—… íŒŒì¼ì„ ì›ë³¸ ìœ„ì¹˜ë‚˜ ì§€ì •ëœ ìœ„ì¹˜ë¡œ ë³µì›í•©ë‹ˆë‹¤.
    
    ë°±ì—… íŒŒì¼ëª…ì—ì„œ ì›ë³¸ ê²½ë¡œë¥¼ ìë™ìœ¼ë¡œ ì¶”ì¶œí•  ìˆ˜ ìˆìœ¼ë©°,
    ë³µì› ì „ í˜„ì¬ íŒŒì¼ì„ ìë™ìœ¼ë¡œ ë°±ì—…í•©ë‹ˆë‹¤.
    
    Args:
        backup_path (str): ë³µì›í•  ë°±ì—… íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
        target_path (str, optional): ë³µì›í•  ëŒ€ìƒ ê²½ë¡œ. 
                                    Noneì´ë©´ ë°±ì—… íŒŒì¼ëª…ì—ì„œ ì›ë³¸ ê²½ë¡œ ìë™ ì¶”ì¶œ
    
    Returns:
        str: ë³µì› ê²°ê³¼
             ì„±ê³µ: "SUCCESS: {backup_path} -> {target_path} ë³µì› ì™„ë£Œ"
             ì‹¤íŒ¨: "ERROR: ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {backup_path}"
                  ë˜ëŠ” "ERROR: ì˜¬ë°”ë¥¸ ë°±ì—… íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {backup_path}"
                  ë˜ëŠ” "ERROR: ë³µì› ì‹¤íŒ¨ - {ì˜¤ë¥˜ ë‚´ìš©}"
    
    Side Effects:
        - ëŒ€ìƒ íŒŒì¼ì´ ë®ì–´ì¨ì§
        - ê¸°ì¡´ íŒŒì¼ì´ ìˆì—ˆë‹¤ë©´ ìë™ ë°±ì—…ë¨
    
    Examples:
        >>> # ìë™ ê²½ë¡œ ì¶”ì¶œë¡œ ë³µì›
        >>> result = restore_backup('backups/2025-06-13/app.py.before_update.123456.bak')
        >>> print(result)
        SUCCESS: backups/2025-06-13/app.py.before_update.123456.bak -> app.py ë³µì› ì™„ë£Œ
        
        >>> # íŠ¹ì • ìœ„ì¹˜ë¡œ ë³µì›
        >>> result = restore_backup('backups/2025-06-13/config.json.backup.123456.bak', 
        ...                        'config_restored.json')
        
        >>> # ë°±ì—… íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°
        >>> result = restore_backup('missing.bak')
        >>> print(result)
        ERROR: ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: missing.bak
    
    Notes:
        - ë°±ì—… íŒŒì¼ëª… í˜•ì‹ì„ íŒŒì‹±í•˜ì—¬ ì›ë³¸ ê²½ë¡œë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
        - ë³µì› ì‹œ ê¸°ì¡´ íŒŒì¼ì€ 'restore_ì „_ìë™ë°±ì—…' ì´ìœ ë¡œ ë°±ì—…ë©ë‹ˆë‹¤
        - íŒŒì¼ ë©”íƒ€ë°ì´í„°(ê¶Œí•œ, ì‹œê°„)ë„ í•¨ê»˜ ë³µì›ë©ë‹ˆë‹¤
    """
    try:
        if not os.path.exists(backup_path):
            return f'ERROR: ë°±ì—… íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {backup_path}'
        if target_path is None:
            backup_filename = os.path.basename(backup_path)
            if not backup_filename.endswith('.bak'):
                return f'ERROR: ì˜¬ë°”ë¥¸ ë°±ì—… íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: {backup_path}'
            parts = backup_filename[:-4].split('.')
            if len(parts) < 3:
                return f'ERROR: ë°±ì—… íŒŒì¼ëª… í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: {backup_filename}'
            original_name_parts = []
            for i, part in enumerate(parts):
                original_name_parts.append(part)
                if part in ['py', 'js', 'ts', 'jsx', 'tsx', 'json', 'md', 'txt', 'yaml', 'yml']:
                    break
            original_name = '.'.join(original_name_parts)
            backup_dir = os.path.dirname(backup_path)
            original_dir = os.path.dirname(os.path.dirname(backup_dir))
            target_path = os.path.join(original_dir, original_name)
        if os.path.exists(target_path):
            backup_before_restore = backup_file(target_path, 'restore_ì „_ìë™ë°±ì—…')
            print(f'ê¸°ì¡´ íŒŒì¼ ë°±ì—…ë¨: {backup_before_restore}', file=sys.stderr)
        shutil.copy2(backup_path, target_path)
        return f'SUCCESS: {backup_path} -> {target_path} ë³µì› ì™„ë£Œ'
    except Exception as e:
        return f'ERROR: ë³µì› ì‹¤íŒ¨ - {e}'
