#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  AI Coding Brain - í†µí•© ë²„ì „ v6.2
==========================================

claude_code_ai_brain.pyì™€ context_manager.pyë¥¼ í†µí•©í•œ ë‹¨ì¼ íŒŒì¼.
í•µì‹¬ ê¸°ëŠ¥ë§Œ ìœ ì§€í•˜ê³  ê°„ì†Œí™”í•¨.

ì£¼ìš” ê¸°ëŠ¥:
- /flow ëª…ë ¹ì–´ë¡œ í”„ë¡œì íŠ¸ ì „í™˜
- ë©”ëª¨ë¦¬ ë£¨íŠ¸ì— ìºì‹œ ì¤‘ì•™ ì €ì¥
- í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‘ì—… ìˆ˜í–‰
- ì‘ì—… ì¶”ì  ë° ì‹¬ë³¼ ì¸ë±ì‹±
- ì‹±ê¸€í†¤ íŒ¨í„´ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬

v6.2 ë³€ê²½ì‚¬í•­:
- execute_code í™˜ê²½ê³¼ì˜ í˜¸í™˜ì„± ê°œì„ 
- ì§ë ¬í™” ë¬¸ì œ ì™„ì „ í•´ê²°
- ì „ì—­ context ë³€ìˆ˜ì™€ í†µí•©

ì‘ì„±ì¼: 2025-06-14
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy


# ===========================================
# í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================

class UnifiedContextManager:
    """í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì - ì‹±ê¸€í†¤ íŒ¨í„´"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None  # ìºì‹œ ì €ì¥ ìœ„ì¹˜
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str, memory_root: str = None, 
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        
        Args:
            project_path: í”„ë¡œì íŠ¸ ì‘ì—… ê²½ë¡œ
            project_name: í”„ë¡œì íŠ¸ ì´ë¦„
            memory_root: ìºì‹œ ì €ì¥ ë£¨íŠ¸ (ê¸°ë³¸ê°’: ~/Desktop/memory)
            existing_context: ê¸°ì¡´ context (execute_code í™˜ê²½ìš©)
        """
        self.project_path = project_path
        self.project_name = project_name
        
        # ë©”ëª¨ë¦¬ ë£¨íŠ¸ ì„¤ì • (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
        if memory_root:
            self.memory_root = memory_root
        else:
            # ê¸°ë³¸ê°’: í™ˆ/Desktop/memory
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # ê¸°ì¡´ contextê°€ ìˆìœ¼ë©´ ì‚¬ìš© (execute_code í™˜ê²½)
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"âœ… ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©: {project_name}")
        else:
            # ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"âœ… ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"âœ… ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±: {project_name}")
        
        # êµ¬ì¡° ì •ê·œí™”
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_path(self) -> str:
        """ìºì‹œ íŒŒì¼ ê²½ë¡œ ë°˜í™˜ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ ê¸°ì¤€)"""
        # ë©”ëª¨ë¦¬/{í”„ë¡œì íŠ¸ëª…}/.cache/cache_{í”„ë¡œì íŠ¸ëª…}.json
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        return os.path.join(cache_dir, f'cache_{self.project_name}.json')
    
    def _create_new_context(self) -> Dict[str, Any]:
        """ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        return {
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '6.2',
            
            # ìºì‹œ êµ¬ì¡°
            'cache': {
                'analyzed_files': {},
                'symbol_index': {},
                'work_tracking': {
                    'file_access': {},
                    'file_edits': {},
                    'function_edits': {},
                    'session_start': dt.datetime.now().isoformat(),
                    'total_operations': 0
                }
            },
            
            # ì‘ì—… ê´€ë¦¬
            'tasks': {'next': [], 'done': []},
            'current_focus': '',
            
            # AI í•™ìŠµ ë°ì´í„°
            'coding_experiences': [],
            
            # Phase ê´€ë¦¬ (execute_code í˜¸í™˜)
            'phase_reports': {},
            'error_log': [],
            
            # ê¸°íƒ€ í•„ë“œë“¤
            'analyzed_files': {},
            'work_tracking': {},
            'symbol_index': {}
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì—ì„œ)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_file = self._get_cache_file_path()
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    loaded_context = json.load(f)
                
                # í”„ë¡œì íŠ¸ ê²½ë¡œ ì—…ë°ì´íŠ¸ (ê²½ë¡œê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
                loaded_context['project_path'] = self.project_path
                loaded_context['memory_root'] = self.memory_root
                
                return loaded_context
            except Exception as e:
                print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
        return None
    
    def _normalize_context_structure(self):
        """ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ì •ê·œí™”"""
        if not self.context:
            return
            
        # í•„ìˆ˜ í‚¤ í™•ì¸
        self.context.setdefault('cache', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('work_tracking', {})
        self.context.setdefault('symbol_index', {})
        
        # ê²½ë¡œ ì •ë³´ ì—…ë°ì´íŠ¸
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root
        
        # ìºì‹œ êµ¬ì¡° í™•ì¸
        cache = self.context['cache']
        cache.setdefault('analyzed_files', {})
        cache.setdefault('symbol_index', {})
        
        # work_tracking êµ¬ì¡°
        work_tracking = cache.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        
        # ë ˆê±°ì‹œ í•„ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜
        if 'analyzed_files' in self.context and self.context['analyzed_files']:
            cache['analyzed_files'].update(self.context['analyzed_files'])
        
        if 'work_tracking' in self.context and isinstance(self.context['work_tracking'], dict):
            cache['work_tracking'].update(self.context['work_tracking'])
        
        if 'symbol_index' in self.context and self.context['symbol_index']:
            cache['symbol_index'].update(self.context['symbol_index'])
    
    def save(self) -> bool:
        """ì»¨í…ìŠ¤íŠ¸ ì €ì¥ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì—)"""
        if not self.context:
            print("âš ï¸ ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        try:
            # ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
            self.context['updated_at'] = dt.datetime.now().isoformat()
            
            # ìºì‹œ íŒŒì¼ ê²½ë¡œ
            cache_file = self._get_cache_file_path()
            
            # JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜
            serializable_context = self._prepare_serializable_context()
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… ìºì‹œ ì €ì¥: {cache_file}")
            
            # í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹œë„
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"âš ï¸ í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            return True
            
        except Exception as e:
            print(f"âŒ ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜ (ê°•í™”ëœ ë²„ì „)"""
        # contextê°€ ì—†ê±°ë‚˜ dictê°€ ì•„ë‹Œ ê²½ìš° ë¹ˆ dict ë°˜í™˜
        if not self.context or not isinstance(self.context, dict):
            return {}
        
        def is_serializable(obj):
            """ê°ì²´ê°€ JSON ì§ë ¬í™” ê°€ëŠ¥í•œì§€ í™•ì¸"""
            try:
                json.dumps(obj)
                return True
            except:
                return False
        
        def convert(obj):
            """ì¬ê·€ì ìœ¼ë¡œ ê°ì²´ë¥¼ ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜"""
            # ì´ë¯¸ ì§ë ¬í™” ê°€ëŠ¥í•œ ê¸°ë³¸ íƒ€ì…
            if obj is None or isinstance(obj, (bool, int, float, str)):
                return obj
            
            # ë‚ ì§œ/ì‹œê°„ íƒ€ì…
            elif isinstance(obj, (dt.datetime, dt.date)):
                return obj.isoformat()
            
            # defaultdict -> dict
            elif isinstance(obj, defaultdict):
                return dict(obj)
            
            # set -> list
            elif isinstance(obj, set):
                return list(obj)
            
            # dict ì²˜ë¦¬
            elif isinstance(obj, dict):
                result = {}
                for k, v in obj.items():
                    # í‚¤ë„ ë¬¸ìì—´ë¡œ ë³€í™˜
                    key = str(k) if not isinstance(k, str) else k
                    # ì§ë ¬í™” ë¶ˆê°€ëŠ¥í•œ ê°’ì€ ì œì™¸
                    if is_serializable(v):
                        result[key] = convert(v)
                    else:
                        # ê°ì²´ íƒ€ì…ì´ë©´ íƒ€ì…ëª…ë§Œ ì €ì¥
                        if hasattr(v, '__class__'):
                            result[key] = f"<{v.__class__.__name__} object>"
                        else:
                            # ê·¸ ì™¸ëŠ” ê±´ë„ˆë›°ê¸°
                            pass
                return result
            
            # list/tuple ì²˜ë¦¬
            elif isinstance(obj, (list, tuple)):
                return [convert(item) for item in obj if is_serializable(item)]
            
            # ì»¤ìŠ¤í…€ ê°ì²´ë“¤ì€ ë¬¸ìì—´ë¡œ í‘œí˜„
            elif hasattr(obj, '__class__'):
                return f"<{obj.__class__.__name__} object>"
            
            # ê·¸ ì™¸ì˜ ê²½ìš°
            else:
                return str(obj)
        
        # ì»¨í…ìŠ¤íŠ¸ ë³µì‚¬ í›„ ë³€í™˜
        serializable = convert(copy.deepcopy(self.context))
        
        # íŠ¹ì • í•„ë“œ ì œê±° (ì§ë ¬í™” ë¶ˆê°€ëŠ¥í•œ ê²ƒë“¤) - dictì¸ ê²½ìš°ì—ë§Œ
        if isinstance(serializable, dict):
            fields_to_remove = ['error_tracker', 'phase_reporter', 'change_tracker', 'flow_options']
            for field in fields_to_remove:
                if field in serializable:
                    del serializable[field]
        
        return serializable
    
    def _update_project_docs(self):
        """í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸"""
        if not self.context or not self.project_path:
            return
        
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(self.memory_root, self.project_name, filename)
            try:
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"âš ï¸ {filename} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = len(self.context.get('cache', {}).get('analyzed_files', {}))
        symbols = len(self.context.get('cache', {}).get('symbol_index', {}))
        tasks = self.context.get('tasks', {})
        
        content = f"""# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „

## ğŸ¯ í”„ë¡œì íŠ¸ ê°œìš”
MCP (Model Context Protocol) ê¸°ë°˜ í†µí•© ê°œë°œ ì§€ì› ì‹œìŠ¤í…œ

## ğŸ“Š í˜„ì¬ ìƒíƒœ
- ë¶„ì„ëœ íŒŒì¼: {analyzed}ê°œ
- ì‹¬ë³¼ ì¸ë±ìŠ¤: {symbols}ê°œ
- ì™„ë£Œëœ ì‘ì—…: {len(tasks.get('done', []))}ê°œ
- ì§„í–‰ ì¤‘ ì‘ì—…: {len(tasks.get('next', []))}ê°œ

## ğŸ”§ í•µì‹¬ ê¸°ëŠ¥
1. **ìë™ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬**: ì‘ì—… ìƒíƒœ ìë™ ì €ì¥/ë³µì›
2. **í†µí•© ê²€ìƒ‰ ì‹œìŠ¤í…œ**: ì½”ë“œ, ë©”ëª¨ë¦¬, ìºì‹œ í†µí•© ê²€ìƒ‰
3. **Phase ê¸°ë°˜ ì‘ì—… ê´€ë¦¬**: ì²´ê³„ì ì¸ í”„ë¡œì íŠ¸ ì§„í–‰
4. **SimplEdit ì•ˆì „ ìˆ˜ì •**: ë°±ì—…ê³¼ í•¨ê»˜í•˜ëŠ” ì•ˆì „í•œ ì½”ë“œ ìˆ˜ì •

## ğŸ“¦ ì£¼ìš” ëª¨ë“ˆ

## ğŸ“ˆ í”„ë¡œì íŠ¸ í†µê³„
"""
        
        # project_pathê°€ ìˆì„ ë•Œë§Œ íŒŒì¼ í†µê³„ ì¶”ê°€
        if self.project_path and os.path.exists(self.project_path):
            try:
                py_files = [f for f in os.listdir(self.project_path) if f.endswith('.py')]
                py_count = len(py_files)
                completion_rate = (analyzed / max(1, py_count)) * 100
                
                content += f"""- ì „ì²´ Python íŒŒì¼: {py_count}ê°œ
- ë¶„ì„ ì™„ë£Œìœ¨: {completion_rate:.1f}%

"""
            except Exception:
                pass
        
        content += f"""ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í˜„ì¬ ì‘ì—…\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        focus = self.context.get('current_focus', '')
        tasks = self.context.get('tasks', {})
        
        return f"""# AI Coding Brain - í˜„ì¬ ì‘ì—…

## ğŸ¯ í˜„ì¬ Focus
{focus}

## ğŸ”„ ì§„í–‰ ì¤‘ì¸ ì‘ì—…
{chr(10).join(f'- {task}' for task in tasks.get('next', [])[:5])}

## ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„

## ğŸ“ ë©”ëª¨
- save_context() í˜¸ì¶œ ì‹œ 4ê°œ ë¬¸ì„œ ìë™ ì—…ë°ì´íŠ¸
- ë°±ì—… ì—†ì´ ì§ì ‘ ì €ì¥

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
    
    def _generate_file_directory(self) -> str:
        """file_directory.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = self.context.get('cache', {}).get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## ğŸ“ Python ëª¨ë“ˆ ëª©ë¡

| ê²½ë¡œ | ì„¤ëª… | ìˆ˜ì •ì¼ |
|------|------|--------|
"""
        
        for file_path, info in analyzed.items():
            mod_time = info.get('last_modified', 'Unknown')
            content += f"| {file_path} | - | {mod_time} |\n"
        
        content += f"""

## ğŸ“Š í†µê³„
- Python íŒŒì¼: {len(analyzed)}ê°œ
- ë¶„ì„ ì™„ë£Œ: {len(analyzed)}ê°œ

## ğŸ“Œ ì£¼ìš” ë””ë ‰í† ë¦¬
- `/python/` - í•µì‹¬ Python ëª¨ë“ˆë“¤
- `/src/` - TypeScript/JavaScript ì†ŒìŠ¤
- `/backups/` - ë°±ì—… íŒŒì¼ë“¤
- `/dist/` - ë¹Œë“œ ê²°ê³¼ë¬¼
- `/.cache/` - ìºì‹œ íŒŒì¼ë“¤
"""
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - ì§„í–‰ ìƒí™©\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        tasks = self.context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total = done_count + next_count
        progress = (done_count / max(1, total)) * 100
        
        return f"""# AI Coding Brain - ì§„í–‰ ìƒí™©

## ğŸ“Š ì „ì²´ ì§„í–‰ë¥ 
- ì™„ë£Œ: {done_count}ê°œ
- ë‚¨ìŒ: {next_count}ê°œ
- ì§„í–‰ë¥ : {progress:.1f}%

## ğŸ¯ Phase ì§„í–‰ ìƒí™©

## ğŸ“‹ ìµœê·¼ ì™„ë£Œ ì‘ì—…
{chr(10).join(f'- {task}' for task in tasks.get('done', [])[-5:])}

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
    
    # ===========================================
    # ìºì‹œ ê´€ë¦¬ ë©”ì„œë“œ
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """ìºì‹œ ì—…ë°ì´íŠ¸ (ì¤‘ì²© í‚¤ ì§€ì›)"""
        if not self.context:
            return
        
        cache = self.context.setdefault('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """ìºì‹œ ê°’ ì¡°íšŒ"""
        if not self.context:
            return default
        
        cache = self.context.get('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # ì‹¬ë³¼ ë° ì‘ì—… ì¶”ì 
    # ===========================================
    
    def find_symbol(self, symbol_name: str) -> Optional[Dict[str, Any]]:
        """ì‹¬ë³¼ ê²€ìƒ‰"""
        if not self.context:
            return None
        
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        return symbol_index.get(symbol_name)
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        file_access[file_path] = file_access.get(file_path, 0) + 1
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        # í•¨ìˆ˜ í‚¤ ìƒì„±
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        # í¸ì§‘ ì •ë³´ ì—…ë°ì´íŠ¸
        if func_key not in function_edits:
            function_edits[func_key] = {'count': 0, 'operations': []}
        
        function_edits[func_key]['count'] += 1
        function_edits[func_key]['operations'].append({
            'timestamp': dt.datetime.now().isoformat(),
            'file': file_path
        })
        
        # íŒŒì¼ í¸ì§‘ë„ ì¶”ì 
        file_edits = work_tracking.setdefault('file_edits', {})
        file_edits[file_path] = file_edits.get(file_path, 0) + 1
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
    
    def get_work_tracking_summary(self) -> str:
        """ì‘ì—… ì¶”ì  ìš”ì•½"""
        if not self.context:
            return "ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # ì„¸ì…˜ ì‹œê°„ ê³„ì‚°
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        # í†µê³„ ìˆ˜ì§‘
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        
        # ìš”ì•½ ìƒì„±
        summary = f"""
ğŸ“Š ì‘ì—… ì¶”ì  ìš”ì•½
================
â€¢ í”„ë¡œì íŠ¸: {self.project_name}
â€¢ ì‘ì—… ê²½ë¡œ: {self.project_path}
â€¢ ìºì‹œ ê²½ë¡œ: {self.memory_root}
â€¢ ì„¸ì…˜ ì‹œê°„: {duration_str}
â€¢ ì „ì²´ ì‘ì—…: {total_ops}íšŒ
â€¢ ì ‘ê·¼í•œ íŒŒì¼: {len(file_access)}ê°œ
â€¢ ìˆ˜ì •í•œ íŒŒì¼: {len(file_edits)}ê°œ
â€¢ ìˆ˜ì •í•œ í•¨ìˆ˜: {len(function_edits)}ê°œ
"""
        
        # Top 5 íŒŒì¼
        if file_access:
            summary += "\nğŸ”¥ ê°€ì¥ ë§ì´ ì ‘ê·¼í•œ íŒŒì¼:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:5]
            for file_path, count in sorted_files:
                summary += f"  â€¢ {file_path}: {count}íšŒ\n"
        
        # Top 5 í•¨ìˆ˜
        if function_edits:
            summary += "\nâœï¸ ê°€ì¥ ë§ì´ ìˆ˜ì •í•œ í•¨ìˆ˜:\n"
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1]['count'], reverse=True)[:5]
            for func_name, info in sorted_funcs:
                summary += f"  â€¢ {func_name}: {info['count']}íšŒ\n"
        
        return summary


# ===========================================
# ê¸€ë¡œë²Œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str, memory_root: str = None,
                      existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
    return _context_manager.initialize(project_path, project_name, memory_root, existing_context)

def save_context() -> bool:
    """ì»¨í…ìŠ¤íŠ¸ ì €ì¥"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """ìºì‹œ ì—…ë°ì´íŠ¸"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """ìºì‹œ ê°’ ì¡°íšŒ"""
    return _context_manager.get_value(key, default)

def find_symbol(symbol_name: str) -> Optional[Dict[str, Any]]:
    """ì‹¬ë³¼ ì°¾ê¸°"""
    return _context_manager.find_symbol(symbol_name)

def track_file_access(file_path: str, operation: str = 'read'):
    """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """ì‘ì—… ì¶”ì  ìš”ì•½"""
    return _context_manager.get_work_tracking_summary()


# ===========================================
# Claude Desktop ì„¤ì • ë° ëª…ë ¹ì–´ ì²˜ë¦¬
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop ì„¤ì •ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_root': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_root'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"âš ï¸ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    return paths


def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> None:
    """/flow ëª…ë ¹ì–´ - í”„ë¡œì íŠ¸ ì „í™˜
    
    Args:
        project_name: ì „í™˜í•  í”„ë¡œì íŠ¸ëª…
        existing_context: ê¸°ì¡´ context (execute_code í™˜ê²½ìš©)
    """
    
    if not project_name:
        # í˜„ì¬ ìƒíƒœ í‘œì‹œ
        if _context_manager.project_name:
            print(f"\nğŸ”¥ í˜„ì¬ í”„ë¡œì íŠ¸: {_context_manager.project_name}")
            print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {_context_manager.project_path}")
            print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {_context_manager.memory_root}")
            print(get_work_tracking_summary())
        else:
            print("\nâš ï¸ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            print("ì‚¬ìš©ë²•: /flow [í”„ë¡œì íŠ¸ëª…]")
        return
    
    # ì´ì „ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
    if _context_manager.context:
        save_context()
    
    # ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    # execute_code í™˜ê²½ì—ì„œëŠ” Desktop ì§ì† ê²½ë¡œ ìš°ì„  í™•ì¸
    if existing_context:
        # Desktop ì§ì† ê²½ë¡œ ë¨¼ì € í™•ì¸
        desktop_path = paths['project_root'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            project_path = os.getcwd()
            location = 'current'
    else:
        # í”„ë¡œì íŠ¸ ê²½ë¡œ ì°¾ê¸° (Desktop ìš°ì„ , ê·¸ ë‹¤ìŒ ë©”ëª¨ë¦¬)
        project_path = paths['project_root'] / project_name
        location = 'desktop'
        
        if not project_path.exists():
            # ë©”ëª¨ë¦¬ ë£¨íŠ¸ í™•ì¸
            project_path = paths['memory_root'] / project_name
            location = 'memory'
            
            if not project_path.exists():
                # í˜„ì¬ ë””ë ‰í† ë¦¬ì—ì„œ ì°¾ê¸°
                if os.path.basename(os.getcwd()) == project_name:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\nâŒ í”„ë¡œì íŠ¸ '{project_name}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                    print(f"   â€¢ Desktop: {paths['project_root'] / project_name}")
                    print(f"   â€¢ Memory: {paths['memory_root'] / project_name}")
                    return
    
    # ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½ (execute_code í™˜ê²½ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ)
    if not existing_context:
        os.chdir(project_path)
    
    # Context ì´ˆê¸°í™” (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì™€ ê¸°ì¡´ context ì „ë‹¬)
    context = initialize_context(str(project_path), project_name, memory_root, existing_context)
    
    print(f"\nâœ… í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì™„ë£Œ!")
    print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {project_path} ({location})")
    print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {memory_root}/{project_name}/.cache/")
    print(f"ğŸ“Š ìºì‹œ ë²„ì „: {context.get('version', 'Unknown')}")
    
    # ê°„ë‹¨í•œ í†µê³„ í‘œì‹œ
    analyzed_files = context.get('cache', {}).get('analyzed_files', {})
    tasks = context.get('tasks', {})
    print(f"ğŸ“ˆ ë¶„ì„ëœ íŒŒì¼: {len(analyzed_files)}ê°œ")
    print(f"ğŸ“‹ ë‚¨ì€ ì‘ì—…: {len(tasks.get('next', []))}ê°œ")
    print(f"âœ… ì™„ë£Œëœ ì‘ì—…: {len(tasks.get('done', []))}ê°œ")


# ===========================================
# ë©”ì¸ ì§„ì…ì 
# ===========================================



def cmd_plan(plan_name: str = None, description: str = None, ctx: Dict[str, Any] = None) -> None:
    """/plan ëª…ë ¹ì–´ - ìƒˆë¡œìš´ ê³„íš ìƒì„± (ê¸°ì¡´ ê³„íš ë¦¬ì…‹)
    
    Args:
        plan_name: ê³„íš ì´ë¦„
        description: ê³„íš ì„¤ëª…
    """
    ctx = ctx or (_context_manager.context if _context_manager else None)
    if not ctx:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € /flow [í”„ë¡œì íŠ¸ëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    if not plan_name:
        # í˜„ì¬ ê³„íš í‘œì‹œ
        if 'plan' in ctx and ctx['plan']:
            plan = ctx['plan']
            print(f"\nğŸ“‹ í˜„ì¬ ê³„íš: {plan['name']}")
            print(f"   ì„¤ëª…: {plan.get('description', 'N/A')}")
            print(f"   ìƒì„±: {plan.get('created_at', 'N/A')}")
            print(f"   ìˆ˜ì •: {plan.get('updated_at', 'N/A')}")
            print(f"\n   Phase ìˆ˜: {len(plan.get('phases', []))}ê°œ")
            
            for phase in plan.get('phases', []):
                status_emoji = "âœ…" if phase['status'] == 'done' else "ğŸ”„" if phase['status'] == 'in_progress' else "â³"
                print(f"\n   {status_emoji} {phase['name']}")
                for task in phase.get('tasks', []):
                    task_emoji = "âœ…" if task['status'] == 'done' else "ğŸ”„" if task['status'] == 'in_progress' else "â³"
                    print(f"      {task_emoji} [{task['id']}] {task['title']}")
        else:
            print("\nâš ï¸ í˜„ì¬ ì„¤ì •ëœ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤.")
            print("ì‚¬ìš©ë²•: /plan [ê³„íšëª…] [ì„¤ëª…]")
        return
    
    # ìƒˆ ê³„íš ìƒì„±
    timestamp = dt.datetime.now().isoformat()
    
    ctx['plan'] = {
        'name': plan_name,
        'description': description or f"{_context_manager.project_name} ì‘ì—… ê³„íš",
        'created_at': timestamp,
        'updated_at': timestamp,
        'phases': [],
        'current_phase': None,
        'current_task': None
    }
    
    # ê¸°ë³¸ Phase 1 ìƒì„±
    phase1 = {
        'id': 'phase-1',
        'name': 'Phase 1: ì´ˆê¸° ì‘ì—…',
        'status': 'pending',
        'tasks': []
    }
    
    _context_manager.context['plan']['phases'].append(phase1)
    _context_manager.context['plan']['current_phase'] = 'phase-1'
    
    save_context()
    print(f"\nâœ… ìƒˆ ê³„íš '{plan_name}' ìƒì„± ì™„ë£Œ!")
    print(f"   ì„¤ëª…: {ctx['plan']['description']}")
    if ctx['plan']['phases']:
        print(f"   Phase 1ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. /task add phase-1 [ì‘ì—…ëª…]ìœ¼ë¡œ ì‘ì—…ì„ ì¶”ê°€í•˜ì„¸ìš”.")


def cmd_task(action: str, *args, ctx: Dict[str, Any] = None) -> None:
    """/task ëª…ë ¹ì–´ - ì‘ì—… ì¶”ê°€/ìˆ˜ì •
    
    Args:
        action: add, edit, delete, move
        args: ì•¡ì…˜ë³„ ì¸ì
    """
    if not _context_manager.context or 'plan' not in _context_manager.context:
        print("âŒ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € /plan [ê³„íšëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    plan = ctx['plan']
    
    if action == 'add':
        # /task add [phase-id] [task-title] [description]
        if len(args) < 2:
            print("ì‚¬ìš©ë²•: /task add [phase-id] [ì‘ì—…ëª…] [ì„¤ëª…(ì„ íƒ)]")
            return
            
        phase_id = args[0]
        task_title = args[1]
        task_desc = args[2] if len(args) > 2 else ""
        
        # Phase ì°¾ê¸°
        phase = next((p for p in plan['phases'] if p['id'] == phase_id), None)
        if not phase:
            print(f"âŒ Phase '{phase_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # ìƒˆ Task ID ìƒì„±
        phase_num = phase_id.split('-')[1]
        task_num = len(phase['tasks']) + 1
        new_task = {
            'id': f'{phase_num}-{task_num}',
            'title': task_title,
            'description': task_desc,
            'status': 'pending',
            'subtasks': []
        }
        
        phase['tasks'].append(new_task)
        plan['updated_at'] = dt.datetime.now().isoformat()
        save_context()
        
        print(f"âœ… Task ì¶”ê°€ë¨: [{new_task['id']}] {task_title}")
        
    elif action == 'edit':
        # /task edit [task-id] status|title|desc [new-value]
        if len(args) < 3:
            print("ì‚¬ìš©ë²•: /task edit [task-id] status|title|desc [ìƒˆê°’]")
            return
            
        task_id = args[0]
        field = args[1]
        new_value = ' '.join(args[2:])
        
        # Task ì°¾ê¸°
        task_found = False
        for phase in plan['phases']:
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if field == 'status' and new_value in ['pending', 'in_progress', 'done', 'blocked']:
                        task['status'] = new_value
                    elif field == 'title':
                        task['title'] = new_value
                    elif field in ['desc', 'description']:
                        task['description'] = new_value
                    else:
                        print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” í•„ë“œ: {field}")
                        return
                    
                    task_found = True
                    plan['updated_at'] = dt.datetime.now().isoformat()
                    save_context()
                    print(f"âœ… Task [{task_id}] {field} ìˆ˜ì •ë¨")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"âŒ Task '{task_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    elif action == 'list':
        # í˜„ì¬ ëª¨ë“  task í‘œì‹œ
        print("\nğŸ“‹ ì „ì²´ Task ëª©ë¡:")
        for phase in plan['phases']:
            status_emoji = "âœ…" if phase['status'] == 'done' else "ğŸ”„" if phase['status'] == 'in_progress' else "â³"
            print(f"\n{status_emoji} {phase['name']} ({phase['id']})")
            for task in phase['tasks']:
                task_emoji = "âœ…" if task['status'] == 'done' else "ğŸ”„" if task['status'] == 'in_progress' else "ğŸ“Œ" if task['status'] == 'blocked' else "â³"
                current = " ğŸ‘ˆ í˜„ì¬" if plan.get('current_task') == task['id'] else ""
                print(f"   {task_emoji} [{task['id']}] {task['title']}{current}")
                if task['description']:
                    print(f"      ğŸ“ {task['description']}")
    
    else:
        print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ì•¡ì…˜: {action}")
        print("ì‚¬ìš© ê°€ëŠ¥í•œ ì•¡ì…˜: add, edit, list")


def cmd_next(ctx: Dict[str, Any] = None) -> None:
    """/next ëª…ë ¹ì–´ - ë‹¤ìŒ ì‘ì—…ìœ¼ë¡œ ì§„í–‰
    
    í˜„ì¬ ì‘ì—…ì„ ì™„ë£Œë¡œ í‘œì‹œí•˜ê³  ë‹¤ìŒ pending ì‘ì—…ìœ¼ë¡œ ì´ë™
    """
    if not _context_manager.context or 'plan' not in _context_manager.context:
        print("âŒ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € /plan [ê³„íšëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    plan = ctx['plan']
    
    # í˜„ì¬ ì‘ì—…ì´ ìˆìœ¼ë©´ ì™„ë£Œë¡œ í‘œì‹œ
    if plan.get('current_task'):
        for phase in plan['phases']:
            for task in phase['tasks']:
                if task['id'] == plan['current_task']:
                    if task['status'] != 'done':
                        task['status'] = 'done'
                        print(f"âœ… Task [{task['id']}] {task['title']} ì™„ë£Œ!")
    
    # ë‹¤ìŒ pending ì‘ì—… ì°¾ê¸°
    next_task = None
    next_phase = None
    
    for phase in plan['phases']:
        if phase['status'] == 'done':
            continue
            
        for task in phase['tasks']:
            if task['status'] == 'pending':
                next_task = task
                next_phase = phase
                break
        
        if next_task:
            break
    
    if next_task:
        # í˜„ì¬ ì‘ì—… ì„¤ì •
        plan['current_task'] = next_task['id']
        plan['current_phase'] = next_phase['id']
        next_task['status'] = 'in_progress'
        next_phase['status'] = 'in_progress'
        
        plan['updated_at'] = dt.datetime.now().isoformat()
        save_context()
        
        print(f"\nğŸ¯ ë‹¤ìŒ ì‘ì—…: [{next_task['id']}] {next_task['title']}")
        if next_task['description']:
            print(f"   ğŸ“ ì„¤ëª…: {next_task['description']}")
        print(f"   ğŸ“ Phase: {next_phase['name']}")
        
        # ì„œë¸ŒíƒœìŠ¤í¬ê°€ ìˆìœ¼ë©´ í‘œì‹œ
        if next_task.get('subtasks'):
            print(f"\n   ğŸ“Œ ì„œë¸ŒíƒœìŠ¤í¬:")
            for subtask in next_task['subtasks']:
                print(f"      - {subtask['title']}")
    else:
        # ëª¨ë“  ì‘ì—… ì™„ë£Œ í™•ì¸
        all_done = True
        for phase in plan['phases']:
            for task in phase['tasks']:
                if task['status'] != 'done':
                    all_done = False
                    break
            if not all_done:
                break
        
        if all_done:
            print("\nğŸ‰ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
        else:
            print("\nâš ï¸ ì§„í–‰ ê°€ëŠ¥í•œ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤. (blocked ì‘ì—… í™•ì¸ í•„ìš”)")


def process_command(command: str, existing_context: Dict[str, Any] = None) -> Any:
    """ëª…ë ¹ì–´ ì²˜ë¦¬
    
    Args:
        command: ì²˜ë¦¬í•  ëª…ë ¹ì–´
        existing_context: ê¸°ì¡´ context (execute_code í™˜ê²½ìš©)
        
    Returns:
        ëª…ë ¹ì–´ ì‹¤í–‰ ê²°ê³¼
    """
    parts = command.strip().split()
    if not parts:
        return None
    
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    if cmd == '/flow':
        project_name = args[0] if args else None
        return cmd_flow(project_name, existing_context)
    
    elif cmd == '/plan':
        if len(args) == 0:
            return cmd_plan()
        elif len(args) == 1:
            return cmd_plan(args[0])
        else:
            # ì²« ë²ˆì§¸ ì¸ìëŠ” ê³„íšëª…, ë‚˜ë¨¸ì§€ëŠ” ì„¤ëª…
            return cmd_plan(args[0], ' '.join(args[1:]))
    
    elif cmd == '/task':
        if not args:
            print("ì‚¬ìš©ë²•: /task add|edit|list [ì¸ì...]")
            return None
        return cmd_task(args[0], *args[1:])
    
    elif cmd == '/next':
        return cmd_next()
    
    else:
        print(f"ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {cmd}")
        print("ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´: /flow, /plan, /task, /next")
        return None
