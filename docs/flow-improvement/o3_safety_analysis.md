# Flow 시스템 타입 안전성 및 에러 처리 분석 보고서

생성일: 2025-07-23T00:42:46.522902
분석 도구: o3 (high effort)

## 분석 결과

{'answer': '아래 제안은 “타입 안전성 강화”와 “견고한 런타임-에러 처리”라는 두 축을 동시에 달성하도록 설계되었습니다.  \n핵심 전략은 다음과 같습니다.\n\n1. 정적 타입 보강: Any → 구체적 타입, Frozen Dataclass, TypedDict, mypy/pyright strict 모드.  \n2. 모델 단위 검증: __post_init__ + 전담 Validator, 커스텀 예외 계층.  \n3. (De)Serializer 경량 래퍼: try/except 집중, datetime 파싱 래퍼, Enum 강제 변환.  \n4. 영속 계층 분리(Repository 패턴): 파일 I/O 예외 포착 + 원자적(atomic) 저장.  \n5. 테스트/CI: 유형 검증 + 예외 흐름 테스트.\n\n────────────────────────────────────────\n1. 예외 계층 정의\n────────────────────────────────────────\nclass FlowError(Exception): """루트 예외"""\n\nclass ValidationError(FlowError): """도메인 검증 실패"""\n\nclass SerializationError(FlowError): """직렬화/역직렬화 오류"""\n\nclass StorageError(FlowError): """파일·DB 접근 오류"""\n\n도메인 코드에서는 “raise ValidationError(…\u200b)” 정도만 알면 되고, 호출 측은 FlowError 단일 루트만 catch 하도록 설계해 추상화를 유지합니다.\n\n────────────────────────────────────────\n2. 타입 선언 & 도메인 검증\n────────────────────────────────────────\n(1) Frozen Dataclass + __post_init__\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Dict, Optional, TypedDict\nfrom enum import Enum\n\nclass TaskStatus(str, Enum):\n    TODO         = "todo"\n    PLANNING     = "planning"\n    IN_PROGRESS  = "in_progress"\n    REVIEWING    = "reviewing"\n    COMPLETED    = "completed"\n    SKIP         = "skip"\n    ERROR        = "error"\n\nclass TaskDict(TypedDict):\n    id: str\n    name: str\n    status: str\n    created_at: str\n    updated_at: str\n    started_at: Optional[str]\n    completed_at: Optional[str]\n    context: Dict[str, object]\n\ndef _parse_dt(value: str | None) -> datetime | None:\n    if value is None:\n        return None\n    try:\n        return datetime.fromisoformat(value)\n    except ValueError as e:\n        raise SerializationError(f"날짜 파싱 실패: {value}") from e\n\n@dataclass(frozen=True, slots=True)\nclass Task:\n    id: str\n    name: str\n    status: TaskStatus = TaskStatus.TODO\n    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    context: Dict[str, object] = field(default_factory=dict)\n\n    # 사후 검증\n    def __post_init__(self):\n        if not self.id or not self.name:\n            raise ValidationError("id, name 는 비어 있을 수 없습니다.")\n        if self.completed_at and self.started_at and self.completed_at < self.started_at:\n            raise ValidationError("completed_at 은 started_at 이후여야 합니다.")\n        if self.updated_at < self.created_at:\n            raise ValidationError("updated_at 은 created_at 이상이어야 합니다.")\n\n    # 직렬화\n    def to_dict(self) -> TaskDict:\n        return TaskDict(\n            id          = self.id,\n            name        = self.name,\n            status      = self.status.value,\n            created_at  = self.created_at.isoformat(),\n            updated_at  = self.updated_at.isoformat(),\n            started_at  = self.started_at.isoformat()   if self.started_at   else None,\n            completed_at= self.completed_at.isoformat() if self.completed_at else None,\n            context     = self.context\n        )\n\n    # 역직렬화\n    @classmethod\n    def from_dict(cls, data: TaskDict) -> "Task":\n        try:\n            status = TaskStatus(data["status"])\n        except ValueError as e:\n            raise ValidationError(f"지원하지 않는 status: {data[\'status\']}") from e\n\n        return cls(\n            id=data["id"],\n            name=data["name"],\n            status=status,\n            created_at=_parse_dt(data["created_at"]) or datetime.now(timezone.utc),\n            updated_at=_parse_dt(data["updated_at"]) or datetime.now(timezone.utc),\n            started_at=_parse_dt(data.get("started_at")),\n            completed_at=_parse_dt(data.get("completed_at")),\n            context=data.get("context", {})\n        )\n\n동일한 방식으로 Plan 에도 __post_init__ 검증(중복 Task id, Plan 완료 여부 등)을 넣어 주면 됨.\n\n(2) Any 제거  \ncontext 필드가 “임의 데이터”라 어쩔 수 없이 Dict[str, object] 로 남지만, 시스템 내부에서 사용하는 key 는 Literal["…\u200b"] 타입을 지정한 helper 모델을 별도로 두면 mypy 도 추론 가능.\n\n────────────────────────────────────────\n3. (De)Serializer 집중 에러 처리\n────────────────────────────────────────\n• datetime 파싱과 Enum 변환에서 발생하는 ValueError, KeyError 를 SerializationError 로 감쌉니다.  \n• 호출 측은 try: Task.from_dict(data) except FlowError: …\u200b 로 일관된 인터페이스를 사용.\n\n────────────────────────────────────────\n4. 파일 I/O (Repository) 계층\n────────────────────────────────────────\nimport json\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom typing import Final\n\n_JSON_OPTS: Final = dict(ensure_ascii=False, indent=2)\n\nclass PlanRepository:\n    def __init__(self, root: Path):\n        self._root = root\n\n    def _path(self, plan_id: str) -> Path:\n        return self._root / f"{plan_id}.json"\n\n    def save(self, plan: "Plan") -> None:\n        path = self._path(plan.id)\n        try:\n            # 원자적 저장: tmp → rename\n            with NamedTemporaryFile("w", delete=False, dir=path.parent, encoding="utf-8") as tmp:\n                json.dump(plan.to_dict(), tmp, **_JSON_OPTS)\n                tmp.flush()\n                os.fsync(tmp.fileno())\n            os.replace(tmp.name, path)\n        except (OSError, json.JSONDecodeError) as e:\n            raise StorageError(f"Plan 저장 실패: {plan.id}") from e\n\n    def load(self, plan_id: str) -> "Plan":\n        path = self._path(plan_id)\n        try:\n            with open(path, encoding="utf-8") as fp:\n                data = json.load(fp)\n            return Plan.from_dict(data)\n        except FileNotFoundError as e:\n            raise StorageError(f"Plan 파일 없음: {plan_id}") from e\n        except json.JSONDecodeError as e:\n            raise StorageError(f"JSON 파싱 오류({plan_id})") from e\n        except FlowError:\n            # Validation/SerializationError 그대로 상위로 전파\n            raise\n        except OSError as e:\n            raise StorageError(f"Plan 로드 실패: {plan_id}") from e\n\n장점  \n• 파일·직렬화 오류를 StorageError 로 집약.  \n• 상위 계층(사용자 인터페이스, API)에서는 except FlowError 로 단일 처리 가능.  \n• NamedTemporaryFile + os.replace → 전원 꺼져도 중간 파일 손상 최소화.\n\n────────────────────────────────────────\n5. 정적 검사 & 테스트\n────────────────────────────────────────\n• mypy --strict / pyright --strict 설정  \n  - Any 사용 시 경고, datetime | None 누락 체크.  \n• pytest 로 Happy-path + 에러-path (잘못된 status, 날짜 역전, 파일 손상) 케이스 작성.  \n• pre-commit 훅: isort, black, ruff, mypy.\n\n────────────────────────────────────────\n6. 부가 개선 체크리스트\n────────────────────────────────────────\n• timezone-aware datetime (UTC) 일관 적용.  \n• 구조체 변경 시 마이그레이션 레이어(버전 넘버 포함) 마련.  \n• to_dict()/from_dict() 는 가능하면 jsonable_encoder 와 같은 “버전 고정 프록시”로 감싸 호환성 보장.  \n• Enum → Literal 전파: 함수 인수에서 status: Literal["todo","planning",…\u200b] → IDE 자동완성 강화.  \n• context 에 스키마가 필요한 경우 pydantic BaseModel 로 세분화.  \n• Optional 필드의 None 처리 대신 NullObject 패턴 도입 검토(예: NotStarted = datetime.min.replace(tzinfo=UTC)).\n\n────────────────────────────────────────\n결론\n────────────────────────────────────────\n1. 도메인 모델에 불변성(Frozen dataclass)과 __post_init__ 검증을 넣어 “타입은 맞는데 값이 이상한” 오류를 사전에 차단합니다.  \n2. 커스텀 예외 계층을 정의하고 (De)Serializer·Repository 레이어에서 try/except 를 집중시켜 호출자가 FlowError 하나만 처리하도록 만듭니다.  \n3. 파일 I/O 는 Repository 패턴 + 원자적 저장 + 상세 예외 매핑(StorageError)로 견고성을 확보합니다.  \n4. mypy/pyright strict, 테스트 케이스를 통해 정적·동적 품질을 동시에 확보합니다.', 'reasoning_effort': 'high', 'usage': {'prompt_tokens': 1109, 'completion_tokens': 2640, 'total_tokens': 3749, 'reasoning_tokens': 0}}
