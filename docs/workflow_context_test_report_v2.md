# 워크플로우-컨텍스트매니저 연계 테스트 보고서

## 테스트 일시
- 2025-07-07 16:28 ~ 16:33

## 테스트 목적
워크플로우 시스템과 컨텍스트 매니저의 연동 상태를 점검하고, 워크플로우 진행사항 추적 및 컨텍스트 자동 업데이트 메커니즘이 제대로 작동하는지 검증하기 위함입니다. 특히 **WorkflowManager**와 **ContextManager** 간의 데이터 공유, 이벤트 전달, 파일 기록 연결 등이 정상적으로 이루어지는지 확인하는 데 초점을 두었습니다.

## 테스트 결과

### ✅ 정상 동작 확인 항목

#### WorkflowManager 주요 기능 검증
- 새 계획(Plan) 생성 및 관리 기능 정상 작동 ✓
- 태스크(Task) 추가 및 상태 변경 (TODO → IN_PROGRESS → COMPLETED 등) 정상 처리 ✓
- 진행률 자동 계산 (예: 0% → 33.3% → 66.7% → 100%) 정확히 반영 ✓
- `workflow.json` 파일이 원자적 쓰기로 자동 저장되어 데이터 무결성 확보 ✓
- 계획 완료 시 해당 Plan이 기록(히스토리)으로 이동 처리 ✓

#### 데이터 구조 정상 확인
- **Plan** 객체가 `id`, `name`, `status`, `tasks[]`, `created_at`, `updated_at` 등의 필드로 구조화되어 정상 관리됨
- **Task** 객체가 `id`, `title`, `description`, `status`, `started_at`, `completed_at`, `completion_notes` 등의 필드를 포함하여 개별 작업을 표현함
- **TaskStatus** 열거형에 `TODO`, `IN_PROGRESS`, `COMPLETED`, `BLOCKED`, `CANCELLED`, `APPROVED`, `PENDING` 등의 상태 값이 정의되어 있음

#### 파일 저장 메커니즘 확인
- **즉시 저장:** 워크플로우 상태가 변경될 때마다 즉시 `workflow.json`에 저장이 이루어짐
- **원자적 쓰기:** 임시 파일을 활용한 원자적 쓰기로 저장하여 중간에 파일 손상이 없도록 함
- **구조화된 JSON:** 모든 워크플로우 데이터가 JSON 형식으로 구조화되어 저장되며, 나중에 로드 시 구조를 복원할 수 있음

### ⚠️ 문제점 및 제한사항

#### 순환 import 문제
`context_manager.py` ↔ `workflow_integration.py` ↔ `workflow/commands.py` 모듈 간에 순환 의존성이 발생했습니다. 이로 인해 helpers 모듈의 일부 워크플로우 함수가 제대로 로드되지 못하며, 현재 구조에서는 **ContextManager**와 **WorkflowManager**를 직접 통합하기 어려운 상황입니다.

#### 컨텍스트 연동 부재
워크플로우에서 이루어지는 작업 사항이 **컨텍스트(context.json)**에 전혀 반영되지 않고 있습니다. 예를 들어:
- 워크플로우에서 Task 상태가 변해도 `context.json` 내 프로젝트 컨텍스트 데이터가 업데이트되지 않음
- 파일 접근 추적 기능은 동작하지만, 어느 작업(Task) 중에 파일이 접근되었는지 식별할 수 있는 `task_id` 연결 정보가 없음
- 결과적으로 워크플로우 진행에 따른 컨텍스트 자동 업데이트 메커니즘이 작동하지 않고 있음

#### API 불일치
WorkflowManager의 `add_task()` 호출 시 내부적으로 `Plan.add_task()`를 사용하는 것으로 보이지만, **Plan** 클래스에 `add_task` 메서드가 구현되어 있지 않습니다. 이 불일치로 인해 태스크 추가 동작에 혼란이 있고, 또한 일부 helpers용 워크플로우 함수들이 예상과 달리 `None`을 반환하는 문제가 확인되었습니다.

## 개선 제안

### 1. 모듈 구조 개선
모듈 간 **순환 의존성**을 제거하여 로드 순서를 안정화해야 합니다. 이를 위해 워크플로우와 컨텍스트 매니저 사이의 직접 참조를 피하고, 공용 인터페이스나 추상 레이어로 분리합니다. 예를 들어, 컨텍스트 업데이트에 필요한 함수를 별도 모듈로 추출하거나, 양측이 의존하는 이벤트 인터페이스를 정의하는 방법이 있습니다. 또한 **이벤트 버스(event bus) 패턴**을 도입하면 한쪽에서 발생한 이벤트를 중앙 버스를 통해 전달하여 모듈들이 **느슨하게 결합(loose coupling)**되도록 만들 수 있습니다.

### 2. 통합 레이어 구축
워크플로우 진행과 컨텍스트 관리를 연결해주는 별도의 브릿지(bridge) 레이어를 구현합니다. 예를 들어 `WorkflowContextBridge` 클래스에서 다음과 같은 이벤트 처리 메서드를 제공하도록 합니다:
- `on_task_start(task_id)`: 작업 시작 시 컨텍스트 매니저에 해당 Task의 시작을 기록
- `on_file_access(file_path, operation)`: 파일 접근 발생 시 현재 작업 ID와 함께 컨텍스트에 기록

이러한 브릿지에서는 WorkflowManager나 ContextManager의 내부 구현에 직접 의존하지 않고, **콜백**이나 **신호(signal)**를 통해 이벤트만 받아 처리합니다. 이를 통해 워크플로우 상의 이벤트(태스크 시작/완료, 파일 접근 등)가 발생할 때 컨텍스트 매니저 쪽에 자동으로 해당 내역이 반영되도록 할 수 있습니다.

### 3. 테스트 환경 개선
통합 기능을 검증하기 위한 **테스트 시나리오**와 환경을 정비합니다. 구체적으로, 순환 import 문제를 피할 수 있도록 모듈을 리팩토링한 뒤, 워크플로우-컨텍스트매니저 연계 동작을 전반적으로 시험하는 통합 테스트 스크립트를 작성합니다. 이 테스트에서는 새로운 계획 생성부터 태스크 추가/진행/완료까지 일련의 과정을 수행하고, 그 동안 `context.json`과 `workflow.json`이 올바르게 업데이트되는지 확인합니다. 또한, 에러가 발생했던 helpers 함수들도 실제 시나리오에서 정상적으로 값(또는 예외)을 반환하는지 검증하여, 이전에 확인된 `None` 반환 문제가 해결됐는지 확인해야 합니다.

## 결론
이번 테스트를 통해 **WorkflowManager** 자체는 의도한 대로 동작하고 있음을 확인했지만, **ContextManager**와의 통합에서는 구조적인 문제가 드러났습니다. 핵심 이슈는 모듈 간 순환 참조와 연동 부족으로 인한 데이터 불일치입니다. 따라서 향후 **모듈 의존성을 정리**하고 **이벤트 기반 아키텍처**로 전환함으로써 두 시스템의 연결을 개선해야 합니다. 이러한 개선이 이루어지면 워크플로우 진행 상황이 실시간으로 컨텍스트에 반영되고, 전체 시스템의 신뢰성과 유지보수성이 향상될 것으로 기대됩니다.

## 전반적인 해결책
궁극적으로 워크플로우-컨텍스트매니저 간 연계를 위해서는 **이벤트 중심의 느슨한 결합 구조**로 재설계하는 것이 가장 효과적인 해결책입니다. 워크플로우에서 발생하는 이벤트(예: 작업 추가, 시작, 완료 또는 파일 접근 등)를 **이벤트 버스**를 통해 브로드캐스트하고, 컨텍스트 매니저가 이러한 이벤트를 수신하여 **컨텍스트 데이터를 즉각 갱신**하도록 하는 방식을 제안합니다. 이를 구현하기 위해 앞서 제안한 대로 모듈 간 인터페이스를 분리하고, `WorkflowContextBridge`와 같은 중재 레이어에서 이벤트 핸들러를 관리하면 됩니다. 이런 구조에서는 WorkflowManager와 ContextManager가 서로 직접 호출을 하지 않으므로 **순환 의존 문제를 원천 차단**할 수 있고, 워크플로우의 진행 상황과 컨텍스트 상태가 항상 동기화되어 일관성을 유지할 수 있습니다. 시스템 전반에 걸쳐 이러한 **이벤트 주도 통합**을 적용하는 것이 향후 안정적인 확장과 유지보수에 필수적인 해결책입니다.
