#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
FLOW Command - AI Coding Brain MCP
/flow 명령어 처리


# Wisdom 시스템 통합
try:
    from ..project_wisdom import get_wisdom_manager
    from ..wisdom_hooks import get_wisdom_hooks
    WISDOM_AVAILABLE = True
except ImportError:
    WISDOM_AVAILABLE = False

작성일: 2025-06-20
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from core.context_manager import get_context_manager
from core.config import get_paths_from_config
from api.public import initialize_context
from core.project_summary import generate_project_context_summary

# ===========================================
# FLOW 명령어
# ===========================================


def get_last_activity_time(context):
    """최근 작업 시간 계산"""
    work_tracking = context.get('work_tracking', {})
    if work_tracking and 'file_access' in work_tracking:
        last_times = []
        for file_data in work_tracking['file_access'].values():
            if file_data.get('last_read'):
                last_times.append(file_data['last_read'])
            if file_data.get('last_write'):
                last_times.append(file_data['last_write'])
        if last_times:
            return max(last_times)
    return None

def get_most_accessed_files(context, limit=5):
    """가장 많이 접근한 파일 목록"""
    work_tracking = context.get('work_tracking', {})
    if work_tracking and 'file_access' in work_tracking:
        file_access = work_tracking['file_access']
        sorted_files = sorted(
            file_access.items(),
            key=lambda x: x[1].get('read_count', 0) + x[1].get('write_count', 0),
            reverse=True
        )
        return [
            {
                'file': path,
                'read_count': data.get('read_count', 0),
                'write_count': data.get('write_count', 0)
            }
            for path, data in sorted_files[:limit]
        ]
    return []

def get_recent_edits(context, limit=5):
    """최근 수정 내역"""
    work_tracking = context.get('work_tracking', {})
    if work_tracking and 'function_edits' in work_tracking:
        edits = []
        for func_name, data in work_tracking['function_edits'].items():
            edits.append({
                'function': func_name,
                'file': data.get('file_path'),
                'last_edit': data.get('last_edit'),
                'edit_count': data.get('edit_count', 0)
            })
        # 최근 수정 순으로 정렬
        edits.sort(key=lambda x: x.get('last_edit', ''), reverse=True)
        return edits[:limit]
    return []

def get_tasks_completed_today(tasks):
    """오늘 완료된 작업 수"""
    if not tasks or 'done' not in tasks:
        return 0
    
    from datetime import datetime, date
    today = date.today()
    count = 0
    
    for task in tasks.get('done', []):
        if 'completed_at' in task:
            try:
                completed_date = datetime.fromisoformat(task['completed_at'].replace('Z', '+00:00')).date()
                if completed_date == today:
                    count += 1
            except:
                pass
    return count

def get_phase_progress(plan):
    """현재 Phase의 진행률"""
    if not plan or 'current_phase' not in plan:
        return None
    
    current_phase_id = plan['current_phase']
    phases = plan.get('phases', {})
    
    if current_phase_id in phases:
        phase = phases[current_phase_id]
        tasks = phase.get('tasks', [])
        if not tasks:
            return 0
        completed = sum(1 for task in tasks if task.get('status') == 'completed')
        return {
            'completed': completed,
            'total': len(tasks),
            'percentage': round(completed / len(tasks) * 100, 1)
        }
    return None



def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """/flow 명령어 - 프로젝트 전환"""
    
    # 버전 패턴 정의 (함수 초반에 정의)
    import re
    version_patterns = [
        r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
        r'^app-\d+\.\d+\.\d+$',
        r'^project-\d+\.\d+\.\d+$',
        r'^v\d+\.\d+\.\d+$'
    ]
    
    # 현재 작업 디렉토리가 버전 패턴인지 확인
    current_dir_name = os.path.basename(os.getcwd())
    is_version_pattern = any(re.match(pattern, current_dir_name) for pattern in version_patterns)
    
    if is_version_pattern:
        print(f"⚠️ 현재 디렉토리 '{current_dir_name}'는 버전 패턴입니다.")
        print("   MCP 서버가 잘못된 위치에서 실행되고 있습니다.")
        
        # config에서 실제 프로젝트 경로 찾기
        from ..core.config import get_paths_from_config
        paths = get_paths_from_config()
        
        # project_name이 주어진 경우, 해당 프로젝트 찾기
        if project_name:
            print(f"   프로젝트 '{project_name}'를 검색합니다...")
        else:
            print("   프로젝트명을 지정해주세요.")
            return {"success": False, "message": "버전 패턴 디렉토리에서는 프로젝트명을 명시해야 합니다"}
    else:
        # 기존 경로 설정 로직
        paths = get_paths_from_config()
    
    memory_root = str(paths['memory_root'])
    
    if not project_name:
        # 프로젝트 목록 표시
        print("\n📋 등록된 프로젝트 목록:")
        print("="*60)
        
        project_count = 0
        if os.path.exists(memory_root):
            import re
            version_patterns = [
                r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
                r'^app-\d+\.\d+\.\d+$',
                r'^project-\d+\.\d+\.\d+$',
                r'^v\d+\.\d+\.\d+$'
            ]
            
            for item in sorted(os.listdir(memory_root)):
                is_version_pattern = any(re.match(pattern, item) for pattern in version_patterns)
                if is_version_pattern:
                    continue
                    
                item_path = os.path.join(memory_root, item)
                if os.path.isdir(item_path) and item != 'common':
                    # 새로운 캐시 파일 위치 확인
                    cache_file = os.path.join(item_path, '.cache', 'cache_core.json')
                    if os.path.exists(cache_file):
                        try:
                            with open(cache_file, 'r', encoding='utf-8') as f:
                                cache_data = json.load(f)
                                actual_path = cache_data.get('project_path', 'Unknown')
                                last_accessed = cache_data.get('updated_at', 'Unknown')
                                
                                current_marker = " 🔥" if get_context_manager().project_name == item else ""
                                print(f"  • {item}{current_marker}")
                                print(f"    📁 경로: {actual_path}")
                                print(f"    🕐 최근 접근: {last_accessed[:10] if last_accessed != 'Unknown' else 'Unknown'}")
                                project_count += 1
                        except:
                            print(f"  • {item} (캐시 읽기 실패)")
        
        if project_count == 0:
            print("  등록된 프로젝트가 없습니다.")
        else:
            print(f"\n총 {project_count}개의 프로젝트")
            
        print("\n사용법: /flow [프로젝트명]")
        return {
            'success': True,
            'message': '프로젝트 목록 표시 완료',
            'project_count': project_count,
            'action': 'list_projects'
        }
    
    # 이전 컨텍스트 저장
    if get_context_manager().context and get_context_manager().project_name:
        import re
        version_patterns = [
            r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
            r'^app-\d+\.\d+\.\d+$',
            r'^project-\d+\.\d+\.\d+$',
            r'^v\d+\.\d+\.\d+$'
        ]
        is_version_pattern = any(re.match(pattern, get_context_manager().project_name) for pattern in version_patterns)
        
        if not is_version_pattern:
            prev_cache_dir = os.path.join(memory_root, get_context_manager().project_name, '.cache')
            if os.path.exists(prev_cache_dir):
                get_context_manager().save()
    
    # Memory 폴더에서 프로젝트 캐시 확인
    project_cache_dir = os.path.join(memory_root, project_name, '.cache')
    cache_file = os.path.join(project_cache_dir, 'cache_core.json')
    
    project_path = None
    location = 'unknown'
    
    if os.path.exists(cache_file):
        # 캐시에서 프로젝트 경로 읽기
        try:
            with open(cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                cached_path = cache_data.get('project_path')
                
                if cached_path and os.path.exists(cached_path):
                    project_path = Path(cached_path)
                    location = 'cached'
                    print(f"\n✅ Memory에서 프로젝트 찾음: {project_name}")
        except Exception as e:
            print(f"\n⚠️ 캐시 읽기 실패: {e}")
    
    # 캐시에 없거나 경로가 유효하지 않으면 새로 찾기
    if not project_path:
        desktop_path = paths['project_path'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            if os.path.basename(os.getcwd()) == project_name:
                project_path = Path(os.getcwd())
                location = 'current'
            else:
                if existing_context:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\n❌ 프로젝트 '{project_name}'를 찾을 수 없습니다")
                    return {
                        'success': False,
                        'message': f'프로젝트 경로를 찾을 수 없습니다: {project_name}',
                        'project_name': project_name
                    }
    
    # 작업 디렉토리 변경
    directory_changed = False
    directory_error = None
    
    try:
        # 디렉토리 존재 확인
        if not os.path.exists(str(project_path)):
            print(f"⚠️ 프로젝트 디렉토리가 존재하지 않습니다: {project_path}")
            # 디렉토리 생성 시도
            try:
                os.makedirs(str(project_path), exist_ok=True)
                print(f"✅ 프로젝트 디렉토리 생성됨: {project_path}")
            except Exception as create_err:
                print(f"❌ 디렉토리 생성 실패: {create_err}")
                directory_error = str(create_err)
        
        # 디렉토리 변경 시도
        os.chdir(str(project_path))
        current_dir = os.getcwd()
        if os.path.samefile(current_dir, str(project_path)):
            print(f"📂 작업 디렉토리 변경 성공: {project_path}")
            directory_changed = True
        else:
            print(f"⚠️ 작업 디렉토리 변경 실패: 현재 {current_dir}")
            directory_error = "디렉토리 변경 후 경로 불일치"
    except Exception as e:
        print(f"\n⚠️ 디렉토리 변경 실패: {e}")
        directory_error = str(e)
        # 실패해도 계속 진행 (캐시는 사용 가능)
    
    # 컨텍스트 초기화
    if 'context' in globals():
        globals()['context'].clear()
    
    context = initialize_context(
        project_path=str(project_path),
        project_name=project_name,
        memory_root=memory_root,
        existing_context=existing_context
    )
    
    print(f"\n✅ 프로젝트 '{project_name}'로 전환 완료!")
    print(f"📁 작업 경로: {project_path} ({location})")
    if directory_error:
        print(f"⚠️ 디렉토리 관련 경고: {directory_error}")
    print(f"💾 캐시 경로: {memory_root}/{project_name}/.cache/")
    print(f"📊 캐시 버전: {context.get('version', 'unknown')}")
    print(f"📈 분석된 파일: {len(context.get('analyzed_files', {}))}개")
    
    tasks = context.get('tasks', {})
    if isinstance(tasks, dict):
        next_count = len(tasks.get('next', []))
        done_count = len(tasks.get('done', []))
        print(f"📋 남은 작업: {next_count}개")
        print(f"✅ 완료된 작업: {done_count}개")

    
    # 현재 계획 정보 표시
    plan = context.get('plan')
    if plan:
        print(f"\n📅 현재 계획: {plan.get('name', 'N/A')}")
        current_task_id = context.get('current_task')
        if current_task_id:
            # 현재 작업 찾기
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        print(f"🎯 현재 작업: [{task['id']}] {task.get('title', 'N/A')}")
                        print(f"   상태: {task.get('status', 'pending')}")
                        break
        
        # Phase별 진행 상황
        print("\n📊 Phase별 진행 상황:")
        for phase_id, phase in plan.get('phases', {}).items():
            tasks = phase.get('tasks', [])
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            in_progress = sum(1 for t in tasks if t.get('status') == 'in_progress')
            
            status_icon = "✅" if phase.get('status') == 'completed' else "🔄" if in_progress > 0 else "📝"
            print(f"   {status_icon} {phase.get('name', phase_id)}: {completed}/{len(tasks)} 완료")

    # 글로벌 context 업데이트
    if 'context' in globals():
        globals()['context'].update(context)
    else:
        globals()['context'] = context
    
    
    # 폴더 구조 자동 캐싱 (새로 추가)
    try:
        # auto_tracking_wrapper의 cache_project_structure 직접 호출
        from auto_tracking_wrapper import cache_project_structure
        
        print("\n🔍 프로젝트 구조 캐싱 중...")
        structure = cache_project_structure(str(project_path))
        if structure:
            print(f"✅ 폴더 구조 캐시 완료: {structure['total_files']}개 파일, {structure['total_dirs']}개 디렉토리")
                
            # 주요 디렉토리 표시
            if 'structure' in structure and '/' in structure['structure']:
                root = structure['structure']['/']
            if 'children' in root:
                dirs = [d for d in root['children'] if structure['structure'].get(f"/{d}", {}).get('type') == 'directory']
                files = root.get('files', [])
                        
                print("\n📁 프로젝트 주요 구조:")
                print(f"   디렉토리 ({len(dirs)}개):")
                for d in sorted(dirs)[:10]:  # 상위 10개만
                    dir_info = structure['structure'].get(f"/{d}", {})
                    file_count = dir_info.get('file_count', 0)
                    print(f"      📂 {d}/ ({file_count}개 파일)")
                if len(dirs) > 10:
                    print(f"      ... 외 {len(dirs) - 10}개 디렉토리")
                        
                # 루트의 주요 파일들
                important_files = [f for f in files if f.endswith(('.md', '.json', '.py', '.ts', '.js')) and not f.startswith('.')]
                if important_files:
                    print(f"\n   주요 파일 ({len(important_files)}개):")
                    for f in sorted(important_files)[:5]:
                        print(f"      📄 {f}")
                    if len(important_files) > 5:
                        print(f"      ... 외 {len(important_files) - 5}개 파일")
    except Exception as e:
        import traceback
        print(f"⚠️ 폴더 구조 캐싱 실패: {e}")
        print(f"상세 에러: {traceback.format_exc()}")
    

    # 프로젝트 컨텍스트 요약 표시
    try:
        summary = generate_project_context_summary(context)
        print(summary)
    except Exception as e:
        print(f"\n⚠️ 컨텍스트 요약 생성 실패: {e}")
    
    pending_count = len(tasks.get('next', [])) if isinstance(tasks, dict) else 0
    completed_count = len(tasks.get('done', [])) if isinstance(tasks, dict) else 0
    
    return {
        'success': True,
        'message': f'프로젝트 \'{project_name}\' 전환 완료',
        'project_name': project_name,
        'project_root': str(project_path),
        'directory_changed': directory_changed,
        'directory_error': directory_error,
        'cache_info': {
            'analyzed_files': len(context.get('analyzed_files', {})),
            'pending_tasks': pending_count,
            'completed_tasks': completed_count,
            'cache_version': context.get('version', 'unknown')
        },
'context': {
            'project_name': context.get('project_name'),
            'project_id': context.get('project_id'), 
            'project_path': context.get('project_path'),
            'memory_root': context.get('memory_root'),
            'created_at': context.get('created_at'),
            'updated_at': context.get('updated_at'),
            'version': context.get('version'),
            'current_focus': context.get('current_focus'),
            'current_task': context.get('current_task'),
            'progress': context.get('progress'),
            'current_phase': plan.get('current_phase') if plan else None,
            'error_log': context.get('error_log', [])[-5:],  # 최근 5개만
            'metadata': context.get('metadata'),
            # 중요 정보 추가
            'analyzed_files': {
                path: {
                    'language': info.get('language'),
                    'functions': info.get('function_names', []),
                    'classes': info.get('class_names', []),
                    'last_analyzed': info.get('last_analyzed')
                }
                for path, info in context.get('analyzed_files', {}).items()
            },
            'recent_work': {
                'last_activity': get_last_activity_time(context),
                'most_accessed_files': get_most_accessed_files(context, 5),
                'recent_edits': get_recent_edits(context, 5)
            },
            'tasks': {
                'current': context.get('current_task'),
                'next': tasks.get('next', [])[:3] if tasks else [],  # 다음 3개 작업
                'completed_today': get_tasks_completed_today(tasks)
            },
            'plan_summary': {
                'name': plan.get('name') if plan else None,
                'current_phase': plan.get('current_phase') if plan else None,
                'phase_progress': get_phase_progress(plan) if plan else None
            },
            'file_access_history': context.get('file_access_history', [])[-10:]  # 최근 10개만
        }  # 균형잡힌 context
    }
# 명령어 처리 함수들 (cmd_plan, cmd_task, cmd_next)은 동일하므로 생략...


# ===========================================
# 메인 진입점
# ===========================================

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        command = ' '.join(sys.argv[1:])
        # process_command(command)
    else:
        print("AI Coding Brain v7.0 (캐시 구조 개선)")
        print("사용법: python claude_code_ai_brain.py [명령어]")
        print("명령어: /flow, /plan, /task, /next, /save")
