{
  "answer": "아래 설계는 “아무 것도 신경 쓰지 않고 Flow/Plan/Task/문서만 만들면 자동으로 Context 가 쌓이고  \n필요할 때 과거-패턴을 읽어 추천까지 받을 수 있는” 시스템을 목표로 합니다.\n\n─────────────────────────────\n1. 디렉터리 / 파일 구조\n─────────────────────────────\n.ai-brain/                       ‑ 시스템 루트(변경 가능)\n  └─ contexts/\n       ├─ docs_context.json      ‑ 전체 문서 메타\n       ├─ flow_<flow_id>/\n       │    ├─ context.json      ‑ Flow 레벨 메타\n       │    ├─ tasks/\n       │    │    └─ task_<id>.json\n       │    └─ plans/\n       │         └─ plan_<id>.json\n       └─ analytics/\n            └─ pattern_analysis.json   ‑ 주기적 패턴 분석 결과\n\n─────────────────────────────\n2. 핵심 개념\n─────────────────────────────\n• “ContextIntegration” = CRUD + 분석 엔진  \n• “Wrapper / Decorator”  = 기존 코드의 모든 진입점에 자동 삽입  \n•  ENV  : CONTEXT_SYSTEM=on/off  (fail-safe)  \n•  비차단(non-blocking) 기록 : 쓰기는 Thread / asyncio / Queue 선택 가능  \n•  주기적 분석 : analyze_patterns() 결과를 analytics/ 에 덤프 → UI, CLI, 슬랙봇 등에서 사용  \n\n─────────────────────────────\n3. ContextIntegration 구현 상세\n─────────────────────────────\n(필요 부분만 발췌)\n\nclass ContextIntegration:\n    ...\n    # ---------- Public  API ----------\n    def record_flow_action(self, flow_id, action_type, details):\n        ctx = self._load_flow(flow_id)\n        self._append_activity(\n            ctx, f\"flow_{action_type}\", details\n        )\n        self._save_flow(flow_id, ctx)\n\n    def record_task_action(self, flow_id, task_id, action_type, details):\n        self.record_flow_action(\n            flow_id,\n            f\"task_{action_type}\",\n            {\"task_id\": task_id, **details}\n        )\n        self._save_leaf(\n            flow_id, \"tasks\", f\"task_{task_id}.json\", details\n        )\n\n    def record_plan_action(self, flow_id, plan_id, action_type, details):\n        self.record_flow_action(\n            flow_id,\n            f\"plan_{action_type}\",\n            {\"plan_id\": plan_id, **details}\n        )\n        self._save_leaf(\n            flow_id, \"plans\", f\"plan_{plan_id}.json\", details\n        )\n\n    def record_doc_creation(self, doc_path, doc_type, related: dict):\n        dctx = self._load_json(self.docs_context_file)\n        now = datetime.now().isoformat()\n        dctx[\"documents\"][doc_path] = {\n            \"created_at\": now,\n            \"type\": doc_type,\n            \"related\": related,\n        }\n        self._append_activity(\n            dctx,\n            \"doc_created\",\n            {\"path\": doc_path, **related}\n        )\n        self._save_json(self.docs_context_file, dctx)\n\n    # ---------- Pattern Analysis ----------\n    def analyze_patterns(self):\n        \"\"\"\n        1) 모든 flow_xxx context 읽기\n        2) 최근 N개 action 시퀀스 추출\n        3) 통계/빈발 순서쌍, 평균 소요시간, 실패→재시도 패턴 등 계산\n        4) 'suggestions' 키에 human-readable 메시지 저장\n        \"\"\"\n        flows = self._iter_flows()\n        suggestions: List[str] = []\n        # (예시) 가장 빈번한 task 순서쌍 찾기\n        pair_counter = Counter()\n        for f in flows:\n            seq = [a[\"type\"] for a in f[\"recent_activities\"]]\n            pair_counter.update(zip(seq, seq[1:]))\n        if pair_counter:\n            (a, b), cnt = pair_counter.most_common(1)[0]\n            suggestions.append(\n                f\"작업 순서 상 '{a}' 이후 '{b}'가 {cnt}회 이어졌습니다. \"\n                f\"워크플로 템플릿으로 고정하는 것을 고려하세요.\"\n            )\n        ...\n        out = {\n            \"generated_at\": datetime.now().isoformat(),\n            \"suggestions\": suggestions,\n        }\n        self._save_json(\n            os.path.join(self.contexts_dir, \"analytics\", \"pattern_analysis.json\"),\n            out\n        )\n        return out\n\n    # ---------- 내부 헬퍼 ----------\n    def _append_activity(self, ctx, action_type, details):\n        ctx.setdefault(\"recent_activities\", [])\n        ctx[\"recent_activities\"].append(\n            {\"type\": action_type, \"details\": details,\n             \"timestamp\": datetime.now().isoformat()}\n        )\n        # 100개만 보존\n        ctx[\"recent_activities\"] = ctx[\"recent_activities\"][-100:]\n\n─────────────────────────────\n4. get_context_integration() (싱글턴)\n─────────────────────────────\n_context_singleton = None\n\ndef get_context_integration() -> ContextIntegration:\n    global _context_singleton\n    if _context_singleton is None:\n        _context_singleton = ContextIntegration()\n    return _context_singleton\n\n─────────────────────────────\n5. Wrapper 자동 호출 전략\n─────────────────────────────\nA. 고전적인 “함수 데코레이터” 방안  \n   1) @auto_record(type=\"task\") 와 같이 선언 → 최소 코드 변경  \n   2) 예외 처리 포함 (성공 / 실패 / 재시도 시각)  \n\n# auto_record.py\ndef auto_record(type_: str):\n    def decorator(fn):\n        @functools.wraps(fn)\n        def wrapper(self, *args, **kwargs):\n            if os.getenv(\"CONTEXT_SYSTEM\", \"off\") != \"on\":\n                return fn(self, *args, **kwargs)\n            cid = kwargs.get(\"context_id\") or getattr(self, \"id\", None)\n            flow_id = getattr(self, \"flow_id\", None)\n            start = datetime.now()\n            try:\n                record = {\"status\": \"started\"}\n                _push(type_, flow_id, cid, \"start\", record)\n                result = fn(self, *args, **kwargs)\n                record = {\"status\": \"success\",\n                          \"duration\": (datetime.now()-start).total_seconds()}\n                _push(type_, flow_id, cid, \"success\", record)\n                return result\n            except Exception as e:\n                record = {\"status\": \"failed\",\n                          \"error\": str(e),\n                          \"duration\": (datetime.now()-start).total_seconds()}\n                _push(type_, flow_id, cid, \"failed\", record)\n                raise\n        return wrapper\n    return decorator\n\nB. “Monkey-patch once” 방안 (플러그인 방식)  \n   enable_context_system() 호출 시,  \n   Flow.execute, Task.run 등 코어 메서드를 런타임에 감싸 자동 기록\n\ndef enable_context_system():\n    os.environ[\"CONTEXT_SYSTEM\"] = \"on\"\n    from flows import Flow, Task, Plan\n    Flow.execute = auto_record(\"flow\")(Flow.execute)\n    Task.run     = auto_record(\"task\")(Task.run)\n    Plan.execute = auto_record(\"plan\")(Plan.execute)\n\n─────────────────────────────\n6. 문서 / 레퍼런스 기록\n─────────────────────────────\nflow_context_wrapper.record_doc_creation() 제공\n  • 파일 생성 직후 호출하도록 템플릿 함수(또는 Jinja post-save hook) 배치  \n  • “related” 파라미터로 flow_id, task_id, plan_id, tag 목록 전달  \n  • 동일 경로 재등록 시 version++ 또는 overwrite 정책 선택 가능  \n\n─────────────────────────────\n7. 패턴 분석 스케줄링\n─────────────────────────────\n• cron / Airflow / Celery Beat / GitHub Action 으로 1시간 또는 하루 1회  \n• 실행:\n    from context_integration import get_context_integration\n    get_context_integration().analyze_patterns()\n• 결과 파일 읽어 CLI, Web Dashboard, Slack 메시지로 표출\n\n─────────────────────────────\n8. 성능 및 장애 대책\n─────────────────────────────\n• write() 를 Blocking I/O 로 두면 심플하지만 느림 →  \n  QueuedWriter(Threading) 또는 asyncio-to-file 로 개선 가능  \n• _ensure_directories(), _save_json() 에 file lock 사용 (fcntl/flock)  \n• CONTEXT_SYSTEM=off 일 때 wrapper 오버헤드 → 거의 zero  \n\n─────────────────────────────\n9. 통합 사용 예시\n─────────────────────────────\nfrom flow_context_wrapper import \\\n    record_task_action, record_plan_action, record_doc_creation\nfrom context_integration import enable_context_system\n\nenable_context_system()  # 한 줄이면 끝\n\nclass MyTask(Task):\n    @auto_record(\"task\")\n    def run(self):\n        ... # 실제 로직\n        record_doc_creation(\"reports/out.csv\", \"csv\",\n                            {\"flow_id\": self.flow_id, \"task_id\": self.id})\n\n# 실행\nflow = MyFlow()\nflow.execute()\n\n# 필요 시 패턴 분석\nget_context_integration().analyze_patterns()\n\n─────────────────────────────\n10. 기대 효과\n─────────────────────────────\n• Flow/Task/Plan/문서 생명주기를 그대로 재현할 수 있는 JSON 트레이스  \n• 패턴 분석 결과로 “자주 실패하는 Task”, “빈번한 작업 순서” 등 추천  \n• 추후 RAG, LLM 프롬프트 컨텍스트로 그대로 활용 가능  \n\n위 설계·코드 스니펫을 토대로 구현하면 “자동 기록 → 무중단 분석 → 추천” 파이프라인을 완성할 수 있습니다.",
  "reasoning_effort": "high",
  "usage": {
    "prompt_tokens": 815,
    "completion_tokens": 2693,
    "total_tokens": 3508,
    "reasoning_tokens": 0
  }
}