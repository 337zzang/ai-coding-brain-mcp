# o3 Analysis Result

## Task ID: o3_task_0005

### Question

    Flow Project 워크플로우 시스템의 아키텍처를 개선하기 위한 구체적인 방안을 제시해주세요:

    1. 현재 3개 파일 구조의 장단점 분석
    2. WorkflowManager의 16개 메서드가 적절한지 평가
    3. 모듈 간 결합도를 낮추는 방법
    4. 확장 가능한 플러그인 아키텍처 설계
    5. 단계별 리팩토링 계획

    구체적인 코드 구조와 함께 제안해주세요.
    

### Context

=== Flow Project 워크플로우 시스템 상세 컨텍스트 ===

시스템 구조:
1. flow_project_wrapper.py (127줄)
   - flow_project_with_workflow(project_name) 함수
   - 바탕화면에서 프로젝트 검색
   - WorkflowManager 인스턴스 생성/전환

2. WorkflowManager 클래스 (ai_helpers_new/workflow_manager.py, 275줄)
   - 16개 메서드로 구성
   - 프로젝트별 .ai-brain/workflow.json 관리
   - 주요 메서드:
     * add_task(name)
     * update_task(id, status, summary)  
     * list_tasks()
     * wf_command(command)
     * _handle_task_command(args)

3. workflow_wrapper.py (26줄)
   - wf() 함수: WorkflowManager.wf_command() 래퍼
   - dict 형태로 표준화된 응답 반환

현재 명령어 체계:
- /status: 상태 확인
- /task add [name]: 태스크 추가
- /task list: 목록
- /task start [id]: 시작 (하위 명령)
- /task complete [id]: 완료 (하위 명령)

문제점:
1. /start, /complete가 최상위 명령어가 아님
2. _show_status()가 문자열 반환 (dict 필요)
3. 태스크 삭제 기능 없음
4. 검색/필터링 기능 없음
5. 에러 처리 미흡


### Answer
──────────────────────────────────────────────
1. 3-파일 구조의 장단점
──────────────────────────────────────────────
● flow_project_wrapper.py  
  + 장점: “프로젝트 찾기 + 매니저 호출” 책임이 명확.  
  – 단점: OS I/O(폴더 검색)와 비즈니스 로직(매니저 생성)이 뒤섞여 테스트가 어렵고 재사용성이 낮음.  
● workflow_manager.py  
  + 장점: 기능이 한곳에 모여 있어 파악이 쉽다.  
  – 단점:  
    • ① CLI 파싱, ② 상태 저장(JSON), ③ 도메인 로직(태스크 관리)이 모두 결합 → 단위 테스트-파괴적.  
    • 단일 JSON 파일 형식에 고정 → 저장소 교체(SQL, DynamoDB) 불가.  
● workflow_wrapper.py  
  + 장점: 통일된(dict) 출력 형식 제공.  
  – 단점: 실제 “표준 응답” 정의가 분산되어 있고 예외 처리/로그가 없음.

=> 현재 구조는 “작은 프로젝트에 빠른 구현”에는 좋지만, 기능 추가(삭제, 필터, 플러그인) 시 수정 범위가 세 파일 전체로 번지며 결합도가 급상승.

──────────────────────────────────────────────
2. WorkflowManager(16개 메서드) 적절성 평가
──────────────────────────────────────────────
분석해 보면 메서드는 세 가지 책임 범주로 나뉩니다.  

A. 도메인 조작  
   add_task, update_task, delete_task(미구현), filter_tasks(미구현) …  
B. 저장소 접근  
   _load_wf_file, _save_wf_file …  
C. CLI/프론트엔드 인터페이스  
   wf_command, _handle_task_command, _show_status …

⇒ SRP(단일 책임 원칙) 위반. “16개” 그 자체보다 “성격이 다른 코드가 같은 클래스 안에 있는 것”이 문제입니다. Manager 를 아래처럼 분해하면 메서드 수 자체는 크게 줄어듭니다.

• TaskRepository(JSON/DB 등 저장 책임)  
• WorkflowService(도메인 로직)  
• CommandDispatcher/Parser(CLI → 서비스 호출)  

──────────────────────────────────────────────
3. 모듈 간 결합도 낮추는 핵심 방법
──────────────────────────────────────────────
1) 명시적 인터페이스 도입  
   • repository.py  
     class BaseRepository(Protocol): load() / save() / next_id() …  
   • service.py  
     class WorkflowService: def __init__(self, repo: BaseRepository)

2) 이벤트(or 커맨드) 버스  
   service 에서 “task_completed” 이벤트를 발행하고, 플러그인이나 UI 는 이를 구독.  
   → 파일구조/이벤트핸들러가 느슨하게 연결.

3) 의존성 주입(DI)  
   Wrapper/CLI 에서 필요한 구현체(JSONRepository, SqliteRepository …)를 전달.

4) “Pure Logic vs. I/O” 분리  
   완전히 test-pure 한 모듈(core)과 입·출력(cli / desktop-finder / fastapi 등)을 구분.

──────────────────────────────────────────────
4. 확장 가능한 플러그인 아키텍처
──────────────────────────────────────────────
목표: 커맨드/이벤트/저장소/뷰를 주입 형태로 추가 가능.

디렉터리 예시
flow/
│
├─core/                  (100% 비즈니스 로직)
│   ├─models.py          # Task, Status Enum
│   ├─repository.py      # BaseRepository + JSONRepository
│   ├─service.py         # WorkflowService
│   └─events.py          # EventBus
│
├─cli/
│   ├─parser.py          # argparse / click
│   └─commands.py        # 빌트인 커맨드(상태, 목록 …)
│
├─plugins/
│   ├─base.py            # Plugin ABC
│   ├─delete_task.py     # 신규 기능
│   └─filter_task.py     # 검색/필터
│
├─infra/
│   ├─filescanner.py     # 바탕화면 프로젝트 검색 로직
│   └─logging.py
│
└─tests/

핵심 인터페이스

# plugins/base.py
import abc
class WorkflowPlugin(abc.ABC):
    name: str
    def register(self, dispatcher: 'CommandDispatcher'): ...

# core/events.py
class EventBus:
    _subscribers: dict[str, list[Callable]]
    def subscribe(event: str, fn: Callable): ...
    def publish(event: str, **payload): ...

# cli/commands.py
dispatcher = CommandDispatcher()
def command(name):
    def deco(fn):
        dispatcher.add(name, fn)
        return fn
    return deco

# plugins/delete_task.py
from plugins.base import WorkflowPlugin
class DeleteTaskPlugin(WorkflowPlugin):
    name = "delete"
    def register(self, d):
        @d.command("task delete")
        def _(svc: WorkflowService, task_id: int):
            svc.delete_task(task_id)
            return {"ok": True}

런타임 로더

def load_plugins(dispatcher):
    from importlib import import_module, metadata
    # 1) 프로젝트 플러그인 폴더 스캔
    # 2) optional: setuptools entry_points "flow.workflow_plugins"
    for entry in discover():
        mod = import_module(entry)
        plugin: WorkflowPlugin = mod.Plugin()   # type: ignore
        plugin.register(dispatcher)

결과: “/task delete 3” 같은 CLI가 자동 인식.

──────────────────────────────────────────────
5. 단계별 리팩토링 로드맵
──────────────────────────────────────────────
STEP 0 (테스트 확보)  
  • 기존 3개 파일 freeze → pytest 로 “추가/시작/완료/목록” 골든 테스트 작성.

STEP 1: Model & Repository 추출  
  • core/models.py – Task dataclass(id, name, status, summary="", created_at=…)  
  • core/repository.py – JSONRepository만 우선 구현.  
  • flow_project_wrapper.py → JSONRepository 주입 구현.

STEP 2: Service 계층 도입  
  • core/service.py – add/update/complete/delete/filter 메서드 제공.  
  • 기존 WorkflowManager 대부분 로직을 여기로 이동.  
  • 파일 I/O 코드(workflow.json 읽기/쓰기) 제거 → Repository 의존.

STEP 3: CommandDispatcher/Parser 모듈화  
  • cli/parser.py – 단순 문자열 → 토큰리스트 변환.  
  • cli/commands.py – service 객체를 받아 실제 명령 함수 등록.  
  • flow_project_wrapper.py & workflow_wrapper.py 는 parser → dispatcher.execute 만 호출.

STEP 4: 플러그인 프레임워크  
  • plugins/base.py, loader 추가.  
  • delete_task, filter_task 구현 → 빌트인 기능도 플러그인으로 교체.  
  • 기존 start/complete 명령을 최상위 “/start /complete” 형태로 분리한 뒤, LegacyAdapterPlugin 으로서도 유지 가능.

STEP 5: 이벤트 버스 & 훅  
  • core/events.py 작성.  
  • service 가 “task_added”, “task_completed” 등 발행.  
  • 플러그인(예: github_sync) 이 이를 구독.  
  • 향후 UI 리프레시, 웹훅, 알림 등 확장 용이.

STEP 6: 예외/응답 표준화  
  • utils/errors.py – DomainError, ValidationError  
  • cli/parser & dispatcher 가 try/except → {"ok": False, "error": str(e)} 형태 반환.  
  • tests 갱신.

STEP 7: 다중 저장소 전략 & 설정 파일  
  • BaseRepository + Factory(JSON/SQLite/REST)  
  • ~/.flowrc 또는 .ai-brain/config.toml 로 저장소 종류와 플러그인 enable 리스트 관리.

──────────────────────────────────────────────
마무리
──────────────────────────────────────────────
• 핵심 로직(core) ↔ I/O(cli/infra) ↔ 플러그인 세 층을 분리하면 기능 추가가 “새 파일 하나 + register()” 로 끝나므로 유지보수 난이도가 급감.  
• 단일 JSON → Repository 패턴으로 교체해 팀/프로젝트 단위 DB 전환도 용이.  
• 단계적 리팩토링 로드맵을 따르면 기존 기능을 깨지지 않고 확장성이 높은 아키텍처로 진화시킬 수 있습니다.

### Metadata
- Reasoning Effort: high

- Start Time: 2025-07-21 08:57:25.646858
- End Time: 2025-07-21 08:58:10.138157
- Duration: 44.5초

### Token Usage
- Prompt Tokens: 442
- Completion Tokens: 2,506
- Reasoning Tokens: 0
- Total Tokens: 2,948
