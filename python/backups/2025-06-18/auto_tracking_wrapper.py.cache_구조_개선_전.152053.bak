"""
자동 추적 래퍼 - v6.1
- execute_code 환경 개선
- task별 작업 추적 기능 추가
- 캐시 구조 개선
"""
import sys
import os
import json
import functools
from datetime import datetime
from typing import Any, Dict, Optional, Callable
try:
    from claude_code_ai_brain import get_current_context, UnifiedContextManager
except ImportError:

    def get_current_context():
        return None
    UnifiedContextManager = None

    def update_md_files(context):
        pass

def _get_project_context():
    """프로젝트 컨텍스트를 안전하게 가져옵니다 - execute_code 환경 최적화"""
    try:
        import __main__
        if hasattr(__main__, 'context') and isinstance(__main__.context, dict):
            return __main__.context
        if 'context' in globals() and isinstance(globals()['context'], dict):
            return globals()['context']
        frame = sys._getframe()
        for _ in range(10):
            if not frame:
                break
            if 'context' in frame.f_globals:
                ctx = frame.f_globals['context']
                if isinstance(ctx, dict):
                    return ctx
            if 'context' in frame.f_locals:
                ctx = frame.f_locals['context']
                if isinstance(ctx, dict):
                    return ctx
            frame = frame.f_back
        if UnifiedContextManager:
            manager = UnifiedContextManager()
            return manager.context
        ctx = get_current_context()
        if ctx:
            return ctx
        return {'project_name': 'unknown', 'cache_version': '6.1', 'task_tracking': {}, 'current_task': None}
    except Exception as e:
        print(f'⚠️ Context 획득 실패: {e}')
        return {'project_name': 'unknown', 'task_tracking': {}}

def track_task_operation(task_id: str, operation: str, details: Dict[str, Any]=None):
    """Task 관련 작업을 추적합니다"""
    context = _get_project_context()
    if not context:
        return
    if 'task_tracking' not in context:
        context['task_tracking'] = {}
    if task_id not in context['task_tracking']:
        context['task_tracking'][task_id] = {'operations': [], 'files_modified': set(), 'functions_edited': set(), 'start_time': datetime.now().isoformat(), 'status': 'in_progress'}
    operation_record = {'timestamp': datetime.now().isoformat(), 'operation': operation, 'details': details or {}}
    context['task_tracking'][task_id]['operations'].append(operation_record)

def track_file_operation(operation_type: str):
    """파일 작업 추적 데코레이터 - Task 연동 개선"""

    def decorator(func: Callable) -> Callable:

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            context = _get_project_context()
            current_task = context.get('current_task') if context else None
            file_path = args[0] if args else kwargs.get('path', kwargs.get('filepath', ''))
            result = func(*args, **kwargs)
            
            # claude_code_ai_brain의 track_file_access 호출
            try:
                from claude_code_ai_brain import track_file_access as brain_track_file_access
                brain_track_file_access(file_path, operation_type)
                # 디버그 출력
                if os.environ.get('DEBUG_TRACKING', '').lower() == 'true':
                    print(f"✅ 작업 추적됨: {operation_type} - {os.path.basename(file_path)}")
            except ImportError as e:
                if os.environ.get('DEBUG_TRACKING', '').lower() == 'true':
                    print(f"❌ Import 실패: {e}")
            except Exception as e:
                if os.environ.get('DEBUG_TRACKING', '').lower() == 'true':
                    print(f"❌ 추적 실패: {e}")
            
            if context and current_task:
                track_task_operation(current_task, f'file_{operation_type}', {'file': file_path, 'operation': operation_type, 'success': bool(result)})
                if operation_type in ['write', 'modify', 'replace']:
                    if 'task_tracking' in context and current_task in context['task_tracking']:
                        context['task_tracking'][current_task]['files_modified'].add(file_path)
            if context:
                if 'file_access_history' not in context:
                    context['file_access_history'] = []
                context['file_access_history'].append({'file': file_path, 'operation': operation_type, 'timestamp': datetime.now().isoformat(), 'task_id': current_task})
                if len(context['file_access_history']) > 100:
                    context['file_access_history'] = context['file_access_history'][-100:]
            return result
        return wrapper
    return decorator

def track_block_operation(operation_type: str):
    """코드 블록 작업 추적 데코레이터 - Task 연동 개선"""

    def decorator(func: Callable) -> Callable:

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            context = _get_project_context()
            current_task = context.get('current_task') if context else None
            file_path = args[0] if args else kwargs.get('file_path', '')
            block_name = args[1] if len(args) > 1 else kwargs.get('block_name', '')
            result = func(*args, **kwargs)
            if context and current_task and result:
                track_task_operation(current_task, f'block_{operation_type}', {'file': file_path, 'block': block_name, 'operation': operation_type})
                if 'task_tracking' in context and current_task in context['task_tracking']:
                    context['task_tracking'][current_task]['functions_edited'].add(f'{file_path}::{block_name}')
            if context and result:
                if 'function_edit_history' not in context:
                    context['function_edit_history'] = []
                context['function_edit_history'].append({'file': file_path, 'function': block_name, 'operation': operation_type, 'timestamp': datetime.now().isoformat(), 'task_id': current_task})
                if len(context['function_edit_history']) > 50:
                    context['function_edit_history'] = context['function_edit_history'][-50:]
            return result
        return wrapper
    return decorator

def auto_update_context(func: Callable) -> Callable:
    """
    함수 실행 후 자동으로 컨텍스트를 업데이트하는 데코레이터
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        import claude_code_ai_brain
        if hasattr(claude_code_ai_brain, '_context_manager') and claude_code_ai_brain._context_manager:
            try:
                claude_code_ai_brain.save_context()
            except Exception:
                pass
        return result
    return wrapper

def track_task_start(task_id: str, task_info: Dict[str, Any]):
    """Task 시작을 추적합니다"""
    context = _get_project_context()
    if not context:
        return
    context['current_task'] = task_id
    track_task_operation(task_id, 'start', task_info)

def track_task_complete(task_id: str):
    """Task 완료를 추적합니다"""
    context = _get_project_context()
    if not context:
        return
    if 'task_tracking' in context and task_id in context['task_tracking']:
        context['task_tracking'][task_id]['status'] = 'completed'
        context['task_tracking'][task_id]['end_time'] = datetime.now().isoformat()
        task_data = context['task_tracking'][task_id]
        summary = {'files_modified': list(task_data.get('files_modified', set())), 'functions_edited': list(task_data.get('functions_edited', set())), 'operation_count': len(task_data.get('operations', [])), 'duration': 'calculated_later'}
        track_task_operation(task_id, 'complete', summary)
    if context.get('current_task') == task_id:
        context['current_task'] = None

def track_file_access(file_path, operation, details=None):
    """파일 접근 추적 헬퍼 함수"""
    context = _get_project_context()
    if not context:
        return
    if 'file_access_history' not in context:
        context['file_access_history'] = []
    access_record = {'file': file_path, 'operation': operation, 'timestamp': datetime.now().isoformat(), 'task_id': context.get('current_task')}
    if details:
        access_record['details'] = details
    context['file_access_history'].append(access_record)
    if len(context['file_access_history']) > 100:
        context['file_access_history'] = context['file_access_history'][-100:]
try:
    # 절대 import로 변경하여 순환 import 문제 해결
    from file_system_helpers import read_file as _read_file, create_file as _create_file, backup_file as _backup_file, restore_backup as _restore_backup, replace_block as _replace_block, insert_block as _insert_block
    from ast_parser_helpers import parse_with_snippets as _parse_with_snippets, get_snippet_preview as _get_snippet_preview
    from search_helpers import scan_directory as _scan_directory, search_files_advanced as _search_files_advanced, search_code_content as _search_code_content
except ImportError as e:
    print(f'Warning: 일부 헬퍼 모듈을 찾을 수 없습니다: {e}')

    def _read_file(*args, **kwargs):
        raise ImportError('file_system_helpers not available')

    def _create_file(*args, **kwargs):
        raise ImportError('file_system_helpers not available')

    def _backup_file(*args, **kwargs):
        raise ImportError('file_system_helpers not available')

    def _restore_backup(*args, **kwargs):
        raise ImportError('file_system_helpers not available')

    def _replace_block(*args, **kwargs):
        raise ImportError('file_system_helpers not available')

    def _insert_block(*args, **kwargs):
        raise ImportError('file_system_helpers not available')

    def _parse_with_snippets(*args, **kwargs):
        raise ImportError('ast_parser_helpers not available')

    def _get_snippet_preview(*args, **kwargs):
        raise ImportError('ast_parser_helpers not available')

    def _scan_directory(*args, **kwargs):
        raise ImportError('search_helpers not available')

    def _search_files_advanced(*args, **kwargs):
        raise ImportError('search_helpers not available')

    def _search_code_content(*args, **kwargs):
        raise ImportError('search_helpers not available')
read_file = track_file_operation('read')(_read_file)
create_file = track_file_operation('create')(_create_file)
backup_file = track_file_operation('backup')(_backup_file)
restore_backup = track_file_operation('restore')(_restore_backup)
replace_block = track_block_operation('replace')(_replace_block)
insert_block = track_block_operation('insert')(_insert_block)

def parse_with_snippets(file_path, language='auto', include_snippets=True):
    """파일을 파싱하여 구조화된 정보와 코드 스니펫 추출 - 자동 캐시 저장 포함"""
    import os
    from datetime import datetime
    result = _parse_with_snippets(file_path, language, include_snippets)
    if os.path.exists(file_path):
        try:
            from claude_code_ai_brain import track_file_access
            track_file_access(file_path, 'parse')
        except:
            pass
    if result and result.get('parsing_success'):
        context = _get_project_context()
        if context:
            if 'analyzed_files' not in context:
                context['analyzed_files'] = {}
            file_info = {'path': file_path, 'language': result.get('language', 'unknown'), 'size': os.path.getsize(file_path), 'last_analyzed': datetime.now().isoformat(), 'functions': len(result.get('functions', [])), 'classes': len(result.get('classes', [])), 'imports': len(result.get('imports', [])), 'function_names': [f.get('name', '') for f in result.get('functions', [])], 'class_names': [c.get('name', '') for c in result.get('classes', [])], 'snippets': []}
            for func in result.get('functions', [])[:10]:
                file_info['snippets'].append({'type': 'function', 'name': func.get('name'), 'line_start': func.get('line_start'), 'line_end': func.get('line_end')})
            for cls in result.get('classes', []):
                file_info['snippets'].append({'type': 'class', 'name': cls.get('name'), 'line_start': cls.get('line_start'), 'line_end': cls.get('line_end')})
            context['analyzed_files'][file_path] = file_info
            if os.environ.get('DEBUG_CACHE', '').lower() == 'true':
                print(f"✅ 캐시 자동 저장: {os.path.basename(file_path)} (함수: {file_info['functions']}개, 클래스: {file_info['classes']}개)")
    return result

def get_snippet_preview(file_path, element_name, element_type='function', max_lines=10, start_line=-1, end_line=-1):
    """코드 스니펫 미리보기 (추적 포함)"""
    import os
    result = _get_snippet_preview(file_path, element_name, element_type, max_lines, start_line, end_line)
    if os.path.exists(file_path):
        try:
            from claude_code_ai_brain import track_file_access
            track_file_access(file_path, 'preview')
        except:
            pass
    return result

def scan_directory(directory_path):
    """디렉토리 스캔 (추적 포함)"""
    result = _scan_directory(directory_path)
    try:
        track_file_access(directory_path, 'scan_directory')
    except:
        pass
    return result

def search_files_advanced(directory, pattern, file_extensions=None, exclude_patterns=None, case_sensitive=False):
    """고급 파일 검색 (추적 포함)"""
    if pattern is None:
        pattern = '*'
    if file_extensions:
        if isinstance(file_extensions, list):
            ext = file_extensions[0] if file_extensions else '*'
            if not pattern.endswith(ext):
                pattern = pattern.replace('*', f'*{ext}')
        elif not pattern.endswith(file_extensions):
            pattern = pattern.replace('*', f'*{file_extensions}')
    result = _search_files_advanced(path=directory, pattern=pattern, recursive=True, max_results=100, include_dirs=False, timeout_ms=30000)
    try:
        track_file_access(directory, 'search_files')
    except:
        pass
    return result

def search_code_content(directory, search_pattern, file_extensions=None, exclude_patterns=None, case_sensitive=False, max_file_size=None, show_preview=True):
    """코드 내용 검색 (추적 포함)"""
    file_pattern = '*'
    if file_extensions:
        if isinstance(file_extensions, list):
            file_pattern = file_extensions[0] if file_extensions else '*'
        else:
            file_pattern = file_extensions
    result = _search_code_content(path=directory, pattern=search_pattern, file_pattern=file_pattern, case_sensitive=case_sensitive)
    try:
        track_file_access(directory, 'search_code')
    except:
        pass
    return result
globals()['parse_with_snippets'] = parse_with_snippets
globals()['get_snippet_preview'] = get_snippet_preview
globals()['scan_directory'] = scan_directory
globals()['search_files_advanced'] = search_files_advanced
globals()['search_code_content'] = search_code_content
globals()['track_file_access'] = track_file_access