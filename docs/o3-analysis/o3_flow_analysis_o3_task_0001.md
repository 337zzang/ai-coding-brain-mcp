# Flow 시스템 o3 분석 결과 - o3_task_0001

생성일시: 2025-07-23T17:00:32.346976

## 분석 결과

{'answer': '1. 문제의 근본 원인 \n\n• FlowCommandRouter 는 switch_project․get_status․archive_flow … 등 “상위-레벨” 메서드를 호출 하지만, 전달 받고 있는 객체( FlowManager 또는 FlowManagerUnified )에는 그 메서드가 없다.  \n• workflow_wrapper.get_workflow_manager() 가 FlowManager 인스턴스를 그대로 FlowCommandRouter 에 넘겨 주기 때문에 호출 시점에 AttributeError 가 발생한다.  \n• 즉, “CLI → Router → 상위-레벨 Facade → FlowManager(비즈니스 로직)” 이라는 계층이 설계 의도인데, 중간 Facade 층(상위-레벨 API)이 없어서 컴포넌트가 직접 맞물리지 못한다.  \n\n2. 컴포넌트 역할/정상 흐름(설계 의도)  \n\nCLI(/flow)  \n  → FlowCommandRouter : 문자열 파싱, Facade 로 위임  \n      → Facade( Unified-API / Controller / LegacyAdapter ) : 프로젝트 전환․상태 집계 등 고수준 기능 제공  \n          → FlowManager : Flow/Plan/Task 의 실제 비즈니스 로직  \n              → CachedFlowService : 파일 저장소 접근  \n\n3. 즉시 적용 가능한 수정 코드  \n\n(1) “상위-레벨” Facade 를 확실히 제공  \n   아래 코드를 legacy_flow_adapter.py (또는 새 controller.py) 에 추가하면 Router 가 필요로 하는 API 가 모두 구현된다.\n\n```python\n# --- legacy_flow_adapter.py -----------------------------------------\nclass LegacyFlowAdapter:\n    # 생략 …\n\n    # Facade가 필요로 하는 내부 상태\n    _previous_flow_id: Optional[str] = None\n\n    # ---------- 헬퍼 ----------\n    def _find_flow(self, name: str):\n        for f in self._manager.list_flows():\n            if f.name == name:\n                return f\n        return None\n\n    def _progress(self, flow):\n        t = sum(len(p.tasks) for p in flow.plans.values())\n        if not t:\n            return 0\n        done = sum(\n            1 for p in flow.plans.values()\n              for tsk in p.tasks.values()\n              if tsk.status in ("completed", "reviewing")\n        )\n        return int(done / t * 100)\n\n    # ---------- Router 가 필요로 하는 메서드 ----------\n    def switch_project(self, name: str):\n        flow = self._find_flow(name)\n        if not flow:\n            flow = self._manager.create_flow(name=name, force=True)\n        self._previous_flow_id, self._manager.current_flow = (\n            self._manager._current_flow_id,\n            flow.id,\n        )\n        return {"ok": True, "data": flow.to_dict()}\n\n    def switch_to_previous(self):\n        if not self._previous_flow_id:\n            return {"ok": False, "error": "이전 Flow 가 없습니다"}\n        self._manager.current_flow, self._previous_flow_id = (\n            self._previous_flow_id,\n            self._manager._current_flow_id,\n        )\n        flow = self._manager.current_flow\n        return {"ok": True, "data": flow.to_dict()}\n\n    def list_flows(\n        self,\n        search: str = None,\n        include_archived: bool = False,\n        sort_by: str = "name",\n    ):\n        flows = []\n        for f in self._manager.list_flows():\n            if search and search.lower() not in f.name.lower():\n                continue\n            if not include_archived and getattr(f, "archived", False):\n                continue\n            flows.append(\n                {\n                    "id": f.id,\n                    "name": f.name,\n                    "plans": len(f.plans),\n                    "tasks": sum(len(p.tasks) for p in f.plans.values()),\n                    "archived": getattr(f, "archived", False),\n                    "active": f.id == getattr(self._manager, "_current_flow_id"),\n                    "last_activity": f.updated_at,\n                }\n            )\n        flows.sort(\n            key=lambda x: (x["last_activity"] or "")\n            if sort_by == "recent"\n            else x["name"]\n        )\n        return flows\n\n    def get_status(self):\n        flow = self._manager.current_flow\n        if not flow:\n            return {"ok": False, "error": "활성 Flow 가 없습니다"}\n        return {\n            "ok": True,\n            "data": {\n                "project": {\n                    "name": flow.name,\n                    "path": self._manager._service.base_path,\n                },\n                "flow": {\n                    "plans": len(flow.plans),\n                    "tasks": sum(len(p.tasks) for p in flow.plans.values()),\n                    "progress": self._progress(flow),\n                    "last_activity": flow.updated_at,\n                    "context_events": 0,\n                },\n            },\n        }\n\n    def create_project(self, name, template="default"):\n        flow = self._manager.create_flow(name=name, force=True)\n        return {"ok": True, "data": flow.to_dict()}\n\n    def delete_flow(self, name, force=False):\n        flow = self._find_flow(name)\n        if not flow:\n            return {"ok": False, "error": "Flow 를 찾을 수 없습니다"}\n        if force:\n            self._manager.delete_flow(flow.id)\n            return {"ok": True, "data": f"Flow \'{name}\' 완전 삭제"}\n        flow.archived = True\n        self._manager._service.save_flow(flow)\n        return {"ok": True, "data": f"Flow \'{name}\' 아카이브"}\n\n    archive_flow = delete_flow  # force=False 로 호출\n    def restore_flow(self, name):\n        flow = self._find_flow(name)\n        if not flow or not getattr(flow, "archived", False):\n            return {"ok": False, "error": "아카이브된 Flow 가 없습니다"}\n        flow.archived = False\n        self._manager._service.save_flow(flow)\n        return {"ok": True, "data": f"Flow \'{name}\' 복원"}\n```\n\n(2) Router 가 Facade 를 받도록 workflow_wrapper 수정  \n\n```python\n# --- workflow_wrapper.py --------------------------\nfrom ai_helpers_new.flow_manager import FlowManager\nfrom ai_helpers_new.legacy_flow_adapter import LegacyFlowAdapter\nfrom ai_helpers_new.flow_command_router import FlowCommandRouter\n\nflow_core = FlowManager(context_enabled=True)\nfacade    = LegacyFlowAdapter(flow_core)   # ← 새 Facade\n_manager  = FlowCommandRouter(facade)\n```\n\n이 두 조각만 반영하면 /flow, /flows, /flow create … 등 모든 CLI 명령이 정상 동작한다.  \n\n4. 장기적 개선/리팩터링 제안  \n\n① 계층을 명확히 분리하고 네이밍 일관성 확보  \n   • Application 층 : FlowController (상위-레벨 API)  \n   • Domain 층     : FlowManager (Flow/Plan/Task 로직)  \n   • Infra 층      : CachedFlowService (저장소)  \n   • Interface 층  : FlowCommandRouter( CLI )  \n\n② LegacyFlowAdapter 는 “deprecated” 로 전환 후 삭제 예정 버전을 명시  \n   (Router 가 바로 FlowController 를 사용하도록 구조 단순화)  \n\n③ 메서드명 변경 규칙 통일  \n   create_flow / create_project 같은 중복 명칭 제거.  \n\n④ 테스트 코드와 타입힌트 추가  \n   • Router-Facade 계약 테스트 (mypy / pytest)  \n   • FlowManager 단위 테스트 (state → file persistence)  \n\n⑤ 설정 주입  \n   Context on/off, 저장소 경로 등을 DI 로 교체해 재사용성과 테스트 용이성을 확보.  \n\n⑥ CLI 를 click / typer 같은 라이브러리로 이동해 파싱-로직을 간결화.  \n\n⑦ API 레이어를 FastAPI 로 노출해 VSCode 확장, Web UI 등 다른 채널과도 동일한 비즈니스 로직 재사용.  \n\n위 단기 패치로 에러가 사라지고, 장기 로드맵을 따라가면 “레거시/새 시스템” 이중 구조로 인한 혼선을 완전히 제거할 수 있습니다.', 'reasoning_effort': 'high', 'usage': {'prompt_tokens': 7163, 'completion_tokens': 4974, 'total_tokens': 12137, 'reasoning_tokens': 0}}
