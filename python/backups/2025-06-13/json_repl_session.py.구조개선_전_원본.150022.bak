#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸš€ JSON REPL Session for AI Coding Brain v3.0
==============================================

Claude Desktopê³¼ í†µì‹ í•˜ëŠ” JSON REPL ì„¸ì…˜ ê´€ë¦¬ì
- ê°œì„ ëœ Bootstrap ì‹œìŠ¤í…œ v2.0
- í†µí•©ëœ Helper ë³´í˜¸ ì‹œìŠ¤í…œ v9.0  
- ClaudeCodeAIBrain v2.0 ì™„ë²½ í†µí•©
- í–¥ìƒëœ ì—ëŸ¬ ì²˜ë¦¬ ë° ë¡œê¹…

ì‘ì„±ì: Claude + ì‚¬ìš©ì í˜‘ì—…
ìˆ˜ì •ì¼: 2025-06-13 (v3.0 ë¦¬íŒ©í† ë§)
"""

import sys
import os
import json
import io
import traceback
import time
import threading
import datetime as dt
import importlib
import platform
import subprocess
from pathlib import Path
from typing import Dict, Optional, Tuple, List, Any, Union, Callable
from contextlib import redirect_stdout, redirect_stderr

# ============================================================================
# ğŸ”§ ê¸°ë³¸ ì„¤ì • ë° ê²½ë¡œ ì´ˆê¸°í™”
# ============================================================================

# ì „ì—­ ê²½ë¡œ ì„¤ì •
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

# ============================================================================
# ğŸ” ë¡œê¹… ì‹œìŠ¤í…œ
# ============================================================================

class Logger:
    """ë ˆë²¨ë³„ ë¡œê¹… ì‹œìŠ¤í…œ"""
    
    LEVELS = {
        'DEBUG': 0,
        'INFO': 1,
        'WARNING': 2,
        'ERROR': 3
    }
    
    def __init__(self, level='INFO'):
        self.level = self.LEVELS.get(level, 1)
    
    def log(self, message: str, level: str = 'INFO'):
        if self.LEVELS.get(level, 1) >= self.level:
            timestamp = time.strftime("%H:%M:%S")
            print(f"[{level} {timestamp}] {message}", file=sys.stderr, flush=True)
    
    def debug(self, message: str):
        self.log(message, 'DEBUG')
    
    def info(self, message: str):
        self.log(message, 'INFO')
    
    def warning(self, message: str):
        self.log(message, 'WARNING')
    
    def error(self, message: str):
        self.log(message, 'ERROR')

# ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
logger = Logger(level='INFO')  # í”„ë¡œë•ì…˜ì—ì„œëŠ” 'INFO', ë””ë²„ê¹… ì‹œ 'DEBUG'

# ============================================================================
# ğŸ”Œ ì„ íƒì  ëª¨ë“ˆ ì„í¬íŠ¸
# ============================================================================

# Smart Print Utils
try:
    from smart_print import smart_print, enhanced_smart_print, sp, esp, compress_content
    SMART_PRINT_AVAILABLE = True
    logger.info("Smart Print Utils ì—°ë™ ì„±ê³µ")
except ImportError:
    SMART_PRINT_AVAILABLE = False
    # Fallback í•¨ìˆ˜ë“¤
    def smart_print(content, **kwargs): return str(content)
    def enhanced_smart_print(content, **kwargs): return str(content)
    def sp(content, **kwargs): return str(content)
    def esp(content, **kwargs): return str(content)
    def compress_content(content, **kwargs):
        return str(content)[:15000] + "..." if len(str(content)) > 15000 else str(content)
    logger.info("Smart Print Utils ì—†ìŒ - fallback ì‚¬ìš©")

# Context Manager
try:
    import context_manager
    CONTEXT_MANAGER_AVAILABLE = True
    logger.info("Context Manager v2.0 ì—°ë™ ì„±ê³µ")
except ImportError:
    CONTEXT_MANAGER_AVAILABLE = False
    logger.info("Context Manager ì—†ìŒ")

# Claude Code AI Brain
try:
    from claude_code_ai_brain import ClaudeCodeAIBrain, create_ai_brain
    AI_BRAIN_AVAILABLE = True
    logger.info("Claude Code AI Brain v2.0 ì—°ë™ ì„±ê³µ")
except ImportError:
    AI_BRAIN_AVAILABLE = False
    logger.info("Claude Code AI Brain ì—†ìŒ")

# Auto Tracking Wrapper
try:
    import auto_tracking_wrapper
    AUTO_TRACKING_AVAILABLE = True
    logger.info("Auto Tracking Wrapper v2.0 ì—°ë™ ì„±ê³µ")
except ImportError:
    AUTO_TRACKING_AVAILABLE = False
    logger.info("Auto Tracking Wrapper ì—†ìŒ")

# ============================================================================
# ğŸŒ ì „ì—­ ë³€ìˆ˜ ë° ìƒíƒœ
# ============================================================================

# REPL ì„¸ì…˜ì„ ìœ„í•œ ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤
repl_globals = {
    '__name__': '__console__',
    '__doc__': None,
    'logger': logger  # ë¡œê±°ë¥¼ ì „ì—­ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ
}

# ì´ˆê¸°í™” ìƒíƒœ ì¶”ì 
initialization_state = {
    'bootstrap_completed': False,
    'helpers_registered': False,
    'ai_brain_initialized': False,
    'auto_tracking_enabled': False,
    'timestamp': None
}

# ============================================================================
# ğŸš€ Bootstrap ì‹œìŠ¤í…œ v2.0 (í†µí•© ë° ê°„ì†Œí™”)
# ============================================================================

class BootstrapSystem:
    """í†µí•©ëœ Bootstrap ì‹œìŠ¤í…œ v2.0"""
    
    def __init__(self):
        self.logger = logger
        self.project_root = None
        self.project_context = None
        self.memory_bank_path = None
        
    def find_project_root(self) -> Optional[Path]:
        """í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ ì°¾ëŠ” í†µí•© ë¡œì§"""
        strategies = []
        
        # 1. í™˜ê²½ ë³€ìˆ˜
        if os.environ.get('AI_BRAIN_ROOT'):
            strategies.append(('ENV_VAR', Path(os.environ['AI_BRAIN_ROOT'])))
        
        # 2. í˜„ì¬ íŒŒì¼ ê¸°ì¤€ íƒìƒ‰
        current_file = Path(__file__).resolve()
        for parent in current_file.parents:
            markers = ['.ai-brain-project', 'project_cache.json', 'roadmap.md', '.git']
            if any((parent / marker).exists() for marker in markers):
                strategies.append(('MARKER_FILE', parent))
                break
        
        # 3. í”„ë¡œì íŠ¸ ì´ë¦„ ê¸°ë°˜
        for parent in current_file.parents:
            if 'ai-coding-brain' in parent.name.lower():
                strategies.append(('PROJECT_NAME', parent))
                break
        
        # ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì „ëµ ì„ íƒ
        for strategy_name, path in strategies:
            if path.exists():
                self.logger.info(f"í”„ë¡œì íŠ¸ ë£¨íŠ¸ ë°œê²¬ ({strategy_name}): {path}")
                return path
        
        return None
    
    def find_memory_bank(self, project_name: str = None) -> Optional[Tuple[Path, Path]]:
        """ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ ì°¾ê¸°"""
        memory_bank_root = None
        
        # Claude Desktop ì„¤ì • í™•ì¸
        config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                memory_bank_root = config.get('mcpServers', {}).get('ai-coding-brain-mcp', {}).get('env', {}).get('MEMORY_BANK_ROOT')
            except:
                pass
        
        # í™˜ê²½ ë³€ìˆ˜ í™•ì¸
        if not memory_bank_root:
            memory_bank_root = os.environ.get('MEMORY_BANK_ROOT')
        
        # ê¸°ë³¸ê°’
        if not memory_bank_root:
            memory_bank_root = os.path.expanduser("~/Desktop/memory")
        
        if not os.path.exists(memory_bank_root):
            return None
        
        # í”„ë¡œì íŠ¸ ì´ë¦„ ê²°ì •
        if not project_name:
            project_name = "ai-coding-brain-mcp"
        
        memory_path = Path(memory_bank_root) / project_name
        if memory_path.exists():
            return memory_path, self.project_root or Path.cwd()
        
        return None
    
    def initialize_context(self) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
        if CONTEXT_MANAGER_AVAILABLE:
            try:
                project_name = self.project_root.name if self.project_root else "ai-coding-brain-mcp"
                project_path = str(self.project_root) if self.project_root else os.getcwd()
                
                self.project_context = context_manager.initialize_context(
                    project_path=project_path,
                    project_name=project_name
                )
                
                # ì‘ì—… ì¶”ì  ì´ˆê¸°í™”
                self.project_context = context_manager.initialize_work_tracking(self.project_context)
                
                self.logger.info(f"Context Manager ì´ˆê¸°í™” ì™„ë£Œ - í”„ë¡œì íŠ¸: {project_name}")
                return self.project_context
                
            except Exception as e:
                self.logger.error(f"Context Manager ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        
        # Fallback: ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        return self._create_default_context()
    
    def _create_default_context(self) -> Dict[str, Any]:
        """ê¸°ë³¸ í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        return {
            'project_id': f"json-repl-{int(time.time())}",
            'project_name': self.project_root.name if self.project_root else "ai-coding-brain-mcp",
            'project_path': str(self.project_root) if self.project_root else os.getcwd(),
            'session_id': f"session-{int(time.time())}",
            'version': 'v3.0',
            'created_at': dt.datetime.now().isoformat(),
            'cache': {},
            'storage': {},
            'work_tracking': {
                'file_edits': {},
                'function_edits': {}
            }
        }
    
    def setup_python_paths(self) -> bool:
        """Python ê²½ë¡œ ì„¤ì •"""
        if not self.project_root:
            return False
        
        paths_to_add = [self.project_root]
        
        # í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¶”ê°€
        for subdir in ['python', 'src', 'lib', 'modules']:
            candidate = self.project_root / subdir
            if candidate.exists():
                paths_to_add.append(candidate)
        
        for path in paths_to_add:
            path_str = str(path.resolve())
            if path_str not in sys.path:
                sys.path.insert(0, path_str)
        
        self.logger.info(f"{len(paths_to_add)}ê°œ ê²½ë¡œ ì¶”ê°€ë¨")
        return True
    
    def run(self, config: Dict[str, Any] = None) -> Optional[Dict[str, Any]]:
        """í†µí•© ë¶€íŠ¸ìŠ¤íŠ¸ë© ì‹¤í–‰"""
        config = config or {}
        
        self.logger.info("=== Bootstrap System v2.0 ì‹œì‘ ===")
        
        try:
            # 1. í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸°
            self.project_root = self.find_project_root()
            if not self.project_root:
                self.logger.warning("í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - í˜„ì¬ ë””ë ‰í† ë¦¬ ì‚¬ìš©")
                self.project_root = Path.cwd()
            
            # 2. ë©”ëª¨ë¦¬ ë±…í¬ í™•ì¸
            memory_info = self.find_memory_bank()
            if memory_info:
                self.memory_bank_path = memory_info[0]
                self.logger.info(f"ë©”ëª¨ë¦¬ ë±…í¬ ë°œê²¬: {self.memory_bank_path}")
            
            # 3. Python ê²½ë¡œ ì„¤ì •
            self.setup_python_paths()
            
            # 4. ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            self.project_context = self.initialize_context()
            
            # 5. ì „ì—­ ë“±ë¡
            repl_globals['project_context'] = self.project_context
            repl_globals['project_root'] = str(self.project_root)
            
            self.logger.info("=== Bootstrap ì™„ë£Œ ===")
            return self.project_context
            
        except Exception as e:
            self.logger.error(f"Bootstrap ì‹¤íŒ¨: {e}")
            return None

# ============================================================================
# ğŸ’¾ ì„¸ì…˜ ê´€ë¦¬ì
# ============================================================================

class SessionManager:
    """ê°„ì†Œí™”ëœ ì„¸ì…˜ ê´€ë¦¬ì"""
    
    def __init__(self, project_context: Dict[str, Any]):
        self.project_context = project_context
        self.project_path = project_context.get('project_path', '.')
        self.session_dir = Path(self.project_path) / '.sessions'
        self.session_dir.mkdir(exist_ok=True)
        
        self.meta_file = self.session_dir / 'session_meta.json'
        self.metadata = self._load_metadata()
        
    def _load_metadata(self) -> Dict[str, Any]:
        """ë©”íƒ€ë°ì´í„° ë¡œë“œ"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                pass
        
        return {
            'created': dt.datetime.now().isoformat(),
            'total_sessions': 0,
            'last_session': None,
            'version': 'v3.0'
        }
    
    def save_session(self, session_data: Dict[str, Any]) -> bool:
        """ì„¸ì…˜ ì €ì¥"""
        try:
            timestamp = dt.datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"session_{timestamp}.json"
            filepath = self.session_dir / filename
            
            # ê¸°ë³¸ í•„ë“œ ì¶”ê°€
            session_data.setdefault('session_id', self.project_context.get('session_id'))
            session_data.setdefault('timestamp', dt.datetime.now().isoformat())
            session_data.setdefault('project_name', self.project_context.get('project_name'))
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            # ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
            self.metadata['total_sessions'] += 1
            self.metadata['last_session'] = filename
            self._save_metadata()
            
            logger.debug(f"ì„¸ì…˜ ì €ì¥ ì™„ë£Œ: {filename}")
            return True
            
        except Exception as e:
            logger.error(f"ì„¸ì…˜ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def _save_metadata(self):
        """ë©”íƒ€ë°ì´í„° ì €ì¥"""
        try:
            with open(self.meta_file, 'w', encoding='utf-8') as f:
                json.dump(self.metadata, f, indent=2)
        except Exception as e:
            logger.error(f"ë©”íƒ€ë°ì´í„° ì €ì¥ ì‹¤íŒ¨: {e}")

# ============================================================================
# ğŸ¤– AI Brain í†µí•© ì‹œìŠ¤í…œ
# ============================================================================

class JsonReplAIBrain:
    """JSON REPL í™˜ê²½ì— ìµœì í™”ëœ AI Brain"""
    
    def __init__(self, project_context: Dict[str, Any]):
        self.project_context = project_context
        self.session_id = project_context.get('session_id', f'json-repl-{int(time.time())}')
        self.initialized = False
        self.claude_brain = None
        
        # Claude Code AI Brain ì—°ë™ ì‹œë„
        if AI_BRAIN_AVAILABLE:
            try:
                self.claude_brain = create_ai_brain(
                    project_path=project_context.get('project_path'),
                    restore_session=True
                )
                logger.info("Claude Code AI Brain v2.0 ì—°ë™ ì„±ê³µ")
            except Exception as e:
                logger.warning(f"Claude Code AI Brain ì—°ë™ ì‹¤íŒ¨: {e}")
        
        self.initialized = True
    
    def get_status(self) -> Dict[str, Any]:
        """AI Brain ìƒíƒœ ë°˜í™˜"""
        return {
            'type': 'JsonReplAIBrain',
            'session_id': self.session_id,
            'initialized': self.initialized,
            'claude_brain_connected': self.claude_brain is not None,
            'project_context_available': bool(self.project_context),
            'capabilities': [
                'experience_management',
                'solution_search',
                'vibe_commands',
                'work_tracking'
            ]
        }
    
    def save_experience(self, experience_data: Union[str, Dict[str, Any]]) -> Dict[str, Any]:
        """ê°œë°œ ê²½í—˜ ì €ì¥"""
        # Claude Brainì´ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
        if self.claude_brain and hasattr(self.claude_brain, 'save_experience'):
            return self.claude_brain.save_experience(experience_data)
        
        # ë¡œì»¬ ì €ì¥
        try:
            if isinstance(experience_data, str):
                experience_data = {'description': experience_data}
            
            experience = {
                'timestamp': dt.datetime.now().isoformat(),
                'session_id': self.session_id,
                'data': experience_data,
                'type': 'coding_experience'
            }
            
            # ì»¨í…ìŠ¤íŠ¸ì— ì €ì¥
            if 'experiences' not in self.project_context:
                self.project_context['experiences'] = []
            self.project_context['experiences'].append(experience)
            
            logger.debug("ê²½í—˜ ì €ì¥ ì™„ë£Œ")
            return {'success': True, 'timestamp': experience['timestamp']}
            
        except Exception as e:
            logger.error(f"ê²½í—˜ ì €ì¥ ì‹¤íŒ¨: {e}")
            return {'success': False, 'error': str(e)}
    
    def search_solutions(self, query: str, limit: int = 10) -> Dict[str, Any]:
        """ì†”ë£¨ì…˜ ê²€ìƒ‰"""
        # Claude Brainì´ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©
        if self.claude_brain and hasattr(self.claude_brain, 'search_solutions'):
            return self.claude_brain.search_solutions(query, limit)
        
        # ë¡œì»¬ ê²€ìƒ‰
        try:
            experiences = self.project_context.get('experiences', [])
            results = []
            
            query_lower = query.lower()
            for exp in experiences:
                exp_str = json.dumps(exp.get('data', {})).lower()
                if query_lower in exp_str:
                    results.append(exp)
            
            return {
                'success': True,
                'query': query,
                'results': results[:limit],
                'total': len(results)
            }
            
        except Exception as e:
            logger.error(f"ì†”ë£¨ì…˜ ê²€ìƒ‰ ì‹¤íŒ¨: {e}")
            return {'success': False, 'error': str(e)}
    
    def process_vibe_command(self, command: str) -> str:
        """Vibe ëª…ë ¹ì–´ ì²˜ë¦¬"""
        # Claude Brainì˜ Vibe ì‹œìŠ¤í…œ ì‚¬ìš©
        if self.claude_brain and hasattr(self.claude_brain, 'process_vibe_command'):
            return self.claude_brain.process_vibe_command(command)
        
        return "Vibe ì‹œìŠ¤í…œì´ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."

# ============================================================================
# ğŸ›¡ï¸ Helper í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ v9.0 (í†µí•©)
# ============================================================================

class HelperProtectionSystem:
    """í†µí•©ëœ Helper í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ"""
    
    def __init__(self, repl_globals: Dict[str, Any]):
        self.repl_globals = repl_globals
        self.protected_functions = {}
        self.call_statistics = {}
        self.auto_tracking_enabled = True
        self.locked = False
        
        # Context Manager í•¨ìˆ˜ ì—°ê²°
        self.track_file_access = repl_globals.get('track_file_access')
        self.track_function_edit = repl_globals.get('track_function_edit')
        self.track_code_analysis = repl_globals.get('track_code_analysis')
        
    def register_function(self, name: str, func: Callable, category: str = "GENERAL") -> bool:
        """í•¨ìˆ˜ ë“±ë¡ ë° ë³´í˜¸"""
        if self.locked:
            logger.warning(f"ë³´í˜¸ ì‹œìŠ¤í…œì´ ì ê²¨ìˆìŒ: {name} ë“±ë¡ ë¶ˆê°€")
            return False
        
        # ìë™ ì¶”ì  ë˜í¼ ìƒì„±
        wrapped_func = self._create_tracking_wrapper(func, name, category)
        
        # ë³´í˜¸ ë“±ë¡
        self.protected_functions[name] = {
            'function': wrapped_func,
            'original': func,
            'category': category,
            'protected': True,
            'call_count': 0
        }
        
        # ì „ì—­ ë“±ë¡
        self.repl_globals[name] = wrapped_func
        
        logger.debug(f"Helper í•¨ìˆ˜ ë“±ë¡: {name} ({category})")
        return True
    
    def _create_tracking_wrapper(self, func: Callable, name: str, category: str) -> Callable:
        """ìë™ ì¶”ì  ë˜í¼ ìƒì„±"""
        def wrapper(*args, **kwargs):
            # í˜¸ì¶œ í†µê³„
            if name in self.protected_functions:
                self.protected_functions[name]['call_count'] += 1
            
            # ìë™ ì¶”ì 
            if self.auto_tracking_enabled and self.track_file_access:
                self._track_call(name, category, args, kwargs)
            
            # ì›ë³¸ í•¨ìˆ˜ ì‹¤í–‰
            try:
                return func(*args, **kwargs)
            except Exception as e:
                logger.error(f"{name} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
                raise
        
        wrapper.__name__ = name
        wrapper.__doc__ = func.__doc__
        wrapper._is_protected = True
        return wrapper
    
    def _track_call(self, name: str, category: str, args: tuple, kwargs: dict):
        """í•¨ìˆ˜ í˜¸ì¶œ ì¶”ì """
        try:
            # íŒŒì¼ ê´€ë ¨ í•¨ìˆ˜ ì¶”ì 
            if category == "FILE" and args and self.track_file_access:
                file_path = str(args[0])
                if 'project_context' in self.repl_globals:
                    self.track_file_access(
                        self.repl_globals['project_context'],
                        file_path,
                        name
                    )
        except:
            pass  # ì¶”ì  ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
    
    def lock(self):
        """ë³´í˜¸ ì‹œìŠ¤í…œ ì ê¸ˆ"""
        self.locked = True
        logger.info(f"Helper ë³´í˜¸ ì‹œìŠ¤í…œ ì ê¸ˆ - {len(self.protected_functions)}ê°œ í•¨ìˆ˜ ë³´í˜¸ë¨")
    
    def get_status(self) -> Dict[str, Any]:
        """ë³´í˜¸ ìƒíƒœ ë°˜í™˜"""
        categories = {}
        for name, info in self.protected_functions.items():
            cat = info['category']
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(name)
        
        total_calls = sum(info['call_count'] for info in self.protected_functions.values())
        
        return {
            'version': 'v9.0',
            'locked': self.locked,
            'total_protected': len(self.protected_functions),
            'categories': categories,
            'auto_tracking': self.auto_tracking_enabled,
            'total_calls': total_calls
        }# ============================================================================
# ğŸ“¦ Helper í•¨ìˆ˜ ë“±ë¡
# ============================================================================

def register_all_helpers(protection_system: HelperProtectionSystem) -> Dict[str, Any]:
    """ëª¨ë“  Helper í•¨ìˆ˜ ë“±ë¡"""
    registered = []
    failed = []
    
    # 1. Auto Tracking Wrapper í•¨ìˆ˜ë“¤
    if AUTO_TRACKING_AVAILABLE:
        try:
            if hasattr(auto_tracking_wrapper, '__all__'):
                for func_name in auto_tracking_wrapper.__all__:
                    if hasattr(auto_tracking_wrapper, func_name):
                        func = getattr(auto_tracking_wrapper, func_name)
                        
                        # ì¹´í…Œê³ ë¦¬ ìë™ ë¶„ë¥˜
                        if any(kw in func_name for kw in ['file', 'read', 'write', 'backup']):
                            category = 'FILE'
                        elif any(kw in func_name for kw in ['parse', 'ast', 'analyze']):
                            category = 'AST'
                        elif any(kw in func_name for kw in ['search', 'find']):
                            category = 'SEARCH'
                        else:
                            category = 'GENERAL'
                        
                        if protection_system.register_function(func_name, func, category):
                            registered.append(func_name)
                        else:
                            failed.append(func_name)
        except Exception as e:
            logger.error(f"Auto tracking wrapper ë“±ë¡ ì‹¤íŒ¨: {e}")
    
    # 2. Context Manager í•¨ìˆ˜ë“¤
    if CONTEXT_MANAGER_AVAILABLE:
        cm_functions = {
            # ì‘ì—… ì¶”ì 
            'track_file_access': 'TRACKING',
            'track_function_edit': 'TRACKING',
            'track_code_analysis': 'TRACKING',
            'get_work_tracking_summary': 'TRACKING',
            # ìºì‹œ
            'update_cache': 'CACHE',
            'get_cache_statistics': 'CACHE',
            'save_context': 'CACHE',
            # ì´ˆê¸°í™”
            'initialize_context': 'CORE',
            'initialize_work_tracking': 'CORE'
        }
        
        for func_name, category in cm_functions.items():
            if hasattr(context_manager, func_name):
                func = getattr(context_manager, func_name)
                if protection_system.register_function(func_name, func, category):
                    registered.append(func_name)
                else:
                    failed.append(func_name)
    
    # 3. ê²€ìƒ‰ í•¨ìˆ˜ë“¤
    try:
        from integrated_search import integrated_search
        if protection_system.register_function('integrated_search', integrated_search, 'SEARCH'):
            registered.append('integrated_search')
    except:
        failed.append('integrated_search')
    
    # 4. ë©”ëª¨ë¦¬ í•¨ìˆ˜ë“¤
    memory_functions = {
        'save_coding_experience': lambda data, ctx=None: repl_globals.get('ai_brain', {}).save_experience(data) if 'ai_brain' in repl_globals else {'success': False},
        'search_coding_solutions': lambda query, limit=10: repl_globals.get('ai_brain', {}).search_solutions(query, limit) if 'ai_brain' in repl_globals else {'success': False}
    }
    
    for func_name, func in memory_functions.items():
        if protection_system.register_function(func_name, func, 'MEMORY'):
            registered.append(func_name)
    
    # ë³´í˜¸ ì‹œìŠ¤í…œ ì ê¸ˆ
    protection_system.lock()
    
    return {
        'success': True,
        'registered': registered,
        'failed': failed,
        'total': len(registered),
        'status': protection_system.get_status()
    }

# ============================================================================
# ğŸ’» ì½”ë“œ ì‹¤í–‰ ì‹œìŠ¤í…œ
# ============================================================================

def execute_code_block(code: str, repl_globals: Dict[str, Any]) -> Dict[str, Any]:
    """ì½”ë“œ ë¸”ë¡ ì‹¤í–‰"""
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    execution_start = time.time()
    
    try:
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            # ì½”ë“œ ì»´íŒŒì¼
            compiled_code = compile(code, '<string>', 'exec')
            # ì‹¤í–‰
            exec(compiled_code, repl_globals)
        
        execution_time = time.time() - execution_start
        stdout_content = stdout_capture.getvalue()
        stderr_content = stderr_capture.getvalue()
        
        # ëŒ€ìš©ëŸ‰ ì¶œë ¥ ì••ì¶•
        if SMART_PRINT_AVAILABLE and len(stdout_content) > 100000:
            stdout_content = compress_content(stdout_content, level=1)
        
        return {
            'success': True,
            'stdout': stdout_content,
            'stderr': stderr_content,
            'execution_time': execution_time,
            'variable_count': len(repl_globals),
            'result': 'executed'
        }
        
    except SyntaxError as e:
        return {
            'success': False,
            'error': str(e),
            'error_type': 'SyntaxError',
            'stdout': stdout_capture.getvalue(),
            'stderr': stderr_capture.getvalue(),
            'lineno': e.lineno,
            'offset': e.offset
        }
        
    except Exception as e:
        tb_str = traceback.format_exc()
        return {
            'success': False,
            'error': str(e),
            'error_type': type(e).__name__,
            'stdout': stdout_capture.getvalue(),
            'stderr': stderr_capture.getvalue() + f"\n{tb_str}",
            'traceback': tb_str,
            'execution_time': time.time() - execution_start
        }

# ============================================================================
# ğŸ”Œ EOT í”„ë ˆì´ë° í†µì‹ 
# ============================================================================

def read_eot_framed_input() -> Optional[str]:
    """EOT í”„ë ˆì´ë°ëœ ì…ë ¥ ì½ê¸°"""
    buffer = ""
    while True:
        try:
            char = sys.stdin.read(1)
            
            if not char:  # EOF
                logger.debug("EOF ê°ì§€")
                return None
            
            if char == '\x04':  # EOT
                logger.debug(f"EOT ê°ì§€ - ë²„í¼ í¬ê¸°: {len(buffer)}")
                return buffer
            
            buffer += char
            
        except Exception as e:
            logger.error(f"ì…ë ¥ ì½ê¸° ì˜¤ë¥˜: {e}")
            return None

def send_eot_framed_response(response_data: Dict[str, Any]) -> bool:
    """EOT í”„ë ˆì´ë°ëœ ì‘ë‹µ ì „ì†¡"""
    try:
        # ëŒ€ìš©ëŸ‰ ì‘ë‹µ ì••ì¶•
        if SMART_PRINT_AVAILABLE and len(str(response_data)) > 20000:
            compressed = compress_content(str(response_data), level=1)
            if len(compressed) < len(str(response_data)):
                response_data = {
                    'compressed': True,
                    'content': compressed,
                    'original_size': len(str(response_data))
                }
        
        json_response = json.dumps(response_data, ensure_ascii=False)
        sys.stdout.write(json_response)
        sys.stdout.write('\x04')
        sys.stdout.flush()
        
        logger.debug(f"ì‘ë‹µ ì „ì†¡ ì™„ë£Œ - í¬ê¸°: {len(json_response)}")
        return True
        
    except Exception as e:
        logger.error(f"ì‘ë‹µ ì „ì†¡ ì˜¤ë¥˜: {e}")
        return False

# ============================================================================
# ğŸ”„ ë©”ì¸ ë£¨í”„
# ============================================================================

def main_loop():
    """ë©”ì¸ ì‹¤í–‰ ë£¨í”„"""
    logger.info("=== JSON REPL ë©”ì¸ ë£¨í”„ ì‹œì‘ ===")
    
    # ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸
    status_report = []
    
    if 'project_context' in repl_globals:
        status_report.append(f"âœ… Project Context: {repl_globals['project_context'].get('project_name')}")
    
    if 'ai_brain' in repl_globals:
        brain_status = repl_globals['ai_brain'].get_status()
        status_report.append(f"âœ… AI Brain: {brain_status['type']}")
    
    if 'protection_system' in repl_globals:
        protection_status = repl_globals['protection_system'].get_status()
        status_report.append(f"âœ… Helper í•¨ìˆ˜: {protection_status['total_protected']}ê°œ ë³´í˜¸ë¨")
    
    logger.info("ì‹œìŠ¤í…œ ìƒíƒœ: " + " | ".join(status_report))
    
    request_count = 0
    
    while True:
        try:
            # ì…ë ¥ ëŒ€ê¸°
            raw_input = read_eot_framed_input()
            
            if raw_input is None:
                logger.info("ì…ë ¥ ì¢…ë£Œ - ë£¨í”„ ì¢…ë£Œ")
                break
            
            request_count += 1
            
            if not raw_input.strip():
                continue
            
            try:
                # JSON íŒŒì‹±
                request = json.loads(raw_input)
                command_id = request.get('id', f'req_{request_count}')
                code = request.get('code', '')
                
                logger.debug(f"ìš”ì²­ #{request_count} - ID: {command_id}")
                
                # ì½”ë“œ ì‹¤í–‰
                if code.strip():
                    execution_result = execute_code_block(code, repl_globals)
                else:
                    execution_result = {
                        'success': True,
                        'result': None,
                        'stdout': '',
                        'stderr': ''
                    }
                
                # ì‘ë‹µ êµ¬ì„±
                response = {
                    'id': command_id,
                    **execution_result,
                    'session_mode': 'JSON_REPL',
                    'request_number': request_count
                }
                
                # ì„¸ì…˜ ìë™ ì €ì¥
                if 'session_manager' in repl_globals and request_count % 10 == 0:
                    repl_globals['session_manager'].save_session({
                        'type': 'checkpoint',
                        'request_count': request_count,
                        'timestamp': dt.datetime.now().isoformat()
                    })
                
            except json.JSONDecodeError as e:
                logger.error(f"JSON íŒŒì‹± ì˜¤ë¥˜: {e}")
                response = {
                    'id': f'error_{request_count}',
                    'success': False,
                    'error': f"JSON parsing error: {e}",
                    'error_type': 'JSONDecodeError'
                }
            
            # ì‘ë‹µ ì „ì†¡
            send_eot_framed_response(response)
            
        except KeyboardInterrupt:
            logger.info("KeyboardInterrupt - ì¢…ë£Œ")
            break
        except Exception as e:
            logger.error(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}")
            error_response = {
                'id': f'critical_error_{request_count}',
                'success': False,
                'error': str(e),
                'error_type': type(e).__name__,
                'traceback': traceback.format_exc()
            }
            send_eot_framed_response(error_response)
    
    logger.info(f"JSON REPL ì¢…ë£Œ - ì´ {request_count}ê°œ ìš”ì²­ ì²˜ë¦¬")

# ============================================================================
# ğŸš€ ì´ˆê¸°í™” ë° ì‹œì‘
# ============================================================================

def initialize_system() -> bool:
    """ì „ì²´ ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
    try:
        logger.info("=== AI Coding Brain JSON REPL v3.0 ì´ˆê¸°í™” ===")
        
        # 1. Bootstrap ì‹¤í–‰
        bootstrap = BootstrapSystem()
        project_context = bootstrap.run()
        
        if not project_context:
            logger.error("Bootstrap ì‹¤íŒ¨")
            return False
        
        # 2. ì„¸ì…˜ ê´€ë¦¬ì ì´ˆê¸°í™”
        session_manager = SessionManager(project_context)
        repl_globals['session_manager'] = session_manager
        
        # 3. AI Brain ì´ˆê¸°í™”
        ai_brain = JsonReplAIBrain(project_context)
        repl_globals['ai_brain'] = ai_brain
        
        # 4. Helper ë³´í˜¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        protection_system = HelperProtectionSystem(repl_globals)
        repl_globals['protection_system'] = protection_system
        
        # 5. Helper í•¨ìˆ˜ ë“±ë¡
        helper_result = register_all_helpers(protection_system)
        logger.info(f"Helper í•¨ìˆ˜ ë“±ë¡: {helper_result['total']}ê°œ ì„±ê³µ")
        
        # 6. Context Manager í•¨ìˆ˜ ì „ì—­ ë“±ë¡
        if CONTEXT_MANAGER_AVAILABLE:
            for name in ['track_file_access', 'track_function_edit', 'update_cache']:
                if hasattr(context_manager, name):
                    repl_globals[name] = getattr(context_manager, name)
        
        # 7. ì´ˆê¸°í™” ìƒíƒœ ì—…ë°ì´íŠ¸
        initialization_state.update({
            'bootstrap_completed': True,
            'helpers_registered': True,
            'ai_brain_initialized': True,
            'auto_tracking_enabled': protection_system.auto_tracking_enabled,
            'timestamp': dt.datetime.now().isoformat()
        })
        
        # 8. ì´ˆê¸° ì„¸ì…˜ ì €ì¥
        session_manager.save_session({
            'type': 'initialization',
            'status': 'success',
            'initialization_state': initialization_state,
            'helper_functions': helper_result['registered']
        })
        
        logger.info("=== ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ ===")
        return True
        
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        logger.error(traceback.format_exc())
        return False

# ============================================================================
# ğŸ¯ ë©”ì¸ ì‹¤í–‰
# ============================================================================

if __name__ == "__main__":
    logger.info("=== AI Coding Brain JSON REPL v3.0 ===")
    logger.info(f"Python {sys.version}")
    logger.info(f"ì‘ì—… ë””ë ‰í† ë¦¬: {os.getcwd()}")
    
    # READY ì‹œê·¸ë„
    print("__READY__", flush=True)
    
    # ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    if initialize_system():
        try:
            main_loop()
        except Exception as e:
            logger.error(f"ë©”ì¸ ë£¨í”„ ì˜¤ë¥˜: {e}")
            logger.error(traceback.format_exc())
    else:
        logger.error("ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨ - ì¢…ë£Œ")
    
    logger.info("=== JSON REPL ì„¸ì…˜ ì¢…ë£Œ ===")