# ===========================================
# Public API - Only these 7 functions are exposed
# ===========================================
__all__ = [
    'sync_to_files',          # 캐시 → 파일 동기화
    'sync_from_files',        # 파일 → 캐시 동기화
    'auto_save',              # 자동 저장
    'force_sync',             # 강제 양방향 동기화
    'save_coding_experience', # 개발 경험 저장
    'search_coding_solutions',# 과거 해결책 검색
    'get_coding_insights'     # 프로젝트 인사이트
]

"""
🔥 바이브 코딩 메모리 시스템
========================

바이브코딩에 최적화된 메모리 관리 시스템
- VibeMemoryManager: 바이브 메모리 관리 핵심
- VibeCommandSystem: 바이브 명령어 시스템 (/task, /flow 등)
- VibeAutoSync: 실시간 자동 동기화

작성자: Claude + 사용자 협업  
생성일: 2025-06-04
즉시 구현 완료: Phase 1-5 모든 단계 완성
"""

import os
import json
import datetime as dt
from typing import Dict, List, Any, Optional
import sys


import json
from datetime import datetime

def __get_memory_bank_root_from_claude_config():
    """Claude Desktop 설정에서 MEMORY_BANK_ROOT 동적 읽기"""
    import os
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        # ai-coding-brain-mcp 서버 설정에서 MEMORY_BANK_ROOT 추출
        memory_root = config['mcpServers']['ai-coding-brain-mcp']['env']['MEMORY_BANK_ROOT']
        print(f"✅ Claude Desktop 설정에서 메모리 루트 로드: {memory_root}")
        return memory_root
    except Exception as e:
        print(f"⚠️ Claude 설정 읽기 실패: {e}")
        # 폴백 경로
        fallback_path = r"C:\Users\Administrator\Desktop\memory"
        print(f"📁 폴백 경로 사용: {fallback_path}")
        return fallback_path

def _sync_project_context_with_memory_bank(project_context):
    """project_context를 메모리 뱅크와 동기화"""
    memory_root = __get_memory_bank_root_from_claude_config()
    project_name = project_context.get('name', 'common')
    project_memory_path = os.path.join(memory_root, project_name)
    
    # 프로젝트 메모리 폴더 생성
    os.makedirs(project_memory_path, exist_ok=True)
    
    # project_context에 메모리 경로 정보 저장
    project_context['memory_bank'] = {
        'root': memory_root,
        'project_path': project_memory_path,
        'project_name': project_name,
        'last_sync': datetime.now().isoformat(),
        'sync_enabled': True
    }
    
    # sync_status 초기화
    if 'sync_status' not in project_context:
        project_context['sync_status'] = {
            'last_sync': datetime.now().isoformat(),
            'pending_changes': [],
            'auto_sync': True
        }
    
    return project_memory_path




def _ensure_data_compatibility(project_context):
    """두 시스템의 데이터 구조 호환성 보장"""
    # AI Coding Brain 구조 -> Vibe System 구조 매핑
    if 'vibe_system' not in project_context:
        project_context['vibe_system'] = {}
    
    vibe_sys = project_context['vibe_system']
    
    # current_focus 동기화
    if 'current_focus' in project_context and project_context['current_focus']:
        vibe_sys['current_focus'] = project_context['current_focus']
    elif 'current_focus' not in vibe_sys:
        vibe_sys['current_focus'] = ''
    
    # next_tasks 동기화
    if 'next_tasks' in project_context and project_context['next_tasks']:
        # AI Brain의 단순 문자열 리스트를 Vibe 형식으로 변환
        vibe_tasks = []
        for task in project_context['next_tasks']:
            if isinstance(task, str):
                vibe_tasks.append({
                    'description': task,
                    'added_time': datetime.now().strftime("%H:%M"),
                    'status': 'pending'
                })
            else:
                vibe_tasks.append(task)
        vibe_sys['next_tasks'] = vibe_tasks
    elif 'next_tasks' not in vibe_sys:
        vibe_sys['next_tasks'] = []
    
    # work_tracking 정보도 활용
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        if 'current_focus' in wt and wt['current_focus']:
            vibe_sys['current_focus'] = wt['current_focus']
        if 'next_tasks' in wt and wt['next_tasks']:
            # work_tracking의 tasks도 병합
            for task in wt['next_tasks']:
                if isinstance(task, str) and task not in [t.get('description', t) for t in vibe_sys['next_tasks']]:
                    vibe_sys['next_tasks'].append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
    
    # completed_tasks 초기화
    if 'completed_tasks' not in vibe_sys:
        vibe_sys['completed_tasks'] = []
    
    # session_activities 초기화
    if 'session_activities' not in vibe_sys:
        vibe_sys['session_activities'] = []
    
    return project_context

def _parse_coding_flow_md(file_path):
    """coding_flow.md 파일을 파싱해서 딕셔너리로 반환"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        coding_flow = {
            'current_focus': '',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }
        
        lines = content.split('\n')
        current_section = None
        
        for line in lines:
            line_stripped = line.strip()
            
            # 섹션 감지
            if any(marker in line for marker in ['🔥 Current Focus', 'Current Focus', '## 🎯 Current Focus']):
                current_section = 'focus'
            elif any(marker in line for marker in ['⏭️ Next Up', 'Next Up', '## 📋 Next Tasks']):
                current_section = 'next_up'
            elif any(marker in line for marker in ['✅ Completed', 'Completed']):
                current_section = 'completed'
            elif any(marker in line for marker in ['📝 Quick Notes', 'Quick Notes']):
                current_section = 'notes'
            elif any(marker in line for marker in ['🚫 Blockers', 'Blockers']):
                current_section = 'blockers'
            elif any(marker in line for marker in ['📁 Working Files', 'Working Files']):
                current_section = 'files'
            elif any(marker in line for marker in ['🕐 Session Activity', 'Session Activity']):
                current_section = 'activity'
            
            # 내용 파싱
            elif current_section == 'focus' and line_stripped and not line_stripped.startswith('#') and not line_stripped.startswith('*'):
                if not coding_flow['current_focus']:
                    coding_flow['current_focus'] = line_stripped
            
            elif current_section == 'next_up':
                # 다양한 체크박스 형식 지원
                if line_stripped.startswith('- [ ]') or line_stripped.startswith('• [ ]'):
                    task = line_stripped[5:].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
                elif line_stripped.startswith('-') and '[' not in line_stripped:
                    # 체크박스 없는 항목도 지원
                    task = line_stripped[1:].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
                elif line_stripped and line_stripped[0].isdigit() and '.' in line_stripped:
                    # 번호 형식 (1. task) 지원
                    task = line_stripped.split('.', 1)[1].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
            
            elif current_section == 'completed' and (line_stripped.startswith('- [x]') or line_stripped.startswith('• [x]')):
                task = line_stripped[5:].strip()
                if task and task not in coding_flow['completed']:
                    coding_flow['completed'].append(task)
            
            elif current_section == 'notes' and line_stripped and not line_stripped.startswith('#'):
                coding_flow['quick_notes'] += line_stripped + '\n'
        
        # quick_notes 정리
        coding_flow['quick_notes'] = coding_flow['quick_notes'].strip()
        
        return coding_flow
        
    except Exception as e:
        print(f"⚠️ coding_flow.md 파싱 실패: {e}")
        return {
            'current_focus': 'memory_cache_persistence_system',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }

def __generate_coding_flow_md(coding_flow_data, memory_path):
    """coding_flow 데이터를 기반으로 coding_flow.md 생성"""
    try:
        content = f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

{coding_flow_data.get('current_focus', 'memory_cache_persistence_system')}

## ⏭️ Next Up ({len(coding_flow_data.get('next_up', []))}) tasks)
*바로 다음에 할 일들*

"""
        
        for task in coding_flow_data.get('next_up', []):
            content += f"- [ ] {task}\n"
        
        content += f"""
## ✅ Completed ({len(coding_flow_data.get('completed', []))}) tasks)
*완료된 작업들*

"""
        
        for task in coding_flow_data.get('completed', []):
            content += f"- [x] {task}\n"
        
        content += f"""
## 📝 Quick Notes
*빠른 메모*

{coding_flow_data.get('quick_notes', '')}

## 📁 Working Files
*최근 주로 작업한 파일들*

"""
        # Working Files 섹션 추가
        working_files = coding_flow_data.get('working_files', [])
        if working_files:
            for file_info in working_files:
                content += f"- {file_info.get('name', 'N/A')} ({file_info.get('count', 0)}회 접근)\n"
        else:
            content += "- (추적된 작업 파일 없음)\n"
        
        content += f"""
## 🕐 Session Activity Log
*최근 10개 활동 요약*

"""
        # Session Activity Log 섹션 추가
        activity_log = coding_flow_data.get('activity_log', [])
        if activity_log:
            for log in activity_log[:10]:  # 최근 10개만
                content += f"- {log.get('time', '')}: {log.get('op', '')} - {log.get('target', '')}\n"
        else:
            content += "- (기록된 활동 없음)\n"
        
        content += f"""
마지막 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
동기화 방식: 실시간 자동 동기화

## 🔧 System Status
- Cache items: {len(coding_flow_data)}
- Auto sync: True
- Base path: {memory_path}
"""
        
        coding_flow_file = os.path.join(memory_path, 'coding_flow.md')
        with open(coding_flow_file, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"✅ coding_flow.md 업데이트: {coding_flow_file}")
        return True
        
    except Exception as e:
        print(f"❌ coding_flow.md 생성 실패: {e}")
        return False

def _load_live_context_from_memory(project_context):
    """메모리 폴더에서 live_context 캐시로 로드 및 vibe_system 동기화"""
    try:
        memory_path = project_context['memory_bank']['project_path']
        live_context = {}
        
        # coding_flow.md 파싱
        coding_flow_file = os.path.join(memory_path, 'coding_flow.md')
        if os.path.exists(coding_flow_file):
            live_context['coding_flow'] = _parse_coding_flow_md(coding_flow_file)
            print(f"✅ coding_flow.md 로드 완료")
            
            # vibe_system에 동기화 (중요!)
            if 'vibe_system' in project_context:
                coding_flow = live_context['coding_flow']
                
                # Current Focus 동기화
                if coding_flow.get('current_focus'):
                    project_context['vibe_system']['current_focus'] = coding_flow['current_focus']
                
                # Next Tasks 동기화
                if coding_flow.get('next_up'):
                    tasks = []
                    for task_text in coding_flow['next_up']:
                        tasks.append({
                            'task': task_text,
                            'description': task_text,
                            'added_time': datetime.now().strftime("%H:%M"),
                            'status': 'pending',
                            'completed': False
                        })
                    project_context['vibe_system']['next_tasks'] = tasks
                
                # Completed Tasks 동기화
                if coding_flow.get('completed'):
                    completed = []
                    for task_text in coding_flow['completed']:
                        completed.append({
                            'task': task_text,
                            'description': task_text,
                            'completed_time': datetime.now().strftime("%H:%M"),
                            'status': 'completed',
                            'completed': True
                        })
                    project_context['vibe_system']['completed_tasks'] = completed
                
                print(f"✅ vibe_system 동기화 완료: Focus={coding_flow.get('current_focus', 'None')}, Tasks={len(coding_flow.get('next_up', []))}")
        else:
            live_context['coding_flow'] = {
                'current_focus': 'memory_cache_persistence_system',
                'next_up': [],
                'completed': [],
                'quick_notes': '',
                'last_updated': datetime.now().isoformat()
            }
            print(f"📝 coding_flow.md 기본값 생성")
        
        # 다른 컨텍스트들도 기본값 설정
        live_context['feature_roadmap'] = {'features': [], 'priorities': []}
        live_context['code_analysis'] = {'recent_files': [], 'insights': []}
        live_context['decision_log'] = {'decisions': []}
        live_context['project_vision'] = {'goals': [], 'principles': []}
        
        project_context['live_context'] = live_context
        print(f"✅ live_context 로드 완료: {len(live_context)}개 컨텍스트")
        
        return live_context
        
    except Exception as e:
        print(f"❌ live_context 로드 실패: {e}")
        project_context['live_context'] = {
            'coding_flow': {
                'current_focus': 'memory_cache_persistence_system',
                'next_up': [],
                'completed': [],
                'quick_notes': '',
                'last_updated': datetime.now().isoformat()
            }
        }
        return project_context['live_context']

def _sync_live_context_to_memory(project_context, changed_keys=None):
    """live_context 변경사항을 메모리 폴더에 즉시 반영"""
    try:
        memory_path = project_context['memory_bank']['project_path']
        live_context = project_context.get('live_context', {})
        
        # 변경된 키만 동기화 (성능 최적화)
        keys_to_sync = changed_keys or live_context.keys()
        
        synced_count = 0
        for key in keys_to_sync:
            if key == 'coding_flow' and 'coding_flow' in live_context:
                if __generate_coding_flow_md(live_context['coding_flow'], memory_path):
                    synced_count += 1
            # 추후 다른 파일들도 추가 예정
        
        # 동기화 상태 업데이트
        project_context['sync_status']['last_sync'] = datetime.now().isoformat()
        if changed_keys:
            project_context['sync_status']['pending_changes'] = []
        
        print(f"🔄 Live context 동기화 완료: {synced_count}개 파일")
        return True
        
    except Exception as e:
        print(f"❌ Live context 동기화 실패: {e}")
        return False

def _auto_sync_hook(project_context, trigger='unknown'):
    """execute_code 헬퍼 함수 실행 후 자동 동기화"""
    try:
        if project_context.get('sync_status', {}).get('auto_sync', True):
            _sync_live_context_to_memory(project_context)
            print(f"🔄 Auto-sync triggered by: {trigger}")
            return True
        else:
            print(f"⏸️ Auto-sync disabled (trigger: {trigger})")
            return False
    except Exception as e:
        print(f"❌ Auto-sync 실패: {e}")
        return False



def _ensure_vibe_memory_structure(memory_path: str) -> bool:
    """바이브 메모리 구조 확인 및 생성"""
    try:
        os.makedirs(memory_path, exist_ok=True)
        return True
    except Exception as e:
        print(f"❌ Error ensuring vibe memory structure: {e}")
        return False


def get_vibe_coding_flow_template() -> str:
    """coding_flow.md 템플릿 생성"""
    timestamp = dt.datetime.now().strftime("%Y-%m-%d %H:%M")
    return f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

현재 세션 시작: {timestamp}

## ⏭️ Next Up (1-3 items)
*바로 다음에 할 일들*

- [ ] 


## 📝 Quick Notes
*빠른 메모나 생각들*



## 🚫 Blockers
*막히거나 해결해야 할 것들*



## 📁 Working Files
*현재 작업중인 파일들*



## 🕐 Session Activity Log
*이 세션에서 한 일들*

- {timestamp[:5]} Session started
"""


def get_vibe_feature_roadmap_template() -> str:
    """feature_roadmap.md 템플릿 생성"""
    return """# 🚧 In Progress
*지금 만들고 있는 기능들*



## 📋 Planned Features  
*이번에 만들 예정인 기능들*



## ✅ Completed
*완료된 기능들*



## 🔗 Dependencies
*기능간 의존성이나 순서*



## 🧪 Testing Notes
*테스트 관련 메모*

"""


def get_vibe_project_vision_template() -> str:
    """project_vision.md 템플릿 생성"""
    return """# 🎯 Project Overview
*이 프로젝트가 뭔지*

## AI-Coding-Brain-MCP
execute_code 기반 24개 헬퍼 함수와 지속적 세션을 활용한 지능형 개발 어시스턴트

## 🏗️ Architecture
*전체 구조와 설계*

### Core Components
- execute_code 시스템 (24개 헬퍼 함수)
- parse_with_snippets 중심 분석
- 연속 세션 상태 관리
- 피드백 기반 학습

## 🛠️ Tech Stack
*사용하는 기술들*

- Python (core logic)
- JavaScript/TypeScript (MCP)
- JSON (data storage)
- Markdown (documentation)

## 🗂️ Major Milestones
*주요 마일스톤들*

- [x] Basic helper functions
- [x] parse_with_snippets 구현
- [x] 피드백 시스템
- [x] Vibe Memory System 구현

## 🔮 Future Direction
*앞으로의 방향*

- 더 지능적인 코드 분석
- 자동화 확대
- 개발자 경험 개선
"""


def vibe_task_capture(description: str, project_context: dict) -> str:
    """'/task "설명"' - 즉시 태스크 추가 (모든 구조 지원)"""
    if not description.strip():
        return "❌ Task description required"
    
    # 데이터 구조 호환성 보장
    _ensure_data_compatibility(project_context)
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    task_entry = {
        'description': description.strip(),
        'added_time': timestamp,
        'status': 'pending'
    }
    
    # 여러 위치에 추가 (호환성)
    # 1. vibe_system에 추가
    if 'vibe_system' in project_context:
        project_context['vibe_system']['next_tasks'].append(task_entry)
    
    # 2. 최상위 next_tasks에도 추가 (AI Brain 호환)
    if 'next_tasks' not in project_context:
        project_context['next_tasks'] = []
    project_context['next_tasks'].append(description.strip())
    
    # 3. work_tracking에도 추가
    if 'work_tracking' in project_context:
        if 'next_tasks' not in project_context['work_tracking']:
            project_context['work_tracking']['next_tasks'] = []
        if description.strip() not in project_context['work_tracking']['next_tasks']:
            project_context['work_tracking']['next_tasks'].append(description.strip())
    
    return f"✅ Task added: {description.strip()}"


def vibe_task_complete(task_description: str, project_context: dict) -> str:
    """'/done "태스크"' - 태스크 완료 처리 (기존 패턴 따름)"""
    if not task_description.strip():
        return "❌ Task description required"
    
    if 'vibe_system' not in project_context:
        return "❌ Vibe system not initialized"
    
    task_desc = task_description.strip()
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    # 진행중인 태스크에서 제거
    vibe_sys = project_context['vibe_system']
    remaining_tasks = []
    task_found = False
    
    for task in vibe_sys.get('next_tasks', []):
        if task.get('description', '') == task_desc:
            task_found = True
            # 완료된 태스크로 이동
            completed_task = task.copy()
            completed_task['completed_time'] = timestamp
            completed_task['status'] = 'completed'
            
            if 'completed_tasks' not in vibe_sys:
                vibe_sys['completed_tasks'] = []
            vibe_sys['completed_tasks'].append(completed_task)
        else:
            remaining_tasks.append(task)
    
    vibe_sys['next_tasks'] = remaining_tasks
    
    if task_found:
        return f"✅ Task completed: {task_desc}"
    else:
        return f"❌ Task not found: {task_desc}"


def vibe_update_focus(new_focus: str, project_context: dict) -> str:
    """'/focus "새포커스"' - 현재 집중 영역 변경 (모든 구조 지원)"""
    if not new_focus.strip():
        return "❌ Focus description required"
    
    # 데이터 구조 호환성 보장
    _ensure_data_compatibility(project_context)
    
    # 여러 위치에 업데이트 (호환성)
    # 1. vibe_system
    if 'vibe_system' in project_context:
        project_context['vibe_system']['current_focus'] = new_focus.strip()
    
    # 2. 최상위 current_focus (AI Brain 호환)
    project_context['current_focus'] = new_focus.strip()
    
    # 3. work_tracking
    if 'work_tracking' in project_context:
        project_context['work_tracking']['current_focus'] = new_focus.strip()
    
    return f"✅ Focus updated: {new_focus.strip()}"


def vibe_get_current_flow(project_context: dict) -> str:
    """'/flow' - 현재 코딩 플로우 보기 (캐시와 파일 모두 확인)"""
    # 데이터 구조 호환성 보장
    _ensure_data_compatibility(project_context)
    
    # vibe_system에서 데이터 가져오기
    vibe_sys = project_context.get('vibe_system', {})
    
    # 현재 focus 확인 (여러 소스에서)
    current_focus = (
        vibe_sys.get('current_focus') or 
        project_context.get('current_focus') or 
        project_context.get('work_tracking', {}).get('current_focus') or
        'No current focus set'
    )
    
    # next_tasks 통합
    all_tasks = []
    seen_tasks = set()
    
    # vibe_system의 tasks
    for task in vibe_sys.get('next_tasks', []):
        desc = task.get('description', task) if isinstance(task, dict) else str(task)
        if desc not in seen_tasks:
            all_tasks.append(task)
            seen_tasks.add(desc)
    
    # project_context의 tasks
    for task in project_context.get('next_tasks', []):
        desc = task if isinstance(task, str) else task.get('description', str(task))
        if desc not in seen_tasks:
            all_tasks.append({
                'description': desc,
                'added_time': datetime.now().strftime("%H:%M"),
                'status': 'pending'
            } if isinstance(task, str) else task)
            seen_tasks.add(desc)
    
    # work_tracking의 tasks
    for task in project_context.get('work_tracking', {}).get('next_tasks', []):
        desc = task if isinstance(task, str) else task.get('description', str(task))
        if desc not in seen_tasks:
            all_tasks.append({
                'description': desc,
                'added_time': datetime.now().strftime("%H:%M"),
                'status': 'pending'
            } if isinstance(task, str) else task)
            seen_tasks.add(desc)
    
    # 파일에서도 읽기 시도
    try:
        memory_path = project_context.get('memory_bank', {}).get('project_path')
        if not memory_path:
            # 경로 자동 감지
            memory_root = __get_memory_bank_root_from_claude_config()
            project_name = project_context.get('name', 'common')
            memory_path = os.path.join(memory_root, project_name)
        
        flow_file = os.path.join(memory_path, 'coding_flow.md')
        if os.path.exists(flow_file):
            file_data = _parse_coding_flow_md(flow_file)
            
            # 파일의 focus가 더 구체적이면 사용
            if file_data.get('current_focus') and current_focus == 'No current focus set':
                current_focus = file_data['current_focus']
            
            # 파일의 tasks 추가
            for task in file_data.get('next_up', []):
                if task not in seen_tasks:
                    all_tasks.append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
                    seen_tasks.add(task)
    except Exception as e:
        print(f"⚠️ 파일 읽기 중 오류: {e}")
    
    # 결과 생성
    result = "📋 CURRENT CODING FLOW:\n" + "="*40 + "\n"
    result += f"\n🔥 Current Focus: {current_focus}\n"
    result += f"\n⏭️ Next Up ({len(all_tasks)} tasks):\n"
    
    for i, task in enumerate(all_tasks[:10], 1):  # 최근 10개만
        desc = task.get('description', task) if isinstance(task, dict) else str(task)
        time = task.get('added_time', '') if isinstance(task, dict) else ''
        result += f"  {i}. {desc}"
        if time:
            result += f" (added {time})"
        result += "\n"
    
    if len(all_tasks) > 10:
        result += f"  ... and {len(all_tasks) - 10} more tasks\n"
    
    # 작업 통계 추가
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        file_access = wt.get('file_access_count', {})
        if file_access:
            result += "\n📊 Recent Activity:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:3]
            for file_path, count in sorted_files:
                file_name = os.path.basename(file_path)
                result += f"  • {file_name} ({count} times)\n"
    
    return result


def vibe_execute_code_hook(func_name: str, result: dict, project_context: dict):
    """execute_code 실행 후 자동 호출 훅 (기존 패턴 따름)"""
    if 'vibe_system' not in project_context:
        return
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    # 활동 로그 기록
    activity = {
        'function': func_name,
        'timestamp': timestamp,
        'summary': f"Executed {func_name}"
    }
    
    # 함수별 특별 처리
    if func_name == 'parse_with_snippets' and isinstance(result, dict):
        file_path = result.get('file_path', 'unknown')
        functions_count = len(result.get('functions', []))
        activity['summary'] = f"Analyzed {functions_count} functions in {os.path.basename(file_path)}"
        
        # 포커스 자동 업데이트
        project_context['vibe_system']['current_focus'] = f"Analyzing: {os.path.basename(file_path)}"
    
    elif func_name in ['safe_replace', 'insert_line', 'delete_lines']:
        file_path = result.get('file_path', 'unknown')
        activity['summary'] = f"Code modification: {func_name}"
        project_context['vibe_system']['current_focus'] = f"Modifying: {os.path.basename(file_path)}"
    
    # 세션 활동에 추가
    if 'session_activities' not in project_context['vibe_system']:
        project_context['vibe_system']['session_activities'] = []
    
    project_context['vibe_system']['session_activities'].append(activity)
    
    # 최근 20개만 유지
    if len(project_context['vibe_system']['session_activities']) > 20:
        project_context['vibe_system']['session_activities'] = project_context['vibe_system']['session_activities'][-20:]


class VibeMemoryManager:
    """바이브코딩 메모리 관리자 (기존 패턴 따름)"""
    
    def __init__(self, project_context: dict, project_name: str = None):
        """Claude Desktop 설정 기반 VibeMemoryManager 초기화"""
        self.project_context = project_context

        # 데이터 구조 호환성 보장 (중요!)
        _ensure_data_compatibility(self.project_context)

        # project_context에서 프로젝트명 가져오기
        self.project_name = project_name or project_context.get("name", "ai-coding-brain-mcp")

        # Claude Desktop 설정 기반 경로 설정
        self.memory_bank_root = globals()['__get_memory_bank_root_from_claude_config']()
        self.memory_path = os.path.join(self.memory_bank_root, self.project_name)

        # project_context와 연동
        _sync_project_context_with_memory_bank(self.project_context)

        # live_context 로드
        _load_live_context_from_memory(self.project_context)

        # 기존 템플릿 설정
        self.templates = {
            "coding_flow.md": get_vibe_coding_flow_template(),
            "feature_roadmap.md": get_vibe_feature_roadmap_template(),
            "project_vision.md": get_vibe_project_vision_template(),
            "decision-log.md": "# 🧠 Decision Log\n*중요한 설계 결정들과 배경*\n\n",
            "system-patterns.md": "# 🔧 System Patterns\n*아키텍처 패턴과 코딩 패턴들*\n\n"
        }

        # 메모리 뱅크 초기화
        self.initialize()

        print(f"✅ VibeMemoryManager 초기화 완료: {self.memory_path}")
    def initialize(self) -> bool:
        """바이브 메모리 시스템 초기화 (기존 패턴 따름)"""
        try:
            # 메모리 폴더 생성
            _ensure_vibe_memory_structure(self.memory_path)
            
            # project_context에 vibe_system 초기화
            if 'vibe_system' not in self.project_context:
                self.project_context['vibe_system'] = {
                    'next_tasks': [],
                    'completed_tasks': [],
                    'current_focus': 'Vibe Memory System activated',
                    'session_activities': [],
                    'status': 'active',
                    'initialized_at': dt.datetime.now().isoformat()
                }
            
            # 마크다운 파일들 생성
            created_files = []
            for filename, template in self.templates.items():
                filepath = os.path.join(self.memory_path, filename)
                if not os.path.exists(filepath):
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(template)
                    created_files.append(filename)
            
            print(f"✅ Vibe Memory System initialized")
            print(f"   📁 Path: {self.memory_path}")
            print(f"   📄 Files: {len(self.templates)} markdown files")
            if created_files:
                print(f"   🆕 Created: {', '.join(created_files)}")
            
            return True
            
        except Exception as e:
            print(f"❌ Vibe initialization error: {e}")
            return False
    
    def get_status(self) -> dict:
        """현재 바이브 시스템 상태 반환 (기존 패턴 따름)"""
        if 'vibe_system' not in self.project_context:
            return {'status': 'not_initialized'}
        
        vibe_sys = self.project_context['vibe_system']
        return {
            'status': vibe_sys.get('status', 'unknown'),
            'current_focus': vibe_sys.get('current_focus', ''),
            'pending_tasks': len(vibe_sys.get('next_tasks', [])),
            'completed_tasks': len(vibe_sys.get('completed_tasks', [])),
            'recent_activities': len(vibe_sys.get('session_activities', [])),
            'memory_path': self.memory_path
        }

    def sync_to_files(self):
        """캐시메모리 → .md 파일 동기화 (기존 파일 내용 보존)"""
        try:
            # 데이터 구조 호환성 보장
            _ensure_data_compatibility(self.project_context)
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            sync_results = []
            
            # coding_flow.md 업데이트 - 기존 파일 내용 먼저 읽기
            flow_path = os.path.join(self.memory_path, 'coding_flow.md')
            if os.path.exists(flow_path):
                # 기존 파일 파싱
                existing_data = _parse_coding_flow_md(flow_path)
                
                # 데이터 병합 (캐시 우선, 하지만 빈 값은 기존 값 유지)
                if not vibe_sys.get('current_focus') and existing_data.get('current_focus'):
                    vibe_sys['current_focus'] = existing_data['current_focus']
                
                # 기존 tasks와 캐시 tasks 병합 (중복 제거)
                existing_tasks = existing_data.get('next_up', [])
                for task in existing_tasks:
                    if task not in [t.get('description', t) for t in vibe_sys.get('next_tasks', [])]:
                        if 'next_tasks' not in vibe_sys:
                            vibe_sys['next_tasks'] = []
                        vibe_sys['next_tasks'].append({
                            'description': task,
                            'added_time': datetime.now().strftime("%H:%M"),
                            'status': 'pending'
                        })
            
            # 데이터가 있을 때만 파일 업데이트
            if vibe_sys.get('next_tasks') or vibe_sys.get('current_focus') or os.path.exists(flow_path):
                flow_content = self._generate_flow_content(vibe_sys)
                
                with open(flow_path, 'w', encoding='utf-8') as f:
                    f.write(flow_content)
                sync_results.append(f"✅ Updated coding_flow.md")
            
            # feature_roadmap.md 업데이트 (completed_tasks 반영)
            if vibe_sys.get('completed_tasks'):
                roadmap_content = self._generate_roadmap_content(vibe_sys)
                roadmap_path = os.path.join(self.memory_path, 'feature_roadmap.md')
                
                with open(roadmap_path, 'w', encoding='utf-8') as f:
                    f.write(roadmap_content)
                sync_results.append(f"✅ Updated feature_roadmap.md")
            
            # 동기화 시간 기록
            vibe_sys['last_sync_to_files'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'synced_files': len(sync_results),
                'results': sync_results,
                'timestamp': vibe_sys['last_sync_to_files']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_from_files(self):
        """.md 파일을 캐시메모리로 동기화 (v1.1부터 비활성화됨)"""
        print("⚠️ [DEPRECATED] sync_from_files: 이 함수는 더 이상 사용되지 않습니다.")
        print("   데이터 흐름은 항상 'Context Manager -> .md파일' 단방향으로 유지됩니다.")
        print("   .md 파일은 시스템 상태를 보여주는 뷰(View) 역할만 합니다.")
        return {
            'status': 'deprecated', 
            'message': 'Unidirectional data flow enforced. This function is disabled.'
        }
    def auto_save(self, interval=300):
        """자동 저장 (기본 5분 간격)"""
        try:
            # 현재는 즉시 동기화, 나중에 백그라운드 스케줄러로 확장 가능
            sync_result = self.sync_to_files()
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            vibe_sys['auto_save_interval'] = interval
            vibe_sys['last_auto_save'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'message': f'Auto-save completed (interval: {interval}s)',
                'sync_result': sync_result,
                'timestamp': vibe_sys['last_auto_save']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def force_sync(self):
        """강제 동기화 (캐시 -> 파일) - v1.1 단방향"""
        try:
            print("🔄 강제 동기화 (Cache -> Files) 실행...")
            
            # sync_from_files 호출을 제거하고 sync_to_files만 실행
            to_files_result = self.sync_to_files()
            
            if to_files_result:
                print("✅ 단방향 동기화 완료 (Cache → Files)")
                return {
                    'status': 'success',
                    'message': 'Unidirectional sync completed (cache to files)',
                    'direction': 'cache_to_files',
                    'to_files': to_files_result,
                    'timestamp': dt.datetime.now().isoformat()
                }
            else:
                return {'status': 'failed', 'message': 'sync_to_files failed'}
                
        except Exception as e:
            print(f"❌ 동기화 중 오류: {str(e)}")
            return {'status': 'error', 'message': str(e)}
    
    def sync_status(self):
        """동기화 상태 및 차이점 확인"""
        try:
            if 'vibe_system' not in self.project_context:
                return {'status': 'not_initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            
            # 마지막 동기화 시간들
            last_sync_to = vibe_sys.get('last_sync_to_files', 'Never')
            last_sync_from = vibe_sys.get('last_sync_from_files', 'Never')
            last_auto_save = vibe_sys.get('last_auto_save', 'Never')
            
            # 파일 존재 여부 확인
            file_status = {}
            for filename in self.templates.keys():
                filepath = os.path.join(self.memory_path, filename)
                file_status[filename] = {
                    'exists': os.path.exists(filepath),
                    'modified': dt.datetime.fromtimestamp(os.path.getmtime(filepath)).isoformat() if os.path.exists(filepath) else 'N/A'
                }
            
            return {
                'status': 'active',
                'cache_items': {
                    'next_tasks': len(vibe_sys.get('next_tasks', [])),
                    'completed_tasks': len(vibe_sys.get('completed_tasks', [])),
                    'current_focus': bool(vibe_sys.get('current_focus'))
                },
                'sync_history': {
                    'last_sync_to_files': last_sync_to,
                    'last_sync_from_files': last_sync_from,
                    'last_auto_save': last_auto_save
                },
                'file_status': file_status,
                'auto_save_interval': vibe_sys.get('auto_save_interval', 'Not set')
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def enable_auto_sync(self, enabled=True, interval=300):
        """자동 동기화 활성화/비활성화"""
        try:
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            vibe_sys['auto_sync_enabled'] = enabled
            vibe_sys['auto_sync_interval'] = interval
            vibe_sys['auto_sync_modified'] = dt.datetime.now().isoformat()
            
            if enabled:
                # 활성화시 즉시 한번 동기화
                sync_result = self.sync_to_files()
                return {
                    'status': 'success',
                    'message': f'Auto-sync enabled (interval: {interval}s)',
                    'initial_sync': sync_result,
                    'timestamp': vibe_sys['auto_sync_modified']
                }
            else:
                return {
                    'status': 'success',
                    'message': 'Auto-sync disabled',
                    'timestamp': vibe_sys['auto_sync_modified']
                }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def _generate_flow_content(self, vibe_sys):
        """coding_flow.md 내용 생성 헬퍼 (work_tracking 정보도 활용)"""
        # 데이터 구조 호환성 확인
        _ensure_data_compatibility(self.project_context)
        
        current_focus = vibe_sys.get('current_focus', '')
        
        # work_tracking에서도 focus 가져오기
        if not current_focus and 'work_tracking' in self.project_context:
            wt_focus = self.project_context['work_tracking'].get('current_focus', '')
            if wt_focus:
                current_focus = wt_focus
        
        if not current_focus:
            current_focus = 'No current focus set'
            
        next_tasks = vibe_sys.get('next_tasks', [])
        
        # work_tracking에서도 tasks 가져오기
        if 'work_tracking' in self.project_context:
            wt_tasks = self.project_context['work_tracking'].get('next_tasks', [])
            for task in wt_tasks:
                if isinstance(task, str) and task not in [t.get('description', t) for t in next_tasks]:
                    next_tasks.append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
        

    # ===========================================
    # Claude Memory Integration (from claude_memory_helpers.py)
    # ===========================================
    
        def save(self, key: str, content: str, metadata: Dict[str, Any] = None) -> Dict[str, Any]:
            """💾 ChromaDB 기반 경험 저장 (save_coding_experience 래핑)"""
            if not self.claude_memory:
                return {'status': 'error', 'message': 'Claude Memory not initialized'}
        
            try:
                # key를 기반으로 경험 데이터 구성
                experience_data = {
                    'key': key,
                    'content': content,
                    'timestamp': None,  # 자동 생성
                    'project_context': os.path.basename(os.getcwd()),
                    'tech_stack': self._detect_tech_stack(content),
                    'metadata': metadata or {}
                }
            
                # 기존 save_coding_experience 호출
                result = self.save_coding_experience(
                    experience_data=experience_data,
                    project_context=experience_data['project_context'],
                    tech_stack=experience_data['tech_stack'],
                    auto_categorize=True
                )
            
                return {
                    'status': 'success',
                    'key': key,
                    'result': result
                }
            
            except Exception as e:
                return {'status': 'error', 'message': str(e)}
    
        def search(self, query: str, limit: int = 5) -> List[Dict[str, Any]]:
            """🔍 ChromaDB 기반 검색 (search_coding_solutions 래핑)"""
            if not self.claude_memory:
                return [{'error': 'Claude Memory not initialized'}]
        
            try:
                # 기존 search_coding_solutions 호출
                results = self.search_coding_solutions(
                    error_signature=query,
                    project_context=os.path.basename(os.getcwd()),
                    tech_stack=["Python", "TypeScript", "JavaScript"],
                    top_k=limit
                )
            
                return results
            
            except Exception as e:
                return [{'error': f'Search failed: {str(e)}'}]
    
        def delete(self, pattern: str, confirm: bool = False) -> Dict[str, Any]:
            """🗑️ ChromaDB 기반 정리 (cleanup_coding_memory 래핑)"""
            if not self.claude_memory:
                return {'status': 'error', 'message': 'Claude Memory not initialized'}
        
            if not confirm:
                return {
                    'status': 'confirmation_required',
                    'message': f'정리 패턴: {pattern}. confirm=True로 재실행하세요.',
                    'pattern': pattern
                }
        
            try:
                # 패턴 기반 정리 설정
                if pattern.startswith('old:'):
                    days = int(pattern.split(':')[1].replace('days', ''))
                    max_age_days = days
                    min_importance = 0.0
                elif pattern.startswith('low:'):
                    threshold = float(pattern.split(':')[1])
                    max_age_days = 180
                    min_importance = threshold
                else:
                    # 기본 정리
                    max_age_days = 30
                    min_importance = 0.3
            
                # 기존 cleanup_coding_memory 호출
                result = self.cleanup_coding_memory(
                    auto_mode=True,
                    dry_run=False,
                    max_age_days=max_age_days,
                    min_importance=min_importance
                )
            
                return {
                    'status': 'success',
                    'pattern': pattern,
                    'result': result
                }
            
            except Exception as e:
                return {'status': 'error', 'message': str(e)}
    
        def insights(self, time_range_days: int = 30) -> Dict[str, Any]:
            """📊 ChromaDB 기반 인사이트 (get_coding_insights 래핑)"""
            if not self.claude_memory:
                return {'error': 'Claude Memory not initialized'}
        
            try:
                return self.get_coding_insights(
                    insight_types=["errors", "patterns", "suggestions"],
                    project_context=os.path.basename(os.getcwd()),
                    tech_stack=["Python", "TypeScript", "JavaScript"],
                    time_range_days=time_range_days
                )
            except Exception as e:
                return {'error': f'Insights failed: {str(e)}'}
    
        def analyze(self, code_result: Dict[str, Any]) -> Dict[str, Any]:
            """🔍 코드 결과 분석 (analyze_coding_context 래핑)"""
            if not self.claude_memory:
                return {'error': 'Claude Memory not initialized'}
        
            try:
                return self.analyze_coding_context(
                    code_result=code_result,
                    project_context=os.path.basename(os.getcwd()),
                    tech_stack=["Python", "TypeScript", "JavaScript"]
                )
            except Exception as e:
                return {'error': f'Analysis failed: {str(e)}'}
    
        def _detect_tech_stack(self, content: str) -> List[str]:
            """기술 스택 자동 감지"""
            tech_stack = []
            content_lower = content.lower()
        
            if any(keyword in content_lower for keyword in ['python', 'import ', 'def ', 'class ']):
                tech_stack.append("Python")
            if any(keyword in content_lower for keyword in ['typescript', 'interface', 'enum', '.ts']):
                tech_stack.append("TypeScript")
            if any(keyword in content_lower for keyword in ['javascript', 'function', 'const ', '.js']):
                tech_stack.append("JavaScript")
            if any(keyword in content_lower for keyword in ['react', 'jsx', 'component']):
                tech_stack.append("React")
            if any(keyword in content_lower for keyword in ['mcp', 'claude', 'anthropic']):
                tech_stack.append("MCP")
            
            return tech_stack if tech_stack else ["General"]
        content = f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

{current_focus}

## ⏭️ Next Up ({len(next_tasks)} tasks)
*바로 다음에 할 일들*

"""
        
        for task in next_tasks:
            title = task.get('description', task.get('title', 'Untitled task')) if isinstance(task, dict) else str(task)
            added_time = task.get('added_at', '') if isinstance(task, dict) else ''
            time_str = f" (added {added_time[11:16]})" if added_time else ""
            content += f"- [ ] {title}{time_str}\n"
        
        content += """

## 📝 Quick Notes
*빠른 메모나 생각들*



## 🚫 Blockers
*막히거나 해결해야 할 것들*



## 📁 Working Files
*현재 작업중인 파일들*



## 🕐 Session Activity Log
*이 세션에서 한 일들*

"""
        
        # 세션 활동들 추가
        activities = vibe_sys.get('session_activities', [])
        for activity in activities[-10:]:  # 최근 10개만
            content += f"- {activity}\n"
        
        return content
    
    def _generate_roadmap_content(self, vibe_sys):
        """feature_roadmap.md 내용 생성 헬퍼"""
        completed_tasks = vibe_sys.get('completed_tasks', [])
        
        content = """# 🗺️ Feature Roadmap
*장기 계획과 완료된 기능들*

## ✅ Completed Features

"""
        
        for task in completed_tasks[-20:]:  # 최근 20개만
            title = task.get('description', task.get('title', 'Untitled task')) if isinstance(task, dict) else str(task)
            completed_time = task.get('completed_at', '') if isinstance(task, dict) else ''
            time_str = f" (completed {completed_time[:10]})" if completed_time else ""
            content += f"- [x] {title}{time_str}\n"
        
        content += """

## 🚀 Upcoming Features
*계획된 기능들*

- [ ] Advanced auto-sync scheduler
- [ ] File change detection
- [ ] Multi-project support
- [ ] Real-time collaboration

## 💡 Ideas & Backlog
*아이디어 백로그*

"""
        
        return content



    
    def save(self, data, importance=0.5):
        """코딩 경험을 Claude Memory에 저장"""
        try:
            return save_coding_experience(data, self.project_context, importance=importance)
        except Exception as e:
            print(f"❌ save 실패: {e}")
            return False
    
    def search(self, query, tech_stack=None):
        """코딩 해결책 검색"""
        try:
            return search_coding_solutions(query, self.project_context, tech_stack)
        except Exception as e:
            print(f"❌ search 실패: {e}")
            return []
    
    def insights(self, tech_stack=None, time_range=None):
        """프로젝트 인사이트 조회"""
        try:
            return get_coding_insights(self.project_context, tech_stack, time_range)
        except Exception as e:
            print(f"❌ insights 실패: {e}")
            return {}
    
    def delete(self, query=None, confirm=False):
        """메모리 정리 (신중하게 사용)"""
        try:
            if not confirm:
                print("⚠️ delete 호출시 confirm=True 필요")
                return False
            return cleanup_coding_memory(dry_run=False, max_age=30, min_importance=0.3)
        except Exception as e:
            print(f"❌ delete 실패: {e}")
            return False

class VibeCommandSystem:
    """바이브 명령어 시스템 (기존 패턴 따름)"""
    
    def __init__(self, project_context: dict):
        self.project_context = project_context
        self.commands = {
            '/task': self._cmd_task,
            '/flow': self._cmd_flow,
            '/done': self._cmd_done,
            '/focus': self._cmd_focus,
            '/roadmap': self._cmd_roadmap,
            '/vision': self._cmd_vision,
            '/accept': self._cmd_accept,
            'help': self._cmd_help
        }
    
    def execute(self, command_line: str) -> str:
        """명령어 실행 (기존 패턴 따름) - 타입 검증 강화"""
        # 타입 검증 추가 (iterable 문제 해결)
        if not isinstance(command_line, str):
            return f"❌ Invalid command type: expected str, got {type(command_line).__name__}"
        
        if not command_line.strip():
            return "❌ Command required. Type 'help' for usage."
        
        command_line = command_line.strip()
        
        # 명령어 파싱
        if command_line == 'help':
            return self._cmd_help()
        elif command_line.startswith('/'):
            parts = command_line.split(' ', 1)
            cmd = parts[0]
            arg = parts[1].strip('\"') if len(parts) > 1 else ""
            
            if cmd in self.commands:
                try:
                    return self.commands[cmd](arg)
                except Exception as e:
                    return f"❌ Error executing {cmd}: {e}"
            else:
                return f"❌ Unknown command: {cmd}. Type 'help' for available commands."
        else:
            return f"❌ Commands must start with '/'. Type 'help' for usage."
    
    def _cmd_task(self, description: str) -> str:
        """'/task "설명"' 명령어"""
        return vibe_task_capture(description, self.project_context)
    
    def _cmd_flow(self, _: str = "") -> str:
        """'/flow' 명령어 - 캐시/메모리뱅크 정보 중심"""
        flow_text = "\n🔥 AI Coding Brain - Project Status\n"
        flow_text += "=" * 70 + "\n"
        
        # 1. 프로젝트 상태 요약
        flow_text += "\n📌 프로젝트 상태\n"
        flow_text += "-" * 60 + "\n"
        flow_text += f"프로젝트: {self.project_context.get('project_name', 'Unknown')}\n"
        flow_text += f"현재 Focus: {self.project_context.get('current_focus', 'Not set')}\n"
        
        # 작업 진행률 계산
        tasks = self.project_context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total_count = done_count + next_count
        progress = (done_count / total_count * 100) if total_count > 0 else 0
        
        flow_text += f"작업 진행률: {progress:.1f}% ({done_count}/{total_count})\n"
        
        # 2. 분석된 코드 구조
        flow_text += "\n📊 분석된 코드 구조\n"
        flow_text += "-" * 60 + "\n"
        
        analyzed_files = self.project_context.get('analyzed_files', {})
        if analyzed_files:
            total_functions = 0
            total_classes = 0
            
            for file_path, info in list(analyzed_files.items())[:5]:  # 최대 5개 파일
                file_name = os.path.basename(file_path)
                functions = info.get('functions', [])
                classes = info.get('classes', [])
                
                total_functions += len(functions)
                total_classes += len(classes)
                
                flow_text += f"\n📄 {file_name}\n"
                flow_text += f"   • 함수: {len(functions)}개"
                if functions[:3]:
                    flow_text += " (" + ", ".join(functions[:3])
                    if len(functions) > 3:
                        flow_text += f", ... +{len(functions)-3}"
                    flow_text += ")"
                flow_text += "\n"
                
                if classes:
                    flow_text += f"   • 클래스: {len(classes)}개 ({', '.join(classes)})\n"
            
            flow_text += f"\n📈 전체 통계:\n"
            flow_text += f"   • 분석된 파일: {len(analyzed_files)}개\n"
            flow_text += f"   • 총 함수: {total_functions}개\n"
            flow_text += f"   • 총 클래스: {total_classes}개\n"
        else:
            flow_text += "   ⚠️ 아직 분석된 파일이 없습니다.\n"
        
        # 3. 작업 추적 정보
        flow_text += "\n🔄 작업 추적 정보\n"
        flow_text += "-" * 60 + "\n"
        
        work_tracking = self.project_context.get('work_tracking', {})
        if work_tracking:
            # 파일 편집 통계
            file_edits = work_tracking.get('file_edits', {})
            if file_edits:
                flow_text += "최근 편집한 파일:\n"
                sorted_files = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)
                for file_path, count in sorted_files[:5]:
                    flow_text += f"   • {os.path.basename(file_path)}: {count}회 편집\n"
            
            # 함수 편집 통계
            function_edits = work_tracking.get('function_edits', {})
            if function_edits:
                flow_text += "\n최근 편집한 함수:\n"
                sorted_funcs = sorted(function_edits.items(), 
                                    key=lambda x: x[1].get('count', 0), reverse=True)
                for func_key, info in sorted_funcs[:5]:
                    count = info.get('count', 0)
                    flow_text += f"   • {func_key}: {count}회 편집\n"
        
        # 4. 메모리뱅크 정보
        flow_text += "\n💾 메모리뱅크 정보\n"
        flow_text += "-" * 60 + "\n"
        
        # 저장된 경험
        experiences = self.project_context.get('coding_experiences', [])
        if experiences:
            flow_text += f"저장된 경험: {len(experiences)}개\n"
            for exp in experiences[-3:]:
                task = exp.get('task', 'Unknown')
                solution = exp.get('solution', 'N/A')[:50]
                flow_text += f"   • {task}: {solution}...\n"
        
        # 5. 로드맵과 다음 단계
        flow_text += "\n🎯 로드맵과 다음 단계\n"
        flow_text += "-" * 60 + "\n"
        
        if self.project_context.get('current_focus'):
            flow_text += f"현재 Focus: {self.project_context['current_focus']}\n"
        
        # 다음 작업들
        next_tasks = tasks.get('next', [])
        if next_tasks:
            flow_text += "\n📋 다음 작업들:\n"
            for i, task in enumerate(next_tasks[:5], 1):
                flow_text += f"   {i}. {task}\n"
        else:
            flow_text += "\n   ℹ️ 다음 작업이 없습니다. /task 명령으로 추가하세요.\n"
        
        # 완료된 작업들 (최근 3개)
        done_tasks = tasks.get('done', [])
        if done_tasks:
            flow_text += "\n✅ 최근 완료:\n"
            for task in done_tasks[-3:]:
                flow_text += f"   • {task}\n"
        
        return flow_text
    

    def _cmd_accept(self, args: str) -> str:
        """'/accept' 명령어 - 더 이상 사용하지 않음"""
        return "ℹ️ /accept 명령어는 더 이상 사용되지 않습니다. /flow로 현재 상태를 확인하세요."

    def _cmd_done(self, task_description: str) -> str:
        """'/done "태스크"' 명령어"""
        return vibe_task_complete(task_description, self.project_context)
    
    def _cmd_focus(self, new_focus: str) -> str:
        """'/focus "새포커스"' 명령어"""
        return vibe_update_focus(new_focus, self.project_context)
    
    def _cmd_roadmap(self, _: str = "") -> str:
        """'/roadmap' 명령어"""
        if 'vibe_system' not in self.project_context:
            return "❌ Vibe system not initialized"
        
        completed = self.project_context['vibe_system'].get('completed_tasks', [])
        result = "🗂️ FEATURE ROADMAP:\n" + "="*40 + "\n"
        result += f"\n✅ Completed ({len(completed)} items):\n"
        
        for task in completed[-10:]:  # 최근 10개만
            desc = task.get('description', '')
            time = task.get('completed_time', '')
            result += f"  • {desc} (completed {time})\n"
        
        return result
    
    def _cmd_vision(self, _: str = "") -> str:
        """'/vision' 명령어"""
        return "🎯 PROJECT VISION:\nAI-Coding-Brain-MCP with Vibe Memory System\nOptimized for natural coding workflow\n"
    
    def _cmd_help(self) -> str:
        """도움말 명령어"""
        return """🔥 VIBE CODING MEMORY SYSTEM - 사용법
================================================================

📋 바이브 명령어:
  /task "설명"        → 즉시 태스크 추가 (5초 내 완료)
  /flow              → 현재 코딩 플로우 보기
  /done "태스크"      → 태스크 완료 처리
  /focus "새포커스"   → 현재 집중 영역 변경
  /roadmap           → 기능 로드맵 보기 
  /vision            → 프로젝트 비전 보기
  help               → 이 도움말

⚡ 자동화 기능:
  • execute_code 실행 → 자동으로 활동 기록
  • parse_with_snippets → 자동으로 포커스 업데이트
  • 모든 태스크와 활동이 project_context에 저장

🚀 시작하기: vibe_system.initialize() 실행 후 사용!
================================================================"""


# 전역 함수들 (기존 패턴에 맞춤)
def initialize_vibe_system(project_context: dict, project_name: str = 'ai-coding-brain-mcp') -> tuple:
    """바이브 시스템 초기화 및 반환 (기존 패턴 따름)"""
    vibe_manager = VibeMemoryManager(project_context, project_name)
    vibe_commands = VibeCommandSystem(project_context)
    
    success = globals()['vibe_manager'].initialize()
    
    return vibe_manager, vibe_commands, success


def register_vibe_helpers():
    """바이브 헬퍼 함수들을 전역에 등록 (기존 register_all_helpers 패턴 따름)"""
    global vibe_task_capture, vibe_task_complete, vibe_update_focus
    global vibe_get_current_flow, vibe_execute_code_hook
    global initialize_vibe_system, VibeMemoryManager, VibeCommandSystem
    global _ensure_data_compatibility, _parse_coding_flow_md
    
    # 헬퍼 함수들을 globals에 추가
    globals()['_ensure_data_compatibility'] = _ensure_data_compatibility
    globals()['_parse_coding_flow_md'] = _parse_coding_flow_md
    
    # 이미 전역에 정의되어 있으므로 추가 등록 불필요
    print("✅ Vibe helper functions registered globally", file=sys.stderr)
    return True

def enable_auto_sync_for_project_context(project_context):
    """project_context에 auto_sync_hook 활성화"""
    try:
        if 'sync_status' not in project_context:
            project_context['sync_status'] = {
                'last_sync': datetime.now().isoformat(),
                'pending_changes': [],
                'auto_sync': True
            }
        
        project_context['sync_status']['auto_sync'] = True
        print("✅ Auto-sync 활성화됨")
        
        # 즉시 한번 동기화 실행
        _auto_sync_hook(project_context, trigger='auto_sync_enabled')
        
        return True
    except Exception as e:
        print(f"❌ Auto-sync 활성화 실패: {e}")
        return False

def update_live_context_task(project_context, action, task_data):
    """live_context의 작업 목록 업데이트 및 자동 동기화"""
    try:
        if 'live_context' not in project_context:
            _load_live_context_from_memory(project_context)
        
        coding_flow = project_context['live_context']['coding_flow']
        
        if action == 'add_task':
            coding_flow['next_up'].append(task_data)
            print(f"✅ 새 작업 추가: {task_data}")
            
        elif action == 'complete_task':
            if task_data in coding_flow['next_up']:
                coding_flow['next_up'].remove(task_data)
                coding_flow['completed'].append(task_data)
                print(f"✅ 작업 완료: {task_data}")
            
        elif action == 'set_focus':
            coding_flow['current_focus'] = task_data
            print(f"🎯 포커스 변경: {task_data}")
            
        elif action == 'add_note':
            coding_flow['quick_notes'] += f"\n{datetime.now().strftime('%H:%M')} - {task_data}"
            print(f"📝 노트 추가: {task_data}")
        
        # 자동 동기화
        _auto_sync_hook(project_context, trigger=f'task_{action}')
        
        return True
        
    except Exception as e:
        print(f"❌ Live context 업데이트 실패: {e}")
        return False




# 자동 등록 (기존 패턴 따름)
if __name__ == "__main__":
    register_vibe_helpers()
    print("🔥 Vibe Memory System module loaded and ready!")

# ===========================================
# Global Claude Memory Functions
# ===========================================

def save_coding_experience(data, project_context=None, tech_stack=None, importance=0.7):
    """개발 경험 자동 저장 (VibeMemoryManager 연동)"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        vibe_manager = VibeMemoryManager(project_context)
        
        # 데이터 구조화
        if isinstance(data, str):
            structured_data = {
                'task': data,
                'tech_stack': tech_stack or 'unknown',
                'importance': importance,
                'timestamp': datetime.now().isoformat()
            }
        else:
            structured_data = data
            structured_data['importance'] = importance
            structured_data['timestamp'] = datetime.now().isoformat()
        
        # VibeMemoryManager의 save 메서드 사용
        key = f"coding_exp_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        return globals()['vibe_manager'].save(structured_data, importance)
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def search_coding_solutions(query, project_context=None, tech_stack=None, limit=10):
    """과거 해결책 검색 (VibeMemoryManager 연동)"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        vibe_manager = VibeMemoryManager(project_context)
        
        # VibeMemoryManager의 search 메서드 사용
        return globals()['vibe_manager'].search(query)
        
    except Exception as e:
        return {"status": "error", "message": str(e), "results": []}

def get_coding_insights(project_context=None, tech_stack=None, time_range=30):
    """프로젝트별 인사이트 (VibeMemoryManager 연동)"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        vibe_manager = VibeMemoryManager(project_context)
        
        # VibeMemoryManager의 insights 메서드 사용
        return globals()['vibe_manager'].insights(time_range=time_range)
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def get_claude_memory():
    """Claude Memory 직접 접근 (VibeMemoryManager 연동)"""
    try:
        project_context = globals().get('project_context', {})
        vibe_manager = VibeMemoryManager(project_context)
        
        # 간단한 메모리 상태 반환
        status = globals()['vibe_manager'].get_status()
        return {
            "status": "success",
            "memory_system": "VibeMemoryManager",
            "vibe_status": status
        }
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def cleanup_coding_memory(dry_run=True, max_age=90, min_importance=0.3):
    """메모리 최적화 (VibeMemoryManager 연동)"""
    try:
        project_context = globals().get('project_context', {})
        vibe_manager = VibeMemoryManager(project_context)
        
        # VibeMemoryManager의 delete 메서드 사용
        if not dry_run:
            pattern = f"importance:<{min_importance}"
            return globals()['vibe_manager'].delete(pattern, confirm=True)
        else:
            return {
                "status": "success", 
                "message": f"Dry run - would clean items older than {max_age} days with importance < {min_importance}",
                "dry_run": True
            }
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

# =============================================================================
# __all__ 선언된 함수들 구현 (VibeMemoryManager 래퍼)
# =============================================================================

def sync_to_files():
    """캐시메모리를 .md 파일로 동기화"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].sync_to_files()
    else:
        print('⚠️ vibe_manager가 초기화되지 않음')
        return False

def sync_from_files(self):
        """.md 파일을 캐시메모리로 동기화 (v1.1부터 비활성화됨)"""
        print("⚠️ [DEPRECATED] sync_from_files: 이 함수는 더 이상 사용되지 않습니다.")
        print("   데이터 흐름은 항상 'Context Manager -> .md파일' 단방향으로 유지됩니다.")
        print("   .md 파일은 시스템 상태를 보여주는 뷰(View) 역할만 합니다.")
        return {
            'status': 'deprecated', 
            'message': 'Unidirectional data flow enforced. This function is disabled.'
        }

def auto_save(interval=300):
    """자동 저장 활성화 (기본 5분 간격)"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].auto_save(interval)
    else:
        print('⚠️ vibe_manager가 초기화되지 않음')
        return False
def force_sync():
    """강제 동기화 (캐시 -> 파일) - v1.1 단방향 + 데이터 보존"""
    print("🔄 강제 동기화 (Cache -> Files) 실행...")
    
    # project_context 가져오기
    project_context = globals().get('project_context', {})
    if not project_context:
        return {'status': 'error', 'message': 'project_context not found'}
    
    # 데이터 구조 호환성 보장
    _ensure_data_compatibility(project_context)
    
    # vibe_manager가 없으면 생성
    if 'vibe_manager' not in globals():
        globals()['vibe_manager'] = VibeMemoryManager(project_context)
    
    # sync_to_files만 실행 (기존 데이터 보존 로직 포함)
    return globals()['vibe_manager'].force_sync()