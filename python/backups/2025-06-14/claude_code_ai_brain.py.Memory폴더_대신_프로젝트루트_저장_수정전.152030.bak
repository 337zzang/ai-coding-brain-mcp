#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
🧠 AI Coding Brain - 통합 버전 v6.2
==========================================

claude_code_ai_brain.py와 context_manager.py를 통합한 단일 파일.
핵심 기능만 유지하고 간소화함.

주요 기능:
- /flow 명령어로 프로젝트 전환
- 메모리 루트에 캐시 중앙 저장
- 프로젝트 루트에서 작업 수행
- 작업 추적 및 심볼 인덱싱
- 싱글톤 패턴 컨텍스트 관리

v6.2 변경사항:
- execute_code 환경과의 호환성 개선
- 직렬화 문제 완전 해결
- 전역 context 변수와 통합

작성일: 2025-06-14
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy


# ===========================================
# 통합 컨텍스트 관리자
# ===========================================

class UnifiedContextManager:
    """통합 컨텍스트 관리자 - 싱글톤 패턴"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None  # 캐시 저장 위치
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str, memory_root: str = None, 
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """프로젝트 컨텍스트 초기화
        
        Args:
            project_path: 프로젝트 작업 경로
            project_name: 프로젝트 이름
            memory_root: 캐시 저장 루트 (기본값: ~/Desktop/memory)
            existing_context: 기존 context (execute_code 환경용)
        """
        self.project_path = project_path
        self.project_name = project_name
        
        # 메모리 루트 설정 (없으면 기본값 사용)
        if memory_root:
            self.memory_root = memory_root
        else:
            # 기본값: 홈/Desktop/memory
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # 기존 context가 있으면 사용 (execute_code 환경)
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"✅ 기존 컨텍스트 사용: {project_name}")
        else:
            # 캐시된 컨텍스트 로드 시도
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"✅ 캐시된 컨텍스트 로드: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"✅ 새 컨텍스트 생성: {project_name}")
        
        # 구조 정규화
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_path(self) -> str:
        """캐시 파일 경로 반환 (메모리 루트 기준)"""
        # 메모리/{프로젝트명}/.cache/cache_{프로젝트명}.json
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        return os.path.join(cache_dir, f'cache_{self.project_name}.json')
    
    def _create_new_context(self) -> Dict[str, Any]:
        """새로운 컨텍스트 생성"""
        return {
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '6.2',
            
            # 캐시 구조
            'cache': {
                'analyzed_files': {},
                'symbol_index': {},
                'work_tracking': {
                    'file_access': {},
                    'file_edits': {},
                    'function_edits': {},
                    'session_start': dt.datetime.now().isoformat(),
                    'total_operations': 0
                }
            },
            
            # 작업 관리
            'tasks': {'next': [], 'done': []},
            'current_focus': '',
            
            # AI 학습 데이터
            'coding_experiences': [],
            
            # Phase 관리 (execute_code 호환)
            'phase_reports': {},
            'error_log': [],
            
            # 기타 필드들
            'analyzed_files': {},
            'work_tracking': {},
            'symbol_index': {}
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """캐시된 컨텍스트 로드 (메모리 루트에서)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_file = self._get_cache_file_path()
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    loaded_context = json.load(f)
                
                # 프로젝트 경로 업데이트 (경로가 변경되었을 수 있음)
                loaded_context['project_path'] = self.project_path
                loaded_context['memory_root'] = self.memory_root
                
                return loaded_context
            except Exception as e:
                print(f"⚠️ 캐시 로드 실패: {e}")
        return None
    
    def _normalize_context_structure(self):
        """컨텍스트 구조 정규화"""
        if not self.context:
            return
            
        # 필수 키 확인
        self.context.setdefault('cache', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('work_tracking', {})
        self.context.setdefault('symbol_index', {})
        
        # 경로 정보 업데이트
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root
        
        # 캐시 구조 확인
        cache = self.context['cache']
        cache.setdefault('analyzed_files', {})
        cache.setdefault('symbol_index', {})
        
        # work_tracking 구조
        work_tracking = cache.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        
        # 레거시 필드 마이그레이션
        if 'analyzed_files' in self.context and self.context['analyzed_files']:
            cache['analyzed_files'].update(self.context['analyzed_files'])
        
        if 'work_tracking' in self.context and isinstance(self.context['work_tracking'], dict):
            cache['work_tracking'].update(self.context['work_tracking'])
        
        if 'symbol_index' in self.context and self.context['symbol_index']:
            cache['symbol_index'].update(self.context['symbol_index'])
    
    def save(self) -> bool:
        """컨텍스트 저장 (메모리 루트에)"""
        if not self.context:
            print("⚠️ 저장할 컨텍스트가 없습니다")
            return False
        
        try:
            # 업데이트 시간 갱신
            self.context['updated_at'] = dt.datetime.now().isoformat()
            
            # 캐시 파일 경로
            cache_file = self._get_cache_file_path()
            
            # JSON 직렬화 가능한 형태로 변환
            serializable_context = self._prepare_serializable_context()
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            print(f"✅ 캐시 저장: {cache_file}")
            
            # 프로젝트 문서 업데이트 시도
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"⚠️ 프로젝트 문서 업데이트 실패: {e}")
            
            return True
            
        except Exception as e:
            print(f"❌ 캐시 저장 실패: {e}")
            return False
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON 직렬화 가능한 형태로 변환 (강화된 버전)"""
        # context가 없거나 dict가 아닌 경우 빈 dict 반환
        if not self.context or not isinstance(self.context, dict):
            return {}
        
        def is_serializable(obj):
            """객체가 JSON 직렬화 가능한지 확인"""
            try:
                json.dumps(obj)
                return True
            except:
                return False
        
        def convert(obj):
            """재귀적으로 객체를 직렬화 가능한 형태로 변환"""
            # 이미 직렬화 가능한 기본 타입
            if obj is None or isinstance(obj, (bool, int, float, str)):
                return obj
            
            # 날짜/시간 타입
            elif isinstance(obj, (dt.datetime, dt.date)):
                return obj.isoformat()
            
            # defaultdict -> dict
            elif isinstance(obj, defaultdict):
                return dict(obj)
            
            # set -> list
            elif isinstance(obj, set):
                return list(obj)
            
            # dict 처리
            elif isinstance(obj, dict):
                result = {}
                for k, v in obj.items():
                    # 키도 문자열로 변환
                    key = str(k) if not isinstance(k, str) else k
                    # 직렬화 불가능한 값은 제외
                    if is_serializable(v):
                        result[key] = convert(v)
                    else:
                        # 객체 타입이면 타입명만 저장
                        if hasattr(v, '__class__'):
                            result[key] = f"<{v.__class__.__name__} object>"
                        else:
                            # 그 외는 건너뛰기
                            pass
                return result
            
            # list/tuple 처리
            elif isinstance(obj, (list, tuple)):
                return [convert(item) for item in obj if is_serializable(item)]
            
            # 커스텀 객체들은 문자열로 표현
            elif hasattr(obj, '__class__'):
                return f"<{obj.__class__.__name__} object>"
            
            # 그 외의 경우
            else:
                return str(obj)
        
        # 컨텍스트 복사 후 변환
        serializable = convert(copy.deepcopy(self.context))
        
        # 특정 필드 제거 (직렬화 불가능한 것들) - dict인 경우에만
        if isinstance(serializable, dict):
            fields_to_remove = ['error_tracker', 'phase_reporter', 'change_tracker', 'flow_options']
            for field in fields_to_remove:
                if field in serializable:
                    del serializable[field]
        
        return serializable
    
    def _update_project_docs(self):
        """프로젝트 문서 업데이트"""
        if not self.context or not self.project_path:
            return
        
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(self.memory_root, self.project_name, filename)
            try:
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"⚠️ {filename} 업데이트 실패: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md 생성"""
        if not self.context:
            return "# AI Coding Brain MCP - 프로젝트 비전\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        analyzed = len(self.context.get('cache', {}).get('analyzed_files', {}))
        symbols = len(self.context.get('cache', {}).get('symbol_index', {}))
        tasks = self.context.get('tasks', {})
        
        content = f"""# AI Coding Brain MCP - 프로젝트 비전

## 🎯 프로젝트 개요
MCP (Model Context Protocol) 기반 통합 개발 지원 시스템

## 📊 현재 상태
- 분석된 파일: {analyzed}개
- 심볼 인덱스: {symbols}개
- 완료된 작업: {len(tasks.get('done', []))}개
- 진행 중 작업: {len(tasks.get('next', []))}개

## 🔧 핵심 기능
1. **자동 컨텍스트 관리**: 작업 상태 자동 저장/복원
2. **통합 검색 시스템**: 코드, 메모리, 캐시 통합 검색
3. **Phase 기반 작업 관리**: 체계적인 프로젝트 진행
4. **SimplEdit 안전 수정**: 백업과 함께하는 안전한 코드 수정

## 📦 주요 모듈

## 📈 프로젝트 통계
"""
        
        # project_path가 있을 때만 파일 통계 추가
        if self.project_path and os.path.exists(self.project_path):
            try:
                py_files = [f for f in os.listdir(self.project_path) if f.endswith('.py')]
                py_count = len(py_files)
                completion_rate = (analyzed / max(1, py_count)) * 100
                
                content += f"""- 전체 Python 파일: {py_count}개
- 분석 완료율: {completion_rate:.1f}%

"""
            except Exception:
                pass
        
        content += f"""최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 현재 작업\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        focus = self.context.get('current_focus', '')
        tasks = self.context.get('tasks', {})
        
        return f"""# AI Coding Brain - 현재 작업

## 🎯 현재 Focus
{focus}

## 🔄 진행 중인 작업
{chr(10).join(f'- {task}' for task in tasks.get('next', [])[:5])}

## 💡 다음 단계

## 📝 메모
- save_context() 호출 시 4개 문서 자동 업데이트
- 백업 없이 직접 저장

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
    
    def _generate_file_directory(self) -> str:
        """file_directory.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 프로젝트 구조\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        analyzed = self.context.get('cache', {}).get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - 프로젝트 구조

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## 📁 Python 모듈 목록

| 경로 | 설명 | 수정일 |
|------|------|--------|
"""
        
        for file_path, info in analyzed.items():
            mod_time = info.get('last_modified', 'Unknown')
            content += f"| {file_path} | - | {mod_time} |\n"
        
        content += f"""

## 📊 통계
- Python 파일: {len(analyzed)}개
- 분석 완료: {len(analyzed)}개

## 📌 주요 디렉토리
- `/python/` - 핵심 Python 모듈들
- `/src/` - TypeScript/JavaScript 소스
- `/backups/` - 백업 파일들
- `/dist/` - 빌드 결과물
- `/.cache/` - 캐시 파일들
"""
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 진행 상황\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        tasks = self.context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total = done_count + next_count
        progress = (done_count / max(1, total)) * 100
        
        return f"""# AI Coding Brain - 진행 상황

## 📊 전체 진행률
- 완료: {done_count}개
- 남음: {next_count}개
- 진행률: {progress:.1f}%

## 🎯 Phase 진행 상황

## 📋 최근 완료 작업
{chr(10).join(f'- {task}' for task in tasks.get('done', [])[-5:])}

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
    
    # ===========================================
    # 캐시 관리 메서드
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """캐시 업데이트 (중첩 키 지원)"""
        if not self.context:
            return
        
        cache = self.context.setdefault('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """캐시 값 조회"""
        if not self.context:
            return default
        
        cache = self.context.get('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # 심볼 및 작업 추적
    # ===========================================
    
    def find_symbol(self, symbol_name: str) -> Optional[Dict[str, Any]]:
        """심볼 검색"""
        if not self.context:
            return None
        
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        return symbol_index.get(symbol_name)
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """파일 접근 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        # 상대 경로로 정규화
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        file_access[file_path] = file_access.get(file_path, 0) + 1
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """함수 수정 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        # 함수 키 생성
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        # 상대 경로로 정규화
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        # 편집 정보 업데이트
        if func_key not in function_edits:
            function_edits[func_key] = {'count': 0, 'operations': []}
        
        function_edits[func_key]['count'] += 1
        function_edits[func_key]['operations'].append({
            'timestamp': dt.datetime.now().isoformat(),
            'file': file_path
        })
        
        # 파일 편집도 추적
        file_edits = work_tracking.setdefault('file_edits', {})
        file_edits[file_path] = file_edits.get(file_path, 0) + 1
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
    
    def get_work_tracking_summary(self) -> str:
        """작업 추적 요약"""
        if not self.context:
            return "컨텍스트가 초기화되지 않았습니다."
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # 세션 시간 계산
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        # 통계 수집
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        
        # 요약 생성
        summary = f"""
📊 작업 추적 요약
================
• 프로젝트: {self.project_name}
• 작업 경로: {self.project_path}
• 캐시 경로: {self.memory_root}
• 세션 시간: {duration_str}
• 전체 작업: {total_ops}회
• 접근한 파일: {len(file_access)}개
• 수정한 파일: {len(file_edits)}개
• 수정한 함수: {len(function_edits)}개
"""
        
        # Top 5 파일
        if file_access:
            summary += "\n🔥 가장 많이 접근한 파일:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:5]
            for file_path, count in sorted_files:
                summary += f"  • {file_path}: {count}회\n"
        
        # Top 5 함수
        if function_edits:
            summary += "\n✏️ 가장 많이 수정한 함수:\n"
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1]['count'], reverse=True)[:5]
            for func_name, info in sorted_funcs:
                summary += f"  • {func_name}: {info['count']}회\n"
        
        return summary


# ===========================================
# 글로벌 컨텍스트 관리자
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str, memory_root: str = None,
                      existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """프로젝트 컨텍스트 초기화"""
    return _context_manager.initialize(project_path, project_name, memory_root, existing_context)

def save_context() -> bool:
    """컨텍스트 저장"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """캐시 업데이트"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """캐시 값 조회"""
    return _context_manager.get_value(key, default)

def find_symbol(symbol_name: str) -> Optional[Dict[str, Any]]:
    """심볼 찾기"""
    return _context_manager.find_symbol(symbol_name)

def track_file_access(file_path: str, operation: str = 'read'):
    """파일 접근 추적"""
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """함수 수정 추적"""
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """작업 추적 요약"""
    return _context_manager.get_work_tracking_summary()


# ===========================================
# Claude Desktop 설정 및 명령어 처리
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop 설정에서 경로 가져오기"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_root': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_root'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"⚠️ 설정 로드 실패: {e}")
    
    return paths


def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> None:
    """/flow 명령어 - 프로젝트 전환
    
    Args:
        project_name: 전환할 프로젝트명
        existing_context: 기존 context (execute_code 환경용)
    """
    
    if not project_name:
        # 현재 상태 표시
        if _context_manager.project_name:
            print(f"\n🔥 현재 프로젝트: {_context_manager.project_name}")
            print(f"📁 작업 경로: {_context_manager.project_path}")
            print(f"💾 캐시 경로: {_context_manager.memory_root}")
            print(get_work_tracking_summary())
        else:
            print("\n⚠️ 프로젝트가 선택되지 않았습니다")
            print("사용법: /flow [프로젝트명]")
        return
    
    # 이전 컨텍스트 저장
    if _context_manager.context:
        save_context()
    
    # 경로 가져오기
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    # execute_code 환경에서는 Desktop 직속 경로 우선 확인
    if existing_context:
        # Desktop 직속 경로 먼저 확인
        desktop_path = paths['project_root'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            project_path = os.getcwd()
            location = 'current'
    else:
        # 프로젝트 경로 찾기 (Desktop 우선, 그 다음 메모리)
        project_path = paths['project_root'] / project_name
        location = 'desktop'
        
        if not project_path.exists():
            # 메모리 루트 확인
            project_path = paths['memory_root'] / project_name
            location = 'memory'
            
            if not project_path.exists():
                # 현재 디렉토리에서 찾기
                if os.path.basename(os.getcwd()) == project_name:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\n❌ 프로젝트 '{project_name}'를 찾을 수 없습니다")
                    print(f"   • Desktop: {paths['project_root'] / project_name}")
                    print(f"   • Memory: {paths['memory_root'] / project_name}")
                    return
    
    # 작업 디렉토리 변경 (execute_code 환경이 아닌 경우에만)
    if not existing_context:
        os.chdir(project_path)
    
    # Context 초기화 (메모리 루트와 기존 context 전달)
    context = initialize_context(str(project_path), project_name, memory_root, existing_context)
    
    print(f"\n✅ 프로젝트 '{project_name}'로 전환 완료!")
    print(f"📁 작업 경로: {project_path} ({location})")
    print(f"💾 캐시 경로: {memory_root}/{project_name}/.cache/")
    print(f"📊 캐시 버전: {context.get('version', 'Unknown')}")
    
    # 간단한 통계 표시
    analyzed_files = context.get('cache', {}).get('analyzed_files', {})
    tasks = context.get('tasks', {})
    print(f"📈 분석된 파일: {len(analyzed_files)}개")
    print(f"📋 남은 작업: {len(tasks.get('next', []))}개")
    print(f"✅ 완료된 작업: {len(tasks.get('done', []))}개")


# ===========================================
# 메인 진입점
# ===========================================



def cmd_plan(plan_name: str = None, description: str = None, ctx: Dict[str, Any] = None) -> None:
    """/plan 명령어 - 새로운 계획 생성 (기존 계획 리셋)
    
    Args:
        plan_name: 계획 이름
        description: 계획 설명
    """
    ctx = ctx or (_context_manager.context if _context_manager else None)
    if not ctx:
        print("❌ 프로젝트가 선택되지 않았습니다. 먼저 /flow [프로젝트명]을 실행하세요.")
        return
    
    if not plan_name:
        # 현재 계획 표시
        if 'plan' in ctx and ctx['plan']:
            plan = ctx['plan']
            print(f"\n📋 현재 계획: {plan['name']}")
            print(f"   설명: {plan.get('description', 'N/A')}")
            print(f"   생성: {plan.get('created_at', 'N/A')}")
            print(f"   수정: {plan.get('updated_at', 'N/A')}")
            print(f"\n   Phase 수: {len(plan.get('phases', []))}개")
            
            for phase in plan.get('phases', []):
                status_emoji = "✅" if phase['status'] == 'done' else "🔄" if phase['status'] == 'in_progress' else "⏳"
                print(f"\n   {status_emoji} {phase['name']}")
                for task in phase.get('tasks', []):
                    task_emoji = "✅" if task['status'] == 'done' else "🔄" if task['status'] == 'in_progress' else "⏳"
                    print(f"      {task_emoji} [{task['id']}] {task['title']}")
        else:
            print("\n⚠️ 현재 설정된 계획이 없습니다.")
            print("사용법: /plan [계획명] [설명]")
        return
    
    # 새 계획 생성
    timestamp = dt.datetime.now().isoformat()
    
    ctx['plan'] = {
        'name': plan_name,
        'description': description or f"{_context_manager.project_name} 작업 계획",
        'created_at': timestamp,
        'updated_at': timestamp,
        'phases': [],
        'current_phase': None,
        'current_task': None
    }
    
    # 기본 Phase 1 생성
    phase1 = {
        'id': 'phase-1',
        'name': 'Phase 1: 초기 작업',
        'status': 'pending',
        'tasks': []
    }
    
    _context_manager.context['plan']['phases'].append(phase1)
    _context_manager.context['plan']['current_phase'] = 'phase-1'
    
    save_context()
    print(f"\n✅ 새 계획 '{plan_name}' 생성 완료!")
    print(f"   설명: {ctx['plan']['description']}")
    if ctx['plan']['phases']:
        print(f"   Phase 1이 생성되었습니다. /task add phase-1 [작업명]으로 작업을 추가하세요.")


def cmd_task(action: str, *args, ctx: Dict[str, Any] = None) -> None:
    """/task 명령어 - 작업 추가/수정
    
    Args:
        action: add, edit, delete, move
        args: 액션별 인자
    """
    if not _context_manager.context or 'plan' not in _context_manager.context:
        print("❌ 계획이 없습니다. 먼저 /plan [계획명]을 실행하세요.")
        return
    
    plan = ctx['plan']
    
    if action == 'add':
        # /task add [phase-id] [task-title] [description]
        if len(args) < 2:
            print("사용법: /task add [phase-id] [작업명] [설명(선택)]")
            return
            
        phase_id = args[0]
        task_title = args[1]
        task_desc = args[2] if len(args) > 2 else ""
        
        # Phase 찾기
        phase = next((p for p in plan['phases'] if p['id'] == phase_id), None)
        if not phase:
            print(f"❌ Phase '{phase_id}'를 찾을 수 없습니다.")
            return
        
        # 새 Task ID 생성
        phase_num = phase_id.split('-')[1]
        task_num = len(phase['tasks']) + 1
        new_task = {
            'id': f'{phase_num}-{task_num}',
            'title': task_title,
            'description': task_desc,
            'status': 'pending',
            'subtasks': []
        }
        
        phase['tasks'].append(new_task)
        plan['updated_at'] = dt.datetime.now().isoformat()
        save_context()
        
        print(f"✅ Task 추가됨: [{new_task['id']}] {task_title}")
        
    elif action == 'edit':
        # /task edit [task-id] status|title|desc [new-value]
        if len(args) < 3:
            print("사용법: /task edit [task-id] status|title|desc [새값]")
            return
            
        task_id = args[0]
        field = args[1]
        new_value = ' '.join(args[2:])
        
        # Task 찾기
        task_found = False
        for phase in plan['phases']:
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if field == 'status' and new_value in ['pending', 'in_progress', 'done', 'blocked']:
                        task['status'] = new_value
                    elif field == 'title':
                        task['title'] = new_value
                    elif field in ['desc', 'description']:
                        task['description'] = new_value
                    else:
                        print(f"❌ 알 수 없는 필드: {field}")
                        return
                    
                    task_found = True
                    plan['updated_at'] = dt.datetime.now().isoformat()
                    save_context()
                    print(f"✅ Task [{task_id}] {field} 수정됨")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"❌ Task '{task_id}'를 찾을 수 없습니다.")
    
    elif action == 'list':
        # 현재 모든 task 표시
        print("\n📋 전체 Task 목록:")
        for phase in plan['phases']:
            status_emoji = "✅" if phase['status'] == 'done' else "🔄" if phase['status'] == 'in_progress' else "⏳"
            print(f"\n{status_emoji} {phase['name']} ({phase['id']})")
            for task in phase['tasks']:
                task_emoji = "✅" if task['status'] == 'done' else "🔄" if task['status'] == 'in_progress' else "📌" if task['status'] == 'blocked' else "⏳"
                current = " 👈 현재" if plan.get('current_task') == task['id'] else ""
                print(f"   {task_emoji} [{task['id']}] {task['title']}{current}")
                if task['description']:
                    print(f"      📝 {task['description']}")
    
    else:
        print(f"❌ 알 수 없는 액션: {action}")
        print("사용 가능한 액션: add, edit, list")


def cmd_next(ctx: Dict[str, Any] = None) -> None:
    """/next 명령어 - 다음 작업으로 진행
    
    현재 작업을 완료로 표시하고 다음 pending 작업으로 이동
    """
    if not _context_manager.context or 'plan' not in _context_manager.context:
        print("❌ 계획이 없습니다. 먼저 /plan [계획명]을 실행하세요.")
        return
    
    plan = ctx['plan']
    
    # 현재 작업이 있으면 완료로 표시
    if plan.get('current_task'):
        for phase in plan['phases']:
            for task in phase['tasks']:
                if task['id'] == plan['current_task']:
                    if task['status'] != 'done':
                        task['status'] = 'done'
                        print(f"✅ Task [{task['id']}] {task['title']} 완료!")
    
    # 다음 pending 작업 찾기
    next_task = None
    next_phase = None
    
    for phase in plan['phases']:
        if phase['status'] == 'done':
            continue
            
        for task in phase['tasks']:
            if task['status'] == 'pending':
                next_task = task
                next_phase = phase
                break
        
        if next_task:
            break
    
    if next_task:
        # 현재 작업 설정
        plan['current_task'] = next_task['id']
        plan['current_phase'] = next_phase['id']
        next_task['status'] = 'in_progress'
        next_phase['status'] = 'in_progress'
        
        plan['updated_at'] = dt.datetime.now().isoformat()
        save_context()
        
        print(f"\n🎯 다음 작업: [{next_task['id']}] {next_task['title']}")
        if next_task['description']:
            print(f"   📝 설명: {next_task['description']}")
        print(f"   📍 Phase: {next_phase['name']}")
        
        # 서브태스크가 있으면 표시
        if next_task.get('subtasks'):
            print(f"\n   📌 서브태스크:")
            for subtask in next_task['subtasks']:
                print(f"      - {subtask['title']}")
    else:
        # 모든 작업 완료 확인
        all_done = True
        for phase in plan['phases']:
            for task in phase['tasks']:
                if task['status'] != 'done':
                    all_done = False
                    break
            if not all_done:
                break
        
        if all_done:
            print("\n🎉 모든 작업이 완료되었습니다!")
        else:
            print("\n⚠️ 진행 가능한 작업이 없습니다. (blocked 작업 확인 필요)")


def process_command(command: str, existing_context: Dict[str, Any] = None) -> Any:
    """명령어 처리
    
    Args:
        command: 처리할 명령어
        existing_context: 기존 context (execute_code 환경용)
        
    Returns:
        명령어 실행 결과
    """
    parts = command.strip().split()
    if not parts:
        return None
    
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    if cmd == '/flow':
        project_name = args[0] if args else None
        return cmd_flow(project_name, existing_context)
    
    elif cmd == '/plan':
        if len(args) == 0:
            return cmd_plan()
        elif len(args) == 1:
            return cmd_plan(args[0])
        else:
            # 첫 번째 인자는 계획명, 나머지는 설명
            return cmd_plan(args[0], ' '.join(args[1:]))
    
    elif cmd == '/task':
        if not args:
            print("사용법: /task add|edit|list [인자...]")
            return None
        return cmd_task(args[0], *args[1:])
    
    elif cmd == '/next':
        return cmd_next()
    
    else:
        print(f"알 수 없는 명령어: {cmd}")
        print("사용 가능한 명령어: /flow, /plan, /task, /next")
        return None
