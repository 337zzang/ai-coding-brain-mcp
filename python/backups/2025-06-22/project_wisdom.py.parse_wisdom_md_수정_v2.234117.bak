#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Project Wisdom Manager - AI Coding Brain MCP
í”„ë¡œì íŠ¸ ì‘ì—… ì¤‘ ì¶•ì ë˜ëŠ” ì§€í˜œì™€ êµí›ˆì„ ê´€ë¦¬í•˜ëŠ” ëª¨ë“ˆ

ì‘ì„±ì¼: 2025-06-22
"""

import os
import json
import re
from datetime import datetime
from typing import Dict, List, Any, Optional
from pathlib import Path

class ProjectWisdomManager:
    """í”„ë¡œì íŠ¸ ì§€í˜œ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.wisdom_file = self.project_root / "project_wisdom.md"
        self.vision_file = self.project_root / "project_vision.md"
        self.wisdom_data = {
            'error_patterns': {},
            'common_mistakes': {},
            'best_practices': [],
            'last_updated': datetime.now().isoformat()
        }
        self.load_wisdom()
    
    def load_wisdom(self):
        """ê¸°ì¡´ wisdom ë°ì´í„° ë¡œë“œ"""
        if self.wisdom_file.exists():
            # MD íŒŒì¼ íŒŒì‹±í•˜ì—¬ ë°ì´í„° ì¶”ì¶œ
            content = self.wisdom_file.read_text(encoding='utf-8')
            self._parse_wisdom_md(content)
    
    def _parse_wisdom_md(self, content: str):
        """MD íŒŒì¼ì—ì„œ wisdom ë°ì´í„° ì¶”ì¶œ"""
        lines = content.split('\n')
        current_section = None
        
        for i, line in enumerate(lines):
            # ì„¹ì…˜ ê°ì§€
            if '## ğŸ› ìì£¼ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ íŒ¨í„´' in line:
                current_section = 'errors'
            elif '## âŒ ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ë“¤' in line:
                current_section = 'mistakes'
            elif '## âœ… ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤' in line:
                current_section = 'practices'
            
            # ë°ì´í„° ì¶”ì¶œ
            if current_section == 'errors' and '###' in line:
                error_name = line.replace('###', '').strip()
                # ë‹¤ìŒ ì¤„ë“¤ì—ì„œ ì •ë³´ ì¶”ì¶œ
                for j in range(i+1, min(i+5, len(lines))):
                    if 'ë°œìƒ íšŸìˆ˜' in lines[j]:
                        count = int(re.search(r'(\d+)íšŒ', lines[j]).group(1))
                        self.wisdom_data['error_patterns'][error_name] = {'count': count}
                        break
    
    def track_error(self, error_type: str, error_msg: str):
        """ì˜¤ë¥˜ ë°œìƒ ì¶”ì """
        if error_type not in self.wisdom_data['error_patterns']:
            self.wisdom_data['error_patterns'][error_type] = {
                'count': 0,
                'first_seen': datetime.now().isoformat(),
                'messages': []
            }
        
        pattern = self.wisdom_data['error_patterns'][error_type]
        pattern['count'] += 1
        pattern['last_seen'] = datetime.now().isoformat()
        
        # ë©”ì‹œì§€ ì €ì¥ (ìµœëŒ€ 5ê°œ)
        if error_msg not in pattern['messages']:
            pattern['messages'].append(error_msg)
            pattern['messages'] = pattern['messages'][-5:]
        
        self.save_wisdom()
        
        # ê²½ê³  ë©”ì‹œì§€
        if pattern['count'] > 2:
            print(f"âš ï¸ '{error_type}' ì˜¤ë¥˜ê°€ {pattern['count']}ë²ˆì§¸ ë°œìƒí–ˆìŠµë‹ˆë‹¤!")
            print(f"ğŸ’¡ íŒ: {self._get_error_tip(error_type)}")
    
    def track_mistake(self, mistake_type: str, context: str = ""):
        """ì‹¤ìˆ˜ ì¶”ì """
        if mistake_type not in self.wisdom_data['common_mistakes']:
            self.wisdom_data['common_mistakes'][mistake_type] = {
                'count': 0,
                'first_seen': datetime.now().isoformat(),
                'contexts': []
            }
        
        mistake = self.wisdom_data['common_mistakes'][mistake_type]
        mistake['count'] += 1
        mistake['last_seen'] = datetime.now().isoformat()
        
        if context and context not in mistake['contexts']:
            mistake['contexts'].append(context)
            mistake['contexts'] = mistake['contexts'][-3:]
        
        self.save_wisdom()
        
        # ì‹¤ì‹œê°„ ê²½ê³ 
        self._show_mistake_warning(mistake_type, mistake['count'])
    
    def _show_mistake_warning(self, mistake_type: str, count: int):
        """ì‹¤ìˆ˜ì— ëŒ€í•œ ê²½ê³  ë©”ì‹œì§€ í‘œì‹œ"""
        warnings = {
            'console_usage': f"ë˜ consoleì„ ì‚¬ìš©í•˜ì…¨ë„¤ìš”! ({count}ë²ˆì§¸) TypeScriptì—ì„œëŠ” loggerë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.",
            'no_backup': f"ë°±ì—… ì—†ì´ íŒŒì¼ì„ ìˆ˜ì •í•˜ë ¤ê³  í•˜ì‹œë‚˜ìš”? ({count}ë²ˆì§¸) í•­ìƒ ë°±ì—… ë¨¼ì €!",
            'direct_flow': f"flow_projectë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ì…¨ë„¤ìš”! ({count}ë²ˆì§¸) execute_codeë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
        }
        
        if mistake_type in warnings:
            print(f"\nâš ï¸ {warnings[mistake_type]}")
            print(f"ğŸ’¡ ì˜¬ë°”ë¥¸ ë°©ë²•: {self._get_correct_way(mistake_type)}")
    
    def _get_correct_way(self, mistake_type: str) -> str:
        """ì˜¬ë°”ë¥¸ ë°©ë²• ì œì‹œ"""
        correct_ways = {
            'console_usage': "import { logger } from '../utils/logger'; logger.info('ë©”ì‹œì§€');",
            'no_backup': "backup = helpers.backup_file('file.py', 'ìˆ˜ì •_ì „')",
            'direct_flow': "execute_code: helpers.cmd_flow_with_context('project-name')"
        }
        return correct_ways.get(mistake_type, "ë¬¸ì„œë¥¼ ì°¸ê³ í•˜ì„¸ìš”")
    
    def _get_error_tip(self, error_type: str) -> str:
        """ì˜¤ë¥˜ì— ëŒ€í•œ íŒ ì œê³µ"""
        tips = {
            'TypeError': "íƒ€ì…ì„ í™•ì¸í•˜ì„¸ìš”. TypeScriptë¥¼ ì‚¬ìš©í•˜ë©´ ì´ëŸ° ì˜¤ë¥˜ë¥¼ ì˜ˆë°©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            'FileNotFoundError': "íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•˜ì„¸ìš”. os.path.join()ì„ ì‚¬ìš©í•˜ë©´ ì•ˆì „í•©ë‹ˆë‹¤.",
            'KeyError': "ë”•ì…”ë„ˆë¦¬ í‚¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. dict.get('key', default)ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”."
        }
        return tips.get(error_type, "ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ìì„¸íˆ ì½ì–´ë³´ì„¸ìš”")
    
    def add_best_practice(self, practice: str, category: str = "general"):
        """ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ ì¶”ê°€"""
        practice_entry = {
            'text': practice,
            'category': category,
            'added_at': datetime.now().isoformat()
        }
        
        # ì¤‘ë³µ ì²´í¬
        if not any(p['text'] == practice for p in self.wisdom_data['best_practices']):
            self.wisdom_data['best_practices'].append(practice_entry)
            self.save_wisdom()
            print(f"âœ… ìƒˆë¡œìš´ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤: {practice}")
    
    def save_wisdom(self):
        """wisdom ë°ì´í„°ë¥¼ MD íŒŒì¼ë¡œ ì €ì¥"""
        content = self._generate_wisdom_md()
        self.wisdom_file.write_text(content, encoding='utf-8')
        
    def _generate_wisdom_md(self) -> str:
        """wisdom ë°ì´í„°ë¥¼ MD í˜•ì‹ìœ¼ë¡œ ë³€í™˜"""
        lines = [
            "# ğŸ§  Project Wisdom - ai-coding-brain-mcp",
            "",
            "> ì´ ë¬¸ì„œëŠ” í”„ë¡œì íŠ¸ ì‘ì—… ì¤‘ ì¶•ì ëœ ì§€í˜œì™€ êµí›ˆì„ ë‹´ê³  ìˆìŠµë‹ˆë‹¤.",
            "",
            "## ğŸ“Œ í”„ë¡œì íŠ¸ ë¹„ì „",
            f"- í”„ë¡œì íŠ¸ëª…: {self.project_root.name}",
            f"- ê²½ë¡œ: {self.project_root.absolute()}",
            "- ì£¼ìš” ëª©ì : AI ê¸°ë°˜ ì½”ë”© ë„ìš°ë¯¸ MCP ì„œë²„",
            "",
            "## ğŸ› ìì£¼ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ íŒ¨í„´",
            ""
        ]
        
        # ì˜¤ë¥˜ íŒ¨í„´
        for error_type, data in sorted(self.wisdom_data['error_patterns'].items(), 
                                     key=lambda x: x[1]['count'], reverse=True):
            lines.extend([
                f"### {error_type}",
                f"- **ë°œìƒ íšŸìˆ˜**: {data['count']}íšŒ",
                f"- **ìµœì´ˆ ë°œìƒ**: {data.get('first_seen', 'N/A')}",
                f"- **ìµœê·¼ ë°œìƒ**: {data.get('last_seen', 'N/A')}",
                f"- **í•´ê²° íŒ**: {self._get_error_tip(error_type)}",
                ""
            ])
        
        # ì‹¤ìˆ˜ íŒ¨í„´
        lines.extend(["", "## âŒ ìì£¼ í•˜ëŠ” ì‹¤ìˆ˜ë“¤", ""])
        for i, (mistake_type, data) in enumerate(sorted(self.wisdom_data['common_mistakes'].items(),
                                                       key=lambda x: x[1]['count'], reverse=True), 1):
            lines.extend([
                f"{i}. **{mistake_type}**",
                f"   - ë°œìƒ íšŸìˆ˜: {data['count']}íšŒ",
                f"   - ìµœì´ˆ ë°œìƒ: {data.get('first_seen', 'N/A')}",
                f"   - ì˜¬ë°”ë¥¸ ë°©ë²•: `{self._get_correct_way(mistake_type)}`",
                ""
            ])
        
        # ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤
        lines.extend(["", "## âœ… ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤", ""])
        categories = {}
        for practice in self.wisdom_data['best_practices']:
            cat = practice.get('category', 'general')
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(practice['text'])
        
        for category, practices in categories.items():
            lines.append(f"### {category.title()}")
            for practice in practices:
                lines.append(f"- {practice}")
            lines.append("")
        
        lines.extend([
            "",
            "---",
            f"*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*"
        ])
        
        return '\n'.join(lines)

# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
_wisdom_manager = None

def get_wisdom_manager(project_root: str = ".") -> ProjectWisdomManager:
    """Wisdom Manager ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _wisdom_manager
    if _wisdom_manager is None:
        _wisdom_manager = ProjectWisdomManager(project_root)
    return _wisdom_manager
