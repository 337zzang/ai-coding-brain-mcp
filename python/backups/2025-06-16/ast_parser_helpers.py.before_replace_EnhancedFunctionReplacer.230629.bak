# -*- coding: utf-8 -*-
"""
AST Parser Helper - Refactored Version
Python: ast.parse() 기반 파싱
JavaScript/TypeScript: Tree-sitter 지연 로딩 파싱  
"""

import ast
import os
import time
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, cast
import textwrap
import re

# ============================================================================
# 전역 설정 및 캐시
# ============================================================================

# Tree-sitter 지연 로딩
TREE_SITTER_AVAILABLE = False
_tree_sitter_modules = {}
_advanced_parser = None
_parser_lock = threading.Lock()

# 로깅 설정
VERBOSE = False

def set_verbose(flag: bool) -> None:
    """전역 verbose 모드 설정"""
    global VERBOSE
    VERBOSE = flag

def get_verbose() -> bool:
    """현재 verbose 모드 상태 반환"""
    return VERBOSE

def _log(msg: str, level: str = "INFO") -> None:
    """조건부 로깅"""
    if VERBOSE:
        print(f"[{level}] {msg}")

# ============================================================================
# 통합 캐시 시스템
# ============================================================================

class CacheManager:
    """모든 캐시를 중앙에서 관리"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.ast_cache: Dict[str, Any] = {}
            self.file_mtime_cache: Dict[str, float] = {}
            self.language_cache: Dict[str, Any] = {}
            self.parser_cache: Dict[str, Any] = {}
            self.initialized = True
    
    def get_cached_ast(self, file_path: str) -> Optional[Any]:
        """캐시된 AST 반환"""
        if file_path not in self.ast_cache:
            return None
            
        # 파일 수정 시간 확인
        try:
            current_mtime = os.path.getmtime(file_path)
            cached_mtime = self.file_mtime_cache.get(file_path, 0)
            
            if current_mtime > cached_mtime:
                # 캐시 무효화
                del self.ast_cache[file_path]
                return None
                
            return self.ast_cache[file_path]
        except:
            return None
    
    def set_cached_ast(self, file_path: str, ast_data: Any):
        """AST 캐시 저장"""
        self.ast_cache[file_path] = ast_data
        self.file_mtime_cache[file_path] = os.path.getmtime(file_path)
    
    def clear_all(self):
        """모든 캐시 초기화"""
        self.ast_cache.clear()
        self.file_mtime_cache.clear()
        self.language_cache.clear()
        self.parser_cache.clear()

# ============================================================================
# Tree-sitter 지연 로딩
# ============================================================================

def _lazy_import_tree_sitter() -> bool:
    """Tree-sitter 모듈 지연 임포트"""
    global TREE_SITTER_AVAILABLE, _tree_sitter_modules
    
    if _tree_sitter_modules:
        return True
        
    try:
        import tree_sitter
        import tree_sitter_python
        import tree_sitter_javascript
        
        _tree_sitter_modules['tree_sitter'] = tree_sitter
        _tree_sitter_modules['python'] = tree_sitter_python
        _tree_sitter_modules['javascript'] = tree_sitter_javascript
        
        TREE_SITTER_AVAILABLE = True
        _log("Tree-sitter 모듈 로드 성공")
        return True
    except ImportError as e:
        _log(f"Tree-sitter 로드 실패: {e}", "WARNING")
        return False

class TreeSitterManager:
    """Tree-sitter 파서 관리"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self._parsers = {}
            self.initialized = True
    
    def get_parser(self, language: str):
        """언어별 파서 반환"""
        if not _lazy_import_tree_sitter():
            return None
            
        if language not in self._parsers:
            self._parsers[language] = self._create_parser(language)
            
        return self._parsers[language]
    
    def _create_parser(self, language: str):
        """파서 생성"""
        tree_sitter = _tree_sitter_modules.get('tree_sitter')
        if not tree_sitter:
            return None
            
        parser = tree_sitter.Parser()
        
        lang_map = {
            'python': 'python',
            'javascript': 'javascript',
            'typescript': 'javascript'
        }
        
        lang_key = lang_map.get(language)
        if not lang_key:
            return None
            
        lang_module = _tree_sitter_modules.get(lang_key)
        if lang_module:
            parser.set_language(lang_module.Language())
            return parser
            
        return None

# ============================================================================
# AST Parser 메인 클래스
# ============================================================================

class FunctionReplacer(ast.NodeTransformer):
    """
    AST 트리에서 특정 이름을 가진 함수/메서드를 찾아
    새로운 코드 블록으로 교체하는 NodeTransformer입니다.
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        # 새로운 코드를 파싱하여 교체할 노드를 준비합니다.
        # 여러 문장이 포함될 수 있으므로 body에서 노드를 가져옵니다.
        self.new_nodes = ast.parse(new_code).body

    def visit_FunctionDef(self, node: ast.FunctionDef) -> Union[ast.FunctionDef, List[ast.AST]]:
        """일반 함수(def) 노드를 방문합니다."""
        # 자식 노드들도 계속 방문
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # 함수의 이름이 일치하면 준비된 새 노드들로 교체합니다.
            return self.new_nodes
        return node  # 일치하지 않으면 원래 노드를 그대로 반환합니다.

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Union[ast.AsyncFunctionDef, List[ast.AST]]:
        """비동기 함수(async def) 노드를 방문합니다."""
        # 자식 노드들도 계속 방문
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # 함수의 이름이 일치하면 준비된 새 노드들로 교체합니다.
            return self.new_nodes
        return node  # 일치하지 않으면 원래 노드를 그대로 반환합니다.


class EnhancedFunctionReplacer(ast.NodeTransformer):
    """
    클래스명.메서드명 형식을 지원하는 향상된 NodeTransformer
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        
        # ClassName.method_name 형식 파싱
        if '.' in target_name:
            parts = target_name.split('.')
            self.target_class = parts[0]
            self.target_method = parts[1]
            self.is_class_method = True
        else:
            self.target_class = None
            self.target_method = target_name
            self.is_class_method = False
            
        # 새로운 코드 준비
        self.new_nodes = ast.parse(new_code).body
        
        # 현재 클래스 컨텍스트 추적
        self.current_class = None
        self.found_and_replaced = False

    def visit_ClassDef(self, node: ast.ClassDef):
        """클래스 정의 방문"""
        # 현재 클래스 이름 저장
        old_class = self.current_class
        self.current_class = node.name
        
        # 클래스 내부 방문
        self.generic_visit(node)
        
        # 클래스 컨텍스트 복원
        self.current_class = old_class
        
        # 클래스 자체를 교체하는 경우
        if not self.is_class_method and node.name == self.target_name:
            self.found_and_replaced = True
            return self.new_nodes
            
        return node

    def visit_FunctionDef(self, node: ast.FunctionDef):
        """일반 함수(def) 노드 방문"""
        self.generic_visit(node)
        
        # 클래스 메서드를 찾는 경우
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # 일반 함수를 찾는 경우
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        """비동기 함수(async def) 노드 방문"""
        self.generic_visit(node)
        
        # 클래스 메서드를 찾는 경우
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # 일반 함수를 찾는 경우
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node



class ASTParser:
    """통합 AST 파서"""
    
    def __init__(self):
        self.cache_manager = CacheManager()
        self.ts_manager = TreeSitterManager()
        
    def _detect_language(self, file_path: str, language: str = 'auto') -> str:
        """파일 언어 감지"""
        if language != 'auto':
            return language
            
        ext = Path(file_path).suffix.lower()
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.ts': 'typescript',
            '.tsx': 'typescript'
        }
        
        return ext_map.get(ext, 'unknown')
    
    def _extract_docstring(self, node: ast.AST) -> Optional[str]:
        """Python docstring 추출"""
        # body 속성이 있는 노드 타입들만 처리
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module)):
            return None
            
        if not hasattr(node, 'body') or not node.body:
            return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, (ast.Str, ast.Constant)):
            # Python 3.8+에서는 ast.Constant 사용
            if isinstance(first.value, ast.Str):
                return textwrap.dedent(first.value.s).strip()
            elif isinstance(first.value, ast.Constant) and isinstance(first.value.value, str):
                return textwrap.dedent(first.value.value).strip()
                
        return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, ast.Str):
            return textwrap.dedent(first.value.s).strip()
            
        return None
    
    def _extract_function_info(self, node: ast.FunctionDef, source_lines: List[str]) -> Dict:
        """함수 정보 추출"""
        info = {
            'type': 'function',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'col_start': node.col_offset + 1,  # 0-based를 1-based로 변환
            'col_end': getattr(node, 'end_col_offset', 0) + 1 if hasattr(node, 'end_col_offset') else None,
            'args': [arg.arg for arg in node.args.args],
            'docstring': self._extract_docstring(node),
            'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list if d],
            'is_async': isinstance(node, ast.AsyncFunctionDef)
        }
        
        # 코드 스니펫 추출
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def _extract_class_info(self, node: ast.ClassDef, source_lines: List[str]) -> Dict:
        """클래스 정보 추출"""
        info = {
            'type': 'class',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'col_start': node.col_offset + 1,  # 0-based를 1-based로 변환
            'col_end': getattr(node, 'end_col_offset', 0) + 1 if hasattr(node, 'end_col_offset') else None,
            'bases': [base.id if isinstance(base, ast.Name) else str(base) for base in node.bases],
            'docstring': self._extract_docstring(node),
            'methods': []
        }
        
        # 메서드 추출
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                method_info = self._extract_function_info(item, source_lines)
                method_info['type'] = 'method'
                info['methods'].append(method_info)
        
        # 코드 스니펫 추출
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def parse_python(self, file_path: str, include_snippets: bool = True) -> Dict[str, Any]:
        """Python 파일 파싱"""
        try:
            # 캐시 확인
            cached = self.cache_manager.get_cached_ast(file_path)
            if cached and not include_snippets:
                return cached
                
            # 파일 읽기
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST 파싱
            tree = ast.parse(content, filename=file_path)
            source_lines = content.split('\n') if include_snippets else []
            
            # 결과 수집
            result = {
                'parsing_success': True,
                'language': 'python',
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # AST 순회
            for node in ast.walk(tree):  
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    result['functions'].append(self._extract_function_info(node, source_lines))
                elif isinstance(node, ast.ClassDef):
                    result['classes'].append(self._extract_class_info(node, source_lines))
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            result['imports'].append(alias.name)
                    else:
                        result['imports'].append(node.module or '')
            
            # 캐시 저장
            if not include_snippets:
                self.cache_manager.set_cached_ast(file_path, result)
                
            return result
            
        except Exception as e:
            _log(f"Python 파싱 오류: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': 'python',
                'error': str(e)
            }
    
    def parse_javascript(self, file_path: str, language: str = 'javascript', 
                        include_snippets: bool = True) -> Dict[str, Any]:
        """JavaScript/TypeScript 파일 파싱"""
        parser = self.ts_manager.get_parser(language)
        if not parser:
            return {
                'parsing_success': False,
                'language': language,
                'error': 'Tree-sitter not available'
            }
            
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
                
            tree = parser.parse(content)
            
            # 간단한 결과 반환 (실제 구현은 더 복잡함)
            result = {
                'parsing_success': True,
                'language': language,
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # Tree-sitter 노드 순회 로직 (간략화)
            # 실제로는 traverse_node 같은 복잡한 함수가 필요하지만
            # 여기서는 간단히 처리
            
            return result
            
        except Exception as e:
            _log(f"JavaScript 파싱 오류: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': language,
                'error': str(e)
            }
    
    def parse_with_snippets(self, file_path: str, language: str = 'auto', 
                          include_snippets: bool = True) -> Dict[str, Any]:
        """파일 파싱 메인 메서드"""
        # 언어 감지
        detected_lang = self._detect_language(file_path, language)
        
        if detected_lang == 'python':
            return self.parse_python(file_path, include_snippets)
        elif detected_lang in ['javascript', 'typescript']:
            return self.parse_javascript(file_path, detected_lang, include_snippets)
        else:
            return {
                'parsing_success': False,
                'language': detected_lang,
                'error': f'Unsupported language: {detected_lang}'
            }
    
    def get_snippet_preview(self, file_path: str, element_name: str, 
                          element_type: str = 'function', max_lines: int = 10) -> str:
        """코드 스니펫 미리보기"""
        result = self.parse_with_snippets(file_path, include_snippets=True)
        
        if not result.get('parsing_success'):
            return f"Error: {result.get('error', 'Unknown error')}"
            
        # 요소 찾기
        element_key = f'{element_type}s'
        if element_type == 'class':
            element_key = 'classes'
        elif element_type == 'function':
            element_key = 'functions'
            
        elements = result.get(element_key, [])
        for elem in elements:
            if elem.get('name') == element_name:
                snippet = elem.get('snippet', '')
                if not snippet:
                    # snippet이 없으면 기본 정보 반환
                    return f"{element_type} '{element_name}' found at line {elem.get('line_start', '?')}"
                    
                lines = snippet.split('\n')
                if len(lines) > max_lines:
                    return '\n'.join(lines[:max_lines]) + '\n...'
                return snippet

    def replace_block(self, file_path: str, block_name: str, new_content: str) -> tuple:
        """
        파일의 특정 블록을 새로운 내용으로 교체합니다.

        이 메서드는 file_system_helpers.py의 호환성을 위해 추가되었습니다.
        실제 교체 로직은 file_system_helpers.py에서 처리    됩니다.

        Args:
            file_path: 파일 경로
            block_name: 교체할 블록 이름
            new_content: 새로운 내용

        Returns:
            tuple: (메시지, 정보 딕셔너리)
        """
        # 단순히 파싱 결과만 반환하여 file_system_helpers가 처리하도록 함
        parse_result = self.parse_with_snippets(file_path)

        if not parse_result.get('parsing_success'):
            return ("ERROR: 파일 파싱 실패", {})

        # 블록 찾기
        all_blocks = []
        for func in parse_result.get('functions', []):
            if func.get('name') == block_name:
                return ("SUCCESS: 블록 찾음", {
                    'block_type': 'function',
                    'line_start': func.get('line_start'),
                    'line_end': func.get('line_end')
                })

        for cls in parse_result.get('classes', []):
            if cls.get('name') == block_name:
                return ("SUCCESS: 블록 찾음", {
                    'block_type': 'class', 
                    'line_start': cls.get('line_start'),
                    'line_end': cls.get('line_end')
                })

            # 메서드 확인
            for method in cls.get('methods', []):
                if method.get('name') == block_name:
                    return ("SUCCESS: 블록 찾음", {
                        'block_type': 'method',
                        'line_start': method.get('line_start'), 
                        'line_end': method.get('line_end')
                    })

        return (f"ERROR: 블록 '{block_name}'을 찾을 수 없습니다", {})

                    
                

    

# ============================================================================
# 전역 파서 인스턴스
# ============================================================================

def _get_parser() -> ASTParser:
    """싱글톤 파서 인스턴스 반환"""
    global _advanced_parser, _parser_lock
    
    if _advanced_parser is None:
        with _parser_lock:
            if _advanced_parser is None:
                _advanced_parser = ASTParser()
                
    return _advanced_parser

# ============================================================================
# 공개 API
# ============================================================================

def parse_with_snippets(file_path: str, language: str = 'auto', 
                       include_snippets: bool = True) -> Dict[str, Any]:
    """파일 파싱 (공개 API)"""
    parser = _get_parser()
    return parser.parse_with_snippets(file_path, language, include_snippets)

def get_snippet_preview(file_path: str, element_name: str, 
                       element_type: str = 'function', max_lines: int = 10,
                       start_line: int = -1, end_line: int = -1) -> str:
    """코드 스니펫 미리보기 (공개 API)"""
    parser = _get_parser()
    return parser.get_snippet_preview(file_path, element_name, element_type, max_lines)

# ============================================================================
# 백그라운드 초기화 (선택적)
# ============================================================================

def init_background():
    """백그라운드에서 Tree-sitter 초기화"""
    def _init():
        _lazy_import_tree_sitter()
        _log("백그라운드 초기화 완료")
        
    thread = threading.Thread(target=_init, daemon=True)
    thread.start()

# 자동 백그라운드 초기화
init_background()