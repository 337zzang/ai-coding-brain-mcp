/**
 * Execute Code í•¸ë“¤ëŸ¬ - JSON REPL ì„¸ì…˜ ê°•ì œ í™œì„±í™”
 * json_repl_session.pyë¥¼ ë¬´ì¡°ê±´ ì‚¬ìš©í•˜ì—¬ ë³€ìˆ˜ ì§€ì†ì„± ë³´ì¥
 */

import { createLogger } from '../services/logger';
import { spawn, ChildProcess, execFile } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

const logger = createLogger('execute-code-handler');
const execFileAsync = promisify(execFile);

export class ExecuteCodeHandler {
  // ğŸš€ JSON REPL ì„¸ì…˜ ê´€ë¦¬
  private static replProcess: ChildProcess | null = null;
  private static replReady: boolean = false;
  private static sessionVariables: Set<string> = new Set();
  private static lastActivity: Date | null = null;
  private static requestCounter: number = 0;

  /**
   * ğŸ“Š ì„¸ì…˜ ì •ë³´ ë°˜í™˜
   */
  private static getSessionInfo(): any {
    return {
      session_active: this.replProcess !== null && !this.replProcess.killed,
      repl_ready: this.replReady,
      variables_count: this.sessionVariables.size,
      last_activity: this.lastActivity?.toISOString(),
      session_mode: 'JSON_REPL'
    };
  }

  /**
   * ğŸš€ JSON REPL ì„¸ì…˜ ì´ˆê¸°í™” (json_repl_session.py ì§ì ‘ ì‹¤í–‰)
   */
  private static async initializeJsonReplSession(): Promise<boolean> {
    if (this.replProcess && !this.replProcess.killed) {
      logger.info('JSON REPL ì„¸ì…˜ì´ ì´ë¯¸ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤');
      return true;
    }

    try {
      const projectRoot = path.join(__dirname, '..', '..');
      const replScript = path.join(projectRoot, 'python', 'json_repl_session.py');

      logger.info(`ğŸš€ JSON REPL ì„¸ì…˜ ì‹œì‘: ${replScript}`);

      // json_repl_session.py ì§ì ‘ ì‹¤í–‰
      const pythonPath = process.env['PYTHON_PATH'] || 'python';
      this.replProcess = spawn(pythonPath, ['-X', 'utf8', replScript], {
        stdio: ['pipe', 'pipe', 'pipe'],
        env: {
          ...process.env,
          PYTHONIOENCODING: 'utf-8',
          PYTHONUTF8: '1',
          PYTHON_SCRIPT_PATH: 'python\\json_repl_session.py'
        }
      });

      // ì¤€ë¹„ ì‹ í˜¸ ëŒ€ê¸°
      return new Promise((resolve) => {
        let initBuffer = '';
        const timeout = setTimeout(() => {
          logger.error('JSON REPL ì´ˆê¸°í™” íƒ€ì„ì•„ì›ƒ');
          resolve(false);
        }, 10000);

        this.replProcess!.stdout!.on('data', (data) => {
          initBuffer += data.toString();
          if (initBuffer.includes('__READY__')) {
            clearTimeout(timeout);
            this.replReady = true;
            logger.info('âœ… JSON REPL ì„¸ì…˜ ì¤€ë¹„ ì™„ë£Œ');
            resolve(true);
          }
        });

        this.replProcess!.stderr!.on('data', (data) => {
          const errorOutput = data.toString();
          logger.info(`JSON REPL stderr: ${errorOutput}`);
        });

        this.replProcess!.on('error', (error) => {
          clearTimeout(timeout);
          logger.error('JSON REPL í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜:', error);
          resolve(false);
        });

        this.replProcess!.on('exit', (code) => {
          logger.warn(`JSON REPL í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ: ì½”ë“œ ${code}`);
          this.replProcess = null;
          this.replReady = false;
        });
      });
    } catch (error) {
      logger.error('JSON REPL ì„¸ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
      return false;
    }
  }

  /**
   * ğŸ¯ JSON REPL ì„¸ì…˜ìœ¼ë¡œ ì½”ë“œ ì‹¤í–‰
   */
  private static async executeWithJsonRepl(code: string): Promise<any> {
    if (!this.replProcess || !this.replReady) {
      const initialized = await this.initializeJsonReplSession();
      if (!initialized) {
        throw new Error('JSON REPL ì„¸ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨');
      }
    }

    return new Promise((resolve, reject) => {
      const requestId = `req_${++this.requestCounter}_${Date.now()}`;
      const request = {
        id: requestId,
        command: 'execute',
        code: code
      };

      let responseBuffer = '';
      let timeout: NodeJS.Timeout;

      const cleanup = () => {
        if (timeout) clearTimeout(timeout);
        this.replProcess!.stdout!.removeAllListeners('data');
      };

      // ì‘ë‹µ ëŒ€ê¸°
      const dataHandler = (data: Buffer) => {
        responseBuffer += data.toString();

        // EOT ë¬¸ìë¡œ ì‘ë‹µ ì™„ë£Œ ê°ì§€
        const eotIndex = responseBuffer.indexOf('\x04');
        if (eotIndex !== -1) {
          cleanup();

          const responseData = responseBuffer.substring(0, eotIndex);
          try {
            const response = JSON.parse(responseData);
            if (response.id === requestId) {
              this.lastActivity = new Date();
              resolve(response);
            } else {
              reject(new Error(`ì‘ë‹µ ID ë¶ˆì¼ì¹˜: ì˜ˆìƒ=${requestId}, ì‹¤ì œ=${response.id}`));
            }
          } catch (parseError) {
            reject(new Error(`JSON íŒŒì‹± ì‹¤íŒ¨: ${parseError}, ë°ì´í„°: ${responseData}`));
          }
        }
      };

      this.replProcess!.stdout!.on('data', dataHandler);

      // íƒ€ì„ì•„ì›ƒ ì„¤ì •
      timeout = setTimeout(() => {
        cleanup();
        reject(new Error('JSON REPL ì‘ë‹µ íƒ€ì„ì•„ì›ƒ'));
      }, 300000); // 300ì´ˆ (5ë¶„) - ì¦ê°€ë¨

      // ìš”ì²­ ì „ì†¡
      const requestJson = JSON.stringify(request);
      this.replProcess!.stdin!.write(requestJson + '\x04', 'utf8');
    });
  }

  /**
   * ğŸ›ï¸ ì„¸ì…˜ ëª…ë ¹ì–´ ì²˜ë¦¬
   */
  private static async handleSessionCommand(command: string): Promise<any> {
    const cmd = command.toLowerCase().trim();

    switch (cmd) {
      case '/vars':
        if (this.replReady && this.replProcess) {
          try {
            const result = await this.executeWithJsonRepl('print("ğŸ“Š ì„¸ì…˜ ë³€ìˆ˜ ëª©ë¡:")\\nfor k, v in locals().items():\\n    if not k.startswith("_"):\\n        print(f"  {k}: {type(v).__name__}")');
            return {
              success: true,
              stdout: result.stdout || 'ì„¸ì…˜ ë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤',
              note: 'JSON REPL Session Variables',
              timestamp: new Date().toISOString()
            };
          } catch (error) {
            return {
              success: false,
              error: `ë³€ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨: ${error}`,
              timestamp: new Date().toISOString()
            };
          }
        } else {
          return {
            success: true,
            stdout: 'âŒ JSON REPL ì„¸ì…˜ì´ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
            note: 'Session not active',
            timestamp: new Date().toISOString()
          };
        }

      case '/clear':
        if (this.replReady && this.replProcess) {
          try {
            await this.executeWithJsonRepl('locals().clear()\\nprint("ğŸ§¹ ì„¸ì…˜ ë³€ìˆ˜ ì´ˆê¸°í™” ì™„ë£Œ")');
            this.sessionVariables.clear();
            return {
              success: true,
              stdout: 'ğŸ§¹ JSON REPL ì„¸ì…˜ ë³€ìˆ˜ ì´ˆê¸°í™” ì™„ë£Œ',
              note: 'Session variables cleared',
              timestamp: new Date().toISOString()
            };
          } catch (error) {
            return {
              success: false,
              error: `ì„¸ì…˜ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error}`,
              timestamp: new Date().toISOString()
            };
          }
        }
        break;

      case '/reset':
        // REPL í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ í›„ ì¬ì‹œì‘
        if (this.replProcess) {
          this.replProcess.kill();
          this.replProcess = null;
          this.replReady = false;
        }
        this.sessionVariables.clear();
        this.lastActivity = null;

        const restarted = await this.initializeJsonReplSession();
        return {
          success: restarted,
          stdout: restarted ? 'ğŸ”„ JSON REPL ì„¸ì…˜ ì¬ì‹œì‘ ì™„ë£Œ' : 'âŒ ì„¸ì…˜ ì¬ì‹œì‘ ì‹¤íŒ¨',
          note: 'Session restart attempt',
          timestamp: new Date().toISOString()
        };

      case '/memory':
        let output = 'ğŸ’¾ JSON REPL ì„¸ì…˜ ìƒíƒœ:\\n\\n';
        output += `ğŸ”§ ì‹¤í–‰ ëª¨ë“œ: JSON REPL (json_repl_session.py)\\n`;
        output += `ğŸ“Š ë³€ìˆ˜ ì§€ì†ì„±: âœ… ì™„ì „ ì§€ì›\\n`;
        output += `ğŸš€ AI í—¬í¼ í•¨ìˆ˜: âœ… ë°±ê·¸ë¼ìš´ë“œ ë¡œë“œ\\n`;
        output += `âš¡ ì‹¤í–‰ ë°©ì‹: JSON í”„ë ˆì´ë° í†µì‹ \\n`;
        output += `ğŸ”„ ì„¸ì…˜ ìƒíƒœ: ${this.replReady ? 'í™œì„±' : 'ë¹„í™œì„±'}\\n`;
        output += `ğŸ“ˆ í”„ë¡œì„¸ìŠ¤ ID: ${this.replProcess?.pid || 'N/A'}\\n`;
        return {
          success: true,
          stdout: output,
          note: 'JSON REPL Session Status',
          timestamp: new Date().toISOString()
        };

      case '/help':
        const help = `
ğŸš€ JSON REPL ì„¸ì…˜ ëª…ë ¹ì–´:

ğŸ“Š /vars    - í˜„ì¬ ì„¸ì…˜ ë³€ìˆ˜ ëª©ë¡
ğŸ§¹ /clear   - ì„¸ì…˜ ë³€ìˆ˜ ì´ˆê¸°í™”  
ğŸ”„ /reset   - REPL ì„¸ì…˜ ì¬ì‹œì‘
ğŸ’¾ /memory  - ì„¸ì…˜ ìƒíƒœ í™•ì¸
â“ /help    - ì´ ë„ì›€ë§ í‘œì‹œ

âš¡ í˜„ì¬ ëª¨ë“œ: JSON REPL (json_repl_session.py)
â€¢ ë³€ìˆ˜ì™€ í•¨ìˆ˜ê°€ ì‹¤í–‰ ê°„ ìœ ì§€ë©ë‹ˆë‹¤
â€¢ AI í—¬í¼ í•¨ìˆ˜ê°€ ìë™ìœ¼ë¡œ ë¡œë“œë©ë‹ˆë‹¤
â€¢ InteractiveConsole ê¸°ë°˜ ì„¸ì…˜ ê´€ë¦¬
â€¢ JSON í”„ë ˆì´ë°ìœ¼ë¡œ ì•ˆì •ì  í†µì‹ 
`;
        return {
          success: true,
          stdout: help,
          note: 'JSON REPL Session Help',
          timestamp: new Date().toISOString()
        };

      default:
        return {
          success: false,
          error: `Unknown session command: ${command}`,
          note: 'Available: /vars, /clear, /reset, /memory, /help',
          timestamp: new Date().toISOString()
        };
    }
  }

  /**
   * stdoutì—ì„œ ë¶ˆí•„ìš”í•œ ë©”ì‹œì§€ í•„í„°ë§
   */
  private static cleanExecutionOutput(stdout: string): string {
    const linesToFilter = [
      '__READY__',
      '[Python] JSON í”„ë ˆì´ë° Python REPL ì‹œì‘',
      '[Python] ì´ˆê¸°í™” ì™„ë£Œ - ì„¸ì…˜ ì¤€ë¹„ë¨',
      '[OK] AI í—¬í¼ í•¨ìˆ˜ 6ê°œ ë¡œë“œ ì™„ë£Œ'
    ];

    return stdout
      .split('\\n')
      .filter(line => !linesToFilter.some(filter => line.includes(filter)))
      .join('\\n')
      .trim();
  }

  /**
   * TypeScript ëŸ°íƒ€ì„ ì°¾ê¸°
   */
  private static async findTypeScriptRuntime(): Promise<string | null> {
    const candidates = [
      'npx tsx',
      'npx ts-node',
      path.join(process.cwd(), 'node_modules/.bin/tsx'),
      path.join(process.cwd(), 'node_modules/.bin/ts-node'),
      'tsx',
      'ts-node'
    ];

    for (const candidate of candidates) {
      try {
        if (candidate.includes(' ')) {
          const parts = candidate.split(' ');
          if (parts[0]) await execFileAsync(parts[0], [...parts.slice(1), '--version']);
        } else {
          await execFileAsync(candidate, ['--version']);
        }
        logger.info(`TypeScript runtime found: ${candidate}`);
        return candidate;
      } catch {
        // Try next candidate
      }
    }

    return null;
  }

  /**
   * ğŸ¯ ë©”ì¸ execute_code í•¸ë“¤ëŸ¬
   */
  static async handleExecuteCode(args: { code: string; language?: string }): Promise<{ content: Array<{ type: string; text: string }> }> {
    const DEBUG_MODE = true;
    logger.info('ğŸš€ JSON REPL ê°•ì œ í™œì„±í™” ëª¨ë“œ - execute_code í•¸ë“¤ëŸ¬');

    // ì„¸ì…˜ ëª…ë ¹ì–´ ì²˜ë¦¬
    if (args.code.startsWith('/')) {
      logger.info(`ğŸ›ï¸ Processing session command: ${args.code}`);
      const result = await this.handleSessionCommand(args.code);

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              ...result,
              session_info: this.getSessionInfo(),
              ai_helpers_enabled: true,
              language: 'session'
            }, null, 2),
          },
        ],
      };
    }

    // ì–¸ì–´ ê°ì§€
    const codeContent = args.code.toLowerCase();

    const strongPythonIndicators = [
      'import ', 'print(', 'def ', 'backup_file', 'safe_replace',
      'from ', 'if __name__', 'elif ', 'with open(', 'r"', "r'", '"""', "'''"
    ];

    const strongJsIndicators = [
      'console.log', 'const ', 'let ', 'var ', 'require(', 'module.exports',
      'function(', '=>', 'document.', 'window.'
    ];

    const strongTsIndicators = [
      'interface ', 'type ', ': string', ': number', ': boolean', ': void',
      'implements ', 'extends ', 'public ', 'private ', 'protected ',
      'enum ', '<T>', 'Generic', 'readonly ', '?: '
    ];

    const hasStrongPython = strongPythonIndicators.some(indicator => codeContent.includes(indicator));
    const hasStrongJs = strongJsIndicators.some(indicator => codeContent.includes(indicator));
    const hasStrongTs = strongTsIndicators.some(indicator => codeContent.includes(indicator));

    let language: 'python' | 'javascript' | 'typescript';
    if (args.language) {
      language = args.language as 'python' | 'javascript' | 'typescript';
    } else {
      if (hasStrongPython) {
        language = 'python';
      } else if (hasStrongTs && !hasStrongPython) {
        language = 'typescript';
      } else if (hasStrongJs && !hasStrongPython) {
        language = 'javascript';
      } else {
        language = 'python'; // ê¸°ë³¸ê°’ì€ Python (JSON REPL ì‚¬ìš©)
      }
    }

    // ğŸš€ Python ì½”ë“œëŠ” ë¬´ì¡°ê±´ JSON REPL ì„¸ì…˜ìœ¼ë¡œ ì‹¤í–‰
    if (language === 'python') {
      try {
        logger.info('ğŸš€ JSON REPL ì„¸ì…˜ìœ¼ë¡œ Python ì½”ë“œ ì‹¤í–‰');

        const result = await this.executeWithJsonRepl(args.code);

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                success: result.success || true,
                language: 'python',
                session_mode: 'JSON_REPL',
                stdout: this.cleanExecutionOutput(result.stdout || ''),
                stderr: result.stderr || '',
                variable_count: result.variable_count,
                note: 'JSON REPL Session - Variables persist between executions',
                debug_info: DEBUG_MODE ? {
                  repl_process_active: this.replProcess !== null,
                  repl_ready: this.replReady,
                  execution: 'success'
                } : undefined,
                timestamp: new Date().toISOString()
              }, null, 2),
            },
          ],
        };
      } catch (error) {
        logger.error('JSON REPL ì‹¤í–‰ ì‹¤íŒ¨:', error);

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                success: false,
                language: 'python',
                session_mode: 'JSON_REPL_ERROR',
                error: error instanceof Error ? error.message : String(error),
                note: 'JSON REPL Session execution failed',
                debug_info: DEBUG_MODE ? {
                  repl_process_active: this.replProcess !== null,
                  repl_ready: this.replReady,
                  error_type: error instanceof Error ? error.constructor.name : 'Unknown'
                } : undefined,
                timestamp: new Date().toISOString()
              }, null, 2),
            },
          ],
        };
      }
    }

    // TypeScript/JavaScriptëŠ” ê¸°ì¡´ execFile ë°©ì‹ ìœ ì§€
    try {
      this.lastActivity = new Date();

      let tempFile: string;
      const tempDir = os.tmpdir();
      const timestamp = Date.now();

      if (language === 'typescript') {
        tempFile = path.join(tempDir, `execute_code_${timestamp}.ts`);
        fs.writeFileSync(tempFile, args.code, 'utf8');
        const tsRuntime = await this.findTypeScriptRuntime();

        let stdout = '';
        let stderr = '';

        if (tsRuntime) {
          if (tsRuntime.includes(' ')) {
            const parts = tsRuntime.split(' ');
            if (parts[0]) {
              const { stdout: out, stderr: err } = await execFileAsync(parts[0], [...parts.slice(1), tempFile]);
              stdout = out;
              stderr = err;
            }
          } else {
            const { stdout: out, stderr: err } = await execFileAsync(tsRuntime, [tempFile]);
            stdout = out;
            stderr = err;
          }
        } else {
          const { stdout: out, stderr: err } = await execFileAsync('npx', ['--yes', 'tsx@latest', tempFile]);
          stdout = out;
          stderr = err;
        }

        fs.unlinkSync(tempFile);

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                success: true,
                language: 'typescript',
                execution_method: 'execFile',
                stdout: (stdout || '').trim(),
                stderr: (stderr || '').trim(),
                note: 'TypeScript execution with execFile',
                timestamp: new Date().toISOString()
              }, null, 2),
            },
          ],
        };
      } else {
        // JavaScript
        tempFile = path.join(tempDir, `execute_code_${timestamp}.js`);
        fs.writeFileSync(tempFile, args.code, 'utf8');

        const { stdout, stderr } = await execFileAsync('node', [tempFile]);
        fs.unlinkSync(tempFile);

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                success: true,
                language: 'javascript',
                execution_method: 'execFile',
                stdout: (stdout || '').trim(),
                stderr: (stderr || '').trim(),
                note: 'JavaScript execution with execFile',
                timestamp: new Date().toISOString()
              }, null, 2),
            },
          ],
        };
      }
    } catch (error) {
      let errorMessage = error instanceof Error ? error.message : String(error);

      if (errorMessage.includes('Traceback')) {
        const lines = errorMessage.split('\\n');
        const errorLine = lines[lines.length - 1] || lines[lines.length - 2];
        if (errorLine && errorLine.includes('Error:')) {
          errorMessage = errorLine.trim();
        }
      }

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              error: errorMessage,
              note: 'Execution failed',
              timestamp: new Date().toISOString()
            }, null, 2),
          },
        ],
      };
    }
  }
}
