#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  AI Coding Brain - í†µí•© ë²„ì „ v6.3
==========================================

claude_code_ai_brain.pyì™€ context_manager.pyë¥¼ í†µí•©í•œ ë‹¨ì¼ íŒŒì¼.
í•µì‹¬ ê¸°ëŠ¥ë§Œ ìœ ì§€í•˜ê³  ê°„ì†Œí™”í•¨.

ì£¼ìš” ê¸°ëŠ¥:
- /flow ëª…ë ¹ì–´ë¡œ í”„ë¡œì íŠ¸ ì „í™˜
- /plan, /task, /next ëª…ë ¹ì–´ë¡œ ì‘ì—… ê´€ë¦¬
- ë©”ëª¨ë¦¬ ë£¨íŠ¸ì— ìºì‹œ ì¤‘ì•™ ì €ì¥
- í”„ë¡œì íŠ¸ ë£¨íŠ¸ì—ì„œ ì‘ì—… ìˆ˜í–‰
- MD íŒŒì¼ ìë™ ìƒì„± ë° ë™ê¸°í™”

v6.3 ë³€ê²½ì‚¬í•­:
- ìºì‹œ êµ¬ì¡°ë¥¼ MD íŒŒì¼ êµ¬ì¡°ì— ë§ê²Œ ê°œì„ 
- plan êµ¬ì¡° ì •ê·œí™” (dict í˜•íƒœë¡œ í†µì¼)
- MD ìƒì„± í•¨ìˆ˜ë“¤ì´ plan ì •ë³´ë¥¼ ì œëŒ€ë¡œ ì½ë„ë¡ ìˆ˜ì •
- /plan, /next ëª…ë ¹ ì‘ë™ ê°œì„ 

ì‘ì„±ì¼: 2025-06-15
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy


# ===========================================
# í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================

class UnifiedContextManager:
    """í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì - ì‹±ê¸€í†¤ íŒ¨í„´"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None  # ìºì‹œ ì €ì¥ ìœ„ì¹˜
            self.base_path = None    # í”„ë¡œì íŠ¸ ë£¨íŠ¸
            self.memory_path = None  # ë©”ëª¨ë¦¬ ê²½ë¡œ
            self.cache_dir = None    # ìºì‹œ ë””ë ‰í† ë¦¬
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str, memory_root: str = None, 
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        
        Args:
            project_path: í”„ë¡œì íŠ¸ ì‘ì—… ê²½ë¡œ
            project_name: í”„ë¡œì íŠ¸ ì´ë¦„
            memory_root: ìºì‹œ ì €ì¥ ë£¨íŠ¸ (ê¸°ë³¸ê°’: ~/Desktop/memory)
            existing_context: ê¸°ì¡´ context (execute_code í™˜ê²½ìš©)
        """
        self.project_path = project_path
        self.project_name = project_name
        self.base_path = project_path  # AIHelpers í˜¸í™˜ì„±
        
        # ë©”ëª¨ë¦¬ ë£¨íŠ¸ ì„¤ì • (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
        if memory_root:
            self.memory_root = memory_root
        else:
            # ê¸°ë³¸ê°’: í™ˆ/Desktop/memory
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # ë©”ëª¨ë¦¬ ê²½ë¡œ ì„¤ì •
        self.memory_path = os.path.join(self.memory_root, self.project_name)
        self.cache_dir = os.path.join(self.memory_path, '.cache')
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # ê¸°ì¡´ contextê°€ ìˆìœ¼ë©´ ì‚¬ìš© (execute_code í™˜ê²½)
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"âœ… ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©: {project_name}")
        else:
            # ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"âœ… ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"âœ… ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±: {project_name}")
        
        # êµ¬ì¡° ì •ê·œí™”
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_path(self) -> str:
        """ìºì‹œ íŒŒì¼ ê²½ë¡œ ë°˜í™˜ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ ê¸°ì¤€)"""
        # ë©”ëª¨ë¦¬/{í”„ë¡œì íŠ¸ëª…}/.cache/cache_{í”„ë¡œì íŠ¸ëª…}.json
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        return os.path.join(cache_dir, f'cache_{self.project_name}.json')
    
    def _create_new_context(self) -> Dict[str, Any]:
        """ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        return {
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '6.3',
            
            # ìºì‹œ êµ¬ì¡° - MD íŒŒì¼ êµ¬ì¡°ì— ë§ì¶¤
            'cache': {
                'analyzed_files': {},
                'symbol_index': {},
                'work_tracking': {
                    'file_access': {},
                    'file_edits': {},
                    'function_edits': {},
                    'session_start': dt.datetime.now().isoformat(),
                    'total_operations': 0
                },
                'metadata': {
                    'version': '6.3',
                    'last_saved': dt.datetime.now().isoformat()
                }
            },
            
            # ê³„íš ê´€ë¦¬ êµ¬ì¡° (ê°œì„ ë¨)
            'current_plan': None,  # í˜„ì¬ ê³„íš ì •ë³´
            'plans': [],  # ëª¨ë“  ê³„íš íˆìŠ¤í† ë¦¬
            
            # ì‘ì—… ê´€ë¦¬ (ë ˆê±°ì‹œ í˜¸í™˜)
            'tasks': {'next': [], 'done': []},
            'current_focus': '',
            'current_task': None,
            
            # AI í•™ìŠµ ë°ì´í„°
            'coding_experiences': [],
            
            # ì§„í–‰ë¥  ì¶”ì 
            'progress': {
                'completed_tasks': 0,
                'total_tasks': 0,
                'percentage': 0.0
            },
            
            # Phase ê´€ë¦¬ (execute_code í˜¸í™˜)
            'phase_reports': {},
            'error_log': [],
            
            # ê¸°íƒ€ í•„ë“œë“¤
            'analyzed_files': {},
            'work_tracking': {},
            'symbol_index': {}
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì—ì„œ)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_file = self._get_cache_file_path()
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    loaded_context = json.load(f)
                
                # í”„ë¡œì íŠ¸ ê²½ë¡œ ì—…ë°ì´íŠ¸ (ê²½ë¡œê°€ ë³€ê²½ë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
                loaded_context['project_path'] = self.project_path
                loaded_context['memory_root'] = self.memory_root
                
                return loaded_context
            except Exception as e:
                print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
        return None
    
    def _normalize_context_structure(self):
        """ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ì •ê·œí™”"""
        if not self.context:
            return
            
        # í•„ìˆ˜ í‚¤ í™•ì¸
        self.context.setdefault('cache', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('work_tracking', {})
        self.context.setdefault('symbol_index', {})
        self.context.setdefault('current_plan', None)
        self.context.setdefault('plans', [])
        self.context.setdefault('progress', {
            'completed_tasks': 0,
            'total_tasks': 0,
            'percentage': 0.0
        })
        
        # ê²½ë¡œ ì •ë³´ ì—…ë°ì´íŠ¸
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root
        
        # ìºì‹œ êµ¬ì¡° í™•ì¸
        cache = self.context['cache']
        cache.setdefault('analyzed_files', {})
        cache.setdefault('symbol_index', {})
        cache.setdefault('metadata', {
            'version': '6.3',
            'last_saved': dt.datetime.now().isoformat()
        })
        
        # work_tracking êµ¬ì¡°
        work_tracking = cache.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        
        # task_tracking êµ¬ì¡° ì¶”ê°€ (v6.4)
        work_tracking.setdefault('task_tracking', {})
        work_tracking.setdefault('current_task_work', {
            'task_id': None,
            'start_time': None,
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        })
        
        # ë ˆê±°ì‹œ í•„ë“œ ë§ˆì´ê·¸ë ˆì´ì…˜
        if 'analyzed_files' in self.context and self.context['analyzed_files']:
            cache['analyzed_files'].update(self.context['analyzed_files'])
        
        if 'work_tracking' in self.context and isinstance(self.context['work_tracking'], dict):
            cache['work_tracking'].update(self.context['work_tracking'])
        
        if 'symbol_index' in self.context and self.context['symbol_index']:
            cache['symbol_index'].update(self.context['symbol_index'])
    
    def save(self) -> bool:
        """ì»¨í…ìŠ¤íŠ¸ ì €ì¥ (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì—)"""
        if not self.context:
            print("âš ï¸ ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        try:
            # ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
            self.context['updated_at'] = dt.datetime.now().isoformat()
            self.context['cache']['metadata']['last_saved'] = dt.datetime.now().isoformat()
            
            # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            self._update_progress()
            
            # ìºì‹œ íŒŒì¼ ê²½ë¡œ
            cache_file = self._get_cache_file_path()
            
            # JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜
            serializable_context = self._prepare_serializable_context()
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… ìºì‹œ ì €ì¥: {cache_file}")
            
            # í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹œë„
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"âš ï¸ í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            return True
            
        except Exception as e:
            print(f"âŒ ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def _update_progress(self):
        """ì§„í–‰ë¥  ì—…ë°ì´íŠ¸"""
        if not self.context:
            return
        
        # í˜„ì¬ ê³„íšì—ì„œ ì‘ì—… ìˆ˜ ê³„ì‚°
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            total_tasks = 0
            completed_tasks = 0
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    total_tasks += 1
                    if task.get('status') == 'completed':
                        completed_tasks += 1
            
            progress = self.context.setdefault('progress', {})
            progress['total_tasks'] = total_tasks
            progress['completed_tasks'] = completed_tasks
            progress['percentage'] = (completed_tasks / max(1, total_tasks)) * 100
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜ (ê°•í™”ëœ ë²„ì „)"""
        # contextê°€ ì—†ê±°ë‚˜ dictê°€ ì•„ë‹Œ ê²½ìš° ë¹ˆ dict ë°˜í™˜
        if not self.context or not isinstance(self.context, dict):
            return {}
        
        def is_serializable(obj):
            """ê°ì²´ê°€ JSON ì§ë ¬í™” ê°€ëŠ¥í•œì§€ í™•ì¸"""
            try:
                json.dumps(obj)
                return True
            except:
                return False
        
        def convert(obj):
            """ì¬ê·€ì ìœ¼ë¡œ ê°ì²´ë¥¼ ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜"""
            # ì´ë¯¸ ì§ë ¬í™” ê°€ëŠ¥í•œ ê¸°ë³¸ íƒ€ì…
            if obj is None or isinstance(obj, (bool, int, float, str)):
                return obj
            
            # ë‚ ì§œ/ì‹œê°„ íƒ€ì…
            elif isinstance(obj, (dt.datetime, dt.date)):
                return obj.isoformat()
            
            # defaultdict -> dict
            elif isinstance(obj, defaultdict):
                return dict(obj)
            
            # set -> list
            elif isinstance(obj, set):
                return list(obj)
            
            # dict ì²˜ë¦¬
            elif isinstance(obj, dict):
                result = {}
                for k, v in obj.items():
                    # í‚¤ë„ ë¬¸ìì—´ë¡œ ë³€í™˜
                    key = str(k) if not isinstance(k, str) else k
                    # ì§ë ¬í™” ë¶ˆê°€ëŠ¥í•œ ê°’ì€ ì œì™¸
                    if is_serializable(v):
                        result[key] = convert(v)
                    else:
                        # ê°ì²´ íƒ€ì…ì´ë©´ íƒ€ì…ëª…ë§Œ ì €ì¥
                        if hasattr(v, '__class__'):
                            result[key] = f"<{v.__class__.__name__} object>"
                        else:
                            # ê·¸ ì™¸ëŠ” ê±´ë„ˆë›°ê¸°
                            pass
                return result
            
            # list/tuple ì²˜ë¦¬
            elif isinstance(obj, (list, tuple)):
                return [convert(item) for item in obj if is_serializable(item)]
            
            # ì»¤ìŠ¤í…€ ê°ì²´ë“¤ì€ ë¬¸ìì—´ë¡œ í‘œí˜„
            elif hasattr(obj, '__class__'):
                return f"<{obj.__class__.__name__} object>"
            
            # ê·¸ ì™¸ì˜ ê²½ìš°
            else:
                return str(obj)
        
        # ì»¨í…ìŠ¤íŠ¸ ë³µì‚¬ í›„ ë³€í™˜
        serializable = convert(copy.deepcopy(self.context))
        
        # íŠ¹ì • í•„ë“œ ì œê±° (ì§ë ¬í™” ë¶ˆê°€ëŠ¥í•œ ê²ƒë“¤) - dictì¸ ê²½ìš°ì—ë§Œ
        if isinstance(serializable, dict):
            fields_to_remove = ['error_tracker', 'phase_reporter', 'change_tracker', 'flow_options']
            for field in fields_to_remove:
                if field in serializable:
                    del serializable[field]
        
        return serializable
    
    def _update_project_docs(self):
        """í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸"""
        if not self.context or not self.project_path:
            return
        
        # None ì²´í¬ ì¶”ê°€
        if not self.memory_root or not self.project_name:
            print("âš ï¸ memory_root ë˜ëŠ” project_nameì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return
            
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(str(self.memory_root), str(self.project_name), filename)
            try:
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"âš ï¸ {filename} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = len(self.context.get('cache', {}).get('analyzed_files', {}))
        symbols = len(self.context.get('cache', {}).get('symbol_index', {}))
        progress = self.context.get('progress', {})
        
        content = f"""# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „

## ğŸ¯ í”„ë¡œì íŠ¸ ê°œìš”
MCP (Model Context Protocol) ê¸°ë°˜ í†µí•© ê°œë°œ ì§€ì› ì‹œìŠ¤í…œ

## ğŸ“Š í˜„ì¬ ìƒíƒœ
- ë¶„ì„ëœ íŒŒì¼: {analyzed}ê°œ
- ì‹¬ë³¼ ì¸ë±ìŠ¤: {symbols}ê°œ
- ì™„ë£Œëœ ì‘ì—…: {progress.get('completed_tasks', 0)}ê°œ
- ì „ì²´ ì‘ì—…: {progress.get('total_tasks', 0)}ê°œ
- ì§„í–‰ë¥ : {progress.get('percentage', 0):.1f}%

## ğŸ”§ í•µì‹¬ ê¸°ëŠ¥
1. **ìë™ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬**: ì‘ì—… ìƒíƒœ ìë™ ì €ì¥/ë³µì›
2. **í†µí•© ê²€ìƒ‰ ì‹œìŠ¤í…œ**: ì½”ë“œ, ë©”ëª¨ë¦¬, ìºì‹œ í†µí•© ê²€ìƒ‰
3. **Phase ê¸°ë°˜ ì‘ì—… ê´€ë¦¬**: ì²´ê³„ì ì¸ í”„ë¡œì íŠ¸ ì§„í–‰
4. **SimplEdit ì•ˆì „ ìˆ˜ì •**: ë°±ì—…ê³¼ í•¨ê»˜í•˜ëŠ” ì•ˆì „í•œ ì½”ë“œ ìˆ˜ì •
"""
        
        # í˜„ì¬ ê³„íš ì •ë³´ ì¶”ê°€
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            content += f"""
## ğŸ“‹ í˜„ì¬ ê³„íš: {plan.get('name', 'N/A')}
{plan.get('description', '')}

### Phase êµ¬ì¡°:
"""
            for phase_id, phase in plan.get('phases', {}).items():
                task_count = len(phase.get('tasks', []))
                completed = sum(1 for t in phase.get('tasks', []) if t.get('status') == 'completed')
                content += f"- **{phase.get('name', phase_id)}** ({completed}/{task_count} ì™„ë£Œ)\n"
        
        # project_pathê°€ ìˆì„ ë•Œë§Œ íŒŒì¼ í†µê³„ ì¶”ê°€
        if self.project_path and os.path.exists(self.project_path):
            try:
                py_files = []
                for root, dirs, files in os.walk(self.project_path):
                    py_files.extend([f for f in files if f.endswith('.py')])
                py_count = len(py_files)
                completion_rate = (analyzed / max(1, py_count)) * 100
                
                content += f"""
## ğŸ“ˆ í”„ë¡œì íŠ¸ í†µê³„
- ì „ì²´ Python íŒŒì¼: {py_count}ê°œ
- ë¶„ì„ ì™„ë£Œìœ¨: {completion_rate:.1f}%
"""
            except Exception:
                pass
        
        content += f"""
ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í˜„ì¬ ì‘ì—…\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        focus = self.context.get('current_focus', '')
        current_task_id = self.context.get('current_task')
        current_task = None
        current_phase = None
        
        # í˜„ì¬ ì‘ì—… ì°¾ê¸°
        if current_task_id and self.context.get('current_plan'):
            plan = self.context['current_plan']
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        current_task = task
                        current_phase = phase
                        break
                if current_task:
                    break
        
        content = f"""# AI Coding Brain - í˜„ì¬ ì‘ì—…

## ğŸ¯ í˜„ì¬ Focus
{focus or 'ì„¤ì •ë˜ì§€ ì•ŠìŒ'}

## ğŸ”„ ì§„í–‰ ì¤‘ì¸ ì‘ì—…
"""
        
        if current_task:
            content += f"""### [{current_task['id']}] {current_task['title']}
- ìƒíƒœ: {current_task.get('status', 'pending')}
- Phase: {current_phase.get('name', 'N/A')}
- ì„¤ëª…: {current_task.get('description', 'N/A')}
"""
            if current_task.get('subtasks'):
                content += "\n#### ì„œë¸ŒíƒœìŠ¤í¬:\n"
                for subtask in current_task['subtasks']:
                    content += f"- [ ] {subtask}\n"
        else:
            content += "í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.\n"
        
        # ë‹¤ìŒ ëŒ€ê¸° ì‘ì—…ë“¤
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            pending_tasks = []
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('status') == 'pending':
                        pending_tasks.append((phase, task))
                        if len(pending_tasks) >= 5:
                            break
                if len(pending_tasks) >= 5:
                    break
            
            if pending_tasks:
                content += "\n## ğŸ“‹ ëŒ€ê¸° ì¤‘ì¸ ì‘ì—… (ë‹¤ìŒ 5ê°œ)\n"
                for phase, task in pending_tasks:
                    content += f"- [{task['id']}] {task['title']} (Phase: {phase['name']})\n"
        
        content += f"""
## ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„
- `/next` ëª…ë ¹ìœ¼ë¡œ ë‹¤ìŒ ì‘ì—… ì§„í–‰
- `/task add` ëª…ë ¹ìœ¼ë¡œ ìƒˆ ì‘ì—… ì¶”ê°€
- `/save` ëª…ë ¹ìœ¼ë¡œ í˜„ì¬ ìƒíƒœ ì €ì¥

## ğŸ“ ë©”ëª¨
- save_context() í˜¸ì¶œ ì‹œ 4ê°œ ë¬¸ì„œ ìë™ ì—…ë°ì´íŠ¸
- ë°±ì—… ì—†ì´ ì§ì ‘ ì €ì¥

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_file_directory(self) -> str:
        """file_directory.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = self.context.get('cache', {}).get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## ğŸ“ Python ëª¨ë“ˆ ëª©ë¡

| ê²½ë¡œ | ì„¤ëª… | ìˆ˜ì •ì¼ |
|------|------|--------|
"""
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ë³€í™˜í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
        def to_relative_path(path):
            """ì ˆëŒ€ ê²½ë¡œë¥¼ í”„ë¡œì íŠ¸ ê¸°ì¤€ ìƒëŒ€ ê²½ë¡œë¡œ ë³€í™˜"""
            # Windows ë°±ìŠ¬ë˜ì‹œë¥¼ ìŠ¬ë˜ì‹œë¡œ í†µì¼
            path = path.replace('\\', '/')
            
            # í”„ë¡œì íŠ¸ ê²½ë¡œë„ ìŠ¬ë˜ì‹œë¡œ í†µì¼
            if self.project_path:
                project_path = self.project_path.replace('\\', '/')
                
                # ì—¬ëŸ¬ ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸ ê²½ë¡œ íŒ¨í„´ ì²˜ë¦¬
                possible_prefixes = [
                    project_path,
                    f"{project_path}/",
                    # memory_coding ê²½ë¡œë„ ì²˜ë¦¬
                    project_path.replace('/ai-coding-brain-mcp', '/memory_coding/ai-coding-brain-mcp'),
                ]
                
                for prefix in possible_prefixes:
                    if path.startswith(prefix):
                        # prefix ì œê±° í›„ ë‚¨ì€ ê²½ë¡œ
                        relative = path[len(prefix):].lstrip('/')
                        # ë¹ˆ ë¬¸ìì—´ì´ë©´ ë£¨íŠ¸
                        return '/' + relative if relative else '/'
            
            # ì´ë¯¸ ìƒëŒ€ ê²½ë¡œì¸ ê²½ìš° ìŠ¬ë˜ì‹œ ì¶”ê°€
            if not path.startswith('C:') and not path.startswith('/'):
                return '/' + path
                
            # ë³€í™˜ ì‹¤íŒ¨ì‹œ ì›ë³¸ ë°˜í™˜
            return path
        
        # ê²½ë¡œë³„ë¡œ ì •ë ¬
        sorted_files = sorted(analyzed.items(), key=lambda x: to_relative_path(x[0]))
        
        for file_path, info in sorted_files:
            mod_time = info.get('last_modified', 'Unknown')
            if isinstance(mod_time, str):
                try:
                    # ISO í˜•ì‹ ë‚ ì§œë¥¼ ë” ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ
                    mod_dt = dt.datetime.fromisoformat(mod_time.replace('Z', '+00:00'))
                    mod_time = mod_dt.strftime('%Y-%m-%d %H:%M')
                except:
                    pass
            
            # ìƒëŒ€ ê²½ë¡œë¡œ ë³€í™˜
            display_path = to_relative_path(file_path)
            
            # ë¶„ì„ëœ ì½”ë“œ ì •ë³´ ì¶”ì¶œ
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            line_count = info.get('lines', 0)
            
            # ì„¤ëª… ìƒì„±
            description = ""
            if func_count > 0 or class_count > 0:
                parts = []
                if func_count > 0:
                    parts.append(f"{func_count}ê°œ í•¨ìˆ˜")
                if class_count > 0:
                    parts.append(f"{class_count}ê°œ í´ë˜ìŠ¤")
                description = ", ".join(parts)
            else:
                description = "-"
                
            content += f"| {display_path} | {description} | {mod_time} |\n"
        
        # ì‘ì—… ì¶”ì  ì •ë³´ì—ì„œ ê°€ì¥ ë§ì´ ì ‘ê·¼í•œ íŒŒì¼
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.get('file_access', {})
        
        if file_access:
            content += f"""

## ğŸ”¥ ìì£¼ ì ‘ê·¼í•˜ëŠ” íŒŒì¼ (Top 10)
"""
            sorted_access = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:10]
            for file_path, count in sorted_access:
                # ìì£¼ ì ‘ê·¼í•˜ëŠ” íŒŒì¼ë„ ìƒëŒ€ ê²½ë¡œë¡œ í‘œì‹œ
                display_path = to_relative_path(file_path)
                content += f"- {display_path}: {count}íšŒ\n"
        
        # ì½”ë“œ ë¶„ì„ í†µê³„
        total_functions = 0
        total_classes = 0
        total_lines = 0
        
        for info in analyzed.values():
            total_functions += len(info.get('functions', []))
            total_classes += len(info.get('classes', []))
            total_lines += info.get('lines', 0)
        
        # ì‹¬ë³¼ ì¸ë±ìŠ¤ ì •ë³´
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        
        content += f"""

## ğŸ“Š ì½”ë“œ ë¶„ì„ í†µê³„
- ì „ì²´ íŒŒì¼: {len(analyzed)}ê°œ
- ì´ í•¨ìˆ˜: {total_functions}ê°œ
- ì´ í´ë˜ìŠ¤: {total_classes}ê°œ
- ì´ ì½”ë“œ ë¼ì¸: {total_lines:,}ì¤„
- ì‹¬ë³¼ ì¸ë±ìŠ¤: {len(symbol_index)}ê°œ
- ì´ íŒŒì¼ ì ‘ê·¼: {sum(file_access.values())}íšŒ

## ğŸ” ì£¼ìš” ì‹¬ë³¼ (Top 10)
"""
        # ì‹¬ë³¼ ì¸ë±ìŠ¤ì—ì„œ ì£¼ìš” í•­ëª© í‘œì‹œ
        if symbol_index:
            sorted_symbols = sorted(symbol_index.items(), key=lambda x: x[0])[:10]
            for symbol_name, symbol_info in sorted_symbols:
                symbol_type = symbol_info.get('type', 'unknown')
                symbol_file = symbol_info.get('file', 'unknown')
                symbol_icon = "ğŸ“¦" if symbol_type == 'class' else "ğŸ”§" if symbol_type == 'function' else "â“"
                content += f"- {symbol_icon} `{symbol_name}` ({symbol_type}) - {symbol_file}\n"
        
        content += f"""

## ğŸ“Œ ì£¼ìš” ë””ë ‰í† ë¦¬
- `/python/` - í•µì‹¬ Python ëª¨ë“ˆë“¤
- `/src/` - TypeScript/JavaScript ì†ŒìŠ¤
- `/backups/` - ë°±ì—… íŒŒì¼ë“¤
- `/dist/` - ë¹Œë“œ ê²°ê³¼ë¬¼
- `/.cache/` - ìºì‹œ íŒŒì¼ë“¤

## ğŸ“ ìµœê·¼ ë¶„ì„ëœ íŒŒì¼
"""
        # ìµœê·¼ ë¶„ì„ëœ íŒŒì¼ (ìˆ˜ì • ì‹œê°„ ê¸°ì¤€)
        recent_files = []
        for file_path, info in analyzed.items():
            mod_time = info.get('last_modified', '')
            if mod_time and mod_time != 'Unknown':
                recent_files.append((file_path, mod_time, info))
        
        recent_files.sort(key=lambda x: x[1], reverse=True)
        
        for file_path, mod_time, info in recent_files[:5]:
            display_path = to_relative_path(file_path)
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            content += f"- {display_path} ({func_count}ê°œ í•¨ìˆ˜, {class_count}ê°œ í´ë˜ìŠ¤)\n"
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - ì§„í–‰ ìƒí™©\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        progress = self.context.get('progress', {})
        done_count = progress.get('completed_tasks', 0)
        total_count = progress.get('total_tasks', 0)
        percentage = progress.get('percentage', 0)
        
        content = f"""# AI Coding Brain - ì§„í–‰ ìƒí™©

## ğŸ“Š ì „ì²´ ì§„í–‰ë¥ 
- ì™„ë£Œ: {done_count}ê°œ
- ì „ì²´: {total_count}ê°œ
- ì§„í–‰ë¥ : {percentage:.1f}%

### ì§„í–‰ë¥  ì°¨íŠ¸
[{'â–ˆ' * int(percentage / 5)}{'â–‘' * (20 - int(percentage / 5))}] {percentage:.1f}%
"""
        
        # Phaseë³„ ì§„í–‰ ìƒí™©
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            content += "\n## ğŸ¯ Phase ì§„í–‰ ìƒí™©\n"
            
            for phase_id, phase in plan.get('phases', {}).items():
                tasks = phase.get('tasks', [])
                completed = sum(1 for t in tasks if t.get('status') == 'completed')
                in_progress = sum(1 for t in tasks if t.get('status') == 'in_progress')
                total = len(tasks)
                
                if total > 0:
                    phase_percentage = (completed / total) * 100
                    content += f"\n### {phase.get('name', phase_id)}\n"
                    content += f"- ì™„ë£Œ: {completed}ê°œ, ì§„í–‰ì¤‘: {in_progress}ê°œ, ëŒ€ê¸°: {total - completed - in_progress}ê°œ\n"
                    content += f"- ì§„í–‰ë¥ : [{phase_percentage:.1f}%] "
                    content += f"[{'â–ˆ' * int(phase_percentage / 10)}{'â–‘' * (10 - int(phase_percentage / 10))}]\n"
        
        # ìµœê·¼ ì™„ë£Œ ì‘ì—…
        if self.context.get('current_plan'):
            plan = self.context['current_plan']
            completed_tasks = []
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('status') == 'completed':
                        completed_tasks.append({
                            'task': task,
                            'phase': phase.get('name', phase_id)
                        })
            
            if completed_tasks:
                content += "\n## ğŸ“‹ ìµœê·¼ ì™„ë£Œ ì‘ì—…\n"
                # ìµœê·¼ 5ê°œë§Œ í‘œì‹œ (ì‹¤ì œë¡œëŠ” ì™„ë£Œ ì‹œê°„ìœ¼ë¡œ ì •ë ¬í•´ì•¼ í•˜ì§€ë§Œ í˜„ì¬ëŠ” ìˆœì„œëŒ€ë¡œ)
                for item in completed_tasks[-5:]:
                    task = item['task']
                    content += f"- [{task['id']}] {task['title']} (Phase: {item['phase']})\n"
        
        # ì‘ì—… í†µê³„
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        content += f"""
## ğŸ“ˆ ì‘ì—… í†µê³„
- ì´ ì‘ì—… ìˆ˜í–‰: {work_tracking.get('total_operations', 0)}íšŒ
- íŒŒì¼ í¸ì§‘: {len(work_tracking.get('file_edits', {}))}ê°œ
- í•¨ìˆ˜ ìˆ˜ì •: {len(work_tracking.get('function_edits', {}))}ê°œ

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    # ===========================================
    # ìºì‹œ ê´€ë¦¬ ë©”ì„œë“œ
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """ìºì‹œ ì—…ë°ì´íŠ¸ (ì¤‘ì²© í‚¤ ì§€ì›)"""
        if not self.context:
            return
        
        cache = self.context.setdefault('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """ìºì‹œ ê°’ ì¡°íšŒ"""
        if not self.context:
            return default
        
        cache = self.context.get('cache', {})
        keys = key.split('.')
        current = cache
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # ì‹¬ë³¼ ë° ì‘ì—… ì¶”ì 
    # ===========================================
    
    def find_symbol(self, symbol_name: str) -> Optional[Dict[str, Any]]:
        """ì‹¬ë³¼ ê²€ìƒ‰"""
        if not self.context:
            return None
        
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        return symbol_index.get(symbol_name)
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        file_access[file_path] = file_access.get(file_path, 0) + 1
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # í˜„ì¬ task ì‘ì—…ì—ë„ ì¶”ê°€
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            files_accessed = current_task_work.setdefault('files_accessed', [])
            if file_path not in files_accessed:
                files_accessed.append(file_path)
            
            # ì‘ì—… ë‚´ì—­ ì¶”ê°€
            self.track_task_operation('file_access', {
                'file': file_path,
                'operation': operation
            })
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        # í•¨ìˆ˜ í‚¤ ìƒì„±
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        # í¸ì§‘ ì •ë³´ ì—…ë°ì´íŠ¸
        if func_key not in function_edits:
            function_edits[func_key] = {'count': 0, 'operations': []}
        
        function_edits[func_key]['count'] += 1
        function_edits[func_key]['operations'].append({
            'timestamp': dt.datetime.now().isoformat(),
            'file': file_path
        })
        
        # íŒŒì¼ í¸ì§‘ë„ ì¶”ì 
        file_edits = work_tracking.setdefault('file_edits', {})
        file_edits[file_path] = file_edits.get(file_path, 0) + 1
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # í˜„ì¬ task ì‘ì—…ì—ë„ ì¶”ê°€
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            functions_edited = current_task_work.setdefault('functions_edited', [])
            if func_key not in functions_edited:
                functions_edited.append(func_key)
            
            # ì‘ì—… ë‚´ì—­ ì¶”ê°€
            self.track_task_operation('function_edit', {
                'file': file_path,
                'function': func_key,
                'class': class_name
            })
    
    def get_work_tracking_summary(self) -> str:
        """ì‘ì—… ì¶”ì  ìš”ì•½"""
        if not self.context:
            return "ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # ì„¸ì…˜ ì‹œê°„ ê³„ì‚°
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        # í†µê³„ ìˆ˜ì§‘
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        task_tracking = work_tracking.get('task_tracking', {})
        
        # ìš”ì•½ ìƒì„±
        summary = f"""
ğŸ“Š ì‘ì—… ì¶”ì  ìš”ì•½
================
â€¢ í”„ë¡œì íŠ¸: {self.project_name}
â€¢ ì‘ì—… ê²½ë¡œ: {self.project_path}
â€¢ ìºì‹œ ê²½ë¡œ: {self.memory_root}
â€¢ ì„¸ì…˜ ì‹œê°„: {duration_str}
â€¢ ì „ì²´ ì‘ì—…: {total_ops}íšŒ
â€¢ ì ‘ê·¼í•œ íŒŒì¼: {len(file_access)}ê°œ
â€¢ ìˆ˜ì •í•œ íŒŒì¼: {len(file_edits)}ê°œ
â€¢ ìˆ˜ì •í•œ í•¨ìˆ˜: {len(function_edits)}ê°œ
â€¢ ìˆ˜í–‰í•œ Task: {len(task_tracking)}ê°œ
"""
        
        # í˜„ì¬ ì‘ì—… ì¤‘ì¸ Task
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            summary += f"\nğŸ¯ í˜„ì¬ ì‘ì—… ì¤‘ì¸ Task: {current_task_work['task_id']}\n"
            summary += f"  â€¢ ì‹œì‘ ì‹œê°„: {current_task_work.get('start_time', 'N/A')}\n"
            summary += f"  â€¢ ì ‘ê·¼ íŒŒì¼: {len(current_task_work.get('files_accessed', []))}ê°œ\n"
            summary += f"  â€¢ ìˆ˜ì • í•¨ìˆ˜: {len(current_task_work.get('functions_edited', []))}ê°œ\n"
        
        # Top 5 íŒŒì¼
        if file_access:
            summary += "\nğŸ”¥ ê°€ì¥ ë§ì´ ì ‘ê·¼í•œ íŒŒì¼:\n"
            sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:5]
            for file_path, count in sorted_files:
                summary += f"  â€¢ {file_path}: {count}íšŒ\n"
        
        # Top 5 í•¨ìˆ˜
        if function_edits:
            summary += "\nâœï¸ ê°€ì¥ ë§ì´ ìˆ˜ì •í•œ í•¨ìˆ˜:\n"
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1]['count'], reverse=True)[:5]
            for func_name, info in sorted_funcs:
                summary += f"  â€¢ {func_name}: {info['count']}íšŒ\n"
        
        # Taskë³„ ì‘ì—… ì´ë ¥
        if task_tracking:
            summary += "\nğŸ“‹ Taskë³„ ì‘ì—… ì´ë ¥:\n"
            for task_id, task_work in list(task_tracking.items())[-5:]:
                summary += f"  â€¢ [{task_id}]: íŒŒì¼ {len(task_work.get('files_accessed', []))}ê°œ, "
                summary += f"í•¨ìˆ˜ {len(task_work.get('functions_edited', []))}ê°œ ìˆ˜ì •\n"
        
        return summary
    
    def start_task_tracking(self, task_id: str):
        """Task ì‘ì—… ì¶”ì  ì‹œì‘"""
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # ì´ì „ task ì‘ì—… ì €ì¥
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id'):
            # task_trackingì— ì €ì¥
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_work['task_id']] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
        
        # ìƒˆ task ì‘ì—… ì‹œì‘
        work_tracking['current_task_work'] = {
            'task_id': task_id,
            'start_time': dt.datetime.now().isoformat(),
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        }
    
    def track_task_operation(self, operation_type: str, details: dict = None):
        """í˜„ì¬ Taskì˜ ì‘ì—… ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        
        if current_task_work.get('task_id'):
            operation = {
                'type': operation_type,
                'timestamp': dt.datetime.now().isoformat(),
                'details': details or {}
            }
            current_task_work.setdefault('operations', []).append(operation)


# ===========================================
# ê¸€ë¡œë²Œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str, memory_root: str = None,
                      existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
    return _context_manager.initialize(project_path, project_name, memory_root, existing_context)

def save_context() -> bool:
    """ì»¨í…ìŠ¤íŠ¸ ì €ì¥"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """ìºì‹œ ì—…ë°ì´íŠ¸"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """ìºì‹œ ê°’ ì¡°íšŒ"""
    return _context_manager.get_value(key, default)

def find_symbol(symbol_name: str) -> Optional[Dict[str, Any]]:
    """ì‹¬ë³¼ ì°¾ê¸°"""
    return _context_manager.find_symbol(symbol_name)

def track_file_access(file_path: str, operation: str = 'read'):
    """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """ì‘ì—… ì¶”ì  ìš”ì•½"""
    return _context_manager.get_work_tracking_summary()

def start_task_tracking(task_id: str):
    """Task ì‘ì—… ì¶”ì  ì‹œì‘"""
    _context_manager.start_task_tracking(task_id)

def track_task_operation(operation_type: str, details: dict = None):
    """í˜„ì¬ Taskì˜ ì‘ì—… ì¶”ì """
    _context_manager.track_task_operation(operation_type, details)

def get_current_context() -> Optional[Dict[str, Any]]:
    """í˜„ì¬ context ë°˜í™˜ (auto_tracking_wrapperìš©)"""
    return _context_manager.context if _context_manager else None


# ===========================================
# Claude Desktop ì„¤ì • ë° ëª…ë ¹ì–´ ì²˜ë¦¬
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop ì„¤ì •ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_root': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_root'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"âš ï¸ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    return paths


def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> None:
    """/flow ëª…ë ¹ì–´ - í”„ë¡œì íŠ¸ ì „í™˜
    
    Args:
        project_name: ì „í™˜í•  í”„ë¡œì íŠ¸ëª…
        existing_context: ê¸°ì¡´ context (execute_code í™˜ê²½ìš©)
    """
    
    if not project_name:
        # í˜„ì¬ ìƒíƒœ í‘œì‹œ
        if _context_manager.project_name:
            print(f"\nğŸ”¥ í˜„ì¬ í”„ë¡œì íŠ¸: {_context_manager.project_name}")
            print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {_context_manager.project_path}")
            print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {_context_manager.memory_root}")
            print(get_work_tracking_summary())
        else:
            print("\nâš ï¸ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            print("ì‚¬ìš©ë²•: /flow [í”„ë¡œì íŠ¸ëª…]")
        return
    
    # ì´ì „ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
    if _context_manager.context:
        save_context()
    
    # ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    # execute_code í™˜ê²½ì—ì„œëŠ” Desktop ì§ì† ê²½ë¡œ ìš°ì„  í™•ì¸
    if existing_context:
        # Desktop ì§ì† ê²½ë¡œ ë¨¼ì € í™•ì¸
        desktop_path = paths['project_root'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            project_path = os.getcwd()
            location = 'current'
    else:
        # í”„ë¡œì íŠ¸ ê²½ë¡œ ì°¾ê¸° (Desktop ìš°ì„ , ê·¸ ë‹¤ìŒ ë©”ëª¨ë¦¬)
        project_path = paths['project_root'] / project_name
        location = 'desktop'
        
        if not project_path.exists():
            # ë©”ëª¨ë¦¬ ë£¨íŠ¸ í™•ì¸
            project_path = paths['memory_root'] / project_name
            location = 'memory'
            
            if not project_path.exists():
                # í˜„ì¬ ë””ë ‰í† ë¦¬ì—ì„œ ì°¾ê¸°
                if os.path.basename(os.getcwd()) == project_name:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\nâŒ í”„ë¡œì íŠ¸ '{project_name}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                    print(f"   â€¢ Desktop: {paths['project_root'] / project_name}")
                    print(f"   â€¢ Memory: {paths['memory_root'] / project_name}")
                    return
    
    # ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½ (execute_code í™˜ê²½ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ)
    if not existing_context:
        os.chdir(project_path)
    
    # Context ì´ˆê¸°í™” (ë©”ëª¨ë¦¬ ë£¨íŠ¸ì™€ ê¸°ì¡´ context ì „ë‹¬)
    context = initialize_context(str(project_path), project_name, memory_root, existing_context)
    
    print(f"\nâœ… í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì™„ë£Œ!")
    print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {project_path} ({location})")
    print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {memory_root}/{project_name}/.cache/")
    print(f"ğŸ“Š ìºì‹œ ë²„ì „: {context.get('version', 'Unknown')}")
    
    # ê°„ë‹¨í•œ í†µê³„ í‘œì‹œ
    analyzed_files = context.get('cache', {}).get('analyzed_files', {})
    progress = context.get('progress', {})
    print(f"ğŸ“ˆ ë¶„ì„ëœ íŒŒì¼: {len(analyzed_files)}ê°œ")
    print(f"ğŸ“‹ ë‚¨ì€ ì‘ì—…: {progress.get('total_tasks', 0) - progress.get('completed_tasks', 0)}ê°œ")
    print(f"âœ… ì™„ë£Œëœ ì‘ì—…: {progress.get('completed_tasks', 0)}ê°œ")


# ===========================================
# ì‘ì—… ê´€ë¦¬ ëª…ë ¹ì–´
# ===========================================

def cmd_plan(plan_name: str = None, description: str = None) -> Dict[str, Any]:
    """/plan ëª…ë ¹ì–´ - ìƒˆë¡œìš´ ê³„íš ìƒì„±
    
    Args:
        plan_name: ê³„íš ì´ë¦„
        description: ê³„íš ì„¤ëª…
    """
    if not _context_manager.context:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € /flow [í”„ë¡œì íŠ¸ëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return None
    
    if not plan_name:
        # í˜„ì¬ ê³„íš í‘œì‹œ
        current_plan = _context_manager.context.get('current_plan')
        if current_plan:
            print(f"\nğŸ“‹ í˜„ì¬ ê³„íš: {current_plan['name']}")
            print(f"   ì„¤ëª…: {current_plan.get('description', 'N/A')}")
            print(f"   ìƒì„±: {current_plan.get('created_at', 'N/A')}")
            print(f"   Phase ìˆ˜: {len(current_plan.get('phases', {}))}ê°œ")
            
            for phase_id, phase in current_plan.get('phases', {}).items():
                tasks = phase.get('tasks', [])
                completed = sum(1 for t in tasks if t.get('status') == 'completed')
                print(f"\n   ğŸ“Œ {phase.get('name', phase_id)} ({completed}/{len(tasks)} ì™„ë£Œ)")
        else:
            print("\nâš ï¸ í˜„ì¬ ì„¤ì •ëœ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤.")
            print("ì‚¬ìš©ë²•: /plan [ê³„íšëª…] [ì„¤ëª…]")
        return None
    
    # ìƒˆ ê³„íš ìƒì„±
    timestamp = dt.datetime.now().isoformat()
    
    new_plan = {
        'name': plan_name,
        'description': description or f"{_context_manager.project_name} ì‘ì—… ê³„íš",
        'created_at': timestamp,
        'updated_at': timestamp,
        'phases': {},
        'current_phase': None,
        'current_task': None
    }
    
    # ê¸°ë³¸ Phase 3ê°œ ìƒì„±
    default_phases = [
        ('phase-1', 'Phase 1: ë¶„ì„ ë° ì„¤ê³„', 'í˜„ì¬ ìƒíƒœ ë¶„ì„ê³¼ ê°œì„  ë°©í–¥ ì„¤ê³„'),
        ('phase-2', 'Phase 2: í•µì‹¬ êµ¬í˜„', 'ì£¼ìš” ê¸°ëŠ¥ êµ¬í˜„ ë° ê°œì„ '),
        ('phase-3', 'Phase 3: í…ŒìŠ¤íŠ¸ ë° ë¬¸ì„œí™”', 'í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ë¬¸ì„œ ì •ë¦¬')
    ]
    
    for phase_id, phase_name, phase_desc in default_phases:
        new_plan['phases'][phase_id] = {
            'id': phase_id,
            'name': phase_name,
            'description': phase_desc,
            'status': 'pending',
            'tasks': []
        }
    
    # ì²« ë²ˆì§¸ Phaseë¥¼ í˜„ì¬ Phaseë¡œ
    new_plan['current_phase'] = 'phase-1'
    
    # ì»¨í…ìŠ¤íŠ¸ì— ì €ì¥
    _context_manager.context['current_plan'] = new_plan
    _context_manager.context['plans'].append({
        'name': plan_name,
        'created_at': timestamp,
        'id': f"plan-{len(_context_manager.context['plans']) + 1}"
    })
    
    save_context()
    print(f"\nâœ… ìƒˆ ê³„íš '{plan_name}' ìƒì„± ì™„ë£Œ!")
    print(f"   ì„¤ëª…: {new_plan['description']}")
    print(f"\n   3ê°œì˜ ê¸°ë³¸ Phaseê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤:")
    for phase_id, phase_name, _ in default_phases:
        print(f"   - {phase_name}")
    print(f"\n   /task add {default_phases[0][0]} [ì‘ì—…ëª…]ìœ¼ë¡œ ì‘ì—…ì„ ì¶”ê°€í•˜ì„¸ìš”.")
    
    return new_plan


def cmd_task(action: str, *args) -> None:
    """/task ëª…ë ¹ì–´ - ì‘ì—… ê´€ë¦¬
    
    Args:
        action: add, edit, delete, list ë“±
        args: ì•¡ì…˜ë³„ ì¸ì
    """
    if not _context_manager.context:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return
        
    current_plan = _context_manager.context.get('current_plan')
    if not current_plan:
        print("âŒ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € /plan [ê³„íšëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    if action == 'add':
        # /task add [phase-id] [task-title] [description]
        if len(args) < 2:
            print("ì‚¬ìš©ë²•: /task add [phase-id] [ì‘ì—…ëª…] [ì„¤ëª…(ì„ íƒ)]")
            return
            
        phase_id = args[0]
        task_title = args[1]
        task_desc = ' '.join(args[2:]) if len(args) > 2 else ""
        
        # Phase ì°¾ê¸°
        phase = current_plan['phases'].get(phase_id)
        if not phase:
            print(f"âŒ Phase '{phase_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            print(f"   ì‚¬ìš© ê°€ëŠ¥í•œ Phase: {', '.join(current_plan['phases'].keys())}")
            return
        
        # ìƒˆ Task ID ìƒì„±
        phase_num = phase_id.split('-')[1]
        task_num = len(phase['tasks']) + 1
        new_task = {
            'id': f'{phase_num}-{task_num}',
            'title': task_title,
            'description': task_desc,
            'status': 'pending',
            'created_at': dt.datetime.now().isoformat(),
            'subtasks': []
        }
        
        phase['tasks'].append(new_task)
        current_plan['updated_at'] = dt.datetime.now().isoformat()
        
        # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        _context_manager._update_progress()
        save_context()
        
        print(f"âœ… Task ì¶”ê°€ë¨: [{new_task['id']}] {task_title}")
        print(f"   Phase: {phase['name']}")
        
    elif action == 'edit':
        # /task edit [task-id] status|title|desc [new-value]
        if len(args) < 3:
            print("ì‚¬ìš©ë²•: /task edit [task-id] status|title|desc [ìƒˆê°’]")
            print("   status ê°’: pending, in_progress, completed, blocked")
            return
            
        task_id = args[0]
        field = args[1]
        new_value = ' '.join(args[2:])
        
        # Task ì°¾ê¸°
        task_found = False
        for phase_id, phase in current_plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if field == 'status':
                        if new_value not in ['pending', 'in_progress', 'completed', 'blocked']:
                            print(f"âŒ ì˜ëª»ëœ ìƒíƒœê°’: {new_value}")
                            print("   ê°€ëŠ¥í•œ ê°’: pending, in_progress, completed, blocked")
                            return
                        task['status'] = new_value
                        
                        # í˜„ì¬ ì‘ì—… ì—…ë°ì´íŠ¸
                        if new_value == 'in_progress':
                            _context_manager.context['current_task'] = task_id
                            current_plan['current_phase'] = phase_id
                            phase['status'] = 'in_progress'
                        elif new_value == 'completed' and _context_manager.context.get('current_task') == task_id:
                            _context_manager.context['current_task'] = None
                            
                    elif field == 'title':
                        task['title'] = new_value
                    elif field in ['desc', 'description']:
                        task['description'] = new_value
                    else:
                        print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” í•„ë“œ: {field}")
                        return
                    
                    task['updated_at'] = dt.datetime.now().isoformat()
                    task_found = True
                    current_plan['updated_at'] = dt.datetime.now().isoformat()
                    
                    # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                    _context_manager._update_progress()
                    save_context()
                    
                    print(f"âœ… Task [{task_id}] {field} ìˆ˜ì •ë¨")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"âŒ Task '{task_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    elif action == 'list':
        # í˜„ì¬ ëª¨ë“  task í‘œì‹œ
        print(f"\nğŸ“‹ ê³„íš: {current_plan['name']}")
        print(f"ì§„í–‰ë¥ : {_context_manager.context['progress']['percentage']:.1f}%")
        print("\nì „ì²´ Task ëª©ë¡:")
        
        for phase_id, phase in current_plan['phases'].items():
            tasks = phase['tasks']
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            
            status_emoji = "âœ…" if phase['status'] == 'completed' else "ğŸ”„" if phase['status'] == 'in_progress' else "â³"
            print(f"\n{status_emoji} {phase['name']} ({completed}/{len(tasks)} ì™„ë£Œ)")
            
            if phase.get('description'):
                print(f"   ğŸ“ {phase['description']}")
            
            for task in tasks:
                task_emoji = "âœ…" if task['status'] == 'completed' else "ğŸ”„" if task['status'] == 'in_progress' else "ğŸš«" if task['status'] == 'blocked' else "â³"
                current = " ğŸ‘ˆ í˜„ì¬" if _context_manager.context.get('current_task') == task['id'] else ""
                print(f"   {task_emoji} [{task['id']}] {task['title']}{current}")
                if task.get('description'):
                    print(f"      ğŸ“ {task['description']}")
    
    else:
        print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ì•¡ì…˜: {action}")
        print("ì‚¬ìš© ê°€ëŠ¥í•œ ì•¡ì…˜: add, edit, list")


def cmd_next() -> None:
    """/next ëª…ë ¹ì–´ - ë‹¤ìŒ ì‘ì—…ìœ¼ë¡œ ì§„í–‰"""
    if not _context_manager.context:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return
        
    current_plan = _context_manager.context.get('current_plan')
    if not current_plan:
        print("âŒ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € /plan [ê³„íšëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    # í˜„ì¬ ì‘ì—…ì´ ìˆìœ¼ë©´ ì™„ë£Œë¡œ í‘œì‹œ
    current_task_id = _context_manager.context.get('current_task')
    if current_task_id:
        # í˜„ì¬ task ì‘ì—… ì¶”ì  ì¢…ë£Œ
        work_tracking = _context_manager.context.get('cache', {}).get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work.get('task_id') == current_task_id:
            # task_trackingì— ì €ì¥
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_id] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
            
            # ì‘ì—… ìš”ì•½ ì¶œë ¥
            print(f"\nğŸ“Š Task [{current_task_id}] ì‘ì—… ìš”ì•½:")
            print(f"   â€¢ ì ‘ê·¼ íŒŒì¼: {len(current_task_work.get('files_accessed', []))}ê°œ")
            print(f"   â€¢ ìˆ˜ì • í•¨ìˆ˜: {len(current_task_work.get('functions_edited', []))}ê°œ")
            print(f"   â€¢ ì´ ì‘ì—…: {len(current_task_work.get('operations', []))}íšŒ")
        
        for phase_id, phase in current_plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == current_task_id:
                    if task['status'] != 'completed':
                        task['status'] = 'completed'
                        task['completed_at'] = dt.datetime.now().isoformat()
                        # ì‘ì—… ì¶”ì  ì •ë³´ taskì— ì €ì¥
                        task['work_summary'] = {
                            'files_accessed': len(current_task_work.get('files_accessed', [])),
                            'functions_edited': len(current_task_work.get('functions_edited', [])),
                            'operations': len(current_task_work.get('operations', []))
                        }
                        print(f"âœ… Task [{task['id']}] {task['title']} ì™„ë£Œ!")
                    break
    
    # ë‹¤ìŒ pending ì‘ì—… ì°¾ê¸°
    next_task = None
    next_phase = None
    
    # í˜„ì¬ Phaseë¶€í„° í™•ì¸
    if current_plan.get('current_phase'):
        phase = current_plan['phases'].get(current_plan['current_phase'])
        if phase:
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
    
    # ì—†ìœ¼ë©´ ì „ì²´ Phaseì—ì„œ ì°¾ê¸°
    if not next_task:
        for phase_id, phase in current_plan['phases'].items():
            if phase['status'] == 'completed':
                continue
                
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
            
            if next_task:
                break
    
    if next_task:
        # í˜„ì¬ ì‘ì—… ì„¤ì •
        _context_manager.context['current_task'] = next_task['id']
        current_plan['current_phase'] = next_phase['id']
        next_task['status'] = 'in_progress'
        next_task['started_at'] = dt.datetime.now().isoformat()
        next_phase['status'] = 'in_progress'
        
        # ìƒˆ task ì‘ì—… ì¶”ì  ì‹œì‘
        _context_manager.start_task_tracking(next_task['id'])
        
        current_plan['updated_at'] = dt.datetime.now().isoformat()
        
        # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        _context_manager._update_progress()
        save_context()
        
        print(f"\nğŸ¯ ë‹¤ìŒ ì‘ì—…: [{next_task['id']}] {next_task['title']}")
        if next_task['description']:
            print(f"   ğŸ“ ì„¤ëª…: {next_task['description']}")
        print(f"   ğŸ“ Phase: {next_phase['name']}")
        
        # ì„œë¸ŒíƒœìŠ¤í¬ê°€ ìˆìœ¼ë©´ í‘œì‹œ
        if next_task.get('subtasks'):
            print(f"\n   ğŸ“Œ ì„œë¸ŒíƒœìŠ¤í¬:")
            for subtask in next_task['subtasks']:
                print(f"      - {subtask}")
        
        print(f"\nğŸ’¡ ì‘ì—… ì¶”ì ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë“  íŒŒì¼ ì ‘ê·¼ê³¼ í•¨ìˆ˜ ìˆ˜ì •ì´ ìë™ìœ¼ë¡œ ê¸°ë¡ë©ë‹ˆë‹¤.")
    else:
        # ëª¨ë“  ì‘ì—… ì™„ë£Œ í™•ì¸
        all_done = True
        blocked_tasks = []
        
        for phase_id, phase in current_plan['phases'].items():
            for task in phase['tasks']:
                if task['status'] == 'blocked':
                    blocked_tasks.append(task)
                elif task['status'] != 'completed':
                    all_done = False
        
        if all_done and not blocked_tasks:
            print("\nğŸ‰ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
            
            # ëª¨ë“  Phaseë„ ì™„ë£Œë¡œ í‘œì‹œ
            for phase in current_plan['phases'].values():
                phase['status'] = 'completed'
            
            _context_manager._update_progress()
            save_context()
        else:
            if blocked_tasks:
                print(f"\nâš ï¸ ì§„í–‰ ê°€ëŠ¥í•œ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤. {len(blocked_tasks)}ê°œì˜ ì‘ì—…ì´ blocked ìƒíƒœì…ë‹ˆë‹¤:")
                for task in blocked_tasks[:3]:
                    print(f"   - [{task['id']}] {task['title']}")
            else:
                print("\nâš ï¸ ì§„í–‰ ê°€ëŠ¥í•œ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.")


def process_command(command: str, existing_context: Dict[str, Any] = None) -> Any:
    """ëª…ë ¹ì–´ ì²˜ë¦¬
    
    Args:
        command: ì²˜ë¦¬í•  ëª…ë ¹ì–´
        existing_context: ê¸°ì¡´ context (execute_code í™˜ê²½ìš©)
        
    Returns:
        ëª…ë ¹ì–´ ì‹¤í–‰ ê²°ê³¼
    """
    parts = command.strip().split()
    if not parts:
        return None
    
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    if cmd == '/flow':
        project_name = args[0] if args else None
        return cmd_flow(project_name, existing_context)
    
    elif cmd == '/plan':
        if len(args) == 0:
            return cmd_plan()
        elif len(args) == 1:
            return cmd_plan(args[0])
        else:
            # ì²« ë²ˆì§¸ ì¸ìëŠ” ê³„íšëª…, ë‚˜ë¨¸ì§€ëŠ” ì„¤ëª…
            return cmd_plan(args[0], ' '.join(args[1:]))
    
    elif cmd == '/task':
        if not args:
            print("ì‚¬ìš©ë²•: /task add|edit|list [ì¸ì...]")
            return None
        return cmd_task(args[0], *args[1:])
    
    elif cmd == '/next':
        return cmd_next()
    
    elif cmd == '/save':
        return save_context()
    
    else:
        print(f"ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {cmd}")
        print("ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´: /flow, /plan, /task, /next, /save")
        return None


# ===========================================
# ë©”ì¸ ì§„ì…ì 
# ===========================================

if __name__ == "__main__":
    import sys
    
    # ì¸ìê°€ ìˆìœ¼ë©´ ëª…ë ¹ì–´ë¡œ ì²˜ë¦¬
    if len(sys.argv) > 1:
        command = ' '.join(sys.argv[1:])
        process_command(command)
    else:
        print("AI Coding Brain v6.3")
        print("ì‚¬ìš©ë²•: python claude_code_ai_brain.py [ëª…ë ¹ì–´]")
        print("ëª…ë ¹ì–´: /flow, /plan, /task, /next, /save")
