# AI Coding Brain MCP - 아키텍처 분석 및 리팩토링 방안

## o3 분석 결과

{'answer': '아래 제안은 59 KB 규모의 6 개 모듈을 “읽지 않고도” 확실히 개선할 수 있도록, 구조 → 코드 → 데이터 → 단계적 실행 → 위험 관리 순으로 서술했습니다.  \n(길지만, 단계별로 그대로 체크리스트-화하면 바로 실무 적용이 가능하도록 작성했습니다.)\n\n────────────────────────────────────────\n1. 아키텍처 수준의 문제점\n────────────────────────────────────────\n1-1. 결합도 & 순환 참조\n • FlowCommandRouter → handle_flow_status 안에서 FlowManager 를 직접 import  \n   ‑ 컴파일 시점에는 의존하지 않지만, 런타임 순환(import loop) 위험이 상존  \n • workflow_wrapper.wf 가 “어떤 Manager 인지”를 if/elif 로 하드코딩  \n   ‑ 새로운 Manager 추가 시 wrapper 수정이 필수 ⇒ OCP(Open–Closed) 위반  \n • LegacyFlowAdapter 까지 포함된 다층 호출 체계가 실제로는 “직접 참조”로 엮여 있어 계층 분리가 무의미\n\n1-2. 계층 불투명\n • Router, Manager, Adapter 들이 모두 “비즈니스 로직 + 라우팅 + 상태 관리”를 동시 수행  \n   ⇒ SRP(Single-Responsibility) 와 Layered Architecture 모두 충돌\n\n1-3. 확장성\n • 명령어가 늘어날수록 if/elif 트리가 선형으로 증가  \n • Data 구조가 dict 또는 객체를 동시에 받아들이면서 static type-check 나 자동 완성 이 모두 불가\n\n────────────────────────────────────────\n2. 코드 품질 문제\n────────────────────────────────────────\n2-1. SOLID 위반\n • SRP: handle_flow_status (538줄)  \n • OCP: workflow_wrapper.wf 의 분기  \n • DIP(Dependency Inversion): 구현체(FlowManager) 를 직접 import\n\n2-2. 중복\n • 동일한 try/except 블록 22회  \n • Flow 객체 판별 로직 반복: isinstance(flow, dict) …\n\n2-3. 복잡도\n • handle_flow_status: 사이클로매틱 복잡도 60 이상 추정  \n • wf 의 분기: 호환 레이어 추가 때마다 N² 규모 로직 삽입\n\n────────────────────────────────────────\n3. 데이터 흐름 분석\n────────────────────────────────────────\n3-1. 데이터 구조\n • Flow, Plan, Task 가 dataclass/ORM/Pydantic 등으로 고정돼 있지 않고  \n   ‑ dict 로 오면 key 접근  \n   ‑ 객체면 attr 접근  \n   ⇒ 캡슐화/타입 안정성 상실, 마셜링 비용 ↑\n\n3-2. 상태 관리\n • Flow.state / Plan.status 등 네이밍 불일치 → enum 도 불통합  \n • 여러 모듈이 동일 상태값을 직접 문자열 비교 (“running” / “RUNNING” 혼재)\n\n3-3. 에러 처리\n • try: … except Exception as e: logger.error … return {\'error\': str(e)}  \n   ‑ 패턴이 22회 반복  \n   ‑ 에러코드/메시지/스택트레이스 구조가 호출부마다 달라 추적 곤란\n\n────────────────────────────────────────\n4. 단계별 리팩토링 전략\n────────────────────────────────────────\n⚠️ 전면 개편은 위험이 크므로 “리팩터블 아키텍처(Refactor-friendly Architecture)”를 먼저 깔고,  \n핵심 도메인부터 변환 → 어댑터로 구버전 지원 → cleanup 순서로 진행합니다.\n\n━━━━━━━━━━━━━━━\nSTEP 0. 가드레일 구축\n━━━━━━━━━━━━━━━\n0-1. 테스트 격자 만들기\n • pytest 기준 명령어 단위 Black-box 테스트 작성 (happy + edge case)  \n   ‑ 현재 출력 스냅샷을 fixture 로 저장\n\n0-2. 옵저버빌리티\n • logging & Sentry 등 통합 에러 리포팅 추가 (handler 하나만 삽입)\n\n━━━━━━━━━━━━━━━\nSTEP 1. 데이터 모델 통합 (가장 우선)\n━━━━━━━━━━━━━━━\n1-1. 공용 Layer: models/\n • Flow, Plan, Task, ErrorResponse 를 모두 pydantic.dataclasses 또는 @dataclass 로 선언\n   ```python\n   @dataclass\n   class Flow:\n       id: str\n       state: FlowState = FlowState.UNKNOWN\n       meta: Dict[str, Any] = field(default_factory=dict)\n   ```\n   ‑ json/dict 양방향 변환은 model.from_dict & model.dict() 로 통일\n\n1-2. enum 정규화\n • FlowState(Enum): NEW/RUNNING/FINISHED/FAILED/CANCELLED/UNKNOWN  \n • PlanState, TaskState 도 동일 패턴\n\n1-3. Legacy ↔ New 어댑터\n • LegacyFlowAdapter 에 to_dict()/from_dict() 만 남기고 비즈니스 로직 제거  \n   (기존 호출부가 dict 에만 의존한다면 adapter.dict() 로 호환)\n\n━━━━━━━━━━━━━━━\nSTEP 2. 서비스 계층 분리\n━━━━━━━━━━━━━━━\n2-1. FlowService (pure business)\n • CRUD + 상태전이(valid_state_matrix) 만 책임  \n2-2. CommandService\n • 명령어 파싱 → Service 호출 → 응답 직렬화 담당  \n   (Router 는 그냥 명령어 → CommandService 매핑만 수행)\n\n2-3. 의존성 역전\n • FlowCommandRouter 는 FlowService 인터페이스(IFlowService) 에만 의존  \n   - 구현체는 runtime DI(Dependency Injection) 로 주입\n\n2-4. 직접 import 제거\n • handle_flow_status → 메소드 분해 + FlowService 주입\n   ```python\n   class FlowCommandRouter:\n       def __init__(self, flow_service: IFlowService):\n           self.flow_service = flow_service\n\n       def handle_flow_status(self, flow_id: str, *, detail: bool=False) -> FlowStatusDto:\n           flow = self.flow_service.get(flow_id)\n           return build_status_response(flow, detail)\n   ```\n   ↳ test 에서는 FakeFlowService 로 대체 가능\n\n━━━━━━━━━━━━━━━\nSTEP 3. 명령 라우팅 개선\n━━━━━━━━━━━━━━━\n3-1. Command 패턴\n • 각 명령은 class-based handler (execute) 로 축약\n   ```python\n   class FlowStatusCmd(Command):\n       name = "flow status"\n       schema = FlowStatusArgs\n       def execute(self, args, services) -> Any:\n           return services.flow.get_status(args.flow_id)\n   ```\n\n3-2. Router 테이블화\n • Dict[CommandName, CommandHandler] + 자동 등록  \n   → handle_flow_status 538줄 → 10줄 로 대체\n\n3-3. workflow_wrapper 경량화\n • “Manager 가 route 구현 여부”를 검사하지 않고  \n   ‑ 단일 interface ICommandRouter 로 캐스팅  \n   ―—————————————————\n   def wf(cmd: str, verbose: bool=False):\n       return container.command_router.route(cmd, verbose=verbose)\n   ―—————————————————\n • Manager 교체 = IoC 컨테이너 구성 변경\n\n━━━━━━━━━━━━━━━\nSTEP 4. 중복 제거 & 유틸리티화\n━━━━━━━━━━━━━━━\n4-1. 공통 오류 처리\n • exception_handler(func) 데코레이터\n   ```python\n   @exception_handler\n   def handle(...):\n       ...\n   ```\n   → 중복 try/except 22곳 제거\n\n4-2. 타입 판별 제거\n • dict/object 혼재 없애면 isinstance 체크 모두 삭제 가능  \n   (불가피한 경우 Protocol/ABC 로 duck-typing)\n\n━━━━━━━━━━━━━━━\nSTEP 5. 모듈 재배치 & 패키징\n━━━━━━━━━━━━━━━\npackages/\n   models/\n   services/\n   routers/\n   adapters/\n   cli/ (workflow_wrapper.py)\n   tests/\n\n보통 2~3 PR 로 나눠 머지:\n  PR-1: models + enum + adapter + 테스트\n  PR-2: 서비스 계층 + Router 재작성 + wrapper 단순화\n  PR-3: 기존 코드 삭제/정리 + 문서화\n\n────────────────────────────────────────\n5. 상세 구현 가이드 (핵심 코드 예시)\n────────────────────────────────────────\nA. 모델 통합 예시\n```python\n# models/flow.py\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom enum import Enum, auto\nfrom typing import Dict, Any\n\nclass FlowState(Enum):\n    NEW = auto()\n    RUNNING = auto()\n    FINISHED = auto()\n    FAILED = auto()\n    CANCELLED = auto()\n    UNKNOWN = auto()\n\n@dataclass\nclass Flow:\n    id: str\n    state: FlowState\n    meta: Dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> "Flow":\n        return cls(\n            id=data["id"],\n            state=FlowState[data.get("state", "UNKNOWN").upper()],\n            meta=data.get("meta", {})\n        )\n\n    def dict(self) -> Dict[str, Any]:\n        return {\n            "id": self.id,\n            "state": self.state.name.lower(),\n            "meta": self.meta,\n        }\n```\n\nB. CommandRouter (축약)\n```python\nclass CommandRouter:\n    def __init__(self, handlers: Iterable[Command]):\n        self._map = {h.name: h for h in handlers}\n\n    @exception_handler\n    def route(self, raw: str, *, verbose=False):\n        cmd_name, *argv = shlex.split(raw)\n        handler = self._map.get(cmd_name)\n        if not handler:\n            raise UnknownCommandError(cmd_name)\n        args = handler.schema.parse(argv)  # pydantic cli parser\n        return handler.execute(args=args, services=container)\n```\n\nC. 에러 핸들러\n```python\ndef exception_handler(func):\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except DomainError as e:\n            logger.warning("domain error", exc_info=e)\n            return ErrorResponse.from_exception(e).dict()\n        except Exception as e:\n            logger.exception("unexpected")\n            return ErrorResponse("internal_error", str(e)).dict()\n    return wrapper\n```\n\nD. handle_flow_status 축소\n(538줄 → 40줄; 세부 로직은 FlowService 로 이동)\n\n────────────────────────────────────────\n6. 예상 위험 요소 & 대응\n────────────────────────────────────────\n• API/Binary 호환 깨짐  \n  ‑ LegacyFlowAdapter 유지, wf 에 “deprecated path” 일단 지원\n\n• 테스트 부족으로 회귀 버그  \n  ‑ Step 0 에서 현행 스냅샷 확보 → diff 통과 확인 후 점진적 삭제\n\n• 조직 내부 “직접 FlowManager 사용” 코드 외부 모듈에 존재  \n  ‑ deprecate decorator + 경고 로그 → 서서히 마이그레이션\n\n• 성능: dataclass 변환 오버헤드  \n  ‑ 모델 객체 수 10^4 이상일 경우 slot dataclass 또는 pydantic v2 에서 compiled mode 사용\n\n────────────────────────────────────────\n7. 마이그레이션 일정(예시)\n────────────────────────────────────────\nWeek 1 : 테스트 격자 + 모델 정규화 설계  \nWeek 2 : PR-1 (models), 팀 리뷰 & 머지  \nWeek 3 : PR-2 (services, router), 기존 루트 코드 동작 확인  \nWeek 4 : PR-3 (cleanup, 문서, deprecation 경로)  \nWeek 5 : 삭제 대상 코드 freeze → 릴리스 태그  \nWeek 6 : 후속 최적화 / 타입 힌팅 100 %\n\n────────────────────────────────────────\n8. 기대 효과\n────────────────────────────────────────\n• 사이클로매틱 복잡도 ‑75 % (God Method 제거)  \n• 신규 명령 추가 시 코드 변경량 1 파일 < 30라인 (OCP 달성)  \n• dict/object 혼재 제거 → mypy/Pyright 통과율 90 % ↑  \n• 에러 핸들링 중복 22→1 로 축소  \n• 순환 참조 제거 → import 시간·패키징 문제 해결  \n• 전체 코드 59 KB → ~35 KB 로 감소 예상\n\n────────────────────────────────────────\n요약\n1) 데이터 모델부터 통일하고, 2) 서비스 계층을 분리하여 God Method 해체,  \n3) Command 패턴 + DI 로 라우팅/확장성 문제 해결,  \n4) 중복 에러 처리와 직접 import 제거로 안정성과 유지보수성을 동시에 높입니다.', 'reasoning_effort': 'high', 'usage': {'prompt_tokens': 779, 'completion_tokens': 3204, 'total_tokens': 3983, 'reasoning_tokens': 0}}

## 추가 분석 데이터

### 복잡도 메트릭
- FlowCommandRouter: 복잡도 점수 130 (가장 높음)
- LegacyFlowAdapter: 복잡도 점수 85
- FlowManager: 복잡도 점수 59
- workflow_wrapper: 복잡도 점수 9
- FlowManagerUnified: 복잡도 점수 3

### 의존성 구조
```
workflow_wrapper
  → FlowManager
  → FlowManagerUnified
  → LegacyFlowAdapter
  → FlowCommandRouter

FlowManagerUnified
  → FlowManager
  → LegacyFlowAdapter

LegacyFlowAdapter
  → FlowManager
```

### 주요 문제점
1. FlowCommandRouter의 handle_flow_status: 538줄
2. LegacyFlowAdapter의 restore_flow: 81줄
3. 데이터 구조 일관성 부재 (dict vs object)
4. 에러 처리 패턴 22회 중복
