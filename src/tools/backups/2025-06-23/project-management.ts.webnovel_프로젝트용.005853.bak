/**
 * 프로젝트 관리 도구
 * webnovel-mcp v2.0
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import { z } from 'zod';
import { logger } from '../services/logger';
import { 
  ListProjectsParams, 
  ListProjectsResponse,
  CreateProjectParams,
  CreateProjectResponse,
  SwitchProjectParams,
  SwitchProjectResponse,
  ArchiveProjectParams,
  ExportProjectParams,
  ProjectStatus
} from '../types/tool-interfaces';

// 프로젝트 루트 경로
const DATA_DIR = path.join(process.cwd(), 'data');
const PROJECTS_FILE = path.join(DATA_DIR, 'projects.json');
const PROJECTS_DIR = path.join(DATA_DIR, 'projects');

// 입력 검증 스키마
const ListProjectsSchema = z.object({
  filter: z.object({
    status: z.enum(['active', 'paused', 'completed', 'archived']).optional(),
    genre: z.string().optional(),
    tags: z.array(z.string()).optional()
  }).optional(),
  sort: z.enum(['created', 'modified', 'title']).optional(),
  limit: z.number().min(1).max(100).optional()
});

const CreateProjectSchema = z.object({
  title: z.string().min(1).max(200),
  genre: z.string().min(1),
  summary: z.string().optional(),
  targetLength: z.number().positive().optional(),
  tags: z.array(z.string()).optional(),
  preferences: z.object({
    writing_style: z.string().optional(),
    pov: z.enum(['first', 'third_limited', 'third_omniscient']).optional(),
    tense: z.enum(['past', 'present']).optional(),
    chapter_length: z.number().positive().optional()
  }).optional(),
  template: z.string().optional()
});

/**
 * 프로젝트 레지스트리 초기화
 */
async function ensureProjectsRegistry() {
  try {
    await fs.access(PROJECTS_FILE);
  } catch {
    // projects.json이 없으면 생성
    const initialRegistry = {
      version: "2.0.0",
      lastUpdated: new Date().toISOString(),
      currentProject: null,
      projects: [],
      templates: {
        character: [],
        worldbuilding: [],
        plot: []
      },
      settings: {
        default_model: "gemini-2.5-pro",
        auto_backup: true,
        consistency_check: "moderate"
      }
    };
    
    await fs.mkdir(DATA_DIR, { recursive: true });
    await fs.mkdir(PROJECTS_DIR, { recursive: true });
    await fs.writeFile(PROJECTS_FILE, JSON.stringify(initialRegistry, null, 2));
    logger.info('프로젝트 레지스트리 초기화 완료');
  }
}

/**
 * 프로젝트 레지스트리 읽기
 */
async function readProjectsRegistry() {
  await ensureProjectsRegistry();
  const content = await fs.readFile(PROJECTS_FILE, 'utf-8');
  return JSON.parse(content);
}

/**
 * 프로젝트 레지스트리 저장
 */
async function saveProjectsRegistry(registry: any) {
  registry.lastUpdated = new Date().toISOString();
  await fs.writeFile(PROJECTS_FILE, JSON.stringify(registry, null, 2));
}

/**
 * 1. 프로젝트 목록 조회
 */
export async function listProjects(params: ListProjectsParams): Promise<ListProjectsResponse> {
  try {
    // 입력 검증
    const validated = ListProjectsSchema.parse(params);
    
    const registry = await readProjectsRegistry();
    let projects = registry.projects;
    
    // 필터링
    if (validated.filter) {
      if (validated.filter.status) {
        projects = projects.filter((p: any) => p.status === validated.filter!.status);
      }
      if (validated.filter.genre) {
        projects = projects.filter((p: any) => p.genre === validated.filter!.genre);
      }
      if (validated.filter.tags && validated.filter.tags.length > 0) {
        projects = projects.filter((p: any) => 
          validated.filter!.tags!.some(tag => p.tags.includes(tag))
        );
      }
    }
    
    // 정렬
    if (validated.sort) {
      projects.sort((a: any, b: any) => {
        switch (validated.sort) {
          case 'created':
            return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
          case 'modified':
            return new Date(b.last_modified).getTime() - new Date(a.last_modified).getTime();
          case 'title':
            return a.title.localeCompare(b.title);
          default:
            return 0;
        }
      });
    }
    
    // 제한
    if (validated.limit) {
      projects = projects.slice(0, validated.limit);
    }
    
    // 완료율 계산
    const projectSummaries = projects.map((p: any) => ({
      id: p.id,
      title: p.title,
      status: p.status,
      genre: p.genre,
      currentChapter: p.current_chapter,
      lastModified: p.last_modified,
      completionRate: p.target_length > 0 
        ? Math.round((p.current_chapter / p.target_length) * 100) 
        : 0
    }));
    
    return {
      projects: projectSummaries,
      total: registry.projects.length,
      currentProjectId: registry.currentProject
    };
    
  } catch (error) {
    logger.error('프로젝트 목록 조회 실패:', error);
    throw error;
  }
}

/**
 * 2. 새 프로젝트 생성
 */
export async function createProject(params: CreateProjectParams): Promise<CreateProjectResponse> {
  try {
    // 입력 검증
    const validated = CreateProjectSchema.parse(params);
    
    const registry = await readProjectsRegistry();
    const projectId = `novel_${uuidv4().slice(0, 8)}`;
    const projectDir = path.join(PROJECTS_DIR, projectId);
    
    // 프로젝트 디렉토리 생성
    await fs.mkdir(projectDir, { recursive: true });
    await fs.mkdir(path.join(projectDir, 'chapters'), { recursive: true });
    
    // 프로젝트 레지스트리에 추가
    const newProject = {
      id: projectId,
      title: validated.title,
      status: 'active' as ProjectStatus,
      created_at: new Date().toISOString(),
      last_modified: new Date().toISOString(),
      genre: validated.genre,
      target_length: validated.targetLength || 100,
      current_chapter: 0,
      tags: validated.tags || [],
      summary: validated.summary || '',
      preferences: validated.preferences || {}
    };
    
    registry.projects.push(newProject);
    registry.currentProject = projectId;
    
    // 기본 파일들 생성
    await createProjectFiles(projectId, validated);
    
    // 레지스트리 저장
    await saveProjectsRegistry(registry);
    
    logger.info(`프로젝트 생성 완료: ${projectId} - ${validated.title}`);
    
    return {
      projectId: projectId,
      status: 'success',
      message: `프로젝트 '${validated.title}'가 성공적으로 생성되었습니다.`,
      projectPath: projectDir
    };
    
  } catch (error) {
    logger.error('프로젝트 생성 실패:', error);
    return {
      projectId: '',
      status: 'error',
      message: error instanceof Error ? error.message : '프로젝트 생성 실패',
      projectPath: ''
    };
  }
}

/**
 * 프로젝트 기본 파일 생성
 */
async function createProjectFiles(projectId: string, params: CreateProjectParams) {
  const projectDir = path.join(PROJECTS_DIR, projectId);
  
  // metadata.json
  const metadata = {
    project_id: projectId,
    title: params.title,
    author: "작가명",
    created_at: new Date().toISOString(),
    version: "1.0.0",
    synopsis: params.summary || "",
    target_audience: "일반"
  };
  await fs.writeFile(
    path.join(projectDir, 'metadata.json'),
    JSON.stringify(metadata, null, 2)
  );
  
  // worldbuilding.json
  const worldbuilding = {
    world_name: "",
    time_period: "",
    geography: {},
    magic_system: {},
    technology_level: "",
    cultures: [],
    history: []
  };
  await fs.writeFile(
    path.join(projectDir, 'worldbuilding.json'),
    JSON.stringify(worldbuilding, null, 2)
  );
  
  // characters.json
  const characters = {
    main_characters: [],
    supporting_characters: [],
    antagonists: [],
    character_relationships: [],
    character_arcs: []
  };
  await fs.writeFile(
    path.join(projectDir, 'characters.json'),
    JSON.stringify(characters, null, 2)
  );
  
  // plot.json
  const plot = {
    three_act_structure: {
      act1: { description: "", chapters: [] },
      act2: { description: "", chapters: [] },
      act3: { description: "", chapters: [] }
    },
    plot_points: [],
    subplots: [],
    themes: [],
    conflicts: []
  };
  await fs.writeFile(
    path.join(projectDir, 'plot.json'),
    JSON.stringify(plot, null, 2)
  );
  
  // chapters/outline.json
  const outline = {
    total_chapters: params.targetLength || 100,
    chapters: []
  };
  await fs.writeFile(
    path.join(projectDir, 'chapters', 'outline.json'),
    JSON.stringify(outline, null, 2)
  );
  
  // consistency.log
  await fs.writeFile(
    path.join(projectDir, 'consistency.log'),
    `일관성 검사 로그\n생성일: ${new Date().toISOString()}\n\n`
  );
}

/**
 * 3. 프로젝트 전환
 */
export async function switchProject(params: SwitchProjectParams): Promise<SwitchProjectResponse> {
  try {
    const registry = await readProjectsRegistry();
    const project = registry.projects.find((p: any) => p.id === params.projectId);
    
    if (!project) {
      throw new Error(`프로젝트를 찾을 수 없습니다: ${params.projectId}`);
    }
    
    const previousProjectId = registry.currentProject;
    registry.currentProject = params.projectId;
    
    // 현재 상태 저장이 요청된 경우
    if (params.saveCurrentState && previousProjectId) {
      // TODO: 현재 프로젝트 상태 저장 로직
      logger.info(`이전 프로젝트 상태 저장: ${previousProjectId}`);
    }
    
    await saveProjectsRegistry(registry);
    
    // 프로젝트 컨텍스트 로드
    const context = await loadProjectContext(params.projectId);
    
    logger.info(`프로젝트 전환 완료: ${previousProjectId} → ${params.projectId}`);
    
    return {
      success: true,
      previousProjectId: previousProjectId,
      context: context
    };
    
  } catch (error) {
    logger.error('프로젝트 전환 실패:', error);
    throw error;
  }
}

/**
 * 4. 프로젝트 보관
 */
export async function archiveProject(params: ArchiveProjectParams): Promise<{ success: boolean; message: string }> {
  try {
    const registry = await readProjectsRegistry();
    const projectIndex = registry.projects.findIndex((p: any) => p.id === params.projectId);
    
    if (projectIndex === -1) {
      throw new Error(`프로젝트를 찾을 수 없습니다: ${params.projectId}`);
    }
    
    // 백업 생성
    if (params.createBackup) {
      // TODO: 백업 로직 구현
      logger.info(`프로젝트 백업 생성: ${params.projectId}`);
    }
    
    // 프로젝트 상태 변경
    registry.projects[projectIndex].status = 'archived';
    registry.projects[projectIndex].last_modified = new Date().toISOString();
    
    if (params.reason) {
      registry.projects[projectIndex].archive_reason = params.reason;
    }
    
    // 현재 프로젝트인 경우 해제
    if (registry.currentProject === params.projectId) {
      registry.currentProject = null;
    }
    
    await saveProjectsRegistry(registry);
    
    logger.info(`프로젝트 보관 완료: ${params.projectId}`);
    
    return {
      success: true,
      message: `프로젝트가 성공적으로 보관되었습니다.`
    };
    
  } catch (error) {
    logger.error('프로젝트 보관 실패:', error);
    throw error;
  }
}

/**
 * 5. 프로젝트 내보내기
 */
export async function exportProject(params: ExportProjectParams): Promise<{ success: boolean; exportPath: string }> {
  try {
    // TODO: 프로젝트 내보내기 구현
    // ZIP, Markdown, JSON 형식 지원
    
    const exportPath = path.join(process.cwd(), 'exports', `${params.projectId}.${params.format}`);
    
    logger.info(`프로젝트 내보내기: ${params.projectId} → ${params.format}`);
    
    return {
      success: true,
      exportPath: exportPath
    };
    
  } catch (error) {
    logger.error('프로젝트 내보내기 실패:', error);
    throw error;
  }
}

/**
 * 프로젝트 컨텍스트 로드 (헬퍼 함수)
 */
async function loadProjectContext(projectId: string): Promise<any> {
  const projectDir = path.join(PROJECTS_DIR, projectId);
  
  // 기본 컨텍스트 구조
  const context = {
    projectId: projectId,
    metadata: {},
    worldbuilding: {},
    characters: [],
    plot: {},
    currentChapter: 0,
    recentEvents: []
  };
  
  try {
    // 각 파일 로드
    context.metadata = JSON.parse(
      await fs.readFile(path.join(projectDir, 'metadata.json'), 'utf-8')
    );
    
    // 추가 파일들도 로드...
    
  } catch (error) {
    logger.warn(`프로젝트 컨텍스트 일부 로드 실패: ${projectId}`, error);
  }
  
  return context;
}
