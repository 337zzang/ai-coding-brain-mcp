#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸš€ JSON REPL Session for AI Coding Brain v4.0
==============================================

Claude Desktopê³¼ í†µì‹ í•˜ëŠ” JSON REPL ì„¸ì…˜ ê´€ë¦¬ì
- ê°œì„ ëœ Bootstrap ì‹œìŠ¤í…œ v3.0 (UnifiedContextManager í†µí•©)
- í†µí•©ëœ Helper ë³´í˜¸ ì‹œìŠ¤í…œ v10.0
- AI Coding Brain v3.0 ì™„ë²½ í†µí•©
- ì‹±ê¸€í†¤ íŒ¨í„´ ë° íƒ€ì… ì•ˆì •ì„± ê°•í™”

ì‘ì„±ì: Claude + ì‚¬ìš©ì í˜‘ì—…
ìˆ˜ì •ì¼: 2025-06-13 (v4.0 - êµ¬ì¡° ê°œì„ )
"""

import sys
import os
import json
import io
import traceback
import time
import threading
import datetime as dt
import importlib
import platform
import subprocess
from pathlib import Path
from typing import Dict, Optional, Tuple, List, Any, Union, Callable
from contextlib import redirect_stdout, redirect_stderr
import logging

# ============================================================================
# ğŸ”§ ê¸°ë³¸ ì„¤ì • ë° ê²½ë¡œ ì´ˆê¸°í™”
# ============================================================================

# ì „ì—­ ê²½ë¡œ ì„¤ì •
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

# ============================================================================
# ğŸ” ë¡œê¹… ì‹œìŠ¤í…œ
# ============================================================================

class Logger:
    """ë ˆë²¨ë³„ ë¡œê¹… ì‹œìŠ¤í…œ"""

    LEVELS = {
        'DEBUG': 0,
        'INFO': 1,
        'WARNING': 2,
        'ERROR': 3
    }

    def __init__(self, level='INFO'):
        self.level = self.LEVELS.get(level, 1)

    def log(self, message: str, level: str = 'INFO'):
        if self.LEVELS.get(level, 1) >= self.level:
            timestamp = time.strftime("%H:%M:%S")
            print(f"[{level} {timestamp}] {message}", file=sys.stderr, flush=True)

    def debug(self, message: str):
        self.log(message, 'DEBUG')

    def info(self, message: str):
        self.log(message, 'INFO')

    def warning(self, message: str):
        self.log(message, 'WARNING')

    def error(self, message: str):
        self.log(message, 'ERROR')

# ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
logger = Logger(level='INFO')

# ============================================================================
# ğŸ”Œ ì„ íƒì  ëª¨ë“ˆ ì„í¬íŠ¸
# ============================================================================

# Smart Print Utils
try:
    from smart_print import smart_print, enhanced_smart_print, sp, esp, compress_content
    SMART_PRINT_AVAILABLE = True
    logger.info("Smart Print Utils ì—°ë™ ì„±ê³µ")
except ImportError:
    SMART_PRINT_AVAILABLE = False
    # Fallback í•¨ìˆ˜ë“¤
    def smart_print(content, **kwargs): return str(content)
    def enhanced_smart_print(content, **kwargs): return str(content)
    def sp(content, **kwargs): return str(content)
    def esp(content, **kwargs): return str(content)
    def compress_content(content, **kwargs):
        return str(content)[:15000] + "..." if len(str(content)) > 15000 else str(content)
    logger.info("Smart Print Utils ì—†ìŒ - fallback ì‚¬ìš©")

# ============================================================================
# ğŸ”Œ í•µì‹¬ ëª¨ë“ˆ ì„í¬íŠ¸ (ê°œì„ ëœ êµ¬ì¡°)
# ============================================================================

# Context Manager v3.0
try:
    from context_manager import (
        initialize_context,
        save_context,
        update_cache,
        get_value,
        find_symbol,
        track_file_access,
        track_function_edit,
        get_work_tracking_summary,
        build_index,
        propose_next_steps
    )
    CONTEXT_MANAGER_AVAILABLE = True
    logger.info("âœ… Context Manager v3.0 ë¡œë“œ ì„±ê³µ")
except ImportError as e:
    CONTEXT_MANAGER_AVAILABLE = False
    logger.error(f"âŒ Context Manager ë¡œë“œ ì‹¤íŒ¨: {e}")

# Vibe Memory System
try:
    from vibe_memory_system import VibeMemoryManager, get_vibe_commands
    VIBE_MEMORY_AVAILABLE = True
    logger.info("âœ… Vibe Memory System ë¡œë“œ ì„±ê³µ")
except ImportError as e:
    VIBE_MEMORY_AVAILABLE = False
    logger.warning(f"âš ï¸ Vibe Memory System ë¡œë“œ ì‹¤íŒ¨: {e}")

# AI Coding Brain v3.0
try:
    import claude_code_ai_brain as ai_brain
    AI_BRAIN_AVAILABLE = True
    logger.info("âœ… AI Coding Brain v3.0 ë¡œë“œ ì„±ê³µ")
except ImportError as e:
    AI_BRAIN_AVAILABLE = False
    logger.warning(f"âš ï¸ AI Coding Brain ë¡œë“œ ì‹¤íŒ¨: {e}")

# ============================================================================
# ğŸŒ ì „ì—­ ë³€ìˆ˜ ë° ìƒíƒœ (ì‹±ê¸€í†¤ íŒ¨í„´)
# ============================================================================

class GlobalReplState:
    """REPL ì„¸ì…˜ ì „ì—­ ìƒíƒœ ê´€ë¦¬ (ì‹±ê¸€í†¤) - REPL ì „ìš©"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialized = False
        return cls._instance
    
    def __init__(self):
        if not self.initialized:
            # REPL ê´€ë ¨ ìƒíƒœë§Œ ê´€ë¦¬
            self.repl_globals: Dict[str, Any] = {}
            self.session_id: str = f"session_{int(time.time())}"
            self.variable_count: int = 0
            self.execution_count: int = 0
            self.last_result: Any = None
            
            # AI Brain ëª¨ë“ˆ ì°¸ì¡° (lazy loading)
            self.ai_brain = None
            self.initialized = True
    
    @property
    def project_context(self):
        """AI Brainì˜ contextë¥¼ í”„ë¡ì‹œë¡œ ì ‘ê·¼"""
        if self.ai_brain and hasattr(self.ai_brain, '_global_state'):
            state = self.ai_brain._global_state
            if state and hasattr(state, 'context'):
                return state.context
        return None
    
    @property
    def project_root(self):
        """AI Brainì˜ project_pathë¥¼ í”„ë¡ì‹œë¡œ ì ‘ê·¼"""
        if self.ai_brain and hasattr(self.ai_brain, '_global_state'):
            state = self.ai_brain._global_state
            if state and hasattr(state, 'project_path') and state.project_path:
                return Path(state.project_path)
        return None

repl_state = GlobalReplState()

# ============================================================================
# ğŸš€ Bootstrap ì‹œìŠ¤í…œ v3.0 (UnifiedContextManager í†µí•©)
# ============================================================================

class BootstrapSystem:
    """í†µí•©ëœ Bootstrap ì‹œìŠ¤í…œ v3.0"""

    def __init__(self):
        self.logger = logger
        self.state = repl_state

    def find_project_root(self) -> Optional[Path]:
        """í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ ì°¾ëŠ” í†µí•© ë¡œì§"""
        strategies = []

        # 1. í™˜ê²½ ë³€ìˆ˜
        if os.environ.get('AI_BRAIN_ROOT'):
            strategies.append(('ENV_VAR', Path(os.environ['AI_BRAIN_ROOT'])))

        # 2. í˜„ì¬ íŒŒì¼ ê¸°ì¤€ íƒìƒ‰
        current_file = Path(__file__).resolve()
        for parent in current_file.parents:
            markers = ['.ai-brain-project', 'project_cache.json', 'roadmap.md', '.git', '.cache']
            if any((parent / marker).exists() for marker in markers):
                strategies.append(('MARKER_FILE', parent))
                break

        # 3. í”„ë¡œì íŠ¸ ì´ë¦„ ê¸°ë°˜
        for parent in current_file.parents:
            if 'ai-coding-brain' in parent.name.lower():
                strategies.append(('PROJECT_NAME', parent))
                break

        # ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì „ëµ ì„ íƒ
        for strategy_name, path in strategies:
            if path.exists():
                self.logger.info(f"í”„ë¡œì íŠ¸ ë£¨íŠ¸ ë°œê²¬ ({strategy_name}): {path}")
                return path

        return None

    def find_memory_bank(self, project_name: str = None) -> Optional[Tuple[Path, Path]]:
        """ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ ì°¾ê¸°"""
        memory_bank_root = None

        # Claude Desktop ì„¤ì • í™•ì¸
        config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                
                # mcpServers ì„¹ì…˜ì—ì„œ ë©”ëª¨ë¦¬ ë±…í¬ ê²½ë¡œ ì°¾ê¸°
                mcp_servers = config.get('mcpServers', {})
                for server_name, server_config in mcp_servers.items():
                    if 'memory' in server_name.lower():
                        env = server_config.get('env', {})
                        if 'MEMORY_BANK_PATH' in env:
                            memory_bank_root = Path(env['MEMORY_BANK_PATH'])
                            self.logger.info(f"âœ… Claude Desktop ì„¤ì •ì—ì„œ ë©”ëª¨ë¦¬ ë£¨íŠ¸ ë¡œë“œ: {memory_bank_root}")
                            break
            except Exception as e:
                self.logger.error(f"Claude Desktop ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")

        # ëŒ€ì²´ ê²½ë¡œë“¤
        if not memory_bank_root or not memory_bank_root.exists():
            fallback_paths = [
                Path.home() / "Desktop" / "memory",
                Path("C:/Users/Administrator/Desktop/memory"),
                Path.home() / "memory",
                Path.home() / "Documents" / "memory"
            ]
            
            for path in fallback_paths:
                if path.exists():
                    memory_bank_root = path
                    self.logger.info(f"ëŒ€ì²´ ë©”ëª¨ë¦¬ ë±…í¬ ê²½ë¡œ ì‚¬ìš©: {memory_bank_root}")
                    break

        if memory_bank_root and project_name:
            project_path = memory_bank_root / project_name
            if project_path.exists():
                return memory_bank_root, project_path

        return memory_bank_root, None if memory_bank_root else (None, None)

    def run_bootstrap(self) -> bool:
        """Bootstrap í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰ - AI Brainì— ìœ„ì„"""
        try:
            self.logger.info("=== Bootstrap System v3.0 ì‹œì‘ ===")

            # Phase 1: AI Brain ì´ˆê¸°í™” (ëª¨ë“  í”„ë¡œì íŠ¸ ê´€ë¦¬ëŠ” ì—¬ê¸°ì„œ!)
            if AI_BRAIN_AVAILABLE:
                try:
                    # í”„ë¡œì íŠ¸ ë£¨íŠ¸ ì°¾ê¸°
                    project_root = self.find_project_root()
                    if project_root:
                        os.chdir(project_root)
                        self.logger.info(f"ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½: {project_root}")
                    
                    # AI Brainì´ ëª¨ë“  ì´ˆê¸°í™”ë¥¼ ë‹´ë‹¹
                    project_path = str(project_root) if project_root else os.getcwd()
                    project_name = os.path.basename(project_path)
                    
                    # AI Brainì€ ì´ë¯¸ auto_initialize()ë¥¼ í†µí•´ ì´ˆê¸°í™”ë¨
                    # ì—¬ê¸°ì„œëŠ” REPL stateì— ì°¸ì¡°ë§Œ ì €ì¥
                    import claude_code_ai_brain as ai_brain
                    self.state.ai_brain = ai_brain
                    
                    self.logger.info("âœ… AI Coding Brain ì°¸ì¡° ì—°ê²° ì™„ë£Œ")
                    
                except Exception as e:
                    self.logger.warning(f"AI Brain ì—°ê²° ì¤‘ ê²½ê³ : {e}")

            # Phase 2: Helper í•¨ìˆ˜ ë“±ë¡
            self._register_helpers()

            self.logger.info("=== Bootstrap ì™„ë£Œ ===")
            return True

        except Exception as e:
            self.logger.error(f"Bootstrap ì‹¤íŒ¨: {e}")
            traceback.print_exc(file=sys.stderr)
            return False

    def _register_helpers(self):
        """í—¬í¼ í•¨ìˆ˜ë“¤ì„ ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì— ë“±ë¡"""
        helpers = {}

        # Auto-Tracking Wrapperì—ì„œ ëª¨ë“  í—¬í¼ í•¨ìˆ˜ ì„í¬íŠ¸
        # ì´ì œ ëª¨ë“  ì‘ì—…ì´ ìë™ìœ¼ë¡œ ì¶”ì ë©ë‹ˆë‹¤!
        try:
            from auto_tracking_wrapper import (
                # íŒŒì¼ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
                create_file, read_file, backup_file, restore_backup,
                replace_block, insert_block,
                
                # AST ë¶„ì„ í•¨ìˆ˜ë“¤
                parse_with_snippets, get_snippet_preview,
                
                # Context Manager í•¨ìˆ˜ë“¤ (ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ìš°)
                initialize_context, save_context, update_cache,
                get_work_tracking_summary,
                
                # ê²€ìƒ‰ ê´€ë ¨ í•¨ìˆ˜ë“¤
                scan_directory, search_files_advanced, search_code_content,
                integrated_search, search_by_date, search_by_file
            )
            
            # ê¸°ë³¸ í—¬í¼ë“¤
            helpers.update({
                'create_file': create_file,
                'read_file': read_file,
                'backup_file': backup_file,
                'restore_backup': restore_backup,
                'replace_block': replace_block,
                'insert_block': insert_block,
                'parse_with_snippets': parse_with_snippets,
                'get_snippet_preview': get_snippet_preview
            })
            
            # Context Manager í•¨ìˆ˜ë“¤
            if CONTEXT_MANAGER_AVAILABLE:
                helpers.update({
                    'initialize_context': initialize_context,
                    'save_context': save_context,
                    'update_cache': update_cache,
                    'get_work_tracking_summary': get_work_tracking_summary
                })
                
                # ì¶”ê°€ Context Manager í•¨ìˆ˜ë“¤ (ì§ì ‘ ì„í¬íŠ¸)
                from context_manager import (
                    get_value, find_symbol,
                    track_file_access, track_function_edit,
                    propose_next_steps
                )
                helpers.update({
                    'get_value': get_value,
                    'find_symbol': find_symbol,
                    'track_file_access': track_file_access,
                    'track_function_edit': track_function_edit,
                    'propose_next_steps': propose_next_steps
                })
            
            # ê²€ìƒ‰ ê´€ë ¨ í•¨ìˆ˜ë“¤
            helpers.update({
                'scan_directory': scan_directory,
                'search_files_advanced': search_files_advanced,
                'search_code_content': search_code_content,
                'integrated_search': integrated_search,
                'search_by_date': search_by_date,
                'search_by_file': search_by_file
            })
            
            self.logger.info("âœ… Auto-Tracking Wrapperë¥¼ í†µí•œ í—¬í¼ í•¨ìˆ˜ ë¡œë“œ ì„±ê³µ")
            
        except ImportError as e:
            self.logger.error(f"Auto-Tracking Wrapper ë¡œë“œ ì‹¤íŒ¨: {e}")
            self.logger.warning("ì›ë³¸ í—¬í¼ í•¨ìˆ˜ë“¤ì„ ì§ì ‘ ë¡œë“œí•©ë‹ˆë‹¤ (ì¶”ì  ì—†ìŒ)")
            
            # Fallback: ì›ë³¸ í•¨ìˆ˜ë“¤ ì§ì ‘ ì„í¬íŠ¸
          

     
        # ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì— ì¶”ê°€
        repl_state.repl_globals.update(helpers)
        self.logger.info(f"âœ… {len(helpers)}ê°œì˜ í—¬í¼ í•¨ìˆ˜ ë“±ë¡ ì™„ë£Œ")

# ============================================================================
# ğŸ’¾ ì„¸ì…˜ ê´€ë¦¬ì
# ============================================================================

class SessionManager:
    """REPL ì„¸ì…˜ ìƒíƒœ ê´€ë¦¬"""

    def __init__(self):
        self.state = repl_state
        self.logger = logger
        self.sessions_dir = Path(".sessions")
        self.sessions_dir.mkdir(exist_ok=True)

    def save_session(self, session_name: str = None) -> bool:
        """ì„¸ì…˜ ìƒíƒœ ì €ì¥"""
        if not session_name:
            session_name = f"session_{self.state.session_id}.json"
        
        session_path = self.sessions_dir / session_name
        
        try:
            session_data = {
                'session_id': self.state.session_id,
                'timestamp': dt.datetime.now().isoformat(),
                'variable_count': self.state.variable_count,
                'execution_count': self.state.execution_count,
                'project_root': str(self.state.project_root) if self.state.project_root else None,
                'context': self.state.project_context
            }
            
            with open(session_path, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"ì„¸ì…˜ ì €ì¥: {session_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"ì„¸ì…˜ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False

    def load_session(self, session_name: str) -> bool:
        """ì„¸ì…˜ ìƒíƒœ ë¡œë“œ"""
        session_path = self.sessions_dir / session_name
        
        if not session_path.exists():
            self.logger.error(f"ì„¸ì…˜ íŒŒì¼ ì—†ìŒ: {session_path}")
            return False
        
        try:
            with open(session_path, 'r', encoding='utf-8') as f:
                session_data = json.load(f)
            
            # ìƒíƒœ ë³µì›
            self.state.session_id = session_data.get('session_id', self.state.session_id)
            self.state.variable_count = session_data.get('variable_count', 0)
            self.state.execution_count = session_data.get('execution_count', 0)
            
            if session_data.get('project_root'):
                self.state.project_root = Path(session_data['project_root'])
            
            if session_data.get('context'):
                self.state.project_context = session_data['context']
            
            self.logger.info(f"ì„¸ì…˜ ë¡œë“œ: {session_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"ì„¸ì…˜ ë¡œë“œ ì‹¤íŒ¨: {e}")
            return False

    def get_last_session_info(self) -> Optional[Dict[str, Any]]:
        """ë§ˆì§€ë§‰ ì„¸ì…˜ ì •ë³´ ì¡°íšŒ"""
        try:
            info_file = Path(".last_session_info.json")
            if info_file.exists():
                with open(info_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception:
            pass
        return None

    def save_last_session_info(self):
        """ë§ˆì§€ë§‰ ì„¸ì…˜ ì •ë³´ ì €ì¥"""
        try:
            info_file = Path(".last_session_info.json")
            info = {
                'session_id': self.state.session_id,
                'timestamp': dt.datetime.now().isoformat(),
                'project_root': str(self.state.project_root) if self.state.project_root else None
            }
            with open(info_file, 'w', encoding='utf-8') as f:
                json.dump(info, f, indent=2)
        except Exception as e:
            self.logger.error(f"ì„¸ì…˜ ì •ë³´ ì €ì¥ ì‹¤íŒ¨: {e}")

# ============================================================================
# ğŸ›¡ï¸ Helper í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ v10.0
# ============================================================================

class HelperProtectionSystem:
    """í—¬í¼ í•¨ìˆ˜ ë³´í˜¸ ë° ì¶”ì  ì‹œìŠ¤í…œ"""

    def __init__(self):
        self.protected_functions = set()
        self.function_categories = {
            'CORE': set(),
            'FILE': set(),
            'AST': set(),
            'SEARCH': set()
        }
        self.logger = logger

    def protect_helpers(self, repl_globals: Dict[str, Any]):
        """í—¬í¼ í•¨ìˆ˜ë“¤ì„ ë³´í˜¸"""
        # ì¹´í…Œê³ ë¦¬ë³„ í•¨ìˆ˜ ì •ì˜
        categories = {
            'CORE': [
                'initialize_context', 'save_context', 'update_cache',
                'get_value', 'find_symbol', 'track_file_access',
                'track_function_edit', 'get_work_tracking_summary',
                'propose_next_steps'
            ],
            'FILE': [
                'create_file', 'read_file', 'backup_file', 'restore_backup'
            ],
            'AST': [
                'parse_with_snippets', 'replace_block', 'insert_block', 
                'get_snippet_preview'
            ],
            'SEARCH': [
                'integrated_search', 'scan_directory', 'search_files_advanced',
                'search_code_content', 'search_by_date', 'search_by_file'
            ]
        }

        # í•¨ìˆ˜ ë³´í˜¸
        for category, func_names in categories.items():
            for func_name in func_names:
                if func_name in repl_globals and callable(repl_globals[func_name]):
                    self.protected_functions.add(func_name)
                    self.function_categories[category].add(func_name)

        self.logger.info(f"âœ… {len(self.protected_functions)}ê°œì˜ í—¬í¼ í•¨ìˆ˜ ë³´í˜¸ ì„¤ì •")

    def verify_functions(self, repl_globals: Dict[str, Any]) -> Dict[str, List[str]]:
        """í•¨ìˆ˜ ìƒíƒœ ê²€ì¦"""
        status = {
            'missing': [],
            'modified': [],
            'intact': []
        }

        for func_name in self.protected_functions:
            if func_name not in repl_globals:
                status['missing'].append(func_name)
            elif not callable(repl_globals[func_name]):
                status['modified'].append(func_name)
            else:
                status['intact'].append(func_name)

        return status

    def restore_if_needed(self, repl_globals: Dict[str, Any], bootstrap_system: BootstrapSystem):
        """í•„ìš”ì‹œ í—¬í¼ í•¨ìˆ˜ ë³µì›"""
        status = self.verify_functions(repl_globals)
        
        if status['missing'] or status['modified']:
            self.logger.warning(f"í—¬í¼ í•¨ìˆ˜ ë¬¸ì œ ê°ì§€ - ë³µì› ì‹œì‘")
            if status['missing']:
                self.logger.warning(f"  ëˆ„ë½: {status['missing']}")
            if status['modified']:
                self.logger.warning(f"  ë³€ê²½: {status['modified']}")
            
            # í—¬í¼ ì¬ë“±ë¡
            bootstrap_system._register_helpers()
            
            # ë³´í˜¸ ì¬ì„¤ì •
            self.protect_helpers(repl_globals)
            
            self.logger.info("âœ… í—¬í¼ í•¨ìˆ˜ ë³µì› ì™„ë£Œ")

# ============================================================================
# ğŸ’» ì½”ë“œ ì‹¤í–‰ ì‹œìŠ¤í…œ
# ============================================================================

def execute_code_block(code: str, repl_globals: Dict[str, Any]) -> Dict[str, Any]:
    """ì½”ë“œ ë¸”ë¡ ì‹¤í–‰"""
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    execution_start = time.time()

    try:
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            # ì½”ë“œ ì»´íŒŒì¼
            compiled_code = compile(code, '<string>', 'exec')
            
            # ì‹¤í–‰
            exec(compiled_code, repl_globals)
            
            # ë³€ìˆ˜ ê°œìˆ˜ ì—…ë°ì´íŠ¸
            repl_state.variable_count = len([k for k in repl_globals.keys() 
                                           if not k.startswith('_') and k not in ['__builtins__']])
            repl_state.execution_count += 1

        execution_time = time.time() - execution_start
        
        # ìë™ ì €ì¥ (Context Manager ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ìš°)
        if CONTEXT_MANAGER_AVAILABLE and repl_state.execution_count % 10 == 0:
            try:
                save_context()
                logger.debug("ìë™ ì €ì¥ ì™„ë£Œ")
            except Exception as e:
                logger.warning(f"ìë™ ì €ì¥ ì‹¤íŒ¨: {e}")

        return {
            "success": True,
            "stdout": stdout_capture.getvalue(),
            "stderr": stderr_capture.getvalue(),
            "execution_time": execution_time,
            "variable_count": repl_state.variable_count,
            "execution_count": repl_state.execution_count,
            "session_id": repl_state.session_id,
            "note": "JSON REPL Session - Variables persist between executions",
            "debug_info": {
                "repl_process_active": True,
                "repl_ready": True,
                "execution": "success"
            }
        }

    except Exception as e:
        return {
            "success": False,
            "stdout": stdout_capture.getvalue(),
            "stderr": stderr_capture.getvalue() + f"\n{type(e).__name__}: {str(e)}\n{traceback.format_exc()}",
            "execution_time": time.time() - execution_start,
            "variable_count": repl_state.variable_count,
            "execution_count": repl_state.execution_count,
            "session_id": repl_state.session_id,
            "error": str(e),
            "error_type": type(e).__name__,
            "note": "JSON REPL Session - Error occurred during execution",
            "debug_info": {
                "repl_process_active": True,
                "repl_ready": True,
                "execution": "error"
            }
        }

# ============================================================================
# ğŸ”Œ EOT í”„ë ˆì´ë° í†µì‹ 
# ============================================================================

def read_json_input() -> Optional[str]:
    """JSON ì…ë ¥ ì½ê¸° (EOT ë¬¸ìë¡œ ì¢…ë£Œ)"""
    try:
        input_data = ""
        while True:
            char = sys.stdin.read(1)
            if not char:  # EOF
                return None
            if char == '\x04':  # EOT ë¬¸ì
                break
            input_data += char
        
        return input_data.strip()
    except Exception as e:
        logger.error(f"ì…ë ¥ ì½ê¸° ì˜¤ë¥˜: {e}")
        return None

def send_json_response(response: Dict[str, Any]):
    """JSON ì‘ë‹µ ì „ì†¡ (EOT ë¬¸ìë¡œ ì¢…ë£Œ)"""
    try:
        response_json = json.dumps(response, ensure_ascii=False)
        sys.stdout.write(response_json)
        sys.stdout.write('\x04')  # EOT ë¬¸ì
        sys.stdout.flush()
    except Exception as e:
        logger.error(f"ì‘ë‹µ ì „ì†¡ ì˜¤ë¥˜: {e}")
        error_response = {
            "success": False,
            "error": f"Response encoding error: {str(e)}",
            "error_type": "ResponseError"
        }
        sys.stdout.write(json.dumps(error_response))
        sys.stdout.write('\x04')
        sys.stdout.flush()

# ============================================================================
# ğŸ”„ ë©”ì¸ ë£¨í”„
# ============================================================================

def main_loop():
    """ë©”ì¸ ì‹¤í–‰ ë£¨í”„"""
    logger.info("=== JSON REPL Session v4.0 ì‹œì‘ ===")
    
    # ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    bootstrap_system = BootstrapSystem()
    session_manager = SessionManager()
    protection_system = HelperProtectionSystem()
    
    # Bootstrap ì‹¤í–‰
    if not bootstrap_system.run_bootstrap():
        logger.error("Bootstrap ì‹¤íŒ¨ - ê¸°ë³¸ ëª¨ë“œë¡œ ì‹¤í–‰")
    
    # í—¬í¼ ë³´í˜¸ ì„¤ì •
    protection_system.protect_helpers(repl_state.repl_globals)
    
    # ê¸°ë³¸ ëª¨ë“ˆ ì„í¬íŠ¸
    default_imports = """
import os
import sys
import json
import datetime
from pathlib import Path
import numpy as np
import pandas as pd
"""
    
    try:
        exec(default_imports, repl_state.repl_globals)
        logger.info("ê¸°ë³¸ ëª¨ë“ˆ ì„í¬íŠ¸ ì™„ë£Œ")
    except Exception as e:
        logger.warning(f"ì¼ë¶€ ëª¨ë“ˆ ì„í¬íŠ¸ ì‹¤íŒ¨: {e}")
    
    # í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì „ì—­ì— ì¶”ê°€
    if repl_state.project_context:
            if repl_state.ai_brain and hasattr(repl_state.ai_brain, '_global_state'):
                context = repl_state.ai_brain._global_state.context
                if context:
                    repl_state.repl_globals['context'] = context
    
    logger.info("REPL ì¤€ë¹„ ì™„ë£Œ - ì…ë ¥ ëŒ€ê¸° ì¤‘...")
    
    # í•¸ë“¤ëŸ¬ì—ê²Œ ì¤€ë¹„ ì™„ë£Œ ì‹ í˜¸ ì „ì†¡
    print("__READY__", flush=True)
    
    # ì´ˆê¸° ìƒíƒœ ì‘ë‹µì€ ë³´ë‚´ì§€ ì•ŠìŒ (í•¸ë“¤ëŸ¬ê°€ í˜¼ë€ìŠ¤ëŸ¬ì›Œí•¨)
    # initial_response = {
    #     "success": True,
    #     "session_mode": "JSON_REPL",
    #     "session_id": repl_state.session_id,
    #     "project_root": str(repl_state.project_root) if repl_state.project_root else None,
    #     "context_available": CONTEXT_MANAGER_AVAILABLE,
    #     "ai_brain_available": AI_BRAIN_AVAILABLE,
    #     "helpers_count": len(protection_system.protected_functions),
    #     "note": "JSON REPL Session Ready",
    #     "timestamp": dt.datetime.now().isoformat()
    # }
    # send_json_response(initial_response)
    
    # ë©”ì¸ ë£¨í”„
    try:
        while True:
            # ì…ë ¥ ì½ê¸°
            code_input = read_json_input()
            if code_input is None:
                logger.info("EOF ê°ì§€ - ì¢…ë£Œ")
                break
            
            # ì½”ë“œ íŒŒì‹±
            try:
                request = json.loads(code_input)
                request_id = request.get('id', None)  # ìš”ì²­ ID ì €ì¥
                code = request.get('code', '')
                language = request.get('language', 'python')
                
                if language != 'python':
                    response = {
                        "success": False,
                        "error": f"Unsupported language: {language}",
                        "error_type": "LanguageError"
                    }
                    if request_id:
                        response['id'] = request_id
                else:
                    # í—¬í¼ í•¨ìˆ˜ ìƒíƒœ í™•ì¸ ë° ë³µì›
                    protection_system.restore_if_needed(repl_state.repl_globals, bootstrap_system)
                    
                    # ì½”ë“œ ì‹¤í–‰
                    response = execute_code_block(code, repl_state.repl_globals)
                    response['language'] = language
                    response['session_mode'] = 'JSON_REPL'
                    response['timestamp'] = dt.datetime.now().isoformat()
                    if request_id:
                        response['id'] = request_id  # ìš”ì²­ IDë¥¼ ì‘ë‹µì— í¬í•¨
                
            except json.JSONDecodeError as e:
                response = {
                    "success": False,
                    "error": f"Invalid JSON: {str(e)}",
                    "error_type": "JSONDecodeError"
                }
            except Exception as e:
                response = {
                    "success": False,
                    "error": str(e),
                    "error_type": type(e).__name__,
                    "traceback": traceback.format_exc()
                }
            
            # ì‘ë‹µ ì „ì†¡
            send_json_response(response)
    
    except KeyboardInterrupt:
        logger.info("KeyboardInterrupt - ì¢…ë£Œ")
    except Exception as e:
        logger.error(f"ë©”ì¸ ë£¨í”„ ì˜¤ë¥˜: {e}")
        traceback.print_exc(file=sys.stderr)
    finally:
        # ì¢…ë£Œ ì²˜ë¦¬
        cleanup()

# ============================================================================
# ğŸš€ ì´ˆê¸°í™” ë° ì‹œì‘
# ============================================================================

def cleanup():
    """ì¢…ë£Œ ì‹œ ì •ë¦¬ ì‘ì—…"""
    logger.info("=== ì •ë¦¬ ì‘ì—… ì‹œì‘ ===")
    
    # ì„¸ì…˜ ì €ì¥
    session_manager = SessionManager()
    session_manager.save_session()
    session_manager.save_last_session_info()
    
    # Context ì €ì¥
    if CONTEXT_MANAGER_AVAILABLE and repl_state.project_context:
        try:
            save_context()
            logger.info("âœ… ìµœì¢… ì»¨í…ìŠ¤íŠ¸ ì €ì¥ ì™„ë£Œ")
        except Exception as e:
            logger.error(f"ìµœì¢… ì»¨í…ìŠ¤íŠ¸ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    logger.info("=== JSON REPL Session ì¢…ë£Œ ===")

def initialize_system():
    """ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
    # í”Œë«í¼ë³„ ì„¤ì •
    if platform.system() == 'Windows':
        # Windows ì½˜ì†” UTF-8 ì„¤ì •
        try:
            subprocess.run(['chcp', '65001'], shell=True, capture_output=True)
        except:
            pass
    
    # í‘œì¤€ ìŠ¤íŠ¸ë¦¼ ì¸ì½”ë”© ì„¤ì •
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(encoding='utf-8')
    if hasattr(sys.stderr, 'reconfigure'):
        sys.stderr.reconfigure(encoding='utf-8')
    
    # ë²„í¼ë§ ë¹„í™œì„±í™”
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', line_buffering=True)
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', line_buffering=True)

# ============================================================================
# ğŸ¯ ë©”ì¸ ì‹¤í–‰
# ============================================================================

if __name__ == "__main__":
    try:
        # ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        initialize_system()
        
        # ë©”ì¸ ë£¨í”„ ì‹¤í–‰
        main_loop()
        
    except Exception as e:
        logger.error(f"ì¹˜ëª…ì  ì˜¤ë¥˜: {e}")
        traceback.print_exc(file=sys.stderr)
        
        # ì˜¤ë¥˜ ì‘ë‹µ
        error_response = {
            "success": False,
            "error": str(e),
            "error_type": "FatalError",
            "traceback": traceback.format_exc()
        }
        send_json_response(error_response)
        
        sys.exit(1)
