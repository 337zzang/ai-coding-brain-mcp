#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  AI Coding Brain ì‹œìŠ¤í…œ v3.0 - í†µí•© ì§€ëŠ¥í˜• ê°œë°œ í™˜ê²½
=====================================================

Claude Desktop execute_code í™˜ê²½ì„ ìœ„í•œ ì™„ì „ í†µí•© AI ë¸Œë ˆì¸ ì‹œìŠ¤í…œ

v3.0 ì£¼ìš” íŠ¹ì§•:
- UnifiedContextManagerì™€ VibeMemoryManager ì™„ì „ í†µí•©
- ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ì•ˆì •ì ì¸ ì¸ìŠ¤í„´ìŠ¤ ê´€ë¦¬
- ìë™ ì„¸ì…˜ ë³µì› ë° ì§€ì†ì„±
- ì§€ëŠ¥í˜• ì½”ë“œ ë¶„ì„ ë° ì¶”ì 
- í†µí•© ë©”ëª¨ë¦¬ ë±…í¬ ì‹œìŠ¤í…œ

ì‘ì„±ì: Claude + ì‚¬ìš©ì í˜‘ì—…
ìƒì„±ì¼: 2025-06-04
ìˆ˜ì •ì¼: 2025-06-13 (v3.0 - ì™„ì „ í†µí•© êµ¬ì¡°)
"""

import os
import json
import logging
import datetime as dt
from pathlib import Path
from typing import Union, Optional, Tuple, Dict, Any, List, Callable
import sys
import traceback
from collections import defaultdict

# ============================================
# ë¡œê¹… ì„¤ì •
# ============================================
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s %(asctime)s] %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# ============================================
# ëª¨ë“ˆ ì„í¬íŠ¸ ë° ì´ˆê¸°í™”
# ============================================

# 2. Context Manager v3.0
try:
    from context_manager import (
        initialize_context,
        save_context,
        update_cache,
        get_value,
        find_symbol,
        track_file_access,
        track_function_edit,
        get_work_tracking_summary,
        build_index,
        propose_next_steps
    )
    CONTEXT_MANAGER_AVAILABLE = True
    logger.info("âœ… Context Manager v3.0 ë¡œë“œ ì™„ë£Œ")
except ImportError as e:
    CONTEXT_MANAGER_AVAILABLE = False
    logger.error(f"âŒ Context Manager ë¡œë“œ ì‹¤íŒ¨: {e}")




# ============================================
# ê¸€ë¡œë²Œ ìƒíƒœ ê´€ë¦¬
# ============================================
class GlobalState:
    """ê¸€ë¡œë²Œ ìƒíƒœ ê´€ë¦¬ (í”„ë¡œì íŠ¸ ì „í™˜ ì§€ì›)"""
    def __init__(self):
        # ê¸°ë³¸ ìƒíƒœ
        self.initialized = False
        self.session_start = dt.datetime.now()
        
        # í”„ë¡œì íŠ¸ ê´€ë ¨ (ë‚˜ì¤‘ì— ì„¤ì •)
        self.current_project = None
        self.project_root = None
        self.project_location = None  # 'project_root' or 'memory_root'
        self.memory_root = None
        self.context = None
        
        # ìºì‹œ
        self.available_projects = {}
        self.claude_config = None


# ê¸€ë¡œë²Œ ìƒíƒœ ì¸ìŠ¤í„´ìŠ¤
_global_state = GlobalState()

# def find_project_root() -> Optional[Path]:
#     """í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ ì°¾ëŠ” í†µí•© ë¡œì§ - ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ"""
#     # ì´ í•¨ìˆ˜ëŠ” get_paths_from_config()ë¡œ ëŒ€ì²´ë˜ì—ˆìŠµë‹ˆë‹¤.
#     pass


def find_memory_bank(project_name: str = None) -> Optional[Tuple[Path, Path]]:
    """ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ ì°¾ê¸°"""
    memory_bank_root = None

    # Claude Desktop ì„¤ì • í™•ì¸
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # mcpServers ì„¹ì…˜ì—ì„œ ë©”ëª¨ë¦¬ ë±…í¬ ê²½ë¡œ ì°¾ê¸°
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'memory' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'MEMORY_BANK_PATH' in env:
                        memory_bank_root = Path(env['MEMORY_BANK_PATH'])
                        logger.info(f"âœ… Claude Desktop ì„¤ì •ì—ì„œ ë©”ëª¨ë¦¬ ë£¨íŠ¸ ë¡œë“œ: {memory_bank_root}")
                        break
        except Exception as e:
            logger.error(f"Claude Desktop ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")

    # ëŒ€ì²´ ê²½ë¡œë“¤
    if not memory_bank_root or not memory_bank_root.exists():
        fallback_paths = [
            Path.home() / "Desktop" / "memory",
            Path("C:/Users/Administrator/Desktop/memory"),
            Path.home() / "memory",
            Path.home() / "Documents" / "memory"
        ]
        
        for path in fallback_paths:
            if path.exists():
                memory_bank_root = path
                logger.info(f"ëŒ€ì²´ ë©”ëª¨ë¦¬ ë±…í¬ ê²½ë¡œ ì‚¬ìš©: {memory_bank_root}")
                break

    if memory_bank_root and project_name:
        project_path = memory_bank_root / project_name
        if project_path.exists():
            return memory_bank_root, project_path

    return memory_bank_root, None if memory_bank_root else (None, None)

def load_claude_desktop_config() -> dict:
    """Claude Desktop ì„¤ì • ë¡œë“œ"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Claude Desktop ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
    return {}

def get_paths_from_config() -> dict:
    """Claude Desktop ì„¤ì •ì—ì„œ PROJECT_ROOTì™€ MEMORY_BANK_ROOT ì§ì ‘ ê°€ì ¸ì˜¤ê¸°"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_root': Path.home() / "Desktop",  # ê¸°ë³¸ê°’
        'memory_root': Path.home() / "Desktop" / "memory"  # ê¸°ë³¸ê°’
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # ai-coding-brain MCP ì„œë²„ ì„¤ì •ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    
                    if 'PROJECT_ROOT' in env:
                        paths['project_root'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            logger.error(f"Claude Desktop ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    return paths

def list_available_projects() -> dict:
    """ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸ ëª©ë¡ (ë‹¨ìˆœí™”ëœ ë²„ì „)"""
    paths = get_paths_from_config()
    projects = {}
    
    # PROJECT_ROOTì˜ í”„ë¡œì íŠ¸ë“¤
    if paths['project_root'].exists():
        for item in paths['project_root'].iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                projects[item.name] = {
                    'path': item,
                    'location': 'project_root'
                }
    
    # MEMORY_ROOTì˜ í”„ë¡œì íŠ¸ë“¤ (ìš°ì„ ìˆœìœ„ê°€ ë†’ìŒ)
    if paths['memory_root'].exists():
        for item in paths['memory_root'].iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                projects[item.name] = {
                    'path': item,
                    'location': 'memory_root'
                }
    
    return projects

def switch_project(project_name: str) -> bool:
    """í”„ë¡œì íŠ¸ ì „í™˜ (ë‹¨ìˆœí™”ëœ ë²„ì „)"""
    global _global_state
    
    # ì´ì „ í”„ë¡œì íŠ¸ ì €ì¥
    if _global_state.context and CONTEXT_MANAGER_AVAILABLE:
        logger.info(f"ì´ì „ í”„ë¡œì íŠ¸ '{_global_state.current_project}' ì €ì¥ ì¤‘...")
        save_context()
    
    # í”„ë¡œì íŠ¸ ê²½ë¡œ ì°¾ê¸°
    paths = get_paths_from_config()
    project_path = None
    location = None
    
    # ë©”ëª¨ë¦¬ ë£¨íŠ¸ ìš°ì„  í™•ì¸
    memory_path = paths['memory_root'] / project_name
    if memory_path.exists():
        project_path = memory_path
        location = 'memory_root'
    else:
        # í”„ë¡œì íŠ¸ ë£¨íŠ¸ í™•ì¸
        project_root_path = paths['project_root'] / project_name
        if project_root_path.exists():
            project_path = project_root_path
            location = 'project_root'
    
    if not project_path:
        logger.error(f"í”„ë¡œì íŠ¸ '{project_name}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return False
    
    # ìƒíƒœ ì—…ë°ì´íŠ¸
    _global_state.current_project = project_name
    _global_state.project_root = str(project_path)
    _global_state.project_location = location
    _global_state.memory_root = str(paths['memory_root'])
    
    # ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½
    os.chdir(project_path)
    
    # Context ì´ˆê¸°í™”
    if CONTEXT_MANAGER_AVAILABLE:
        _global_state.context = initialize_context(str(project_path), project_name)
        logger.info(f"âœ… í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì™„ë£Œ ({location})")
    else:
        logger.warning("Context Managerë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        _global_state.context = None
    
    return True




def initialize_ai_brain(project_path: str = None, project_name: str = None) -> Dict[str, Any]:
    """
    AI Brain ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ìµœì†Œ ë²„ì „)
    
    Args:
        project_path: í”„ë¡œì íŠ¸ ê²½ë¡œ (ì„ íƒì )
        project_name: í”„ë¡œì íŠ¸ ì´ë¦„ (ì„ íƒì )
    
    Returns:
        ì´ˆê¸°í™”ëœ ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” None
    """
    global _global_state
    
    logger.info("ğŸš€ AI Brain ë¶€íŠ¸ìŠ¤íŠ¸ë© ì‹œì‘")
    
    # í”„ë¡œì íŠ¸ê°€ ì§€ì •ëœ ê²½ìš°
    if project_name:
        if switch_project(project_name):
            return _global_state.context
        else:
            logger.warning("í”„ë¡œì íŠ¸ ì „í™˜ ì‹¤íŒ¨, ê¸°ë³¸ ìƒíƒœë¡œ ì‹œì‘")
    
    # í”„ë¡œì íŠ¸ ë¯¸ì§€ì • ì‹œ - ë¶€íŠ¸ìŠ¤íŠ¸ë©ë§Œ
    logger.info("âœ… AI Brain ë¶€íŠ¸ìŠ¤íŠ¸ë© ì™„ë£Œ (í”„ë¡œì íŠ¸ ë¯¸ì„ íƒ)")
    logger.info("ğŸ’¡ ì‚¬ìš©ë²•: /flow [í”„ë¡œì íŠ¸ëª…]")
    
    # ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸ í‘œì‹œ
    projects = list_available_projects()
    if projects:
        logger.info(f"ğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸: {len(projects)}ê°œ")
        for name in list(projects.keys())[:5]:
            logger.info(f"   â€¢ {name}")
    
    _global_state.initialized = True
    return None

def _create_minimal_context() -> Dict[str, Any]:
    """ìµœì†Œí•œì˜ ì»¨í…ìŠ¤íŠ¸ ìƒì„± (í´ë°±ìš©)"""
    context: Dict[str, Any] = {
        'project_name': _global_state.project_name,
        'project_path': _global_state.project_path,
        'created_at': dt.datetime.now().isoformat(),
        'version': 'minimal',
        'cache': {
            'analyzed_files': {},
            'symbol_index': {},
            'work_tracking': {}
        },
        'tasks': {'next': [], 'done': []},
        'current_focus': '',
        'coding_experiences': []
    }
    return context

# ============================================
# ì§€ëŠ¥í˜• ë¶„ì„ í•¨ìˆ˜
# ============================================



def save_ai_brain_state() -> bool:
    """AI Brain ìƒíƒœ ì €ì¥"""
    if not _global_state.context:
        logger.warning("ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
        return False
    
    try:
        result = save_context()
        if result:
            logger.info("ğŸ’¾ AI Brain ìƒíƒœ ì €ì¥ ì™„ë£Œ")
        return result
    except Exception as e:
        logger.error(f"âŒ ì €ì¥ ì¤‘ ì˜¤ë¥˜: {e}")
        return False

# ============================================
# ì§€ëŠ¥í˜• ì œì•ˆ ì‹œìŠ¤í…œ
# ============================================

def get_ai_suggestions(limit: int = 5) -> List[Dict[str, Any]]:
    """AI ê¸°ë°˜ ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ"""
    if not _global_state.context:
        return []
    
    suggestions = propose_next_steps(_global_state.context, limit)
    
    # ì¶”ê°€ ì œì•ˆ ë¡œì§
    work_tracking = get_value(_global_state.context, 'work_tracking', {})
    
    # ì„¸ì…˜ ì‹œê°„ ê¸°ë°˜ ì œì•ˆ
    session_duration = (dt.datetime.now() - _global_state.session_start).total_seconds()
    if session_duration > 7200:  # 2ì‹œê°„ ì´ìƒ
        suggestions.insert(0, {
            'type': 'health',
            'priority': 'high',
            'text': '2ì‹œê°„ ì´ìƒ ì‘ì—…í•˜ì…¨ìŠµë‹ˆë‹¤. ì ì‹œ íœ´ì‹ì„ ì·¨í•˜ì„¸ìš”! â˜•',
            'action': 'take_break'
        })
    
    return suggestions

# ============================================
# ëª…ë ¹ì–´ ì‹œìŠ¤í…œ
# ============================================

def process_command(command: str, *args) -> Any:
    """
    ëª…ë ¹ì–´ ì²˜ë¦¬ ì‹œìŠ¤í…œ
    
    Args:
        command: ëª…ë ¹ì–´ ë¬¸ìì—´
        *args: ëª…ë ¹ì–´ ì¸ìë“¤
    
    Returns:
        ëª…ë ¹ì–´ ì‹¤í–‰ ê²°ê³¼
    """
    commands = {
        '/flow': cmd_flow,
        '/task': cmd_task,
        '/done': cmd_done,
        '/focus': cmd_focus,
        '/suggest': cmd_suggest,
        '/save': cmd_save,
        '/status': cmd_status,
        '/help': cmd_help
    }
    
    if command in commands:
        return commands[command](*args)
    else:
        return f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {command}\nğŸ’¡ /helpë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´ë¥¼ í™•ì¸í•˜ì„¸ìš”"

def cmd_flow(args: List[str]) -> None:
    """í”„ë¡œì íŠ¸ ìƒíƒœ í‘œì‹œ ë° ì „í™˜
    
    ì‚¬ìš©ë²•:
        /flow              - í˜„ì¬ ìƒíƒœ ë° í”„ë¡œì íŠ¸ ëª©ë¡
        /flow project_name - íŠ¹ì • í”„ë¡œì íŠ¸ë¡œ ì „í™˜
    """
    
    # í”„ë¡œì íŠ¸ ì „í™˜ ìš”ì²­
    if args and len(args) > 0:
        project_name = args[0]
        
        print(f"\nğŸ”„ í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì¤‘...")
        
        if switch_project(project_name):
            print(f"âœ… í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì™„ë£Œ!")
            
            # ê°„ë‹¨í•œ ìƒíƒœ í‘œì‹œ
            if _global_state.context:
                analyzed = len(get_value(_global_state.context, 'analyzed_files', {}))
                tasks_next = len(get_value(_global_state.context, 'tasks.next', []))
                tasks_done = len(get_value(_global_state.context, 'tasks.done', []))
                
                print(f"\nğŸ“Š í”„ë¡œì íŠ¸ ìƒíƒœ:")
                print(f"   â€¢ ìœ„ì¹˜: {_global_state.project_location}")
                print(f"   â€¢ ë¶„ì„ëœ íŒŒì¼: {analyzed}ê°œ")
                print(f"   â€¢ ì‘ì—…: {tasks_done}ê°œ ì™„ë£Œ, {tasks_next}ê°œ ëŒ€ê¸°")
        else:
            print(f"âŒ í”„ë¡œì íŠ¸ ì „í™˜ ì‹¤íŒ¨")
            
            # ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸ ëª©ë¡ í‘œì‹œ
            projects = list_available_projects()
            if projects:
                print("\nğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸:")
                print("-" * 60)
                
                # ìœ„ì¹˜ë³„ë¡œ ê·¸ë£¹í™”
                project_root_projects = []
                memory_root_projects = []
                
                for name, info in projects.items():
                    if info['location'] == 'project_root':
                        project_root_projects.append((name, info))
                    else:
                        memory_root_projects.append((name, info))
                
                if project_root_projects:
                    print("\nğŸ“ PROJECT_ROOT:")
                    for name, info in sorted(project_root_projects):
                        cache = "âœ“" if info['has_cache'] else "âœ—"
                        print(f"   â€¢ {name} (ìºì‹œ: {cache})")
                
                if memory_root_projects:
                    print("\nğŸ’¾ MEMORY_ROOT:")
                    for name, info in sorted(memory_root_projects):
                        print(f"   â€¢ {name} (ìºì‹œ: âœ“)")
        return
    
    # í˜„ì¬ ìƒíƒœ í‘œì‹œ
    if not _global_state.context:
        print("\nâš ï¸ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        print("\nì‚¬ìš©ë²•: /flow [í”„ë¡œì íŠ¸ëª…]")
        
        # ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸ ëª©ë¡
        projects = list_available_projects()
        if projects:
            print("\nğŸ“‹ ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸:")
            print("-" * 60)
            
            # ìœ„ì¹˜ë³„ë¡œ ê·¸ë£¹í™”
            project_root_projects = []
            memory_root_projects = []
            
            for name, info in projects.items():
                if info['location'] == 'project_root':
                    project_root_projects.append((name, info))
                else:
                    memory_root_projects.append((name, info))
            
            if project_root_projects:
                print("\nğŸ“ PROJECT_ROOT (C:\\Users\\82106\\Desktop):")
                for name, info in sorted(project_root_projects):
                    cache = "âœ“" if info['has_cache'] else "âœ—"
                    print(f"   â€¢ {name} (ìºì‹œ: {cache})")
            
            if memory_root_projects:
                print("\nğŸ’¾ MEMORY_ROOT (C:\\Users\\82106\\Desktop\\memory):")
                for name, info in sorted(memory_root_projects):
                    print(f"   â€¢ {name} (ìºì‹œ: âœ“)")
        else:
            print("\nâŒ ì‚¬ìš© ê°€ëŠ¥í•œ í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return
    
    # í˜„ì¬ í”„ë¡œì íŠ¸ ìƒíƒœ í‘œì‹œ (ê¸°ì¡´ ë¡œì§)
    print(f"\nğŸ”¥ í˜„ì¬ í”„ë¡œì íŠ¸: {_global_state.current_project}")
    print("=" * 70)
    
    # Context Manager ì‚¬ìš© ê°€ëŠ¥ í™•ì¸
    if not CONTEXT_MANAGER_AVAILABLE:
        print("âŒ Context Managerë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        return
    
    # í”„ë¡œì íŠ¸ ì •ë³´
    print(f"\nğŸ“Œ í”„ë¡œì íŠ¸ ì •ë³´:")
    print(f"   â€¢ ì´ë¦„: {_global_state.current_project}")
    print(f"   â€¢ ê²½ë¡œ: {_global_state.project_root}")
    print(f"   â€¢ ìœ„ì¹˜: {_global_state.project_location}")
    
    # ë¶„ì„ ì •ë³´
    analyzed_files = get_value(_global_state.context, 'analyzed_files', {})
    symbol_index = get_value(_global_state.context, 'symbol_index', {})
    
    print(f"\nğŸ“Š ë¶„ì„ ìƒíƒœ:")
    print(f"   â€¢ ë¶„ì„ëœ íŒŒì¼: {len(analyzed_files)}ê°œ")
    print(f"   â€¢ ì‹¬ë³¼ ì¸ë±ìŠ¤: {len(symbol_index)}ê°œ")
    
    # ì‘ì—… ì¶”ì 
    work_tracking = get_value(_global_state.context, 'work_tracking', {})
    if work_tracking:
        file_edits = work_tracking.get('file_edits', {})
        if file_edits:
            print(f"\nâœï¸ ìµœê·¼ í¸ì§‘:")
            sorted_edits = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)
            for file_path, count in sorted_edits[:5]:
                print(f"   â€¢ {os.path.basename(file_path)}: {count}íšŒ")
    
    # ì‘ì—… ëª©ë¡
    tasks = get_value(_global_state.context, 'tasks', {})
    next_tasks = tasks.get('next', [])
    done_tasks = tasks.get('done', [])
    
    if next_tasks or done_tasks:
        print(f"\nğŸ“‹ ì‘ì—… í˜„í™©:")
        print(f"   â€¢ ì™„ë£Œ: {len(done_tasks)}ê°œ")
        print(f"   â€¢ ëŒ€ê¸°: {len(next_tasks)}ê°œ")
        
        if next_tasks:
            print("\në‹¤ìŒ ì‘ì—…:")
            for i, task in enumerate(next_tasks[:3], 1):
                print(f"   {i}. {task}")
    
    # AI ì œì•ˆ




def cmd_task(*args):
    """ìƒˆ ì‘ì—… ì¶”ê°€"""
    if not args:
        return "âŒ ì‘ì—… ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”"
    
    task = ' '.join(args)
    if _global_state.context:
        tasks = _global_state.context.setdefault('tasks', {})
        tasks.setdefault('next', []).append(task)
        save_ai_brain_state()
        return f"âœ… ì‘ì—… ì¶”ê°€ë¨: {task}"
    
    return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"

def cmd_done(*args):
    """ì‘ì—… ì™„ë£Œ ì²˜ë¦¬"""
    if not _global_state.context:
        return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
    
    tasks = _global_state.context.get('tasks', {})
    next_tasks = tasks.get('next', [])
    
    if not next_tasks:
        return "â„¹ï¸ ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤"
    
    if args and args[0].isdigit():
        idx = int(args[0]) - 1
        if 0 <= idx < len(next_tasks):
            task = next_tasks.pop(idx)
            tasks.setdefault('done', []).append(task)
            save_ai_brain_state()
            return f"âœ… ì™„ë£Œ: {task}"
    
    # ì²« ë²ˆì§¸ ì‘ì—… ì™„ë£Œ
    task = next_tasks.pop(0)
    tasks.setdefault('done', []).append(task)
    save_ai_brain_state()
    return f"âœ… ì™„ë£Œ: {task}"

def cmd_focus(*args):
    """í˜„ì¬ í¬ì»¤ìŠ¤ ì„¤ì •"""
    if not args:
        if _global_state.context:
            return f"ğŸ¯ í˜„ì¬ í¬ì»¤ìŠ¤: {_global_state.context.get('current_focus', 'Not set')}"
        else:
            return "ğŸ¯ í˜„ì¬ í¬ì»¤ìŠ¤: Not set (ì»¨í…ìŠ¤íŠ¸ ì—†ìŒ)"
    
    focus = ' '.join(args)
    if _global_state.context:
        _global_state.context['current_focus'] = focus
        save_ai_brain_state()
        return f"ğŸ¯ í¬ì»¤ìŠ¤ ì„¤ì •: {focus}"
    
    return "âŒ ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"

def cmd_suggest(*args):
    """AI ì œì•ˆ í‘œì‹œ"""
    limit = int(args[0]) if args and args[0].isdigit() else 5
    suggestions = get_ai_suggestions(limit)
    
    if not suggestions:
        return "ğŸ’¡ í˜„ì¬ ì œì•ˆì´ ì—†ìŠµë‹ˆë‹¤"
    
    output = ["ğŸ’¡ AI ì œì•ˆ:"]
    for i, suggestion in enumerate(suggestions, 1):
        output.append(f"   {i}. [{suggestion['type']}] {suggestion['text']}")
    
    return '\n'.join(output)

def cmd_save(*args):
    """ìƒíƒœ ì €ì¥"""
    if save_ai_brain_state():
        return "ğŸ’¾ ì €ì¥ ì™„ë£Œ!"
    else:
        return "âŒ ì €ì¥ ì‹¤íŒ¨"

def cmd_status(*args):
    """ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ"""
    output = ["ğŸ”§ AI Brain System Status"]
    output.append("=" * 40)
    output.append(f"â€¢ Context Manager: {'âœ…' if CONTEXT_MANAGER_AVAILABLE else 'âŒ'}")
    output.append(f"â€¢ Project: {_global_state.project_name or 'Not initialized'}")
    
    session_time = dt.datetime.now() - _global_state.session_start
    output.append(f"â€¢ Session Time: {str(session_time).split('.')[0]}")
    
    return '\n'.join(output)

def cmd_help(*args):
    """ë„ì›€ë§ í‘œì‹œ"""
    help_text = """
ğŸ¤– AI Coding Brain ëª…ë ¹ì–´ ë„ì›€ë§
=====================================

ê¸°ë³¸ ëª…ë ¹ì–´:
  /flow       - í”„ë¡œì íŠ¸ ìƒíƒœ ë° ì‘ì—… íë¦„ í‘œì‹œ
  /analyze    - í”„ë¡œì íŠ¸ íŒŒì¼ ë¶„ì„
  /task       - ìƒˆ ì‘ì—… ì¶”ê°€
  /done       - ì‘ì—… ì™„ë£Œ ì²˜ë¦¬
  /focus      - í˜„ì¬ í¬ì»¤ìŠ¤ ì„¤ì •
  /suggest    - AI ì œì•ˆ í‘œì‹œ
  /save       - ìƒíƒœ ì €ì¥
  /status     - ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
  /help       - ì´ ë„ì›€ë§ í‘œì‹œ

ì‚¬ìš© ì˜ˆì‹œ:
  /task API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
  /done 1
  /focus ë¦¬íŒ©í† ë§ ì‘ì—…
  /analyze .py .js
  
ğŸ’¡ ìì—°ì–´ë¡œë„ ëª…ë ¹ ê°€ëŠ¥í•©ë‹ˆë‹¤!
"""
    return help_text

# ============================================
# ìë™ ì´ˆê¸°í™” (execute_code í™˜ê²½ìš©)
# ============================================

def auto_initialize():
    """execute_code ì‹¤í–‰ ì‹œ ìë™ ì´ˆê¸°í™”"""
    if _global_state.context is None:
        project_path = os.getcwd()
        project_name = os.path.basename(project_path)
        
        # .cache ë””ë ‰í† ë¦¬ì—ì„œ í”„ë¡œì íŠ¸ ì´ë¦„ ì¶”ë¡ 
        cache_dir = os.path.join(project_path, '.cache')
        if os.path.exists(cache_dir):
            for file in os.listdir(cache_dir):
                if file.startswith('cache_') and file.endswith('.json'):
                    project_name = file[6:-5]  # cache_NAME.jsonì—ì„œ NAME ì¶”ì¶œ
                    break
        
        initialize_ai_brain(project_path, project_name)

# ìë™ ì´ˆê¸°í™” ì‹¤í–‰
# auto_initialize()
  # ìë™ ì´ˆê¸°í™” ë¹„í™œì„±í™”

# ============================================


# ============================================
# ì´ˆê¸°í™” ì™„ë£Œ ë©”ì‹œì§€
# ============================================

if _global_state.context:
    logger.info("ğŸ§  AI Coding Brain v3.0 ì¤€ë¹„ ì™„ë£Œ!")
    logger.info("ğŸ’¡ /help ë˜ëŠ” help()ë¡œ ì‚¬ìš©ë²•ì„ í™•ì¸í•˜ì„¸ìš”")
else:
    logger.warning("âš ï¸ AI Coding Brain ë¶€ë¶„ ì´ˆê¸°í™” - ì¼ë¶€ ê¸°ëŠ¥ ì œí•œ")
