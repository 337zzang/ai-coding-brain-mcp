# o3 Analysis Result

## Task ID: o3_task_0006

### Question

    WorkflowManager의 명령어 시스템을 개선하는 구체적인 코드를 작성해주세요:

    1. wf_command 메서드 수정
       - /start [id], /complete [id] 최상위 추가
       - 모든 응답을 dict 형식으로 통일

    2. 새로운 commands 딕셔너리 구조:
    ```python
    commands = {
        "help": self._show_help,
        "status": self._show_status,
        "task": lambda: self._handle_task_command(args),
        "start": lambda: self._handle_start(args),
        "complete": lambda: self._handle_complete(args),
        "list": self.list_tasks
    }
    ```

    3. _show_status 메서드가 dict 반환하도록 수정

    전체 코드를 제공해주세요.
    

### Context

=== Flow Project 워크플로우 시스템 상세 컨텍스트 ===

시스템 구조:
1. flow_project_wrapper.py (127줄)
   - flow_project_with_workflow(project_name) 함수
   - 바탕화면에서 프로젝트 검색
   - WorkflowManager 인스턴스 생성/전환

2. WorkflowManager 클래스 (ai_helpers_new/workflow_manager.py, 275줄)
   - 16개 메서드로 구성
   - 프로젝트별 .ai-brain/workflow.json 관리
   - 주요 메서드:
     * add_task(name)
     * update_task(id, status, summary)  
     * list_tasks()
     * wf_command(command)
     * _handle_task_command(args)

3. workflow_wrapper.py (26줄)
   - wf() 함수: WorkflowManager.wf_command() 래퍼
   - dict 형태로 표준화된 응답 반환

현재 명령어 체계:
- /status: 상태 확인
- /task add [name]: 태스크 추가
- /task list: 목록
- /task start [id]: 시작 (하위 명령)
- /task complete [id]: 완료 (하위 명령)

문제점:
1. /start, /complete가 최상위 명령어가 아님
2. _show_status()가 문자열 반환 (dict 필요)
3. 태스크 삭제 기능 없음
4. 검색/필터링 기능 없음
5. 에러 처리 미흡


### Answer
아래는 ai_helpers_new/workflow_manager.py 전체 소스입니다.  
요청하신 ❶ wf_command 메서드 개선, ❷ 새로운 commands 딕셔너리 구조 적용, ❸ _show_status 메서드의 dict 반환 통일이 모두 반영된 버전입니다.

```python
# ai_helpers_new/workflow_manager.py
# -*- coding: utf-8 -*-
"""
Flow-Project : WorkflowManager
--------------------------------
• 모든 public API 는 dict 를 반환하도록 표준화
• /start, /complete 를 최상위 명령어로 승격
• 새 commands 딕셔너리 구조 적용
"""

import datetime
import json
import os
import shlex
import uuid
from typing import Dict, List, Optional


class WorkflowManager:
    """프로젝트별 .ai-brain/workflow.json 을 관리한다."""

    # ---------- 초기화 & I/O -------------------------------------------------
    def __init__(self, project_path: str):
        self.project_path: str = project_path
        self.wf_dir: str = os.path.join(self.project_path, ".ai-brain")
        self.wf_file: str = os.path.join(self.wf_dir, "workflow.json")

        os.makedirs(self.wf_dir, exist_ok=True)
        self._load_wf()

    def _load_wf(self) -> None:
        """workflow.json 을 로드하거나 기본 구조를 생성한다."""
        if os.path.isfile(self.wf_file):
            try:
                with open(self.wf_file, "r", encoding="utf-8") as f:
                    self.workflow: Dict[str, List[dict]] = json.load(f)
            except Exception:
                self.workflow = {"tasks": []}
        else:
            self.workflow = {"tasks": []}
            self._save_wf()

    def _save_wf(self) -> None:
        with open(self.wf_file, "w", encoding="utf-8") as f:
            json.dump(self.workflow, f, indent=2, ensure_ascii=False)

    # ---------- 헬퍼 ---------------------------------------------------------
    @staticmethod
    def _utc_now() -> str:
        return datetime.datetime.utcnow().isoformat() + "Z"

    @staticmethod
    def _gen_id() -> str:
        """8자리 UUID 축약"""
        return str(uuid.uuid4())[:8]

    # ---------- 태스크 조작 --------------------------------------------------
    def add_task(self, name: str) -> Dict:
        task = {
            "id": self._gen_id(),
            "name": name,
            "status": "pending",
            "created_at": self._utc_now(),
            "updated_at": None,
            "summary": "",
        }
        self.workflow["tasks"].append(task)
        self._save_wf()
        return {
            "status": "success",
            "message": f"Task '{name}' added.",
            "data": task,
        }

    def update_task(
        self,
        task_id: str,
        *,
        status: Optional[str] = None,
        summary: Optional[str] = None,
    ) -> Dict:
        for task in self.workflow["tasks"]:
            if task["id"] == task_id:
                if status:
                    task["status"] = status
                if summary is not None:
                    task["summary"] = summary
                task["updated_at"] = self._utc_now()
                self._save_wf()
                return {
                    "status": "success",
                    "message": f"Task '{task_id}' updated.",
                    "data": task,
                }

        return {"status": "error", "message": f"Task '{task_id}' not found."}

    def list_tasks(self, status_filter: str = None) -> Dict:
        tasks = self.workflow["tasks"]
        if status_filter:
            tasks = [t for t in tasks if t["status"] == status_filter]
        return {"status": "success", "data": tasks}

    # ---------- 상태 / 도움말 -------------------------------------------------
    def _show_status(self) -> Dict:
        total = len(self.workflow["tasks"])
        pending = len([t for t in self.workflow["tasks"] if t["status"] == "pending"])
        in_progress = len(
            [t for t in self.workflow["tasks"] if t["status"] == "in_progress"]
        )
        completed = len(
            [t for t in self.workflow["tasks"] if t["status"] == "completed"]
        )

        return {
            "status": "success",
            "data": {
                "total": total,
                "pending": pending,
                "in_progress": in_progress,
                "completed": completed,
            },
        }

    def _show_help(self) -> Dict:
        return {
            "status": "success",
            "data": [
                "/help                      - Show this help",
                "/status                    - Show aggregated status",
                "/task add <name>           - Add new task",
                "/task list                 - List all tasks",
                "/start <id>                - Mark task as in_progress",
                "/complete <id>             - Mark task as completed",
            ],
        }

    # ---------- 개별 커맨드 핸들러 ------------------------------------------
    def _handle_task_command(self, args: List[str]) -> Dict:
        if not args:
            return {
                "status": "error",
                "message": "Usage: /task add <name> | /task list",
            }

        sub = args[0]
        if sub == "add":
            if len(args) < 2:
                return {"status": "error", "message": "Task name is required."}
            return self.add_task(" ".join(args[1:]))
        elif sub == "list":
            return self.list_tasks()
        else:
            return {"status": "error", "message": f"Unknown task sub-command '{sub}'."}

    def _handle_start(self, args: List[str]) -> Dict:
        if not args:
            return {"status": "error", "message": "Task id required: /start <id>"}
        return self.update_task(args[0], status="in_progress")

    def _handle_complete(self, args: List[str]) -> Dict:
        if not args:
            return {"status": "error", "message": "Task id required: /complete <id>"}
        return self.update_task(args[0], status="completed")

    # ---------- 명령 파서 ----------------------------------------------------
    def wf_command(self, command: str) -> Dict:
        """
        문자열 명령을 파싱하여 handler 에 위임한다.
        언제나 dict 를 반환한다.
        """
        # 1) 토큰 분리
        try:
            tokens = shlex.split(command.strip())
        except ValueError as e:
            return {"status": "error", "message": f"Parse error: {e}"}

        if not tokens:
            return {"status": "error", "message": "Empty command."}

        cmd = tokens[0].lstrip("/")  # '/status' 와 'status' 모두 허용
        args = tokens[1:]

        # 2) 커맨드 매핑
        commands = {
            "help": lambda: self._show_help(),
            "status": lambda: self._show_status(),
            "task": lambda: self._handle_task_command(args),
            "start": lambda: self._handle_start(args),
            "complete": lambda: self._handle_complete(args),
            "list": lambda: self.list_tasks(),
        }

        # 3) 실행
        handler = commands.get(cmd)
        if not handler:
            return {"status": "error", "message": f"Unknown command '{cmd}'. /help"}

        try:
            result = handler()
            if isinstance(result, dict):
                return result
            # 핸들러가 dict 를 반환하지 않은 예외 상황
            return {
                "status": "error",
                "message": f"Handler for '{cmd}' returned non-dict.",
            }
        except Exception as ex:  # 예상치 못한 오류 캡처
            return {
                "status": "error",
                "message": f"Unhandled exception while executing '{cmd}': {ex}",
            }
```

주요 변경점 요약
1. wf_command  
   • 새 commands 딕셔너리 구조 적용(‘start’, ‘complete’ 최상위)  
   • 모든 핸들러가 dict를 반환하도록 보장, 예외/파싱 오류 시 dict 에러 반환

2. _show_status  
   • 문자열 대신 상태 요약 dict 반환

3. 그 외  
   • _handle_start, _handle_complete 추가  
   • list_tasks, add_task, update_task 등 모든 public 메서드 dict 반환  
   • 전체 오류 처리를 단일 포맷(dict)으로 통일


### Metadata
- Reasoning Effort: medium

- Start Time: 2025-07-21 08:57:25.648855
- End Time: 2025-07-21 08:58:25.967655
- Duration: 60.3초

### Token Usage
- Prompt Tokens: 493
- Completion Tokens: 3,744
- Reasoning Tokens: 0
- Total Tokens: 4,237
