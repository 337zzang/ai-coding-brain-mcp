#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
🧠 Vibe Memory System v3.0 - 통합 메모리 관리 시스템
============================================
4개 문서 자동 관리 시스템 통합 버전

주요 기능:
1. 캐시 관리 (.cache/cache_*.json)
2. 메모리뱅크 동기화
3. 4개 프로젝트 문서 자동 업데이트
   - coding_flow.md: 현재 작업 상태
   - progress.md: 진행 상황 (feature_roadmap.md 대체)
   - project_vision.md: 프로젝트 설명
   - file_directory.md: 파일 구조
"""

import os
import json
import shutil
from datetime import datetime
from typing import Dict, Any, Optional, List, Tuple, Callable


class VibeMemoryManager:
    """통합 메모리 관리 시스템"""
    
    def __init__(self, context: Dict[str, Any], project_name: Optional[str] = None):
        """초기화
        
        Args:
            context: 프로젝트 컨텍스트
            project_name: 프로젝트 이름 (기본값: context에서 추출)
        """
        self.context = context
        self.project_name = project_name or context.get('project_name', 'ai-coding-brain-mcp')
        
        # 경로 설정
        self.project_path = context.get('project_path', os.getcwd())
        self.memory_root = self._get_memory_root()
        self.memory_bank_dir = os.path.join(self.memory_root, self.project_name)
        
        # 디렉토리 생성
        self._ensure_directories()
        
        # context에 경로 정보 추가
        context['memory_path'] = self.memory_bank_dir
        context['memory_bank'] = {
            'root': self.memory_root,
            'project': self.memory_bank_dir
        }
        
        print(f"✅ VibeMemoryManager 초기화 완료: {self.project_name}")
    
    def _get_memory_root(self) -> str:
        """메모리 루트 경로 가져오기"""
        # Windows 경로
        if os.name == 'nt':
            return r"C:\Users\Administrator\Desktop\memory"
        # Unix 계열
        else:
            return os.path.expanduser("~/Desktop/memory")
    
    def _ensure_directories(self):
        """필요한 디렉토리 생성"""
        os.makedirs(self.memory_bank_dir, exist_ok=True)
        os.makedirs(os.path.join(self.memory_bank_dir, '.cache'), exist_ok=True)
        os.makedirs(os.path.join(self.project_path, '.cache'), exist_ok=True)
    
    def save_context(self) -> bool:
        """컨텍스트 저장 - 캐시 + 4개 문서 모두 업데이트
        
        Returns:
            bool: 성공 여부
        """
        try:
            print("\n💾 컨텍스트 저장 시작...")
            
            # 1. 캐시 저장
            cache_saved = self._save_cache()
            
            # 2. 메모리뱅크 동기화
            if cache_saved:
                sync_success = self._sync_to_memory_bank()
            else:
                sync_success = False
            
            # 3. 4개 문서 업데이트
            docs_updated = self._update_all_docs()
            
            if cache_saved and sync_success and docs_updated:
                print("✅ 컨텍스트 저장 완료!")
                return True
            else:
                print("⚠️ 일부 저장 실패")
                return False
                
        except Exception as e:
            print(f"❌ save_context 오류: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def _save_cache(self) -> bool:
        """캐시 파일 저장"""
        try:
            # JSON 직렬화 가능한 데이터만 필터링
            serializable_context = self._prepare_serializable_context()
            
            # 로컬 캐시 저장
            cache_file = os.path.join(self.project_path, '.cache', f'cache_{self.project_name}.json')
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            print(f"   ✅ 캐시 저장: {os.path.relpath(cache_file, self.project_path)}")
            return True
            
        except Exception as e:
            print(f"   ❌ 캐시 저장 실패: {e}")
            return False
    
    def _sync_to_memory_bank(self) -> bool:
        """메모리뱅크로 동기화"""
        try:
            local_cache = os.path.join(self.project_path, '.cache', f'cache_{self.project_name}.json')
            memory_cache = os.path.join(self.memory_bank_dir, '.cache', f'cache_{self.project_name}.json')
            
            if os.path.exists(local_cache):
                shutil.copy2(local_cache, memory_cache)
                print(f"   ✅ 메모리뱅크 동기화 완료")
                return True
            else:
                print(f"   ❌ 로컬 캐시 파일이 없습니다: {local_cache}")
                return False
            
        except Exception as e:
            print(f"   ❌ 동기화 실패: {e}")
            return False
    
    def _update_all_docs(self) -> bool:
        """4개 문서 모두 업데이트"""
        print("   📄 프로젝트 문서 업데이트...")
        
        results = [
            self._update_coding_flow(),
            self._update_progress(),
            self._update_project_vision(),
            self._update_file_directory()
        ]
        
        success_count = sum(results)
        print(f"   ✅ 문서 업데이트: {success_count}/4개 완료")
        
        return all(results)
    
    def _update_coding_flow(self) -> bool:
        """coding_flow.md - 현재 작업 상태"""
        try:
            content = f"""# AI Coding Brain - 현재 작업

## 🎯 현재 Focus
{self.context.get('current_focus', 'Not set')}

## 🔄 진행 중인 작업
"""
            # 진행 중인 Phase 작업들
            if 'phase_reports' in self.context:
                for phase_name, report in self.context['phase_reports'].items():
                    if 'end_time' not in report:  # 진행 중
                        content += f"\n### {phase_name}\n"
                        ops = report.get('operations', [])[-5:]  # 최근 5개
                        for op in ops:
                            status = "✅" if op['result'] == 'success' else "❌"
                            content += f"- {status} {op['operation']}\n"
            
            # 다음 작업들
            content += "\n## 💡 다음 단계\n"
            next_tasks = self.context.get('tasks', {}).get('next', [])
            for i, task in enumerate(next_tasks[:5], 1):
                content += f"{i}. {task}\n"
            
            # 메모 섹션
            content += "\n## 📝 메모\n"
            content += "- save_context() 호출 시 4개 문서 자동 업데이트\n"
            content += "- 백업 없이 직접 저장\n"
            
            content += f"\n최종 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M')}"
            
            self._save_file('coding_flow.md', content)
            return True
            
        except Exception as e:
            print(f"     ❌ coding_flow.md 실패: {e}")
            return False
    
    def _update_progress(self) -> bool:
        """progress.md - 진행 상황"""
        try:
            tasks = self.context.get('tasks', {})
            done_count = len(tasks.get('done', []))
            next_count = len(tasks.get('next', []))
            total_count = done_count + next_count
            progress = (done_count / total_count * 100) if total_count > 0 else 0
            
            content = f"""# AI Coding Brain - 진행 상황

## 📊 전체 진행률
- 완료: {done_count}개
- 남음: {next_count}개
- 진행률: {progress:.1f}%

## 🎯 Phase 진행 상황
"""
            # Phase별 상세 정보
            if 'phase_reports' in self.context:
                for phase_name, report in self.context['phase_reports'].items():
                    content += f"\n### {phase_name}\n"
                    
                    if 'start_time' in report:
                        content += f"- 시작: {report['start_time'].strftime('%Y-%m-%d %H:%M')}\n"
                    
                    if 'end_time' in report:
                        content += f"- 종료: {report['end_time'].strftime('%Y-%m-%d %H:%M')}\n"
                        content += f"- 소요: {report.get('duration', 0):.1f}초\n"
                    else:
                        content += f"- 상태: 진행 중\n"
                    
                    content += f"- 성공: {len(report.get('successes', []))}개\n"
                    content += f"- 실패: {len(report.get('errors', []))}개\n"
                    
                    # 메트릭이 있으면 표시
                    if report.get('metrics'):
                        content += "- 주요 성과:\n"
                        for key, value in report['metrics'].items():
                            content += f"  • {key}: {value}\n"
            
            # 최근 완료 작업
            content += "\n## 📋 최근 완료 작업\n"
            for task in tasks.get('done', [])[-10:]:
                content += f"- ✅ {task}\n"
            
            # 오류 현황
            if 'error_log' in self.context:
                unresolved = [e for e in self.context['error_log'] if e.get('status') == 'unresolved']
                if unresolved:
                    content += f"\n## ⚠️ 미해결 오류 ({len(unresolved)}개)\n"
                    for error in unresolved[-5:]:
                        content += f"- [{error['phase']}] {error['error_type']}: {error['error_message'][:50]}...\n"
            
            content += f"\n최종 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M')}"
            
            self._save_file('progress.md', content)
            return True
            
        except Exception as e:
            print(f"     ❌ progress.md 실패: {e}")
            return False
    
    def _update_project_vision(self) -> bool:
        """project_vision.md - 프로젝트 설명"""
        try:
            content = f"""# AI Coding Brain MCP - 프로젝트 비전

## 🎯 프로젝트 개요
MCP (Model Context Protocol) 기반 통합 개발 지원 시스템

## 📊 현재 상태
- 분석된 파일: {len(self.context.get('analyzed_files', {}))}개
- 심볼 인덱스: {len(self.context.get('symbol_index', {}))}개
- 완료된 작업: {len(self.context.get('tasks', {}).get('done', []))}개
- 진행 중 작업: {len(self.context.get('tasks', {}).get('next', []))}개

## 🔧 핵심 기능
1. **자동 컨텍스트 관리**: 작업 상태 자동 저장/복원
2. **통합 검색 시스템**: 코드, 메모리, 캐시 통합 검색
3. **Phase 기반 작업 관리**: 체계적인 프로젝트 진행
4. **SimplEdit 안전 수정**: 백업과 함께하는 안전한 코드 수정

## 📦 주요 모듈
"""
            # 분석된 주요 파일들
            analyzed = self.context.get('analyzed_files', {})
            for path, info in list(analyzed.items())[:10]:
                filename = os.path.basename(path)
                func_count = len(info.get('functions', []))
                class_count = len(info.get('classes', []))
                content += f"- **{filename}**: 함수 {func_count}개, 클래스 {class_count}개\n"
            
            if len(analyzed) > 10:
                content += f"- ... 외 {len(analyzed) - 10}개 파일\n"
            
            # 통계
            content += f"""
## 📈 프로젝트 통계
- 전체 Python 파일: {len(self.context.get('project_files', {}).get('files', {}))}개
- 분석 완료율: {(len(analyzed) / max(1, len(self.context.get('project_files', {}).get('files', {})))) * 100:.1f}%
- 전체 함수: {sum(len(info.get('functions', [])) for info in analyzed.values())}개
- 전체 클래스: {sum(len(info.get('classes', [])) for info in analyzed.values())}개
"""
            
            content += f"\n최종 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M')}"
            
            self._save_file('project_vision.md', content)
            return True
            
        except Exception as e:
            print(f"     ❌ project_vision.md 실패: {e}")
            return False
    
    def _update_file_directory(self) -> bool:
        """file_directory.md - 파일 구조"""
        try:
            content = f"""# AI Coding Brain - 프로젝트 구조

최종 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M')}

## 📁 Python 모듈 목록

| 경로 | 설명 | 수정일 |
|------|------|--------|
"""
            if 'project_files' in self.context:
                files = self.context['project_files'].get('files', {})
                for file_path, info in sorted(files.items()):
                    content += f"| {file_path} | {info['description']} | {info['modified']} |\n"
            
            # 통계
            total_files = len(self.context.get('project_files', {}).get('files', {}))
            analyzed_files = len(self.context.get('analyzed_files', {}))
            
            content += f"""

## 📊 통계
- Python 파일: {total_files}개
- 분석 완료: {analyzed_files}개
- 미분석: {total_files - analyzed_files}개

## 📌 주요 디렉토리
- `/python/` - 핵심 Python 모듈들
- `/src/` - TypeScript/JavaScript 소스
- `/backups/` - 백업 파일들
- `/dist/` - 빌드 결과물
- `/.cache/` - 캐시 파일들
"""
            
            self._save_file('file_directory.md', content)
            return True
            
        except Exception as e:
            print(f"     ❌ file_directory.md 실패: {e}")
            return False
    
    def _save_file(self, filename: str, content: str):
        """파일 저장 (백업 없이)"""
        file_path = os.path.join(self.memory_bank_dir, filename)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON 직렬화 가능한 context 준비"""
        skip_keys = ['error_tracker', 'phase_reporter', 'change_tracker', 'flow_options']
        serializable = {}
        
        for key, value in self.context.items():
            if key in skip_keys:
                continue
            
            serializable[key] = self._convert_to_serializable(value)
        
        return serializable
    
    def _convert_to_serializable(self, obj: Any) -> Any:
        """재귀적으로 직렬화 가능한 형태로 변환"""
        if isinstance(obj, dict):
            return {k: self._convert_to_serializable(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self._convert_to_serializable(item) for item in obj]
        elif hasattr(obj, 'isoformat'):
            return obj.isoformat()
        elif isinstance(obj, (str, int, float, bool, type(None))):
            return obj
        else:
            return str(obj)
    
    def load_context(self) -> Dict[str, Any]:
        """컨텍스트 로드 (캐시에서)"""
        try:
            cache_file = os.path.join(self.project_path, '.cache', f'cache_{self.project_name}.json')
            
            if os.path.exists(cache_file):
                with open(cache_file, 'r', encoding='utf-8') as f:
                    loaded_context = json.load(f)
                
                # 기존 context 업데이트
                self.context.update(loaded_context)
                print(f"✅ 컨텍스트 로드 완료: {len(loaded_context)} 항목")
                return loaded_context
            else:
                print(f"⚠️ 캐시 파일이 없습니다: {cache_file}")
                return {}
                
        except Exception as e:
            print(f"❌ 컨텍스트 로드 실패: {e}")
            return {}
    
    def get_project_status(self) -> Dict[str, Any]:
        """프로젝트 상태 요약"""
        tasks = self.context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total_count = done_count + next_count
        
        return {
            'project_name': self.project_name,
            'current_focus': self.context.get('current_focus', 'Not set'),
            'progress': (done_count / total_count * 100) if total_count > 0 else 0,
            'completed_tasks': done_count,
            'remaining_tasks': next_count,
            'analyzed_files': len(self.context.get('analyzed_files', {})),
            'total_symbols': len(self.context.get('symbol_index', {})),
            'unresolved_errors': len([e for e in self.context.get('error_log', []) if e.get('status') == 'unresolved'])
        }


# 전역 함수들 (호환성 유지)
def initialize_vibe_memory(context: Dict[str, Any], project_name: Optional[str] = None) -> VibeMemoryManager:
    """VibeMemoryManager 초기화"""
    return VibeMemoryManager(context, project_name)


def create_save_context(context: Dict[str, Any]) -> Callable[[], bool]:
    """save_context 함수 생성"""
    vibe_manager = VibeMemoryManager(context)
    
    def save_context():
        return vibe_manager.save_context()
    
    return save_context


# 레거시 함수들 (호환성)
def get_vibe_commands() -> List[str]:
    """사용 가능한 명령어 목록"""
    return [
        "/flow - 프로젝트 상태 확인",
        "/task [내용] - 새 작업 추가",
        "/done [번호/내용] - 작업 완료",
        "/focus [내용] - 현재 포커스 설정",
        "/save - 컨텍스트 저장"
    ]


def get_memory_bank_root() -> str:
    """메모리뱅크 루트 경로"""
    if os.name == 'nt':
        return r"C:\Users\Administrator\Desktop\memory"
    else:
        return os.path.expanduser("~/Desktop/memory")


# 테스트 코드
if __name__ == "__main__":
    # 테스트용 context
    test_context = {
        'project_name': 'test-project',
        'project_path': os.getcwd(),
        'current_focus': '테스트 작업',
        'tasks': {
            'done': ['작업1', '작업2'],
            'next': ['작업3', '작업4']
        }
    }
    
    # VibeMemoryManager 테스트
    vibe = VibeMemoryManager(test_context)
    
    # 상태 확인
    status = vibe.get_project_status()
    print(f"\n프로젝트 상태: {status}")
    
    # 저장 테스트
    vibe.save_context()
