# ===========================================
# Public API - Only these 7 functions are exposed
# ===========================================
__all__ = [
    'sync_to_files',          # 캐시 → 파일 동기화
    'sync_from_files',        # 파일 → 캐시 동기화 (deprecated)
    'auto_save',              # 자동 저장
    'force_sync',             # 강제 양방향 동기화
    'save_coding_experience', # 개발 경험 저장
    'search_coding_solutions',# 과거 해결책 검색
    'get_coding_insights'     # 프로젝트 인사이트
]

"""
🔥 바이브 코딩 메모리 시스템 v2.0
========================

바이브코딩에 최적화된 메모리 관리 시스템
- VibeMemoryManager: 바이브 메모리 관리 핵심
- VibeCommandSystem: 바이브 명령어 시스템 (/task, /flow 등)
- 파일 구조 최적화: 7개 → 3개 파일로 간소화

작성자: Claude + 사용자 협업  
생성일: 2025-06-04
리모델링: 2025-06-12 (v2.0)
"""

import os
import json
import datetime as dt
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import sys


def _get_memory_bank_root_from_claude_config() -> str:
    """Claude Desktop 설정에서 MEMORY_BANK_ROOT 동적 읽기"""
    import os
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        # ai-coding-brain-mcp 서버 설정에서 MEMORY_BANK_ROOT 추출
        memory_root = config['mcpServers']['ai-coding-brain-mcp']['env']['MEMORY_BANK_ROOT']
        print(f"✅ Claude Desktop 설정에서 메모리 루트 로드: {memory_root}")
        return memory_root
    except Exception as e:
        print(f"⚠️ Claude 설정 읽기 실패: {e}")
        # 폴백 경로
        fallback_path = r"C:\Users\Administrator\Desktop\memory"
        print(f"📁 폴백 경로 사용: {fallback_path}")
        return fallback_path

def _sync_project_context_with_memory_bank(project_context: Dict[str, Any]) -> None:
    """project_context를 메모리 뱅크와 동기화"""
    memory_root = _get_memory_bank_root_from_claude_config()
    project_name = project_context.get('name', 'common')
    project_memory_path = os.path.join(memory_root, project_name)
    
    # 프로젝트 메모리 폴더 생성
    os.makedirs(project_memory_path, exist_ok=True)
    
    # project_context에 메모리 경로 정보 저장
    project_context['memory_bank'] = {
        'root': memory_root,
        'project_path': project_memory_path,
        'project_name': project_name,
        'last_sync': datetime.now().isoformat(),
        'sync_enabled': True
    }
    
    # sync_status 초기화
    if 'sync_status' not in project_context:
        project_context['sync_status'] = {
            'last_sync': datetime.now().isoformat(),
            'pending_changes': [],
            'auto_sync': True
        }
    
    return project_memory_path

def _ensure_data_compatibility(project_context: Dict[str, Any]) -> Dict[str, Any]:
    """두 시스템의 데이터 구조 호환성 보장"""
    # AI Coding Brain 구조 -> Vibe System 구조 매핑
    if 'vibe_system' not in project_context:
        project_context['vibe_system'] = {}
    
    vibe_sys = project_context['vibe_system']
    
    # current_focus 동기화
    if 'current_focus' in project_context and project_context['current_focus']:
        vibe_sys['current_focus'] = project_context['current_focus']
    elif 'current_focus' not in vibe_sys:
        vibe_sys['current_focus'] = ''
    
    # next_tasks 동기화
    if 'next_tasks' in project_context and project_context['next_tasks']:
        # AI Brain의 단순 문자열 리스트를 Vibe 형식으로 변환
        vibe_tasks = []
        for task in project_context['next_tasks']:
            if isinstance(task, str):
                vibe_tasks.append({
                    'description': task,
                    'added_time': datetime.now().strftime("%H:%M"),
                    'status': 'pending'
                })
            else:
                vibe_tasks.append(task)
        vibe_sys['next_tasks'] = vibe_tasks
    elif 'next_tasks' not in vibe_sys:
        vibe_sys['next_tasks'] = []
    
    # work_tracking 정보도 활용
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        if 'current_focus' in wt and wt['current_focus']:
            vibe_sys['current_focus'] = wt['current_focus']
        if 'next_tasks' in wt and wt['next_tasks']:
            # work_tracking의 tasks도 병합
            for task in wt['next_tasks']:
                if isinstance(task, str) and task not in [t.get('description', t) for t in vibe_sys['next_tasks']]:
                    vibe_sys['next_tasks'].append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
    
    # completed_tasks 초기화
    if 'completed_tasks' not in vibe_sys:
        vibe_sys['completed_tasks'] = []
    
    # session_activities 초기화
    if 'session_activities' not in vibe_sys:
        vibe_sys['session_activities'] = []
    
    return project_context

def _parse_coding_flow_md(file_path: str) -> Dict[str, Any]:
    """coding_flow.md 파일을 파싱해서 딕셔너리로 반환"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        coding_flow = {
            'current_focus': '',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }
        
        lines = content.split('\n')
        current_section = None
        
        for line in lines:
            line_stripped = line.strip()
            
            # 섹션 감지
            if any(marker in line for marker in ['🔥 Current Focus', 'Current Focus', '## 🎯 Current Focus']):
                current_section = 'focus'
            elif any(marker in line for marker in ['⏭️ Next Up', 'Next Up', '## 📋 Next Tasks']):
                current_section = 'next_up'
            elif any(marker in line for marker in ['✅ Completed', 'Completed']):
                current_section = 'completed'
            elif any(marker in line for marker in ['📝 Quick Notes', 'Quick Notes']):
                current_section = 'notes'
            
            # 내용 파싱
            elif current_section == 'focus' and line_stripped and not line_stripped.startswith('#') and not line_stripped.startswith('*'):
                if not coding_flow['current_focus']:
                    coding_flow['current_focus'] = line_stripped
            
            elif current_section == 'next_up':
                if line_stripped.startswith('- [ ]') or line_stripped.startswith('• [ ]'):
                    task = line_stripped[5:].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
            
            elif current_section == 'completed' and (line_stripped.startswith('- [x]') or line_stripped.startswith('• [x]')):
                task = line_stripped[5:].strip()
                if task and task not in coding_flow['completed']:
                    coding_flow['completed'].append(task)
            
            elif current_section == 'notes' and line_stripped and not line_stripped.startswith('#'):
                coding_flow['quick_notes'] += line_stripped + '\n'
        
        coding_flow['quick_notes'] = coding_flow['quick_notes'].strip()
        
        return coding_flow
        
    except Exception as e:
        print(f"⚠️ coding_flow.md 파싱 실패: {e}")
        return {
            'current_focus': 'memory_cache_persistence_system',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }

def _ensure_vibe_memory_structure(memory_path: str) -> bool:
    """바이브 메모리 구조 확인 및 생성"""
    try:
        os.makedirs(memory_path, exist_ok=True)
        return True
    except Exception as e:
        print(f"❌ Error ensuring vibe memory structure: {e}")
        return False

# ===========================================
# 새로운 헬퍼 함수들 (v2.0)
# ===========================================

def calculate_weekly_progress(project_context):
    """주간 진행률 계산"""
    today = datetime.now()
    week_start = today - timedelta(days=today.weekday())
    
    weekly_completed = 0
    total_active = 0
    
    # vibe_system에서 이번 주 완료 작업 계산
    if 'vibe_system' in project_context:
        vibe_sys = project_context['vibe_system']
        
        # 활성 작업 수
        total_active = len(vibe_sys.get('next_tasks', []))
        
        # 이번 주 완료된 작업 수 (간단히 전체 완료 작업 수로 대체)
        weekly_completed = len(vibe_sys.get('completed_tasks', []))
    
    # tasks에서도 카운트
    if 'tasks' in project_context:
        total_active += len(project_context['tasks'].get('next', []))
        weekly_completed += len(project_context['tasks'].get('done', []))
    
    total_tasks = weekly_completed + total_active
    progress_percentage = (weekly_completed / total_tasks * 100) if total_tasks > 0 else 0
    
    return {
        'completed_this_week': weekly_completed,
        'total_active': total_active,
        'total_tasks': total_tasks,
        'progress_percentage': round(progress_percentage, 1)
    }

def get_development_statistics(project_context):
    """개발 통계 생성"""
    stats = {
        'total_completed': 0,
        'total_active': 0,
        'most_edited_files': [],
        'most_edited_functions': [],
        'analyzed_files': 0,
        'total_functions': 0,
        'total_classes': 0
    }
    
    # vibe_system 통계
    if 'vibe_system' in project_context:
        vibe_sys = project_context['vibe_system']
        stats['total_completed'] += len(vibe_sys.get('completed_tasks', []))
        stats['total_active'] += len(vibe_sys.get('next_tasks', []))
    
    # tasks 통계
    if 'tasks' in project_context:
        stats['total_completed'] += len(project_context['tasks'].get('done', []))
        stats['total_active'] += len(project_context['tasks'].get('next', []))
    
    # work_tracking 통계
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        
        # 가장 많이 편집된 파일
        file_edits = wt.get('file_edits', {})
        if file_edits:
            sorted_files = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)[:5]
            stats['most_edited_files'] = [(os.path.basename(f), c) for f, c in sorted_files]
        
        # 가장 많이 편집된 함수
        function_edits = wt.get('function_edits', {})
        if function_edits:
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1].get('count', 0), reverse=True)[:5]
            stats['most_edited_functions'] = [(f, info.get('count', 0)) for f, info in sorted_funcs]
    
    # analyzed_files 통계
    if 'analyzed_files' in project_context:
        analyzed = project_context['analyzed_files']
        stats['analyzed_files'] = len(analyzed)
        
        for file_info in analyzed.values():
            stats['total_functions'] += len(file_info.get('functions', []))
            stats['total_classes'] += len(file_info.get('classes', []))
    
    return stats

def extract_learned_patterns(project_context):
    """코딩 경험에서 패턴 추출"""
    patterns = {
        'bug_fixes': [],
        'optimizations': [],
        'new_features': [],
        'refactoring': [],
        'general': []
    }
    
    # coding_experiences에서 패턴 분류
    experiences = project_context.get('coding_experiences', [])
    for exp in experiences[-50:]:  # 최근 50개만
        if isinstance(exp, dict):
            task = exp.get('task', '').lower()
            solution = exp.get('solution', '')
            
            # 패턴 분류
            if any(word in task for word in ['error', 'fix', 'bug', 'issue']):
                patterns['bug_fixes'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            elif any(word in task for word in ['improve', 'optimize', 'performance']):
                patterns['optimizations'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            elif any(word in task for word in ['add', 'create', 'new', 'feature']):
                patterns['new_features'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            elif any(word in task for word in ['refactor', 'restructure', 'reorganize']):
                patterns['refactoring'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            else:
                patterns['general'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
    
    # 각 카테고리별로 최대 5개만 유지
    for category in patterns:
        patterns[category] = patterns[category][:5]
    
    return patterns

# ===========================================
# 템플릿 함수들 (v2.0 - 확장된 구조)
# ===========================================

def get_vibe_coding_flow_template() -> str:
    """coding_flow.md 템플릿 생성 (확장된 버전)"""
    timestamp = dt.datetime.now().strftime("%Y-%m-%d %H:%M")
    return f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

현재 세션 시작: {timestamp}

## 📅 Today's Tasks
*오늘 할 일*

### Must Do Today
- [ ] 

### In Progress
- 

## ⏭️ Next Up
*다음 작업들*

- [ ] 

## ✅ Today's Completed
*오늘 완료한 일*

- [x] 

## 📝 Quick Notes
*빠른 메모*



## 📊 This Week Progress
*주간 진행률*

- 이번 주 완료: 0개
- 진행률: 0%

## 🕐 Session Activity
*세션 활동 로그*

- {timestamp[:5]} Session started
"""

def get_vibe_feature_roadmap_template() -> str:
    """feature_roadmap.md 템플릿 생성 (확장된 버전)"""
    return """# 🗺️ Feature Roadmap & History

## 🎯 This Sprint Goals
*이번 스프린트 목표*

1. 
2. 
3. 

## ✅ Completed Features
*완료된 기능들*



## 🚀 Planned Features  
*계획된 기능들*



## 📊 Development Statistics
*개발 통계*

### Overall Stats
- Total Completed: 0
- Total Active: 0
- Files Analyzed: 0

### Most Active Files
1. 

### Productivity Insights
- 

## 💡 Learned Patterns
*학습된 패턴*

### Bug Fixes

### Optimizations

### New Features

## 🗂️ Task Archive
*아카이브된 작업들*

"""

def get_vibe_project_vision_template() -> str:
    """project_vision.md 템플릿 생성 (확장된 버전)"""
    return """# 🎯 Project Overview
*이 프로젝트가 뭔지*

## AI-Coding-Brain-MCP
execute_code 기반 24개 헬퍼 함수와 지속적 세션을 활용한 지능형 개발 어시스턴트

## 🏗️ Architecture
*전체 구조와 설계*

### Core Components
- execute_code 시스템 (24개 헬퍼 함수)
- parse_with_snippets 중심 분석
- 연속 세션 상태 관리
- 피드백 기반 학습

## 🛠️ Tech Stack
*사용하는 기술들*

- Python (core logic)
- JavaScript/TypeScript (MCP)
- JSON (data storage)
- Markdown (documentation)

## 📈 Overall Progress
*전체 진행률*

### Current Status
- Progress: 0%
- Active Tasks: 0
- Completed: 0

### Progress Bar
[░░░░░░░░░░] 0%

## 🏆 Major Milestones
*주요 마일스톤*

- [x] Basic helper functions
- [x] parse_with_snippets 구현
- [x] 피드백 시스템
- [x] Vibe Memory System 구현
- [ ] 파일 구조 최적화 (v2.0)

## 🔮 Future Direction
*앞으로의 방향*

- 더 지능적인 코드 분석
- 자동화 확대
- 개발자 경험 개선
"""

# ===========================================
# 동적 경로 처리 헬퍼 함수들
# ===========================================

def get_dynamic_project_paths(project_context: dict) -> dict:
    """프로젝트의 동적 경로 정보 생성"""
    # 1. 프로젝트명 가져오기
    project_name = (project_context.get('project_name') or 
                   project_context.get('name') or 
                   'ai-coding-brain-mcp')
    
    # 2. 메모리 루트 가져오기 (Claude 설정에서)
    memory_root = _get_memory_bank_root_from_claude_config()
    memory_path = os.path.join(memory_root, project_name)
    
    # 3. 코드 경로 (context에서 가져오거나 현재 디렉토리)
    code_path = (project_context.get('code_path') or 
                 project_context.get('base_path') or
                 os.getcwd())
    
    # 4. 필요한 파일 경로들
    return {
        'project_name': project_name,
        'memory_root': memory_root,
        'memory_path': memory_path,
        'code_path': code_path,
        'cache_file': os.path.join(memory_path, '.cache', f'cache_{project_name}.json'),
        'flow_file': os.path.join(memory_path, 'coding_flow.md'),
        'roadmap_file': os.path.join(memory_path, 'feature_roadmap.md'),
        'vision_file': os.path.join(memory_path, 'project_vision.md')
    }

def load_cache_and_sync_flow(paths: dict, project_context: dict) -> dict:
    """캐시와 coding_flow.md를 로드하고 동기화"""
    # 1. 캐시 파일 로드
    if os.path.exists(paths['cache_file']):
        try:
            with open(paths['cache_file'], 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                # 중요한 데이터만 업데이트 (전체 덮어쓰기 방지)
                for key in ['analyzed_files', 'work_tracking', 'symbol_index', 'coding_experiences']:
                    if key in cache_data:
                        project_context[key] = cache_data[key]
        except Exception as e:
            print(f"⚠️ 캐시 로드 실패: {e}")
    
    # 2. coding_flow.md 로드 및 동기화
    if os.path.exists(paths['flow_file']):
        try:
            flow_data = _parse_coding_flow_md(paths['flow_file'])
            # tasks 동기화
            if 'tasks' not in project_context:
                project_context['tasks'] = {}
            project_context['tasks']['next'] = flow_data.get('next_up', [])
            project_context['tasks']['done'] = flow_data.get('completed', [])
            if flow_data.get('current_focus'):
                project_context['current_focus'] = flow_data['current_focus']
        except Exception as e:
            print(f"⚠️ coding_flow.md 로드 실패: {e}")
    
    return project_context

# ===========================================
# 명령어 관련 함수들
# ===========================================

def vibe_task_capture(description: str, project_context: dict) -> str:
    """'/task "설명"' - 즉시 태스크 추가"""
    if not description.strip():
        return "❌ Task description required"
    
    _ensure_data_compatibility(project_context)
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    task_entry = {
        'description': description.strip(),
        'added_time': timestamp,
        'status': 'pending'
    }
    
    # vibe_system에 추가
    if 'vibe_system' in project_context:
        project_context['vibe_system']['next_tasks'].append(task_entry)
    
    # 최상위 next_tasks에도 추가 (AI Brain 호환)
    if 'next_tasks' not in project_context:
        project_context['next_tasks'] = []
    project_context['next_tasks'].append(description.strip())
    
    # work_tracking에도 추가
    if 'work_tracking' in project_context:
        if 'next_tasks' not in project_context['work_tracking']:
            project_context['work_tracking']['next_tasks'] = []
        if description.strip() not in project_context['work_tracking']['next_tasks']:
            project_context['work_tracking']['next_tasks'].append(description.strip())
    
    return f"✅ Task added: {description.strip()}"

def vibe_task_complete(task_description: str, project_context: dict) -> str:
    """'/done "태스크"' - 태스크 완료 처리"""
    if not task_description.strip():
        return "❌ Task description required"
    
    if 'vibe_system' not in project_context:
        return "❌ Vibe system not initialized"
    
    task_desc = task_description.strip()
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    # 진행중인 태스크에서 제거
    vibe_sys = project_context['vibe_system']
    remaining_tasks = []
    task_found = False
    
    for task in vibe_sys.get('next_tasks', []):
        if task.get('description', '') == task_desc:
            task_found = True
            # 완료된 태스크로 이동
            completed_task = task.copy()
            completed_task['completed_time'] = timestamp
            completed_task['status'] = 'completed'
            
            if 'completed_tasks' not in vibe_sys:
                vibe_sys['completed_tasks'] = []
            vibe_sys['completed_tasks'].append(completed_task)
        else:
            remaining_tasks.append(task)
    
    vibe_sys['next_tasks'] = remaining_tasks
    
    if task_found:
        return f"✅ Task completed: {task_desc}"
    else:
        return f"❌ Task not found: {task_desc}"

def vibe_update_focus(new_focus: str, project_context: dict) -> str:
    """'/focus "새포커스"' - 현재 집중 영역 변경"""
    if not new_focus.strip():
        return "❌ Focus description required"
    
    _ensure_data_compatibility(project_context)
    
    # 여러 위치에 업데이트
    if 'vibe_system' in project_context:
        project_context['vibe_system']['current_focus'] = new_focus.strip()
    
    project_context['current_focus'] = new_focus.strip()
    
    if 'work_tracking' in project_context:
        project_context['work_tracking']['current_focus'] = new_focus.strip()
    
    return f"✅ Focus updated: {new_focus.strip()}"

def vibe_get_current_flow(project_context: dict) -> str:
    """'/flow' - 동적 경로 처리와 UserPreferences 형식의 전체 프로젝트 상태"""
    _ensure_data_compatibility(project_context)
    
    # 1. 동적 경로 가져오기
    paths = get_dynamic_project_paths(project_context)
    
    # 2. 현재 디렉토리 저장
    original_cwd = os.getcwd()
    
    try:
        # 3. 메모리 경로로 이동하여 캐시와 .md 파일 로드
        if os.path.exists(paths['memory_path']):
            os.chdir(paths['memory_path'])
            project_context = load_cache_and_sync_flow(paths, project_context)
        
        # 4. UserPreferences 형식으로 출력 생성
        result = []
        result.append("\n🔥 AI Coding Brain - Project Status")
        result.append("="*70)
        
        # 프로젝트 상태 요약
        # 경로 정보 섹션 (프로젝트 루트와 메모리 뱅크 구분)
        result.append("\n📍 경로 정보")
        result.append("-" * 60)
        
        # 1. 프로젝트 루트 (실제 코드)
        project_root = project_context.get("project_path", os.getcwd())
        result.append("프로젝트 루트 (소스 코드):")
        result.append(f"   📂 {project_root}")
        if os.path.exists(project_root):
            result.append("   ✅ 존재함")
            # 주요 디렉토리 표시
            subdirs = []
            for d in ["python", "backup", "tests", ".vscode"]:
                if os.path.exists(os.path.join(project_root, d)):
                    subdirs.append(d)
            if subdirs:
                result.append(f"   └── 하위 디렉토리: {', '.join(subdirs)}")
        else:
            result.append("   ❌ 존재하지 않음 - 경로 확인 필요!")
        
        # 2. 메모리 뱅크 (캐시/상태)
        memory_bank_root = _get_memory_bank_root_from_claude_config()
        project_memory = os.path.join(memory_bank_root, project_context.get("project_name", "unknown"))
        
        result.append("\n메모리 뱅크 (캐시/상태):")
        result.append(f"   💾 {project_memory}")
        if os.path.exists(project_memory):
            result.append("   ✅ 존재함")
            # 캐시 파일 확인
            cache_files = []
            cache_dir = os.path.join(project_memory, ".cache")
            if os.path.exists(cache_dir):
                cache_files = [f for f in os.listdir(cache_dir) if f.endswith(".json")]
            if cache_files:
                result.append(f"   └── 캐시 파일: {', '.join(cache_files)}")
        else:
            result.append("   ⚠️ 아직 생성되지 않음")
        
        result.append("\n📌 프로젝트 상태")
        result.append("-" * 60)
        result.append(f"프로젝트: {paths['project_name']}")
        result.append(f"현재 Focus: {project_context.get('current_focus', 'Not set')}")
        
        # 작업 진행률
        tasks = project_context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total_count = done_count + next_count
        progress = (done_count / total_count * 100) if total_count > 0 else 0
        result.append(f"작업 진행률: {progress:.1f}% ({done_count}/{total_count})")
        
        # 분석된 코드 구조
        result.append("\n📊 분석된 코드 구조 (프로젝트 루트)")
        result.append("-" * 60)
        
        analyzed_files = project_context.get('analyzed_files', {})
        if analyzed_files:
            total_functions = 0
            total_classes = 0
            
            # 파일명으로 정렬
            sorted_files = sorted(analyzed_files.items(), key=lambda x: os.path.basename(x[0]))[:5]
            
            for file_path, info in sorted_files:
                file_name = os.path.basename(file_path)
                
                # info가 dict인지 확인
                if isinstance(info, dict):
                    functions = info.get('functions', [])
                    classes = info.get('classes', [])
                    
                    total_functions += len(functions)
                    total_classes += len(classes)
                    
                    result.append(f"\n📄 {file_name}")
                    result.append(f"   • 함수: {len(functions)}개")
                    if functions[:3]:
                        for func in functions[:3]:
                            func_name = func.get('name', func) if isinstance(func, dict) else str(func)
                            result.append(f"     - {func_name}")
                        if len(functions) > 3:
                            result.append(f"     ... 외 {len(functions)-3}개")
                    
                    if classes:
                        result.append(f"   • 클래스: {len(classes)}개")
                        for cls in classes[:2]:
                            cls_name = cls.get('name', cls) if isinstance(cls, dict) else str(cls)
                            result.append(f"     - {cls_name}")
                        if len(classes) > 2:
                            result.append(f"     ... 외 {len(classes)-2}개")
                else:
                    # info가 string이거나 다른 타입인 경우
                    result.append(f"\n📄 {file_name}")
                    result.append(f"   • 타입: {type(info).__name__}")
                    if isinstance(info, str):
                        result.append(f"   • 정보: {info[:50]}...") if len(str(info)) > 50 else result.append(f"   • 정보: {info}")
            
            # 전체 파일 통계 계산
            all_analyzed = project_context.get('analyzed_files', {})
            all_total_functions = 0
            all_total_classes = 0
            
            for file_info in all_analyzed.values():
                if isinstance(file_info, dict):
                    all_total_functions += len(file_info.get('functions', []))
                    all_total_classes += len(file_info.get('classes', []))
            
            result.append(f"\n📈 전체 통계:")
            result.append(f"   • 분석된 파일: {len(analyzed_files)}개")
            result.append(f"   • 총 함수: {all_total_functions}개")
            result.append(f"   • 총 클래스: {all_total_classes}개")
        else:
            result.append("   ⚠️ 아직 분석된 파일이 없습니다.")
        
        # 작업 추적 정보
        result.append("\n🔄 작업 추적 정보")
        result.append("-" * 60)
        
        work_tracking = project_context.get('work_tracking', {})
        if work_tracking:
            file_edits = work_tracking.get('file_edits', {})
            if file_edits:
                result.append("최근 편집한 파일:")
                sorted_files = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)[:5]
                for file_path, count in sorted_files:
                    result.append(f"   • {os.path.basename(file_path)}: {count}회 편집")
            
            function_edits = work_tracking.get('function_edits', {})
            if function_edits:
                result.append("\n최근 편집한 함수:")
                sorted_funcs = sorted(function_edits.items(), 
                                    key=lambda x: x[1].get('count', 0), reverse=True)[:5]
                for func_key, info in sorted_funcs:
                    count = info.get('count', 0)
                    # 파일명과 함수명 분리
                    if ':' in func_key:
                        file_part, func_name = func_key.split(':', 1)
                        file_name = os.path.basename(file_part)
                        result.append(f"   • {file_name}:{func_name}: {count}회 편집")
                    else:
                        result.append(f"   • {func_key}: {count}회 편집")
        
        # 메모리뱅크 정보
        result.append("\n💾 메모리뱅크 정보 (캐시/상태)")
        result.append("-" * 60)
        
        experiences = project_context.get('coding_experiences', [])
        if experiences:
            result.append(f"저장된 경험: {len(experiences)}개")
            for exp in experiences[-3:]:
                task = exp.get('task', 'Unknown')
                solution = exp.get('solution', 'N/A')[:50]
                result.append(f"   • {task}: {solution}...")
        else:
            result.append("   ℹ️ 아직 저장된 경험이 없습니다.")
        
        # 로드맵과 다음 단계
        result.append("\n🎯 로드맵과 다음 단계")
        result.append("-" * 60)
        
        if project_context.get('current_focus'):
            result.append(f"현재 Focus: {project_context['current_focus']}")
        
        next_tasks = tasks.get('next', [])
        if next_tasks:
            result.append("\n📋 다음 작업들:")
            
            # Phase별로 그룹화 시도
            phases = {}
            no_phase_tasks = []
            
            for task in next_tasks:
                import re
                phase_match = re.match(r'\[(.+?)\]', task)
                if phase_match:
                    phase = phase_match.group(1)
                    if phase not in phases:
                        phases[phase] = []
                    phases[phase].append(task)
                else:
                    no_phase_tasks.append(task)
            
            # Phase별로 표시
            task_count = 0
            for phase, phase_tasks in phases.items():
                if task_count >= 10:
                    break
                result.append(f"\n   📁 {phase}:")
                for task in phase_tasks[:3]:
                    task_count += 1
                    task_name = task.split('] ')[1] if '] ' in task else task
                    result.append(f"      • {task_name}")
                    if task_count >= 10:
                        break
            
            # Phase가 없는 작업들
            for i, task in enumerate(no_phase_tasks[:max(0, 10-task_count)], task_count+1):
                result.append(f"   {i}. {task}")
        else:
            result.append("\n   ℹ️ 다음 작업이 없습니다. /task 명령으로 추가하세요.")
        
        done_tasks = tasks.get('done', [])
        if done_tasks:
            result.append("\n✅ 최근 완료:")
            for task in done_tasks[-3:]:
                result.append(f"   • {task}")
        
        # 경로 정보 (디버깅용)
        result.append("\n" + "="*70)
        result.append("📁 프로젝트 경로:")
        result.append(f"   • 코드: {paths['code_path']}")
        result.append(f"   • 메모리: {paths['memory_path']}")
        
        return "\n".join(result)
        
    except Exception as e:
        return f"❌ Error in /flow: {str(e)}\n경로: {paths}"
    finally:
        # 원래 디렉토리로 복원
        os.chdir(original_cwd)

def vibe_execute_code_hook(func_name: str, result: dict, project_context: dict):
    """execute_code 실행 후 자동 호출 훅"""
    if 'vibe_system' not in project_context:
        return
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    activity = {
        'function': func_name,
        'timestamp': timestamp,
        'summary': f"Executed {func_name}"
    }
    
    # 함수별 특별 처리
    if func_name == 'parse_with_snippets' and isinstance(result, dict):
        file_path = result.get('file_path', 'unknown')
        functions_count = len(result.get('functions', []))
        activity['summary'] = f"Analyzed {functions_count} functions in {os.path.basename(file_path)}"
        project_context['vibe_system']['current_focus'] = f"Analyzing: {os.path.basename(file_path)}"
    
    elif func_name in ['safe_replace', 'insert_line', 'delete_lines']:
        file_path = result.get('file_path', 'unknown')
        activity['summary'] = f"Code modification: {func_name}"
        project_context['vibe_system']['current_focus'] = f"Modifying: {os.path.basename(file_path)}"
    
    # 세션 활동에 추가
    if 'session_activities' not in project_context['vibe_system']:
        project_context['vibe_system']['session_activities'] = []
    
    project_context['vibe_system']['session_activities'].append(activity)
    
    # 최근 20개만 유지
    if len(project_context['vibe_system']['session_activities']) > 20:
        project_context['vibe_system']['session_activities'] = project_context['vibe_system']['session_activities'][-20:]

# ===========================================
# VibeMemoryManager 클래스 (v2.0)
# ===========================================

class VibeMemoryManager:
    """바이브코딩 메모리 관리자 (v2.0 - 3개 파일로 최적화)"""
    
    def __init__(self, project_context: dict, project_name: str = None):
        """Claude Desktop 설정 기반 VibeMemoryManager 초기화"""
        self.project_context = project_context

        # 데이터 구조 호환성 보장
        _ensure_data_compatibility(self.project_context)

        # project_context에서 프로젝트명 가져오기
        self.project_name = project_name or project_context.get("name", "ai-coding-brain-mcp")

        # Claude Desktop 설정 기반 경로 설정
        self.memory_bank_root = _get_memory_bank_root_from_claude_config()
        self.memory_path = os.path.join(self.memory_bank_root, self.project_name)

        # project_context와 연동
        _sync_project_context_with_memory_bank(self.project_context)

        # 3개 파일 템플릿 설정 (v2.0)
        self.templates = {
            "coding_flow.md": get_vibe_coding_flow_template(),
            "feature_roadmap.md": get_vibe_feature_roadmap_template(),
            "project_vision.md": get_vibe_project_vision_template()
        }

        # 메모리 뱅크 초기화
        self.initialize()

        print(f"✅ VibeMemoryManager v2.0 초기화 완료: {self.memory_path}")
    
    def initialize(self) -> bool:
        """바이브 메모리 시스템 초기화"""
        try:
            # 메모리 폴더 생성
            _ensure_vibe_memory_structure(self.memory_path)
            
            # project_context에 vibe_system 초기화
            if 'vibe_system' not in self.project_context:
                self.project_context['vibe_system'] = {
                    'next_tasks': [],
                    'completed_tasks': [],
                    'current_focus': 'Vibe Memory System v2.0 activated',
                    'session_activities': [],
                    'status': 'active',
                    'initialized_at': dt.datetime.now().isoformat()
                }
            
            # 마크다운 파일들 생성 (3개만)
            created_files = []
            for filename, template in self.templates.items():
                filepath = os.path.join(self.memory_path, filename)
                if not os.path.exists(filepath):
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(template)
                    created_files.append(filename)
            
            print(f"✅ Vibe Memory System v2.0 initialized")
            print(f"   📁 Path: {self.memory_path}")
            print(f"   📄 Files: {len(self.templates)} markdown files")
            if created_files:
                print(f"   🆕 Created: {', '.join(created_files)}")
            
            return True
            
        except Exception as e:
            print(f"❌ Vibe initialization error: {e}")
            return False
    
    def get_status(self) -> dict:
        """현재 바이브 시스템 상태 반환"""
        if 'vibe_system' not in self.project_context:
            return {'status': 'not_initialized'}
        
        vibe_sys = self.project_context['vibe_system']
        weekly_stats = calculate_weekly_progress(self.project_context)
        
        return {
            'status': vibe_sys.get('status', 'unknown'),
            'current_focus': vibe_sys.get('current_focus', ''),
            'pending_tasks': len(vibe_sys.get('next_tasks', [])),
            'completed_tasks': len(vibe_sys.get('completed_tasks', [])),
            'recent_activities': len(vibe_sys.get('session_activities', [])),
            'weekly_progress': weekly_stats['progress_percentage'],
            'memory_path': self.memory_path
        }

    def sync_to_files(self):
        """캐시메모리 → .md 파일 동기화 (3개 파일만)"""
        try:
            _ensure_data_compatibility(self.project_context)
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            sync_results = []
            
            # 1. coding_flow.md 업데이트 (확장된 버전)
            flow_content = self._generate_enhanced_flow_content(vibe_sys)
            flow_path = os.path.join(self.memory_path, 'coding_flow.md')
            with open(flow_path, 'w', encoding='utf-8') as f:
                f.write(flow_content)
            sync_results.append("✅ Updated coding_flow.md")
            
            # 2. feature_roadmap.md 업데이트 (통계 포함)
            roadmap_content = self._generate_enhanced_roadmap_content(vibe_sys)
            roadmap_path = os.path.join(self.memory_path, 'feature_roadmap.md')
            with open(roadmap_path, 'w', encoding='utf-8') as f:
                f.write(roadmap_content)
            sync_results.append("✅ Updated feature_roadmap.md")
            
            # 3. project_vision.md 업데이트 (진행률 포함)
            vision_content = self._generate_enhanced_vision_content(vibe_sys)
            vision_path = os.path.join(self.memory_path, 'project_vision.md')
            with open(vision_path, 'w', encoding='utf-8') as f:
                f.write(vision_content)
            sync_results.append("✅ Updated project_vision.md")
            
            # 동기화 시간 기록
            vibe_sys['last_sync_to_files'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'synced_files': len(sync_results),
                'results': sync_results,
                'timestamp': vibe_sys['last_sync_to_files']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_from_files(self):
        """.md 파일을 캐시메모리로 동기화 (deprecated)"""
        print("⚠️ [DEPRECATED] sync_from_files: v2.0부터 사용되지 않습니다.")
        print("   데이터 흐름은 항상 'Context Manager -> .md파일' 단방향으로 유지됩니다.")
        return {
            'status': 'deprecated', 
            'message': 'This function is deprecated in v2.0'
        }
    
    def auto_save(self, interval=300):
        """자동 저장 (기본 5분 간격)"""
        try:
            sync_result = self.sync_to_files()
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            vibe_sys['auto_save_interval'] = interval
            vibe_sys['last_auto_save'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'message': f'Auto-save completed (interval: {interval}s)',
                'sync_result': sync_result,
                'timestamp': vibe_sys['last_auto_save']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def force_sync(self):
        """강제 동기화 (캐시 -> 파일)"""
        try:
            print("🔄 강제 동기화 (Cache -> Files) 실행...")
            
            to_files_result = self.sync_to_files()
            
            if to_files_result:
                print("✅ 단방향 동기화 완료 (Cache → Files)")
                return {
                    'status': 'success',
                    'message': 'Unidirectional sync completed (cache to files)',
                    'direction': 'cache_to_files',
                    'to_files': to_files_result,
                    'timestamp': dt.datetime.now().isoformat()
                }
            else:
                return {'status': 'failed', 'message': 'sync_to_files failed'}
                
        except Exception as e:
            print(f"❌ 동기화 중 오류: {str(e)}")
            return {'status': 'error', 'message': str(e)}
    
    def _generate_enhanced_flow_content(self, vibe_sys):
        """coding_flow.md 내용 생성 (확장된 버전)"""
        current_focus = vibe_sys.get('current_focus', '')
        if not current_focus and 'work_tracking' in self.project_context:
            current_focus = self.project_context['work_tracking'].get('current_focus', '')
        if not current_focus:
            current_focus = 'No current focus set'
        
        # 주간 진행률
        weekly_stats = calculate_weekly_progress(self.project_context)
        
        # 오늘의 작업 분류
        today_tasks = []
        next_tasks = []
        completed_today = []
        
        # 모든 작업을 오늘 작업으로 간주 (시간 정보가 없으므로)
        for task in vibe_sys.get('next_tasks', []):
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            today_tasks.append(desc)
        
        for task in vibe_sys.get('completed_tasks', []):
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            completed_today.append(desc)
        
        content = f"""# 🔥 Current Focus
*지금 뭐하고 있는지*

{current_focus}

## 📅 Today's Tasks
*오늘 할 일*

### Must Do Today
"""
        for task in today_tasks[:5]:  # 상위 5개
            content += f"- [ ] {task}\n"
        
        content += f"""
### In Progress
- {current_focus}

## ⏭️ Next Up ({len(today_tasks)} tasks)
*다음 작업들*

"""
        for task in today_tasks[5:15]:  # 6-15번째 작업
            content += f"- [ ] {task}\n"
        
        content += f"""
## ✅ Today's Completed ({len(completed_today)} tasks)
*오늘 완료한 일*

"""
        for task in completed_today[-10:]:  # 최근 10개
            content += f"- [x] {task}\n"
        
        content += f"""
## 📝 Quick Notes
*빠른 메모*



## 📊 This Week Progress
*주간 진행률*

- 이번 주 완료: {weekly_stats['completed_this_week']}개
- 활성 작업: {weekly_stats['total_active']}개
- 진행률: {weekly_stats['progress_percentage']}%

Progress: [{'█' * int(weekly_stats['progress_percentage']/10)}{'░' * (10-int(weekly_stats['progress_percentage']/10))}] {weekly_stats['progress_percentage']}%

## 🕐 Session Activity
*세션 활동 로그*

"""
        # 세션 활동
        activities = vibe_sys.get('session_activities', [])
        for activity in activities[-10:]:  # 최근 10개
            content += f"- {activity.get('timestamp', '')}: {activity.get('summary', '')}\n"
        
        content += f"\n마지막 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        return content
    
    def _generate_enhanced_roadmap_content(self, vibe_sys):
        """feature_roadmap.md 내용 생성 (통계 포함)"""
        # 개발 통계
        stats = get_development_statistics(self.project_context)
        
        # 학습된 패턴
        patterns = extract_learned_patterns(self.project_context)
        
        content = """# 🗺️ Feature Roadmap & History

## 🎯 This Sprint Goals
*이번 스프린트 목표*

"""
        # 상위 3개 작업을 스프린트 목표로
        next_tasks = vibe_sys.get('next_tasks', [])
        for i, task in enumerate(next_tasks[:3], 1):
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            content += f"{i}. {desc}\n"
        
        content += f"""
## ✅ Completed Features ({len(vibe_sys.get('completed_tasks', []))})
*완료된 기능들*

"""
        # 최근 완료 작업
        for task in vibe_sys.get('completed_tasks', [])[-20:]:
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            content += f"- [x] {desc}\n"
        
        content += """
## 🚀 Planned Features  
*계획된 기능들*

"""
        # 향후 계획
        for task in next_tasks[3:10]:  # 4-10번째 작업
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            content += f"- [ ] {desc}\n"
        
        content += f"""
## 📊 Development Statistics
*개발 통계*

### Overall Stats
- Total Completed: {stats['total_completed']}
- Total Active: {stats['total_active']}
- Files Analyzed: {stats['analyzed_files']}
- Total Functions: {stats['total_functions']}
- Total Classes: {stats['total_classes']}

### Most Active Files
"""
        for i, (file, count) in enumerate(stats['most_edited_files'], 1):
            content += f"{i}. {file} ({count}회 편집)\n"
        
        content += """
### Most Edited Functions
"""
        for i, (func, count) in enumerate(stats['most_edited_functions'], 1):
            content += f"{i}. {func} ({count}회 수정)\n"
        
        content += """
## 💡 Learned Patterns
*학습된 패턴*

"""
        # 패턴별 출력
        for category, items in patterns.items():
            if items:
                content += f"### {category.replace('_', ' ').title()}\n"
                for item in items:
                    content += f"- **{item['task']}**: {item['solution']}\n"
                content += "\n"
        
        content += f"""
## 🗂️ Task Archive
*30일 이상 된 작업들은 자동으로 아카이브됩니다*

마지막 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        return content
    
    def _generate_enhanced_vision_content(self, vibe_sys):
        """project_vision.md 내용 생성 (진행률 포함)"""
        # 전체 진행률 계산
        weekly_stats = calculate_weekly_progress(self.project_context)
        
        # 개발 통계
        stats = get_development_statistics(self.project_context)
        
        content = f"""# 🎯 Project Overview
*이 프로젝트가 뭔지*

## AI-Coding-Brain-MCP v2.0
execute_code 기반 헬퍼 함수와 지속적 세션을 활용한 지능형 개발 어시스턴트
- 파일 구조 최적화: 7개 → 3개 파일로 간소화
- 실시간 상태 추적 및 자동 동기화
- 개발 패턴 학습 및 재사용

## 🏗️ Architecture
*전체 구조와 설계*

### Core Components
- execute_code 시스템 (24개 헬퍼 함수)
- parse_with_snippets 중심 분석
- Vibe Memory System v2.0 (3개 파일 구조)
- 연속 세션 상태 관리
- 피드백 기반 학습

### File Structure (v2.0)
```
memory_bank/
└── {self.project_name}/
    ├── coding_flow.md      # 일일 작업 & 실시간 상태
    ├── feature_roadmap.md  # 기능 이력 & 장기 계획
    └── project_vision.md   # 프로젝트 정체성 & 현황
```

## 🛠️ Tech Stack
*사용하는 기술들*

- Python (core logic)
- JavaScript/TypeScript (MCP)
- JSON (data storage)
- Markdown (documentation)

## 📈 Overall Progress
*전체 진행률*

### Current Status
- Progress: {weekly_stats['progress_percentage']}%
- Active Tasks: {stats['total_active']}
- Completed: {stats['total_completed']}
- Analyzed Files: {stats['analyzed_files']}

### Progress Bar
[{'█' * int(weekly_stats['progress_percentage']/10)}{'░' * (10-int(weekly_stats['progress_percentage']/10))}] {weekly_stats['progress_percentage']}%

### Key Metrics
- Total Functions: {stats['total_functions']}
- Total Classes: {stats['total_classes']}
- Code Coverage: {stats['analyzed_files']} files analyzed

## 🏆 Major Milestones
*주요 마일스톤*

- [x] Basic helper functions
- [x] parse_with_snippets 구현
- [x] 피드백 시스템
- [x] Vibe Memory System v1.0 구현
- [x] 파일 구조 최적화 v2.0 (3개 파일)
- [ ] 실시간 동기화 시스템
- [ ] AI 패턴 학습 강화
- [ ] 다중 프로젝트 지원

## 🔮 Future Direction
*앞으로의 방향*

### Short Term (1-2 weeks)
- 실시간 파일 변경 감지
- 자동 코드 리뷰 시스템
- 테스트 자동화

### Long Term (1-3 months)  
- AI 기반 코드 생성
- 팀 협업 기능
- 플러그인 시스템

마지막 업데이트: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        return content

# ===========================================
# VibeCommandSystem 클래스 (v2.0)
# ===========================================

class VibeCommandSystem:
    """바이브 명령어 시스템"""
    
    def __init__(self, project_context: dict):
        self.project_context = project_context
        self.commands = {
            '/task': self._cmd_task,
            '/flow': self._cmd_flow,
            '/done': self._cmd_done,
            '/focus': self._cmd_focus,
            '/roadmap': self._cmd_roadmap,
            '/vision': self._cmd_vision,
            '/stats': self._cmd_stats,
            'help': self._cmd_help
        }
    
    def execute(self, command_line: str) -> str:
        """명령어 실행"""
        if not isinstance(command_line, str):
            return f"❌ Invalid command type: expected str, got {type(command_line).__name__}"
        
        if not command_line.strip():
            return "❌ Command required. Type 'help' for usage."
        
        command_line = command_line.strip()
        
        # 명령어 파싱
        if command_line == 'help':
            return self._cmd_help()
        elif command_line.startswith('/'):
            parts = command_line.split(' ', 1)
            cmd = parts[0]
            arg = parts[1].strip('\"') if len(parts) > 1 else ""
            
            if cmd in self.commands:
                try:
                    return self.commands[cmd](arg)
                except Exception as e:
                    return f"❌ Error executing {cmd}: {e}"
            else:
                return f"❌ Unknown command: {cmd}. Type 'help' for available commands."
        else:
            return f"❌ Commands must start with '/'. Type 'help' for usage."
    
    def _cmd_task(self, description: str) -> str:
        """'/task "설명"' 명령어"""
        return vibe_task_capture(description, self.project_context)
    
    def _cmd_flow(self, _: str = "") -> str:
        """'/flow' 명령어"""
        return vibe_get_current_flow(self.project_context)
    
    def _cmd_done(self, task_description: str) -> str:
        """'/done "태스크"' 명령어"""
        return vibe_task_complete(task_description, self.project_context)
    
    def _cmd_focus(self, new_focus: str) -> str:
        """'/focus "새포커스"' 명령어"""
        return vibe_update_focus(new_focus, self.project_context)
    
    def _cmd_roadmap(self, _: str = "") -> str:
        """'/roadmap' 명령어"""
        stats = get_development_statistics(self.project_context)
        
        result = "🗂️ FEATURE ROADMAP:\n" + "="*40 + "\n"
        result += f"\n📊 Statistics:\n"
        result += f"  • Completed: {stats['total_completed']}\n"
        result += f"  • Active: {stats['total_active']}\n"
        result += f"  • Files Analyzed: {stats['analyzed_files']}\n"
        
        return result
    
    def _cmd_vision(self, _: str = "") -> str:
        """'/vision' 명령어"""
        return """🎯 PROJECT VISION:
AI-Coding-Brain-MCP v2.0
- Optimized file structure (3 files)
- Real-time sync and tracking
- Pattern learning system
"""
    
    def _cmd_stats(self, _: str = "") -> str:
        """'/stats' 명령어 - 개발 통계"""
        stats = get_development_statistics(self.project_context)
        weekly = calculate_weekly_progress(self.project_context)
        
        result = "📊 DEVELOPMENT STATISTICS:\n" + "="*40 + "\n"
        result += f"\n📈 Progress: {weekly['progress_percentage']}%\n"
        result += f"  • Completed: {stats['total_completed']}\n"
        result += f"  • Active: {stats['total_active']}\n"
        result += f"\n📁 Code Analysis:\n"
        result += f"  • Files: {stats['analyzed_files']}\n"
        result += f"  • Functions: {stats['total_functions']}\n"
        result += f"  • Classes: {stats['total_classes']}\n"
        
        return result
    
    def _cmd_help(self) -> str:
        """도움말 명령어"""
        return """🔥 VIBE CODING MEMORY SYSTEM v2.0
================================================================

📋 바이브 명령어:
  /task "설명"        → 즉시 태스크 추가
  /flow              → 현재 코딩 플로우 보기
  /done "태스크"      → 태스크 완료 처리
  /focus "새포커스"   → 현재 집중 영역 변경
  /roadmap           → 기능 로드맵 보기
  /vision            → 프로젝트 비전 보기
  /stats             → 개발 통계 보기
  help               → 이 도움말

⚡ v2.0 개선사항:
  • 파일 구조 최적화 (7개 → 3개)
  • 주간 진행률 추적
  • 개발 통계 강화
  • 패턴 학습 시스템

🚀 시작하기: vibe_system.initialize() 실행 후 사용!
================================================================"""

# ===========================================
# 전역 함수들
# ===========================================

def initialize_vibe_system(project_context: dict, project_name: str = 'ai-coding-brain-mcp') -> tuple:
    """바이브 시스템 초기화 및 반환"""
    vibe_manager = VibeMemoryManager(project_context, project_name)
    vibe_commands = VibeCommandSystem(project_context)
    
    success = vibe_manager.initialize()
    
    return vibe_manager, vibe_commands, success

def register_vibe_helpers():
    """바이브 헬퍼 함수들을 전역에 등록"""
    # 헬퍼 함수들을 globals에 추가
    globals()['_ensure_data_compatibility'] = _ensure_data_compatibility
    globals()['_parse_coding_flow_md'] = _parse_coding_flow_md
    globals()['calculate_weekly_progress'] = calculate_weekly_progress
    globals()['get_development_statistics'] = get_development_statistics
    globals()['extract_learned_patterns'] = extract_learned_patterns
    
    print("✅ Vibe helper functions registered globally", file=sys.stderr)
    return True

def enable_auto_sync_for_project_context(project_context):
    """project_context에 auto_sync 활성화"""
    try:
        if 'sync_status' not in project_context:
            project_context['sync_status'] = {
                'last_sync': datetime.now().isoformat(),
                'pending_changes': [],
                'auto_sync': True
            }
        
        project_context['sync_status']['auto_sync'] = True
        print("✅ Auto-sync 활성화됨")
        
        return True
    except Exception as e:
        print(f"❌ Auto-sync 활성화 실패: {e}")
        return False

# ===========================================
# Global Claude Memory Functions
# ===========================================

def save_coding_experience(data, project_context=None, tech_stack=None, importance=0.7):
    """개발 경험 자동 저장"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        # 데이터 구조화
        if isinstance(data, str):
            structured_data = {
                'task': data,
                'solution': '',
                'tech_stack': tech_stack or ['Python'],
                'importance': importance,
                'timestamp': datetime.now().isoformat()
            }
        else:
            structured_data = data
            structured_data['importance'] = importance
            structured_data['timestamp'] = datetime.now().isoformat()
        
        # coding_experiences에 추가
        if 'coding_experiences' not in project_context:
            project_context['coding_experiences'] = []
        
        project_context['coding_experiences'].append(structured_data)
        
        # 최근 100개만 유지
        if len(project_context['coding_experiences']) > 100:
            project_context['coding_experiences'] = project_context['coding_experiences'][-100:]
        
        return {"status": "success", "message": "Experience saved"}
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def search_coding_solutions(query, project_context=None, tech_stack=None, limit=10):
    """과거 해결책 검색"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        experiences = project_context.get('coding_experiences', [])
        results = []
        
        # 간단한 키워드 매칭
        query_lower = query.lower()
        for exp in experiences:
            if isinstance(exp, dict):
                task = exp.get('task', '').lower()
                solution = exp.get('solution', '').lower()
                
                if query_lower in task or query_lower in solution:
                    results.append(exp)
        
        # 최근 것부터 반환
        results = results[-limit:]
        results.reverse()
        
        return {"status": "success", "results": results}
        
    except Exception as e:
        return {"status": "error", "message": str(e), "results": []}

def get_coding_insights(project_context=None, tech_stack=None, time_range=30):
    """프로젝트별 인사이트"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        stats = get_development_statistics(project_context)
        patterns = extract_learned_patterns(project_context)
        
        insights = {
            "status": "success",
            "statistics": stats,
            "patterns": patterns,
            "recommendations": []
        }
        
        # 추천사항 생성
        if stats['total_active'] > 20:
            insights['recommendations'].append("활성 작업이 많습니다. 우선순위를 정리하세요.")
        
        if stats['analyzed_files'] < 5:
            insights['recommendations'].append("더 많은 파일을 분석하여 전체 구조를 파악하세요.")
        
        return insights
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

# ===========================================
# __all__ 선언된 함수들 구현 (VibeMemoryManager 래퍼)
# ===========================================

def sync_to_files():
    """캐시메모리를 .md 파일로 동기화"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].sync_to_files()
    else:
        print('⚠️ vibe_manager가 초기화되지 않음')
        return False

def sync_from_files():
    """.md 파일을 캐시메모리로 동기화 (deprecated)"""
    print("⚠️ [DEPRECATED] sync_from_files: v2.0부터 사용되지 않습니다.")
    return {'status': 'deprecated', 'message': 'This function is deprecated in v2.0'}

def auto_save(interval=300):
    """자동 저장 활성화"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].auto_save(interval)
    else:
        print('⚠️ vibe_manager가 초기화되지 않음')
        return False

def force_sync():
    """강제 동기화"""
    project_context = globals().get('project_context', {})
    if not project_context:
        return {'status': 'error', 'message': 'project_context not found'}
    
    _ensure_data_compatibility(project_context)
    
    if 'vibe_manager' not in globals():
        globals()['vibe_manager'] = VibeMemoryManager(project_context)
    
    return globals()['vibe_manager'].force_sync()

# 자동 등록
if __name__ == "__main__":
    register_vibe_helpers()
    print("🔥 Vibe Memory System v2.0 loaded!")
