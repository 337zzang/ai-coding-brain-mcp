# -*- coding: utf-8 -*-
"""
AST Parser Helper - Refactored Version
Python: ast.parse() ê¸°ë°˜ íŒŒì‹±
JavaScript/TypeScript: Tree-sitter ì§€ì—° ë¡œë”© íŒŒì‹±  
"""

import ast
import os
import time
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, cast
import textwrap
import re

# ============================================================================
# ì „ì—­ ì„¤ì • ë° ìºì‹œ
# ============================================================================

# Tree-sitter ì§€ì—° ë¡œë”©
TREE_SITTER_AVAILABLE = False
_tree_sitter_modules = {}
_advanced_parser = None
_parser_lock = threading.Lock()

# ë¡œê¹… ì„¤ì •
VERBOSE = False

def set_verbose(flag: bool) -> None:
    """ì „ì—­ verbose ëª¨ë“œ ì„¤ì •"""
    global VERBOSE
    VERBOSE = flag

def get_verbose() -> bool:
    """í˜„ì¬ verbose ëª¨ë“œ ìƒíƒœ ë°˜í™˜"""
    return VERBOSE

def _log(msg: str, level: str = "INFO") -> None:
    """ì¡°ê±´ë¶€ ë¡œê¹…"""
    if VERBOSE:
        print(f"[{level}] {msg}")

# ============================================================================
# í†µí•© ìºì‹œ ì‹œìŠ¤í…œ
# ============================================================================

class CacheManager:
    """ëª¨ë“  ìºì‹œë¥¼ ì¤‘ì•™ì—ì„œ ê´€ë¦¬"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.ast_cache: Dict[str, Any] = {}
            self.file_mtime_cache: Dict[str, float] = {}
            self.language_cache: Dict[str, Any] = {}
            self.parser_cache: Dict[str, Any] = {}
            self.initialized = True
    
    def get_cached_ast(self, file_path: str) -> Optional[Any]:
        """ìºì‹œëœ AST ë°˜í™˜"""
        if file_path not in self.ast_cache:
            return None
            
        # íŒŒì¼ ìˆ˜ì • ì‹œê°„ í™•ì¸
        try:
            current_mtime = os.path.getmtime(file_path)
            cached_mtime = self.file_mtime_cache.get(file_path, 0)
            
            if current_mtime > cached_mtime:
                # ìºì‹œ ë¬´íš¨í™”
                del self.ast_cache[file_path]
                return None
                
            return self.ast_cache[file_path]
        except:
            return None
    
    def set_cached_ast(self, file_path: str, ast_data: Any):
        """AST ìºì‹œ ì €ì¥"""
        self.ast_cache[file_path] = ast_data
        self.file_mtime_cache[file_path] = os.path.getmtime(file_path)
    
    def clear_all(self):
        """ëª¨ë“  ìºì‹œ ì´ˆê¸°í™”"""
        self.ast_cache.clear()
        self.file_mtime_cache.clear()
        self.language_cache.clear()
        self.parser_cache.clear()

# ============================================================================
# Tree-sitter ì§€ì—° ë¡œë”©
# ============================================================================

def _lazy_import_tree_sitter() -> bool:
    """Tree-sitter ëª¨ë“ˆ ì§€ì—° ì„í¬íŠ¸"""
    global TREE_SITTER_AVAILABLE, _tree_sitter_modules
    
    if _tree_sitter_modules:
        return True
        
    try:
        import tree_sitter
        import tree_sitter_python
        import tree_sitter_javascript
        
        _tree_sitter_modules['tree_sitter'] = tree_sitter
        _tree_sitter_modules['python'] = tree_sitter_python
        _tree_sitter_modules['javascript'] = tree_sitter_javascript
        
        TREE_SITTER_AVAILABLE = True
        _log("Tree-sitter ëª¨ë“ˆ ë¡œë“œ ì„±ê³µ")
        return True
    except ImportError as e:
        _log(f"Tree-sitter ë¡œë“œ ì‹¤íŒ¨: {e}", "WARNING")
        return False

class TreeSitterManager:
    """Tree-sitter íŒŒì„œ ê´€ë¦¬"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self._parsers = {}
            self.initialized = True
    
    def get_parser(self, language: str):
        """ì–¸ì–´ë³„ íŒŒì„œ ë°˜í™˜"""
        if not _lazy_import_tree_sitter():
            return None
            
        if language not in self._parsers:
            self._parsers[language] = self._create_parser(language)
            
        return self._parsers[language]
    
    def _create_parser(self, language: str):
        """íŒŒì„œ ìƒì„±"""
        tree_sitter = _tree_sitter_modules.get('tree_sitter')
        if not tree_sitter:
            return None
            
        parser = tree_sitter.Parser()
        
        lang_map = {
            'python': 'python',
            'javascript': 'javascript',
            'typescript': 'javascript'
        }
        
        lang_key = lang_map.get(language)
        if not lang_key:
            return None
            
        lang_module = _tree_sitter_modules.get(lang_key)
        if lang_module:
            parser.set_language(lang_module.Language())
            return parser
            
        return None

# ============================================================================
# AST Parser ë©”ì¸ í´ë˜ìŠ¤
# ============================================================================

class FunctionReplacer(ast.NodeTransformer):
    """
    AST íŠ¸ë¦¬ì—ì„œ íŠ¹ì • ì´ë¦„ì„ ê°€ì§„ í•¨ìˆ˜/ë©”ì„œë“œë¥¼ ì°¾ì•„
    ìƒˆë¡œìš´ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ êµì²´í•˜ëŠ” NodeTransformerì…ë‹ˆë‹¤.
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        # ìƒˆë¡œìš´ ì½”ë“œë¥¼ íŒŒì‹±í•˜ì—¬ êµì²´í•  ë…¸ë“œë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.
        # ì—¬ëŸ¬ ë¬¸ì¥ì´ í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ bodyì—ì„œ ë…¸ë“œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        self.new_nodes = ast.parse(new_code).body

    def visit_FunctionDef(self, node: ast.FunctionDef) -> Union[ast.FunctionDef, List[ast.AST]]:
        """ì¼ë°˜ í•¨ìˆ˜(def) ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤."""
        # ìì‹ ë…¸ë“œë“¤ë„ ê³„ì† ë°©ë¬¸
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # í•¨ìˆ˜ì˜ ì´ë¦„ì´ ì¼ì¹˜í•˜ë©´ ì¤€ë¹„ëœ ìƒˆ ë…¸ë“œë“¤ë¡œ êµì²´í•©ë‹ˆë‹¤.
            return self.new_nodes
        return node  # ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì›ë˜ ë…¸ë“œë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Union[ast.AsyncFunctionDef, List[ast.AST]]:
        """ë¹„ë™ê¸° í•¨ìˆ˜(async def) ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤."""
        # ìì‹ ë…¸ë“œë“¤ë„ ê³„ì† ë°©ë¬¸
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # í•¨ìˆ˜ì˜ ì´ë¦„ì´ ì¼ì¹˜í•˜ë©´ ì¤€ë¹„ëœ ìƒˆ ë…¸ë“œë“¤ë¡œ êµì²´í•©ë‹ˆë‹¤.
            return self.new_nodes
        return node  # ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì›ë˜ ë…¸ë“œë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.


class EnhancedFunctionReplacer(ast.NodeTransformer):
    """
    í´ë˜ìŠ¤ëª….ë©”ì„œë“œëª… í˜•ì‹ì„ ì§€ì›í•˜ëŠ” í–¥ìƒëœ NodeTransformer
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        
        # ClassName.method_name í˜•ì‹ íŒŒì‹±
        if '.' in target_name:
            parts = target_name.split('.')
            self.target_class = parts[0]
            self.target_method = parts[1]
            self.is_class_method = True
        else:
            self.target_class = None
            self.target_method = target_name
            self.is_class_method = False
            
        # ìƒˆë¡œìš´ ì½”ë“œ ì¤€ë¹„
        self.new_nodes = ast.parse(new_code).body
        
        # í˜„ì¬ í´ë˜ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì¶”ì 
        self.current_class = None
        self.found_and_replaced = False

    def visit_ClassDef(self, node: ast.ClassDef):
        """í´ë˜ìŠ¤ ì •ì˜ ë°©ë¬¸"""
        # í˜„ì¬ í´ë˜ìŠ¤ ì´ë¦„ ì €ì¥
        old_class = self.current_class
        self.current_class = node.name
        
        # í´ë˜ìŠ¤ ë‚´ë¶€ ë°©ë¬¸
        self.generic_visit(node)
        
        # í´ë˜ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ë³µì›
        self.current_class = old_class
        
        # í´ë˜ìŠ¤ ìì²´ë¥¼ êµì²´í•˜ëŠ” ê²½ìš°
        if not self.is_class_method and node.name == self.target_name:
            self.found_and_replaced = True
            return self.new_nodes
            
        return node

    def visit_FunctionDef(self, node: ast.FunctionDef):
        """ì¼ë°˜ í•¨ìˆ˜(def) ë…¸ë“œ ë°©ë¬¸"""
        self.generic_visit(node)
        
        # í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ì°¾ëŠ” ê²½ìš°
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # ì¼ë°˜ í•¨ìˆ˜ë¥¼ ì°¾ëŠ” ê²½ìš°
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        """ë¹„ë™ê¸° í•¨ìˆ˜(async def) ë…¸ë“œ ë°©ë¬¸"""
        self.generic_visit(node)
        
        # í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ì°¾ëŠ” ê²½ìš°
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # ì¼ë°˜ í•¨ìˆ˜ë¥¼ ì°¾ëŠ” ê²½ìš°
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node



class ASTParser:
    """í†µí•© AST íŒŒì„œ"""
    
    def __init__(self):
        self.cache_manager = CacheManager()
        self.ts_manager = TreeSitterManager()
        
    def _detect_language(self, file_path: str, language: str = 'auto') -> str:
        """íŒŒì¼ ì–¸ì–´ ê°ì§€"""
        if language != 'auto':
            return language
            
        ext = Path(file_path).suffix.lower()
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.ts': 'typescript',
            '.tsx': 'typescript'
        }
        
        return ext_map.get(ext, 'unknown')
    
    def _extract_docstring(self, node: ast.AST) -> Optional[str]:
        """Python docstring ì¶”ì¶œ"""
        # body ì†ì„±ì´ ìˆëŠ” ë…¸ë“œ íƒ€ì…ë“¤ë§Œ ì²˜ë¦¬
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module)):
            return None
            
        if not hasattr(node, 'body') or not node.body:
            return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, (ast.Str, ast.Constant)):
            # Python 3.8+ì—ì„œëŠ” ast.Constant ì‚¬ìš©
            if isinstance(first.value, ast.Str):
                return textwrap.dedent(first.value.s).strip()
            elif isinstance(first.value, ast.Constant) and isinstance(first.value.value, str):
                return textwrap.dedent(first.value.value).strip()
                
        return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, ast.Str):
            return textwrap.dedent(first.value.s).strip()
            
        return None
    
    def _extract_function_info(self, node: ast.FunctionDef, source_lines: List[str]) -> Dict:
        """í•¨ìˆ˜ ì •ë³´ ì¶”ì¶œ"""
        info = {
            'type': 'function',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'args': [arg.arg for arg in node.args.args],
            'docstring': self._extract_docstring(node),
            'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list if d],
            'is_async': isinstance(node, ast.AsyncFunctionDef)
        }
        
        # ì½”ë“œ ìŠ¤ë‹ˆí« ì¶”ì¶œ
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def _extract_class_info(self, node: ast.ClassDef, source_lines: List[str]) -> Dict:
        """í´ë˜ìŠ¤ ì •ë³´ ì¶”ì¶œ"""
        info = {
            'type': 'class',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'bases': [base.id if isinstance(base, ast.Name) else str(base) for base in node.bases],
            'docstring': self._extract_docstring(node),
            'methods': []
        }
        
        # ë©”ì„œë“œ ì¶”ì¶œ
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                method_info = self._extract_function_info(item, source_lines)
                method_info['type'] = 'method'
                info['methods'].append(method_info)
        
        # ì½”ë“œ ìŠ¤ë‹ˆí« ì¶”ì¶œ
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def parse_python(self, file_path: str, include_snippets: bool = True) -> Dict[str, Any]:
        """Python íŒŒì¼ íŒŒì‹±"""
        try:
            # ìºì‹œ í™•ì¸
            cached = self.cache_manager.get_cached_ast(file_path)
            if cached and not include_snippets:
                return cached
                
            # íŒŒì¼ ì½ê¸°
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST íŒŒì‹±
            tree = ast.parse(content, filename=file_path)
            source_lines = content.split('\n') if include_snippets else []
            
            # ê²°ê³¼ ìˆ˜ì§‘
            result = {
                'parsing_success': True,
                'language': 'python',
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # AST ìˆœíšŒ
            for node in ast.walk(tree):  
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    result['functions'].append(self._extract_function_info(node, source_lines))
                elif isinstance(node, ast.ClassDef):
                    result['classes'].append(self._extract_class_info(node, source_lines))
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            result['imports'].append(alias.name)
                    else:
                        result['imports'].append(node.module or '')
            
            # ìºì‹œ ì €ì¥
            if not include_snippets:
                self.cache_manager.set_cached_ast(file_path, result)
                
            return result
            
        except Exception as e:
            _log(f"Python íŒŒì‹± ì˜¤ë¥˜: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': 'python',
                'error': str(e)
            }
    
    def parse_javascript(self, file_path: str, language: str = 'javascript', 
                        include_snippets: bool = True) -> Dict[str, Any]:
        """JavaScript/TypeScript íŒŒì¼ íŒŒì‹±"""
        parser = self.ts_manager.get_parser(language)
        if not parser:
            return {
                'parsing_success': False,
                'language': language,
                'error': 'Tree-sitter not available'
            }
            
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
                
            tree = parser.parse(content)
            
            # ê°„ë‹¨í•œ ê²°ê³¼ ë°˜í™˜ (ì‹¤ì œ êµ¬í˜„ì€ ë” ë³µì¡í•¨)
            result = {
                'parsing_success': True,
                'language': language,
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # Tree-sitter ë…¸ë“œ ìˆœíšŒ ë¡œì§ (ê°„ëµí™”)
            # ì‹¤ì œë¡œëŠ” traverse_node ê°™ì€ ë³µì¡í•œ í•¨ìˆ˜ê°€ í•„ìš”í•˜ì§€ë§Œ
            # ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ì²˜ë¦¬
            
            return result
            
        except Exception as e:
            _log(f"JavaScript íŒŒì‹± ì˜¤ë¥˜: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': language,
                'error': str(e)
            }
    
    def parse_with_snippets(self, file_path: str, language: str = 'auto', 
                          include_snippets: bool = True) -> Dict[str, Any]:
        """íŒŒì¼ íŒŒì‹± ë©”ì¸ ë©”ì„œë“œ"""
        # ì–¸ì–´ ê°ì§€
        detected_lang = self._detect_language(file_path, language)
        
        if detected_lang == 'python':
            return self.parse_python(file_path, include_snippets)
        elif detected_lang in ['javascript', 'typescript']:
            return self.parse_javascript(file_path, detected_lang, include_snippets)
        else:
            return {
                'parsing_success': False,
                'language': detected_lang,
                'error': f'Unsupported language: {detected_lang}'
            }
    
    def get_snippet_preview(self, file_path: str, element_name: str, 
                          element_type: str = 'function', max_lines: int = 10) -> str:
        """ì½”ë“œ ìŠ¤ë‹ˆí« ë¯¸ë¦¬ë³´ê¸°"""
        result = self.parse_with_snippets(file_path, include_snippets=True)
        
        if not result.get('parsing_success'):
            return f"Error: {result.get('error', 'Unknown error')}"
            
        # ìš”ì†Œ ì°¾ê¸°
        element_key = f'{element_type}s'
        if element_type == 'class':
            element_key = 'classes'
        elif element_type == 'function':
            element_key = 'functions'
            
        elements = result.get(element_key, [])
        for elem in elements:
            if elem.get('name') == element_name:
                snippet = elem.get('snippet', '')
                if not snippet:
                    # snippetì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì •ë³´ ë°˜í™˜
                    return f"{element_type} '{element_name}' found at line {elem.get('line_start', '?')}"
                    
                lines = snippet.split('\n')
                if len(lines) > max_lines:
                    return '\n'.join(lines[:max_lines]) + '\n...'
                return snippet
                

    def replace_block(self, file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
        """
        íŒŒì¼ ë‚´ì—ì„œ ì´ë¦„ì´ ì¼ì¹˜í•˜ëŠ” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ ì°¾ì•„ ìƒˆ ì½”ë“œë¡œ êµì²´í•©ë‹ˆë‹¤.
        
        ì§€ì› í˜•ì‹:
        - 'function_name' : ìµœìƒìœ„ í•¨ìˆ˜ ë˜ëŠ” ì²« ë²ˆì§¸ ë§¤ì¹­ë˜ëŠ” ë©”ì„œë“œ
        - 'ClassName' : í´ë˜ìŠ¤ ì „ì²´
        - 'ClassName.method_name' : íŠ¹ì • í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ (ì •í™•í•œ ì§€ì •)

        Args:
            file_path (str): ìˆ˜ì •í•  íŒŒì¼ì˜ ê²½ë¡œ.
            block_name (str): êµì²´í•  ë¸”ë¡ì˜ ì´ë¦„.
            new_code (str): êµì²´í•  ìƒˆë¡œìš´ ì½”ë“œ ë¸”ë¡.
            output_path (str, optional): ê²°ê³¼ë¥¼ ì €ì¥í•  íŒŒì¼ ê²½ë¡œ.

        Returns:
            str: ì„±ê³µ ì‹œ "SUCCESS: ...", ì‹¤íŒ¨ ì‹œ "ERROR: ..." ë©”ì‹œì§€
        """
        try:
            # 1. íŒŒì¼ì„ ì½ê³  ASTë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
            with open(file_path, 'r', encoding='utf-8') as f:
                source = f.read()
            tree = ast.parse(source, filename=file_path)

            # 2. ì ì ˆí•œ Replacer ì„ íƒ
            if '.' in block_name:
                # ClassName.method_name í˜•ì‹ì¸ ê²½ìš°
                transformer = EnhancedFunctionReplacer(block_name, new_code)
            else:
                # ë‹¨ìˆœ ì´ë¦„ì¸ ê²½ìš°
                transformer = FunctionReplacer(block_name, new_code)
            
            # 3. AST ë³€í™˜
            new_tree = transformer.visit(tree)

            # 4. êµì²´ ì„±ê³µ ì—¬ë¶€ í™•ì¸
            if hasattr(transformer, 'found_and_replaced') and not transformer.found_and_replaced:
                return f"ERROR: ë¸”ë¡ '{block_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

            # 5. ë³€ê²½ëœ AST í›„ì²˜ë¦¬
            ast.fix_missing_locations(new_tree)

            # 6. ìˆ˜ì •ëœ ASTë¥¼ ì†ŒìŠ¤ ì½”ë“œë¡œ ë³€í™˜
            modified_code = ast.unparse(new_tree)
            
            # 7. ê²°ê³¼ ì €ì¥
            save_path = output_path or file_path
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(modified_code)
            
            return f"SUCCESS: ë¸”ë¡ '{block_name}' êµì²´ ì™„ë£Œ (íŒŒì¼: {save_path})"

        except FileNotFoundError:
            return f"ERROR: íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {file_path}"
        except Exception as e:
            return f"ERROR: ì½”ë“œ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"

# ============================================================================
# ì „ì—­ íŒŒì„œ ì¸ìŠ¤í„´ìŠ¤
# ============================================================================

def _get_parser() -> ASTParser:
    """ì‹±ê¸€í†¤ íŒŒì„œ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _advanced_parser, _parser_lock
    
    if _advanced_parser is None:
        with _parser_lock:
            if _advanced_parser is None:
                _advanced_parser = ASTParser()
                
    return _advanced_parser

# ============================================================================
# ê³µê°œ API
# ============================================================================

def parse_with_snippets(file_path: str, language: str = 'auto', 
                       include_snippets: bool = True) -> Dict[str, Any]:
    """íŒŒì¼ íŒŒì‹± (ê³µê°œ API)"""
    parser = _get_parser()
    return parser.parse_with_snippets(file_path, language, include_snippets)

def get_snippet_preview(file_path: str, element_name: str, 
                       element_type: str = 'function', max_lines: int = 10,
                       start_line: int = -1, end_line: int = -1) -> str:
    """ì½”ë“œ ìŠ¤ë‹ˆí« ë¯¸ë¦¬ë³´ê¸° (ê³µê°œ API)"""
    parser = _get_parser()
    return parser.get_snippet_preview(file_path, element_name, element_type, max_lines)

# ============================================================================
# ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™” (ì„ íƒì )
# ============================================================================

def init_background():
    """ë°±ê·¸ë¼ìš´ë“œì—ì„œ Tree-sitter ì´ˆê¸°í™”"""
    def _init():
        _lazy_import_tree_sitter()
        _log("ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™” ì™„ë£Œ")
        
    thread = threading.Thread(target=_init, daemon=True)
    thread.start()

# ìë™ ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™”
init_background()

def replace_block(file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
    """
    íŒŒì¼ ë‚´ì—ì„œ ì´ë¦„ì´ ì¼ì¹˜í•˜ëŠ” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ ì°¾ì•„ ìƒˆ ì½”ë“œë¡œ êµì²´í•©ë‹ˆë‹¤.
    (í´ë˜ìŠ¤ ë‚´ë¶€ ë©”ì„œë“œë„ ì§€ì›)
    """
    parser = ASTParser()
    return parser.replace_block(file_path, block_name, new_code, output_path)


# ============================================================================
# ğŸ”§ íŒŒì¼ ì‹œìŠ¤í…œ í†µí•© í´ë˜ìŠ¤
# ============================================================================

class FileSystemHelpers:
    """
    íŒŒì¼ ì‹œìŠ¤í…œ ë ˆë²¨ì—ì„œ AST ê¸°ë°˜ ì½”ë“œ ìˆ˜ì •ì„ ì§€ì›í•˜ëŠ” í—¬í¼ í´ë˜ìŠ¤.
    file_system_helpers.pyì—ì„œ ì´ë™ë¨.
    """
    
    def __init__(self):
        self.parser = ASTParser()
        self.line_delta_cache = {}  # íŒŒì¼ë³„ ë¼ì¸ ë³€ê²½ ì¶”ì 
    
    def _detect_language_from_path(self, file_path: str) -> str:
        """íŒŒì¼ í™•ì¥ìë¡œ ì–¸ì–´ ê°ì§€"""
        ext = os.path.splitext(file_path)[1].lower()
        if ext in ['.py', '.pyw']:
            return 'python'
        elif ext in ['.js', '.jsx']:
            return 'javascript'
        elif ext in ['.ts', '.tsx']:
            return 'typescript'
        return 'unknown'
    
    def _validate_syntax_by_language(self, code: str, language: str, file_path: str) -> Tuple[bool, Optional[str]]:
        """ì–¸ì–´ë³„ êµ¬ë¬¸ ê²€ì¦"""
        if language == 'python':
            try:
                ast.parse(code, filename=file_path)
                return True, None
            except SyntaxError as e:
                return False, f"Line {e.lineno}: {e.msg}"
        # JavaScript/TypeScriptëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í†µê³¼
        return True, None
    
    def _apply_indentation(self, code: str, base_indent: int) -> str:
        """ì½”ë“œì— ê¸°ë³¸ ë“¤ì—¬ì“°ê¸° ì ìš©"""
        indent_str = ' ' * base_indent
        lines = code.splitlines()
        return '\n'.join(indent_str + line if line.strip() else line for line in lines)
    
    def _record_line_delta(self, file_path: str, start_line: int, delta: int):
        """ë¼ì¸ ë³€ê²½ì‚¬í•­ ê¸°ë¡"""
        if file_path not in self.line_delta_cache:
            self.line_delta_cache[file_path] = []
        self.line_delta_cache[file_path].append({
            'start_line': start_line,
            'delta': delta,
            'timestamp': datetime.now().isoformat()
        })


    def find_blocks(self, file_path: str, block_name: str = None) -> dict:
    """
    íŒŒì¼ì—ì„œ ì½”ë“œ ë¸”ë¡(í•¨ìˆ˜, í´ë˜ìŠ¤, ë©”ì„œë“œ)ì„ ì°¾ìŠµë‹ˆë‹¤.
    
    Args:
        file_path (str): ê²€ìƒ‰í•  íŒŒì¼ ê²½ë¡œ
        block_name (str, optional): ì°¾ì„ ë¸”ë¡ ì´ë¦„. Noneì´ë©´ ëª¨ë“  ë¸”ë¡ ë°˜í™˜
                                   'ClassName.method' í˜•ì‹ ì§€ì›
    
    Returns:
        dict: ê²€ìƒ‰ ê²°ê³¼ë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬
        
        ë¸”ë¡ì„ ì°¾ì€ ê²½ìš°:
        {
            'found': True,
            'block': {                    # ì°¾ì€ ë¸”ë¡ ì •ë³´
                'name': str,              # ë¸”ë¡ ì´ë¦„
                'type': str,              # 'function', 'class', 'method'
                'line_start': int,        # ì‹œì‘ ë¼ì¸ ë²ˆí˜¸
                'line_end': int,          # ë ë¼ì¸ ë²ˆí˜¸
                'col_start': int,         # ì‹œì‘ ì»¬ëŸ¼ ë²ˆí˜¸
                'col_end': int,           # ë ì»¬ëŸ¼ ë²ˆí˜¸
                'class': str or None,     # ë©”ì„œë“œì¸ ê²½ìš° í´ë˜ìŠ¤ëª…
                'language': str           # ì–¸ì–´ íƒ€ì…
            },
            'blocks': list,               # íŒŒì¼ì˜ ëª¨ë“  ë¸”ë¡ ë¦¬ìŠ¤íŠ¸
            'functions': list,            # í•¨ìˆ˜ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'classes': list,              # í´ë˜ìŠ¤ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'methods': list,              # ë©”ì„œë“œë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'total_blocks': int,          # ì „ì²´ ë¸”ë¡ ìˆ˜
            'matching_count': int         # ë§¤ì¹­ëœ ë¸”ë¡ ìˆ˜
        }
        
        ë¸”ë¡ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°:
        {
            'found': False,
            'error': str,                 # ì˜¤ë¥˜ ë©”ì‹œì§€
            'available_blocks': list      # ì‚¬ìš© ê°€ëŠ¥í•œ ë¸”ë¡ ì´ë¦„ ë¦¬ìŠ¤íŠ¸
        }
        
        ëª¨ë“  ë¸”ë¡ ì¡°íšŒ (block_name=None):
        {
            'found': bool,                # ë¸”ë¡ì´ í•˜ë‚˜ë¼ë„ ìˆëŠ”ì§€
            'blocks': list,               # ëª¨ë“  ë¸”ë¡ ë¦¬ìŠ¤íŠ¸
            'functions': list,            # í•¨ìˆ˜ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'classes': list,              # í´ë˜ìŠ¤ë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'methods': list,              # ë©”ì„œë“œë§Œ í•„í„°ë§í•œ ë¦¬ìŠ¤íŠ¸
            'total_blocks': int           # ì „ì²´ ë¸”ë¡ ìˆ˜
        }
    
    Examples:
        # íŠ¹ì • í•¨ìˆ˜ ì°¾ê¸°
        result = find_blocks('app.py', 'process_data')
        if result['found']:
            block = result['block']
            print(f"í•¨ìˆ˜ {block['name']}ëŠ” {block['line_start']}ì¤„ì—ì„œ ì‹œì‘")
        
        # í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ ì°¾ê¸°
        result = find_blocks('app.py', 'DataHandler.process')
        
        # ëª¨ë“  ë¸”ë¡ ì¡°íšŒ
        result = find_blocks('app.py')
        for block in result['blocks']:
            print(f"{block['type']}: {block['name']}")
    """
    
    if not os.path.exists(file_path):
        return {'found': False, 'error': f'íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ: {file_path}'}
    
    # íŒŒì¼ ë‚´ìš© ì½ê¸°
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        return {'found': False, 'error': f'íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}'}
    
    # ì–¸ì–´ë³„ íŒŒì‹± (Python v2.3 ê°œì„  ì ìš©)
    file_ext = os.path.splitext(file_path)[1].lower()
    if file_ext == '.py':
                # ì™¸ë¶€ íŒŒì„œ ì‚¬ìš© (JavaScript/TypeScriptì™€ ë™ì¼)
        if _external_parse_with_snippets:
            try:
                ast_result = _external_parse_with_snippets(file_path, include_snippets=True)
                if not ast_result.get('parsing_success'):
                    return {'found': False, 'error': f'Python íŒŒì‹± ì‹¤íŒ¨: {ast_result.get("error")}'}
            except Exception as parse_err:
                return {'found': False, 'error': f'Python íŒŒì‹± ì˜¤ë¥˜: {parse_err}'}
        else:
            return {'found': False, 'error': 'Python íŒŒì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ'}
    else:
        # JavaScript/TypeScriptëŠ” ì™¸ë¶€ íŒŒì„œ ì‚¬ìš© (ì•ˆì „í•œ ë°©ì‹)
        if _external_parse_with_snippets:
            try:
                ast_result = _external_parse_with_snippets(file_path, include_snippets=True)
            except:
                return {'found': False, 'error': 'JavaScript/TypeScript íŒŒì‹± ì‹¤íŒ¨'}
        else:
            return {'found': False, 'error': 'JavaScript/TypeScript íŒŒì„œ ì—†ìŒ'}
    
    if not ast_result.get('parsing_success'):
        return {'found': False, 'error': f'AST íŒŒì‹± ì‹¤íŒ¨: {ast_result.get("error")}'}
    
    # ëª¨ë“  ë¸”ë¡ ìˆ˜ì§‘
    all_blocks = []
    functions = []  # í•¨ìˆ˜ë§Œ ì €ì¥
    classes = []    # í´ë˜ìŠ¤ë§Œ ì €ì¥
    methods = []    # ë©”ì„œë“œë§Œ ì €ì¥
    
    # í•¨ìˆ˜ë“¤
    for func in ast_result.get('functions', []):
        block = {
            'name': func.get('name'),
            'type': 'function',
            'line_start': func.get('line_start'),
            'line_end': func.get('line_end'),
            'col_start': func.get('col_start', 1),
            'col_end': func.get('col_end', 1),
            'class': func.get('class'),
            'language': ast_result.get('language')
        }
        all_blocks.append(block)
        functions.append(block)
    
    # í´ë˜ìŠ¤ë“¤
    for cls in ast_result.get('classes', []):
        block = {
            'name': cls.get('name'),
            'type': 'class',
            'line_start': cls.get('line_start'),
            'line_end': cls.get('line_end'),
            'col_start': cls.get('col_start', 1),
            'col_end': cls.get('col_end', 1),
            'class': None,
            'language': ast_result.get('language')
        }
        all_blocks.append(block)
        classes.append(block)
    
    # ë©”ì„œë“œë“¤
    for method in ast_result.get('methods', []):
        block = {
            'name': method.get('name'),
            'type': 'method',
            'line_start': method.get('line_start'),
            'line_end': method.get('line_end'),
            'col_start': method.get('col_start', 1),
            'col_end': method.get('col_end', 1),
            'class': method.get('class'),  # âœ… v2.3: ì •í™•í•œ í´ë˜ìŠ¤ ì •ë³´
            'language': ast_result.get('language')
        }
        all_blocks.append(block)
        methods.append(block)
    
    # íŠ¹ì • ë¸”ë¡ ê²€ìƒ‰
    if block_name:
        # âœ… v2.3 FINAL í•µì‹¬: ì •ê·œí™”ëœ ì´ë¦„ íŒŒì‹±
        target_class_name = None
        target_func_name = block_name
        
        if '.' in block_name:
            # 'ClassName.method' í˜•íƒœ íŒŒì‹±
            parts = block_name.rsplit('.', 1)
            if len(parts) == 2:
                target_class_name, target_func_name = parts
        
        # ë¸”ë¡ ê²€ìƒ‰
        matching_blocks = []
        for block in all_blocks:
            if block['name'] == target_func_name:
                if target_class_name:
                    # í´ë˜ìŠ¤ëª…ì´ ì§€ì •ëœ ê²½ìš°: ì •í™•í•œ í´ë˜ìŠ¤ ì¼ì¹˜ í™•ì¸
                    if block.get('class') == target_class_name:
                        matching_blocks.append(block)
                else:
                    # í´ë˜ìŠ¤ëª…ì´ ì—†ëŠ” ê²½ìš°: ì „ì—­ í•¨ìˆ˜/í´ë˜ìŠ¤ë§Œ ë§¤ì¹˜
                    if not block.get('class'):
                        matching_blocks.append(block)
        
        if matching_blocks:
            return {
                'found': True,
                'block': matching_blocks[0],
                'blocks': all_blocks,
                'functions': functions,  # ì¶”ê°€
                'classes': classes,      # ì¶”ê°€
                'methods': methods,      # ì¶”ê°€
                'total_blocks': len(all_blocks),
                'matching_count': len(matching_blocks)
            }
        else:
            available_names = [f"{b.get('class', '')}.{b['name']}" if b.get('class') else b['name'] 
                             for b in all_blocks]
            return {
                'found': False, 
                'error': f'ë¸”ë¡ "{block_name}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ',
                'available_blocks': available_names
            }
    
    # ëª¨ë“  ë¸”ë¡ ë°˜í™˜
    return {
        'found': len(all_blocks) > 0,
        'blocks': all_blocks,
        'functions': functions,  # ì¶”ê°€
        'classes': classes,      # ì¶”ê°€
        'methods': methods,      # ì¶”ê°€
        'total_blocks': len(all_blocks)
    }

    def replace_block_fs(self, file_path: str, block_name: str, new_content: str) -> str:
    """
    íŒŒì¼ì˜ íŠ¹ì • ì½”ë“œ ë¸”ë¡(í•¨ìˆ˜, í´ë˜ìŠ¤, ë©”ì„œë“œ)ì„ ìƒˆë¡œìš´ ë‚´ìš©ìœ¼ë¡œ êµì²´í•©ë‹ˆë‹¤.
    
    ìë™ìœ¼ë¡œ ë°±ì—…ì„ ìƒì„±í•˜ê³ , êµ¬ë¬¸ ê²€ì¦ì„ ìˆ˜í–‰í•˜ë©°, ì‹¤íŒ¨ ì‹œ ìë™ ë³µì›ë©ë‹ˆë‹¤.
    ì •ê·œí™”ëœ ì´ë¦„(ClassName.method) í˜•ì‹ì„ ì§€ì›í•˜ë©°, ì›ë³¸ ë¸”ë¡ì˜ ë“¤ì—¬ì“°ê¸°ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
    
    Args:
        file_path (str): ìˆ˜ì •í•  íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
        block_name (str): êµì²´í•  ë¸”ë¡ì˜ ì´ë¦„
                         - í•¨ìˆ˜: 'function_name'
                         - í´ë˜ìŠ¤: 'ClassName'
                         - ë©”ì„œë“œ: 'ClassName.method_name'
        new_content (str): ìƒˆë¡œìš´ ì½”ë“œ ë‚´ìš©
                          - ë¹ˆ ë¬¸ìì—´ì´ë©´ ë¸”ë¡ ì‚­ì œ
                          - ë“¤ì—¬ì“°ê¸°ëŠ” ìë™ìœ¼ë¡œ ì¡°ì •ë¨
    
    Returns:
        str: ì‘ì—… ê²°ê³¼ ë©”ì‹œì§€
             ì„±ê³µ: "SUCCESS: ë¸”ë¡ '{block_name}' êµì²´ ì™„ë£Œ (ë°±ì—…: backup_filename)"
             ì‹¤íŒ¨: "ERROR: êµ¬ì²´ì ì¸ ì˜¤ë¥˜ ë©”ì‹œì§€"
    
    Examples:
        # í•¨ìˆ˜ êµì²´
        result = replace_block('app.py', 'process_data', 
                             'def process_data(x):\n    return x * 2')
        
        # í´ë˜ìŠ¤ ë©”ì„œë“œ êµì²´
        result = replace_block('models.py', 'DataHandler.validate',
                             'def validate(self, data):\n    return True')
        
        # ë¸”ë¡ ì‚­ì œ
        result = replace_block('utils.py', 'deprecated_function', '')
    """
    # 1. íŒŒì¼ ì¡´ì¬ í™•ì¸
    if not os.path.exists(file_path):
        return f"ERROR: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}"
    
    # 2. ë°±ì—… ìƒì„±
    backup_path = backup_file(file_path, f"before_replace_{block_name}")
    if "ERROR" in backup_path:
        return backup_path
    
    # 3. âœ… v2.3 í•µì‹¬: ì •ê·œí™”ëœ ì´ë¦„ìœ¼ë¡œ ì •í™•í•œ ë¸”ë¡ ì°¾ê¸°
    blocks_result = find_blocks(file_path, block_name)
    if not blocks_result.get('found'):
        error_msg = blocks_result.get('error', f'ë¸”ë¡ "{block_name}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ')
        return f"ERROR: {error_msg}"
    
    block_info = blocks_result['block']
    start_line = block_info['line_start']
    end_line = block_info['line_end']
    
    # 4. íŒŒì¼ ì½ê¸°
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception as e:
        return f"ERROR: íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}"
    
    # 5. âœ… v2.3 í•µì‹¬: AST ê¸°ë°˜ ì •í™•í•œ ë“¤ì—¬ì“°ê¸° ì ìš©
    base_indent_col = block_info.get('col_start', 1)
    
    if new_content.strip():
        processed_content = _apply_indentation_from_col(new_content, base_indent_col)
        new_lines = processed_content.splitlines(keepends=True)
        if new_lines and not new_lines[-1].endswith('\n'):
            new_lines[-1] += '\n'
    else:
        new_lines = []
    
    # ë¸”ë¡ êµì²´
    original_line_count = end_line - start_line + 1
    new_line_count = len(new_lines)
    lines[start_line-1:end_line] = new_lines
    
    # 6. êµ¬ë¬¸ ê²€ì¦
    new_file_content = ''.join(lines)
    language = _detect_language_from_path(file_path)
    is_valid, error = _validate_syntax_by_language(new_file_content, language, file_path)
    
    if not is_valid:
        try:
            shutil.copy2(backup_path, file_path) # ë°±ì—…ì—ì„œ ë³µì›
            _record_line_delta(file_path, start_line, 0) # ì‹¤íŒ¨ ì‹œ ë¸íƒ€ ì›ë³µ
        except Exception as restore_err:
            return f"ERROR: êµ¬ë¬¸ ì˜¤ë¥˜ë¡œ ë³µì› ì¤‘ ì¶”ê°€ ì˜¤ë¥˜ ë°œìƒ: {restore_err}"
        return f"ERROR: êµ¬ë¬¸ ì˜¤ë¥˜ë¡œ í¸ì§‘ ì‹¤íŒ¨ (ìë™ ë³µì›ë¨): {error}"
    
    # 7. íŒŒì¼ ì“°ê¸° ë° í›„ì²˜ë¦¬
    try:
        _atomic_write(file_path, new_file_content)
        line_delta = new_line_count - original_line_count
        if line_delta != 0:
            # âœ… ì„±ê³µ ì‹œì—ë§Œ Delta Tracking ì •ë³´ ê¸°ë¡
            _record_line_delta(file_path, start_line, line_delta)
        _invalidate_and_refresh_cache(file_path)
    except Exception as e:
        return f"ERROR: íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨: {e}"
    
    action = "ì‚­ì œ" if not new_content.strip() else "êµì²´"
    return f"SUCCESS: ë¸”ë¡ '{block_name}' {action} ì™„ë£Œ (ë°±ì—…: {os.path.basename(backup_path)})"

    def insert_block(self, file_path: str, target_block: str, position: str, new_content: str) -> str:
    """
    íŒŒì¼ì˜ íŠ¹ì • ë¸”ë¡ ì£¼ë³€ì´ë‚˜ ë‚´ë¶€ì— ìƒˆë¡œìš´ ì½”ë“œë¥¼ ì‚½ì…í•©ë‹ˆë‹¤.
    
    ìë™ìœ¼ë¡œ ë°±ì—…ì„ ìƒì„±í•˜ê³ , êµ¬ë¬¸ ê²€ì¦ì„ ìˆ˜í–‰í•˜ë©°, ì‹¤íŒ¨ ì‹œ ìë™ ë³µì›ë©ë‹ˆë‹¤.
    ëŒ€ìƒ ë¸”ë¡ì˜ ë“¤ì—¬ì“°ê¸° ìˆ˜ì¤€ì— ë§ì¶° ìƒˆ ì½”ë“œì˜ ë“¤ì—¬ì“°ê¸°ê°€ ìë™ ì¡°ì •ë©ë‹ˆë‹¤.
    
    Args:
        file_path (str): ìˆ˜ì •í•  íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
        target_block (str): ì‚½ì… ìœ„ì¹˜ì˜ ê¸°ì¤€ì´ ë˜ëŠ” ë¸”ë¡ ì´ë¦„
                           - í•¨ìˆ˜: 'function_name'
                           - í´ë˜ìŠ¤: 'ClassName'
                           - ë©”ì„œë“œ: 'ClassName.method_name'
        position (str): ì‚½ì… ìœ„ì¹˜ ì§€ì •
                       - 'before': ë¸”ë¡ ì‹œì‘ ì „
                       - 'after': ë¸”ë¡ ì¢…ë£Œ í›„
                       - 'start': ë¸”ë¡ ë‚´ë¶€ ì‹œì‘ ë¶€ë¶„ (ì„ ì–¸ ì§í›„)
                       - 'end': ë¸”ë¡ ë‚´ë¶€ ë ë¶€ë¶„ (return ë¬¸ ì „)
        new_content (str): ì‚½ì…í•  ì½”ë“œ ë‚´ìš©
                          - ë“¤ì—¬ì“°ê¸°ëŠ” ìë™ìœ¼ë¡œ ì¡°ì •ë¨
                          - ì—¬ëŸ¬ ì¤„ ê°€ëŠ¥
    
    Returns:
        str: ì‘ì—… ê²°ê³¼ ë©”ì‹œì§€
             ì„±ê³µ: "SUCCESS: ë¸”ë¡ '{target_block}'ì˜ {position} ìœ„ì¹˜ì— ì½”ë“œ ì‚½ì… ì™„ë£Œ"
             ì‹¤íŒ¨: "ERROR: êµ¬ì²´ì ì¸ ì˜¤ë¥˜ ë©”ì‹œì§€"
    
    Examples:
        # í•¨ìˆ˜ ì•ì— ì£¼ì„ ì¶”ê°€
        result = insert_block('app.py', 'process_data', 'before',
                            '# This function processes data\n')
        
        # í•¨ìˆ˜ ë‚´ë¶€ ì‹œì‘ ë¶€ë¶„ì— ë¡œê¹… ì¶”ê°€
        result = insert_block('app.py', 'process_data', 'start',
                            'print("Processing started")')
        
        # í´ë˜ìŠ¤ ë©”ì„œë“œ ëì— ì½”ë“œ ì¶”ê°€
        result = insert_block('models.py', 'DataHandler.save', 'end',
                            'self.last_saved = datetime.now()')
    """
    if not os.path.exists(file_path):
        return f"ERROR: íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {file_path}"
    
    valid_positions = ['before', 'after', 'start', 'end']
    if position not in valid_positions:
        return f"ERROR: ìœ íš¨í•˜ì§€ ì•Šì€ position: {position}"
    
    backup_path = backup_file(file_path, f"before_insert_{target_block}_{position}")
    if "ERROR" in backup_path:
        return backup_path

    blocks_result = find_blocks(file_path, target_block)
    if not blocks_result.get('found'):
        error_msg = blocks_result.get('error', f'ë¸”ë¡ "{target_block}"ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ')
        return f"ERROR: {error_msg}"
        
    block_info = blocks_result['block']
    start_line = block_info['line_start']
    end_line = block_info['line_end']
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception as e:
        return f"ERROR: íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}"

    target_col = block_info.get('col_start', 1)
    if position in ['start', 'end']:
        final_col = target_col + 4 # ë¸”ë¡ ë‚´ë¶€ëŠ” 4ì¹¸ ì¶”ê°€
    else: # 'before', 'after'
        final_col = target_col

    processed_content = _apply_indentation_from_col(new_content, final_col)
    new_lines = processed_content.splitlines(keepends=True)
    if new_lines and not new_lines[-1].endswith('\n'):
        new_lines[-1] += '\n'
    
    if position == 'before':
        insert_line_idx = start_line - 1
    elif position == 'after':
        insert_line_idx = end_line
    elif position == 'start':
        # Docstringì´ë‚˜ ë‹¤ë¥¸ ìš”ì†Œ ë°”ë¡œ ë’¤ì— ì‚½ì…
        insert_line_idx = start_line
    else: # 'end'
        # return ë¬¸ ë°”ë¡œ ì•ì— ì‚½ì…
        insert_line_idx = end_line - 1

    lines[insert_line_idx:insert_line_idx] = new_lines
    
    new_file_content = ''.join(lines)
    language = _detect_language_from_path(file_path)
    is_valid, error = _validate_syntax_by_language(new_file_content, language, file_path)

    if not is_valid:
        shutil.copy2(backup_path, file_path)
        return f"ERROR: êµ¬ë¬¸ ì˜¤ë¥˜ë¡œ ì‚½ì… ì‹¤íŒ¨ (ìë™ ë³µì›ë¨): {error}"

    _atomic_write(file_path, new_file_content)
    _record_line_delta(file_path, insert_line_idx, len(new_lines))
    _invalidate_and_refresh_cache(file_path)
    
    return f"SUCCESS: ë¸”ë¡ '{target_block}'ì˜ {position} ìœ„ì¹˜ì— ì½”ë“œ ì‚½ì… ì™„ë£Œ"


# ============================================================================
# ğŸ”§ File System Helpers - ì „ì—­ í•¨ìˆ˜ (backward compatibility)
# ============================================================================

_fs_helpers = None

def _get_fs_helpers():
    """FileSystemHelpers ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _fs_helpers
    if _fs_helpers is None:
        _fs_helpers = FileSystemHelpers()
    return _fs_helpers

def find_blocks(file_path: str, block_name: str = None) -> dict:
    """íŒŒì¼ì—ì„œ ì½”ë“œ ë¸”ë¡ì„ ì°¾ìŠµë‹ˆë‹¤."""
    return _get_fs_helpers().find_blocks(file_path, block_name)

def replace_block_fs(file_path: str, block_name: str, new_content: str) -> str:
    """íŒŒì¼ì˜ íŠ¹ì • ì½”ë“œ ë¸”ë¡ì„ êµì²´í•©ë‹ˆë‹¤. (íŒŒì¼ì‹œìŠ¤í…œ ê¸°ë°˜)"""
    return _get_fs_helpers().replace_block_fs(file_path, block_name, new_content)

def insert_block(file_path: str, block_name: str, new_content: str, position: str = 'after') -> str:
    """íŒŒì¼ì— ìƒˆë¡œìš´ ì½”ë“œ ë¸”ë¡ì„ ì‚½ì…í•©ë‹ˆë‹¤."""
    return _get_fs_helpers().insert_block(file_path, block_name, new_content, position)
