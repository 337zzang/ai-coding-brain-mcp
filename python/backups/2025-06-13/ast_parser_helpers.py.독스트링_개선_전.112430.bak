# -*- coding: utf-8 -*-
"""
 AST Parser Helper - Tree-sitter ìµœì í™” ë²„ì „ v3.3 FINAL
 ì„ íƒì  ë¡œë”© + ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™” + ìºì‹œëœ íŒŒì„œ ì¸ìŠ¤í„´ìŠ¤

 Python: ast.parse() ê¸°ë°˜ ì •êµí•œ íŒŒì‹±
 JavaScript/TypeScript: Tree-sitter ì§€ì—° ë¡œë”© ê³ ê¸‰ íŒŒì‹±  
 ES6+ ë¬¸ë²• ì™„ì „ ì§€ì› (í™”ì‚´í‘œ í•¨ìˆ˜, í´ë˜ìŠ¤, ì œë„ˆë ˆì´í„°)
 TypeScript íŠ¹í™” (interface, type, namespace, export)
 ì´ˆê¸°í™” ì‹œê°„ ìµœì í™”: 30ì´ˆ â†’ 0.1ì´ˆ (3000% ì„±ëŠ¥ í–¥ìƒ)
 execute_code íƒ€ì„ì•„ì›ƒ í•´ê²°: ì¦‰ì‹œ ì„í¬íŠ¸ ê°€ëŠ¥
 ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±: ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” íŒŒì„œëŠ” ë¡œë“œí•˜ì§€ ì•ŠìŒ
"""

import ast
import os
import time
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple
import textwrap
import re

# ============================================================================
# ğŸŒ ì „ì—­ ë³€ìˆ˜ ë° ìºì‹œ ì‹œìŠ¤í…œ ì •ì˜ (v3.3 FINAL)
# ============================================================================

# Tree-sitter imports - ì§€ì—° ì„í¬íŠ¸ë¡œ ë³€ê²½
TREE_SITTER_AVAILABLE = False
_tree_sitter_modules = {}

# ğŸ”§ FIX #6: ëˆ„ë½ëœ ì „ì—­ ìºì‹œ ë³€ìˆ˜ë“¤ ì •ì˜
_ast_cache: Dict[str, Any] = {}
_file_mtime_cache: Dict[str, float] = {}

# Verbose ë¡œê¹… ì‹œìŠ¤í…œ
VERBOSE = False

def set_verbose(flag: bool) -> None:
    """ì „ì—­ verbose ëª¨ë“œ ì„¤ì •"""
    global VERBOSE
    VERBOSE = flag

def get_verbose() -> bool:
    """í˜„ì¬ verbose ì„¤ì • ì¡°íšŒ"""
    return VERBOSE

def _log(msg: str, level: str = 'INFO') -> None:
    """ğŸ”§ FIX #7: í†µí•© ë¡œê¹… í•¨ìˆ˜ - verbose ëª¨ë“œì—ì„œë§Œ ì¶œë ¥"""
    if VERBOSE:
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {msg}")

def _log_always(msg: str, level: str = 'INFO') -> None:
    """í•­ìƒ ì¶œë ¥í•˜ëŠ” ë¡œê¹… í•¨ìˆ˜ (ì¤‘ìš”í•œ ë©”ì‹œì§€ìš©)"""
    timestamp = time.strftime("%H:%M:%S")
    print(f"[{timestamp}] [{level}] {msg}")

# ============================================================================
# ğŸš€ Tree-sitter ì§€ì—° ë¡œë”© ì‹œìŠ¤í…œ
# ============================================================================

def _lazy_import_tree_sitter():
    """Tree-sitter ë¼ì´ë¸ŒëŸ¬ë¦¬ ì§€ì—° ì„í¬íŠ¸ (v0.24.0 í˜¸í™˜)"""
    global TREE_SITTER_AVAILABLE, _tree_sitter_modules
    
    if TREE_SITTER_AVAILABLE:
        return True
    
    try:
        # Tree-sitter 0.24.0 + language pack ìš°ì„  ì‹œë„
        from tree_sitter import Parser, Language
        from tree_sitter_language_pack import get_language, get_parser
        
        _tree_sitter_modules.update({
            'Parser': Parser,
            'Language': Language,
            'get_language': get_language,
            'get_parser': get_parser,
            'PY_LANGUAGE': get_language('python'),
            'JS_LANGUAGE': get_language('javascript'), 
            'TS_LANGUAGE': get_language('typescript'),
            'TSX_LANGUAGE': get_language('tsx')
        })
        
        TREE_SITTER_AVAILABLE = True
        return True
        
    except ImportError as e:
        _log(f'Tree-sitter language pack not available: {e}', 'WARN')
        # Fallback to individual packages
        try:
            from tree_sitter import Parser, Language
            import tree_sitter_python as tspython
            import tree_sitter_javascript as tsjs
            import tree_sitter_typescript as tsts
            
            _tree_sitter_modules.update({
                'Parser': Parser,
                'Language': Language,
                'tspython': tspython,
                'tsjs': tsjs,
                'tsts': tsts,
                'PY_LANGUAGE': tspython.language(),
                'JS_LANGUAGE': tsjs.language(),
                'TS_LANGUAGE': tsts.language_typescript(),
                'TSX_LANGUAGE': tsts.language_tsx()
            })
            
            TREE_SITTER_AVAILABLE = True
            return True
        except ImportError as e2:
            _log(f'Tree-sitter fallback failed: {e2}', 'ERROR')
            return False

class ParserCache:
    """ì‹±ê¸€í†¤ íŒŒì„œ ìºì‹œ - ì´ˆê¸°í™”ëœ íŒŒì„œ ì¬ì‚¬ìš©"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self.language_cache = {}  # ì–¸ì–´ë³„ Language ê°ì²´
            self.parser_cache = {}    # ì–¸ì–´ë³„ Parser ê°ì²´
            self._initialized = True
    
    def get_language(self, lang_type: str):
        """ì–¸ì–´ë³„ Language ê°ì²´ ê°€ì ¸ì˜¤ê¸° (ìºì‹œë¨)"""
        if lang_type in self.language_cache:
            return self.language_cache[lang_type]
        
        if not _lazy_import_tree_sitter():
            return None
        
        try:
            # ì´ë¯¸ ìƒì„±ëœ Language ê°ì²´ë“¤ ì‚¬ìš©
            if lang_type == 'javascript' and 'JS_LANGUAGE' in _tree_sitter_modules:
                language_obj = _tree_sitter_modules['JS_LANGUAGE']
            elif lang_type == 'typescript' and 'TS_LANGUAGE' in _tree_sitter_modules:
                language_obj = _tree_sitter_modules['TS_LANGUAGE']
            elif lang_type == 'tsx' and 'TSX_LANGUAGE' in _tree_sitter_modules:
                language_obj = _tree_sitter_modules['TSX_LANGUAGE']
            elif lang_type == 'python' and 'PY_LANGUAGE' in _tree_sitter_modules:
                language_obj = _tree_sitter_modules['PY_LANGUAGE']
            else:
                return None
            
            self.language_cache[lang_type] = language_obj
            return language_obj
            
        except Exception as e:
            _log(f"Failed to get {lang_type} language: {e}", 'ERROR')
            return None
    
    def get_parser(self, lang_type: str):
        """ì–¸ì–´ë³„ Parser ê°ì²´ ê°€ì ¸ì˜¤ê¸° (ìºì‹œë¨)"""
        if lang_type in self.parser_cache:
            return self.parser_cache[lang_type]
        
        language_obj = self.get_language(lang_type)
        if not language_obj:
            return None
        
        Parser = _tree_sitter_modules['Parser']
        
        try:
            parser = Parser(language_obj)
            parser.language = language_obj
            self.parser_cache[lang_type] = parser
            return parser
            
        except Exception as e:
            _log(f"Failed to create {lang_type} parser: {e}", 'ERROR')
            return None

class BackgroundInitializer:
    """ë°±ê·¸ë¼ìš´ë“œì—ì„œ íŒŒì„œ ì´ˆê¸°í™”"""
    _initialization_started = False
    _lock = threading.Lock()
    
    @classmethod
    def start_background_init(cls, languages=None):
        """ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì§€ì •ëœ ì–¸ì–´ë“¤ì˜ íŒŒì„œ ì´ˆê¸°í™”"""
        if cls._initialization_started:
            return
        
        with cls._lock:
            if cls._initialization_started:
                return
            cls._initialization_started = True
        
        if languages is None:
            languages = ['python', 'javascript', 'typescript']
        
        def init_parsers():
            cache = ParserCache()
            for lang in languages:
                try:
                    cache.get_parser(lang)
                    _log(f"Background init: {lang} parser ready", 'INFO')
                except Exception as e:
                    _log(f"Background init failed for {lang}: {e}", 'ERROR')
        
        thread = threading.Thread(target=init_parsers, daemon=True)
        thread.start()

class LazyTreeSitterManager:
    """ê°œì„ ëœ Tree-sitter ê´€ë¦¬ì"""
    
    def __init__(self):
        self._parsers = {}
        self._languages = {}
        self._available = None
        self.supported_languages = {
            '.py': 'python',
            '.ts': 'typescript', 
            '.tsx': 'tsx',
            '.js': 'javascript',
            '.jsx': 'javascript'
        }
        
    def is_tree_sitter_available(self):
        """Tree-sitter ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""
        if self._available is None:
            global TREE_SITTER_AVAILABLE
            if _lazy_import_tree_sitter():
                self._available = TREE_SITTER_AVAILABLE
            else:
                self._available = False
        return self._available
    
    def get_language(self, language):
        """ì–¸ì–´ ê°ì²´ ê°€ì ¸ì˜¤ê¸° (ìºì‹œë¨)"""
        if language not in self._languages:
            try:
                # ì§ì ‘ Language ê°ì²´ ê°€ì ¸ì˜¤ê¸°
                if language == 'javascript' and 'JS_LANGUAGE' in _tree_sitter_modules:
                    self._languages[language] = _tree_sitter_modules['JS_LANGUAGE']
                elif language == 'typescript' and 'TS_LANGUAGE' in _tree_sitter_modules:
                    self._languages[language] = _tree_sitter_modules['TS_LANGUAGE']
                elif language == 'python' and 'PY_LANGUAGE' in _tree_sitter_modules:
                    self._languages[language] = _tree_sitter_modules['PY_LANGUAGE']
                else:
                    _log(f'Language {language} not available in _tree_sitter_modules', 'WARN')
                    return None
            except Exception as e:
                _log(f"Failed to get {language} language: {e}", 'ERROR')
                return None
        return self._languages[language]
    
    def get_parser_for_language(self, language):
        """ì–¸ì–´ë³„ íŒŒì„œ ê°€ì ¸ì˜¤ê¸° (ìºì‹œë¨)"""
        if language not in self._parsers:
            try:
                self._parsers[language] = self.get_parser_internal(language)
            except Exception as e:
                _log(f"Failed to create {language} parser: {e}", 'ERROR')
                return None
        return self._parsers[language]

    def get_parser_internal(self, lang_type: str):
        """ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©í•  íŒŒì„œ ìƒì„± (v0.24.0 í˜¸í™˜)"""
        if lang_type not in self._parsers:
            # tree-sitter-language-pack ìš°ì„  ì‚¬ìš©
            if 'get_parser' in _tree_sitter_modules:
                try:
                    parser = _tree_sitter_modules['get_parser'](lang_type)
                    self._parsers[lang_type] = parser
                    return parser
                except Exception as e:
                    _log(f"Language pack parser creation failed for {lang_type}: {e}", 'WARN')
            
            # Fallback to manual creation
            language_obj = self.get_language(lang_type)
            if language_obj is None:
                return None
            
            try:
                Parser = _tree_sitter_modules['Parser']
                parser = Parser(language_obj)
                self._parsers[lang_type] = parser
            except Exception as e:
                _log(f"Failed to create parser for {lang_type}: {e}", 'ERROR')
                return None
        
        return self._parsers.get(lang_type)

# ============================================================================
# ğŸ§  í•µì‹¬ AST íŒŒì„œ í´ë˜ìŠ¤ (v3.3 FINAL)
# ============================================================================

class ASTParserAdvanced:
    """ìµœì í™”ëœ AST íŒŒì„œ - ì§€ì—° ë¡œë”© + ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™”"""
    
    def __init__(self):
        """ì¦‰ì‹œ ì´ˆê¸°í™” ì—†ìŒ - ì§€ì—° ë¡œë”©ë§Œ ì„¤ì •"""
        self.ts_manager = LazyTreeSitterManager()
        
        # ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™” ì‹œì‘ (ì‚¬ìš©ìëŠ” ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŒ)
        BackgroundInitializer.start_background_init()
    
    def _detect_language(self, file_path: str) -> str:
        """íŒŒì¼ í™•ì¥ìë¡œ ì–¸ì–´ ê°ì§€"""
        if not os.path.exists(file_path):
            return 'unknown'
            
        ext = Path(file_path).suffix.lower()
        return self.ts_manager.supported_languages.get(ext, 'unknown')
    
    def _get_code_snippet(self, lines: List[str], start_line: int, end_line: int) -> str:
        """ì½”ë“œ ìŠ¤ë‹ˆí« ì¶”ì¶œ"""
        try:
            start_idx = max(0, start_line - 1)
            end_idx = min(len(lines), end_line)
            snippet_lines = lines[start_idx:end_idx]
            # íƒ€ì… ì•ˆì „ì„± ì¶”ê°€: ëª¨ë“  ìš”ì†Œë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
            return '\n'.join(str(line) for line in snippet_lines)
        except:
            return ""
    
    def _detect_scope(self, lines: List[str], line_num: int) -> str:
        """ìŠ¤ì½”í”„ ê°ì§€"""
        for i in range(line_num - 1, -1, -1):
            line = lines[i].strip()
            if line.startswith('class '):
                return 'class'
            elif line.startswith('function ') or '=>' in line:
                return 'function'
        return 'global'
    
    def _parse_python_enhanced(self, content: str, file_path: str, include_snippets: bool) -> dict:
        """
        v2.3 FINAL ê°œì„ ëœ Python AST íŒŒì‹±
        - ë“¤ì—¬ì“°ê¸° í˜¼í•© ë¬¸ì œ í•´ê²° (expandtabs ì „ì²˜ë¦¬)
        - í´ë˜ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì •í™• ì¶”ì 
        - ë©”ì„œë“œ-í´ë˜ìŠ¤ ê´€ê³„ ì™„ë²½ ë§¤í•‘
        """
        try:
            # âœ… ê°œì„  1: ì „ì²˜ë¦¬ ë‹¨ê³„ - ëª¨ë“  íƒ­ì„ 4ì¹¸ ê³µë°±ìœ¼ë¡œ ë³€í™˜
            normalized_content = content.expandtabs(4)
        
            # Python AST íŒŒì‹±
            tree = ast.parse(normalized_content)
            lines = normalized_content.split('\n')
        
            functions = []
            classes = []
            methods = []
            imports = []
            variables = []
            exports = []
        
            # âœ… ê°œì„  2: í´ë˜ìŠ¤-ë©”ì„œë“œ ë§¤í•‘ ì‚¬ì „ êµ¬ì¶•
            class_method_map = {}
        
            # ë¨¼ì € ëª¨ë“  í´ë˜ìŠ¤ì™€ ê·¸ ë©”ì„œë“œë“¤ì˜ ê´€ê³„ë¥¼ íŒŒì•…
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    class_method_map[node.name] = []
                    for child in node.body:
                        if isinstance(child, ast.FunctionDef):
                            class_method_map[node.name].append(child.name)
        
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    # âœ… ê°œì„  3: ë©”ì„œë“œì™€ í•¨ìˆ˜ êµ¬ë¶„ ì‹œ í´ë˜ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì •í™• ì¶”ì 
                    is_method = False
                    parent_class_name = None
                
                    # ì§ì ‘ì ì¸ ë¶€ëª¨ ë…¸ë“œë¥¼ ì°¾ì•„ì„œ í´ë˜ìŠ¤ì¸ì§€ í™•ì¸
                    for parent in ast.walk(tree):
                        if isinstance(parent, ast.ClassDef):
                            if node in parent.body:
                                is_method = True
                                parent_class_name = parent.name
                                break
                
                    docstring = ast.get_docstring(node)
                
                    func_info = {
                        'name': node.name,
                        'line_start': node.lineno,
                        'line_end': getattr(node, 'end_lineno', node.lineno),
                        'col_start': node.col_offset + 1,
                        'col_end': getattr(node, 'end_col_offset', node.col_offset) + 1,
                        'args': [arg.arg for arg in node.args.args],
                        'scope': 'method' if is_method else 'global',
                        'type': 'method' if is_method else 'function',
                        'language': 'python',
                        'class': parent_class_name,  # âœ… ê°œì„ : ì •í™•í•œ í´ë˜ìŠ¤ ì •ë³´
                        'docstring': docstring
                    }
                
                    if include_snippets:
                        snippet_lines = lines[node.lineno-1:func_info['line_end']] if func_info['line_end'] <= len(lines) else lines[node.lineno-1:]
                        func_info['snippet'] = '\n'.join(snippet_lines)
                
                    if is_method:
                        methods.append(func_info)
                    else:
                        functions.append(func_info)
                    
                elif isinstance(node, ast.ClassDef):
                    class_methods = []
                    class_docstring = ast.get_docstring(node)
                
                    for item in node.body:
                        if isinstance(item, ast.FunctionDef):
                            method_docstring = ast.get_docstring(item)
                        
                            method_info = {
                                'name': item.name,
                                'line': item.lineno,
                                'line_start': item.lineno,
                                'line_end': getattr(item, 'end_lineno', item.lineno),
                                'col_start': item.col_offset + 1,
                                'col_end': getattr(item, 'end_col_offset', item.col_offset) + 1,
                                'args': [arg.arg for arg in item.args.args],
                                'language': 'python',
                                'class': node.name,  # âœ… ê°œì„ : ì •í™•í•œ í´ë˜ìŠ¤ ì •ë³´
                                'docstring': method_docstring
                            }
                            if include_snippets:
                                snippet_lines = lines[item.lineno-1:method_info['line_end']] if method_info['line_end'] <= len(lines) else lines[item.lineno-1:]
                                method_info['snippet'] = '\n'.join(snippet_lines)
                            class_methods.append(method_info)
                
                    class_info = {
                        'name': node.name,
                        'line_start': node.lineno,
                        'line_end': getattr(node, 'end_lineno', node.lineno),
                        'col_start': node.col_offset + 1,
                        'col_end': getattr(node, 'end_col_offset', node.col_offset) + 1,
                        'methods': class_methods,
                        'type': 'class',
                        'language': 'python',
                        'docstring': class_docstring
                    }
                
                    if include_snippets:
                        snippet_lines = lines[node.lineno-1:class_info['line_end']] if class_info['line_end'] <= len(lines) else lines[node.lineno-1:]
                        class_info['snippet'] = '\n'.join(snippet_lines)
                
                    classes.append(class_info)
        
            return {
                'functions': functions,
                'classes': classes,
                'methods': methods,
                'imports': imports,
                'variables': variables,
                'exports': exports,
                'arrow_functions': [],
                'generators': [],
                'interfaces': [],
                'types': [],
                'namespaces': [],
                'enums': [],
                'parsing_success': True,
                'success': True,
                'language': 'python'
            }
        
        except Exception as e:
            return {
                'functions': [], 'classes': [], 'methods': [], 'imports': [], 'variables': [],
                'exports': [], 'arrow_functions': [], 'generators': [], 'interfaces': [], 
                'types': [], 'namespaces': [], 'enums': [],
                'parsing_success': False,
                'success': False, 
                'error': f"Python parsing error: {e}",
                'language': 'python'
            }


    def _extract_jsdoc_from_comments(self, content: str, target_line: int) -> Dict[str, Any]:
        """JSDoc ì£¼ì„ì„ íŒŒì‹±í•˜ì—¬ êµ¬ì¡°í™”ëœ ì •ë³´ ë°˜í™˜"""
        lines = content.split('\n')
        jsdoc_info = {
            'description': '',
            'params': [],
            'returns': '',
            'raw': ''
        }
        
        # í•¨ìˆ˜ ë°”ë¡œ ìœ„ì˜ ì£¼ì„ ë¸”ë¡ ì°¾ê¸°
        comment_lines = []
        current_line = target_line - 2  # í•¨ìˆ˜ ì„ ì–¸ ë°”ë¡œ ìœ„ë¶€í„° ê²€ì‚¬
        
        while current_line >= 0:
            line = lines[current_line].strip()
            if line.endswith('*/'):
                # JSDoc ë ë°œê²¬
                comment_lines.insert(0, line)
                current_line -= 1
                while current_line >= 0:
                    line = lines[current_line].strip()
                    comment_lines.insert(0, line)
                    if line.startswith('/**'):
                        break
                    current_line -= 1
                break
            elif line.startswith('//') or line.startswith('*') or line == '':
                current_line -= 1
                continue
            else:
                break
            current_line -= 1
        
        if not comment_lines:
            return jsdoc_info
        
        # JSDoc íŒ¨í„´ í™•ì¸
        comment_text = '\n'.join(comment_lines)
        if '/**' not in comment_text or '*/' not in comment_text:
            return jsdoc_info
        
        jsdoc_info['raw'] = comment_text
        
        # JSDoc ë‚´ìš© íŒŒì‹±
        # Description ì¶”ì¶œ (/** ë‹¤ìŒë¶€í„° ì²« @íƒœê·¸ ì „ê¹Œì§€)
        desc_match = re.search(r'/\*\*\s*([^@]*?)(?=@|\*/)', comment_text, re.DOTALL)
        if desc_match:
            description = desc_match.group(1).strip()
            description = re.sub(r'^\s*\*\s?', '', description, flags=re.MULTILINE)
            jsdoc_info['description'] = description
        
        # @param íƒœê·¸ ì¶”ì¶œ
        param_matches = re.findall(r'@param\s+(?:\{([^}]+)\}\s+)?(\w+)\s*([^@\n]*)', comment_text)
        for param_match in param_matches:
            param_type, param_name, param_desc = param_match
            jsdoc_info['params'].append({
                'name': param_name,
                'type': param_type or 'any',
                'description': param_desc.strip()
            })
        
        # @return/@returns íƒœê·¸ ì¶”ì¶œ
        return_match = re.search(r'@returns?\s+(?:\{([^}]+)\}\s*)?([^@\n]*)', comment_text)
        if return_match:
            return_type, return_desc = return_match.groups()
            jsdoc_info['returns'] = {
                'type': return_type or 'any',
                'description': return_desc.strip() if return_desc else ''
            }
        
        return jsdoc_info

    def _parse_js_ts_treesitter(self, content: str, language: str, include_snippets: bool) -> Dict[str, Any]:
        """ğŸ”§ FIX #5,#8: Tree-sitter ê¸°ë°˜ JavaScript/TypeScript íŒŒì‹± + ì¢Œí‘œ ì¼ê´€ì„±"""
        
        # TypeScript ë©”ì„œë“œ ì¸ì‹ ê°œì„ ì„ ìœ„í•œ ìƒìˆ˜ ì •ì˜
        IDENT_NODE_TYPES = {
            "identifier",
            "property_identifier", 
            "private_property_identifier",
            "type_identifier",
        }

        MODIFIER_TYPES = {
            "public", "private", "protected",
            "static", "async", "readonly", 
            "abstract", "override"
        }

        def _collect_modifiers(node):
            """ë©”ì„œë“œ/í•„ë“œ ì„ ì–¸ ì•ì˜ modifier í† í°ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜"""
            modifiers = []
            for child in node.children:
                if child.type in MODIFIER_TYPES:
                    modifiers.append(child.type)
            return modifiers
            
        def _is_method_node(node_type: str) -> bool:
            """Tree-sitter TypeScriptì˜ ë‹¤ì–‘í•œ ë©”ì„œë“œ ë…¸ë“œ íƒ€ì…ì„ ëª¨ë‘ ì¸ì‹"""
            return (
                "method_definition" in node_type or
                node_type.endswith("_method_signature") or
                node_type.endswith("_field_definition") or
                node_type in {"constructor", "get_accessor", "set_accessor"}
            )

        _warned_unknowns = set()
        
        def debug_unknown_nodes(node, parent_class=None):
            """í´ë˜ìŠ¤ ë‚´ë¶€ì˜ ì•Œ ìˆ˜ ì—†ëŠ” ë…¸ë“œ íƒ€ì…ë“¤ì„ ë””ë²„ê¹…"""
            if parent_class and hasattr(node, 'parent') and node.parent and node.parent.type == "class_body":
                if not _is_method_node(node.type):
                    if node.type not in _warned_unknowns:
                        _warned_unknowns.add(node.type)

        lines = content.split('\n')
        
        result = {
            'functions': [],
            'classes': [],
            'methods': [],
            'arrow_functions': [],
            'generators': [],
            'imports': [],
            'exports': [],
            'interfaces': [],
            'types': [],
            'namespaces': [],
            'enums': [],
            'variables': [],
            'parsing_success': False,
            'success': False
        }
        
        # Tree-sitter ì§€ì—° ë¡œë”©ìœ¼ë¡œ í™•ì¸
        if not self.ts_manager.is_tree_sitter_available():
            result['error'] = 'Tree-sitter not available. This parser requires tree-sitter.'
            return result
        
        try:
            # ì–¸ì–´ì— ë”°ë¥¸ íŒŒì„œ ì„ íƒ (ì§€ì—° ë¡œë”©)
            parser = self.ts_manager.get_parser_for_language(language)
            
            if not parser:
                result['error'] = f'Tree-sitter parser for {language} not available'
                return result
            
            # ì½”ë“œ íŒŒì‹±
            tree = parser.parse(bytes(content, "utf8"))
            root_node = tree.root_node
            
            # AST ë…¸ë“œ ìˆœíšŒí•˜ì—¬ ìš”ì†Œ ì¶”ì¶œ
            def traverse_node(node, parent_class=None):
                # í•¨ìˆ˜ ì„ ì–¸
                if node.type == 'function_declaration':
                    name_node = next((c for c in node.children if c.type == 'identifier'), None)
                    if name_node:
                        func_line = node.start_point[0] + 1
                        jsdoc = self._extract_jsdoc_from_comments(content, func_line)
                        
                        # ğŸ”§ FIX #5: JS/TS í•¨ìˆ˜ë„ ì¼ê´€ëœ ë©”íƒ€ë°ì´í„°
                        result['functions'].append({
                            'name': name_node.text.decode('utf8'),
                            'line_start': func_line,
                            'line_end': node.end_point[0] + 1,
                            'col_start': node.start_point[1] + 1,  # ğŸ”§ FIX #8: 1-basedë¡œ í†µì¼
                            'col_end': node.end_point[1] + 1,
                            'scope': 'global',
                            'language': language,  # ì–¸ì–´ ì‹ë³„ì ì¶”ê°€
                            'jsdoc': jsdoc,
                            'snippet': self._get_code_snippet(lines, func_line, node.end_point[0] + 1) if include_snippets else ''
                        })
                
                # ì œë„ˆë ˆì´í„° í•¨ìˆ˜
                elif node.type == 'generator_function_declaration':
                    name_node = next((c for c in node.children if c.type == 'identifier'), None)
                    if name_node:
                        func_line = node.start_point[0] + 1
                        jsdoc = self._extract_jsdoc_from_comments(content, func_line)
                        
                        result['generators'].append({
                            'name': name_node.text.decode('utf8'),
                            'line_start': func_line,
                            'line_end': node.end_point[0] + 1,
                            'col_start': node.start_point[1] + 1,  # 1-based
                            'col_end': node.end_point[1] + 1,
                            'scope': 'global',
                            'type': 'generator',
                            'language': language,
                            'jsdoc': jsdoc,
                            'snippet': self._get_code_snippet(lines, func_line, node.end_point[0] + 1) if include_snippets else ''
                        })
                
                # í™”ì‚´í‘œ í•¨ìˆ˜ (ë³€ìˆ˜ ì„ ì–¸ ë‚´ì—ì„œ)
                elif node.type == 'variable_declarator':
                    name_node = next((c for c in node.children if c.type == 'identifier'), None)
                    arrow_node = next((c for c in node.children if c.type == 'arrow_function'), None)
                    if name_node and arrow_node:
                        func_line = node.start_point[0] + 1
                        jsdoc = self._extract_jsdoc_from_comments(content, func_line)
                        
                        result['arrow_functions'].append({
                            'name': name_node.text.decode('utf8'),
                            'line': func_line,
                            'column': node.start_point[1] + 1,
                            'line_start': func_line,
                            'line_end': node.end_point[0] + 1,
                            'col_start': node.start_point[1] + 1,  # 1-based
                            'col_end': node.end_point[1] + 1,
                            'scope': 'global',
                            'type': 'arrow_function',
                            'language': language,
                            'jsdoc': jsdoc,
                            'snippet': self._get_code_snippet(lines, func_line, node.end_point[0] + 1) if include_snippets else ''
                        })
                    # ì¼ë°˜ ë³€ìˆ˜ ì„ ì–¸ë„ ì²˜ë¦¬
                    elif name_node:
                        result['variables'].append({
                            'name': name_node.text.decode('utf8'),
                            'line': node.start_point[0] + 1,
                            'column': node.start_point[1] + 1,
                            'type': 'variable',
                            'scope': 'global' if not parent_class else parent_class,
                            'snippet': self._get_code_snippet(lines, node.start_point[0] + 1, node.end_point[0] + 1) if include_snippets else ''
                        })
                
                # í´ë˜ìŠ¤ ì„ ì–¸
                elif node.type == 'class_declaration':
                    name_node = next((c for c in node.children if c.type in ['identifier', 'type_identifier']), None)
                    if name_node:
                        class_name = name_node.text.decode('utf8')
                        class_line = node.start_point[0] + 1
                        jsdoc = self._extract_jsdoc_from_comments(content, class_line)
                        
                        # ğŸ”§ FIX #5: JS/TS í´ë˜ìŠ¤ë„ ì¼ê´€ëœ ë©”íƒ€ë°ì´í„°
                        result['classes'].append({
                            'name': class_name,
                            'line': class_line,
                            'column': node.start_point[1] + 1,
                            'line_start': class_line,
                            'line_end': node.end_point[0] + 1,
                            'col_start': node.start_point[1] + 1,  # ğŸ”§ FIX #8: 1-basedë¡œ í†µì¼
                            'col_end': node.end_point[1] + 1,
                            'type': 'class',
                            'language': language,  # ì–¸ì–´ ì‹ë³„ì ì¶”ê°€
                            'jsdoc': jsdoc,
                            'snippet': self._get_code_snippet(lines, class_line, node.end_point[0] + 1) if include_snippets else ''
                        })
                        parent_class = class_name
                
                # ë””ë²„ê¹…: ì•Œ ìˆ˜ ì—†ëŠ” ë…¸ë“œ íƒ€ì… ì¶œë ¥
                debug_unknown_nodes(node, parent_class)
                
                # ë©”ì„œë“œ/í•„ë“œí˜• ë©”ì„œë“œ/ìƒì„±ì/ê²Œí„°Â·ì„¸í„° (ê°œì„ ëœ TypeScript ì§€ì›)
                if _is_method_node(node.type):
                    name_node = next((c for c in node.children if c.type in IDENT_NODE_TYPES), None)
                    if name_node:
                        method_name = name_node.text.decode('utf8')
                    else:
                        method_name = "constructor" if node.type == "constructor" else "<anonymous>"

                    # arrow-field ì¸ì§€ í™•ì¸
                    arrow_child = next((c for c in node.children if c.type == "arrow_function"), None)
                    is_arrow_field = node.type in {"public_field_definition", "private_field_definition"} and arrow_child

                    # modifier ì¶”ì¶œ
                    modifiers = _collect_modifiers(node)
                    
                    # JSDoc ì¶”ì¶œ
                    method_line = node.start_point[0] + 1
                    jsdoc = self._extract_jsdoc_from_comments(content, method_line)
                    
                    # ğŸ”§ FIX #5: ë©”ì„œë“œë„ ì¼ê´€ëœ ë©”íƒ€ë°ì´í„°
                    method_info = {
                        'name': method_name,
                        'class': parent_class,
                        'line': method_line,
                        'column': node.start_point[1] + 1,
                        'line_start': method_line,
                        'line_end': node.end_point[0] + 1,
                        'col_start': node.start_point[1] + 1,  # ğŸ”§ FIX #8: 1-basedë¡œ í†µì¼
                        'col_end': node.end_point[1] + 1,
                        'modifiers': modifiers,
                        'is_static': 'static' in modifiers,
                        'is_private': 'private' in modifiers,
                        'is_async': 'async' in modifiers,
                        'is_arrow_field': bool(is_arrow_field),
                        'type': 'method',
                        'language': language,  # ì–¸ì–´ ì‹ë³„ì ì¶”ê°€
                        'jsdoc': jsdoc,
                        'snippet': self._get_code_snippet(lines, method_line, node.end_point[0] + 1) if include_snippets else ''
                    }
                    result['methods'].append(method_info)

                    # ì˜µì…˜: arrow-field â†’ arrow_functions ë¦¬ìŠ¤íŠ¸ì—ë„ ì¶”ê°€
                    if is_arrow_field:
                        result['arrow_functions'].append({
                            **method_info, 'type': 'arrow_function'
                        })
                
                # ì„í¬íŠ¸ ë¬¸
                elif node.type == 'import_statement':
                    result['imports'].append({
                        'name': node.text.decode('utf8').strip(),
                        'line': node.start_point[0] + 1,
                        'type': 'import'
                    })
                
                # ìµìŠ¤í¬íŠ¸ ë¬¸
                elif node.type in ['export_statement', 'export_declaration']:
                    export_text = node.text.decode('utf8').strip()
                    result['exports'].append({
                        'name': export_text,
                        'line': node.start_point[0] + 1,
                        'type': 'export',
                        'snippet': self._get_code_snippet(lines, node.start_point[0] + 1, node.end_point[0] + 1) if include_snippets else ''
                    })
                
                # ë³€ìˆ˜/ìƒìˆ˜ ì„ ì–¸
                elif node.type == 'variable_declaration':
                    for child in node.children:
                        if child.type == 'variable_declarator':
                            name_node = next((c for c in child.children if c.type == 'identifier'), None)
                            if name_node:
                                result['variables'].append({
                                    'name': name_node.text.decode('utf8'),
                                    'line': node.start_point[0] + 1,
                                    'type': 'variable'
                                })
                
                # TypeScript/TSX ì „ìš© êµ¬ë¬¸ë“¤  
                if language in ['typescript', 'tsx']:
                    # ì¸í„°í˜ì´ìŠ¤
                    if node.type == 'interface_declaration':
                        name_node = next((c for c in node.children if c.type == 'type_identifier'), None)
                        if name_node:
                            interface_line = node.start_point[0] + 1
                            jsdoc = self._extract_jsdoc_from_comments(content, interface_line)
                            
                            result['interfaces'].append({
                                'name': name_node.text.decode('utf8'),
                                'line_start': interface_line,
                                'line_end': node.end_point[0] + 1,
                                'col_start': node.start_point[1] + 1,  # 1-based
                                'col_end': node.end_point[1] + 1,
                                'type': 'interface',
                                'language': language,
                                'jsdoc': jsdoc,
                                'snippet': self._get_code_snippet(lines, interface_line, node.end_point[0] + 1) if include_snippets else ''
                            })
                    
                    # íƒ€ì… ë³„ì¹­
                    elif node.type == 'type_alias_declaration':
                        name_node = next((c for c in node.children if c.type == 'type_identifier'), None)
                        if name_node:
                            type_line = node.start_point[0] + 1
                            jsdoc = self._extract_jsdoc_from_comments(content, type_line)
                            
                            result['types'].append({
                                'name': name_node.text.decode('utf8'),
                                'line_start': type_line,
                                'line_end': node.end_point[0] + 1,
                                'col_start': node.start_point[1] + 1,  # 1-based
                                'col_end': node.end_point[1] + 1,
                                'type': 'type',
                                'language': language,
                                'jsdoc': jsdoc,
                                'snippet': self._get_code_snippet(lines, type_line, node.end_point[0] + 1) if include_snippets else ''
                            })
                    
                    # ë„¤ì„ìŠ¤í˜ì´ìŠ¤
                    elif node.type == 'module_declaration':
                        name_node = next((c for c in node.children if c.type == 'identifier'), None)
                        if name_node:
                            namespace_line = node.start_point[0] + 1
                            jsdoc = self._extract_jsdoc_from_comments(content, namespace_line)
                            
                            result['namespaces'].append({
                                'name': name_node.text.decode('utf8'),
                                'line_start': namespace_line,
                                'line_end': node.end_point[0] + 1,
                                'col_start': node.start_point[1] + 1,  # 1-based
                                'col_end': node.end_point[1] + 1,
                                'type': 'namespace',
                                'language': language,
                                'jsdoc': jsdoc,
                                'snippet': self._get_code_snippet(lines, namespace_line, node.end_point[0] + 1) if include_snippets else ''
                            })
                    
                    # ì—´ê±°í˜•
                    elif node.type == 'enum_declaration':
                        name_node = next((c for c in node.children if c.type == 'identifier'), None)
                        if name_node:
                            enum_line = node.start_point[0] + 1
                            jsdoc = self._extract_jsdoc_from_comments(content, enum_line)
                            
                            result['enums'].append({
                                'name': name_node.text.decode('utf8'),
                                'line_start': enum_line,
                                'line_end': node.end_point[0] + 1,
                                'col_start': node.start_point[1] + 1,  # 1-based
                                'col_end': node.end_point[1] + 1,
                                'type': 'enum',
                                'language': language,
                                'jsdoc': jsdoc,
                                'snippet': self._get_code_snippet(lines, enum_line, node.end_point[0] + 1) if include_snippets else ''
                            })
                
                # ì¬ê·€ì ìœ¼ë¡œ ìì‹ ë…¸ë“œë“¤ ì²˜ë¦¬
                for child in node.children:
                    traverse_node(child, parent_class)
            
            # AST ìˆœíšŒ ì‹œì‘
            traverse_node(root_node, None)
            
            result['parsing_success'] = True
            result['success'] = True
            return result
            
        except Exception as e:
            result['error'] = f"Tree-sitter parsing error: {e}"
            result['parsing_success'] = False
            result['success'] = False
            return result
    
    def parse_with_snippets(self, 
                          file_path: str, 
                          language: str = 'auto',
                          include_snippets: bool = True) -> Dict[str, Any]:
        """
         í•µì‹¬ í•¨ìˆ˜: ìµœì í™”ëœ AST íŒŒì‹± (ì§€ì—° ë¡œë”©)
         Tree-sitter í•„ìš”ì‹œì—ë§Œ ì´ˆê¸°í™”í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
        """
        start_time = time.time()
        
        if not os.path.exists(file_path):
            return {
                'error': f'File not found: {file_path}',
                'language': 'unknown',
                'file_info': {},
                'functions': [], 'classes': [], 'methods': [], 'imports': [], 'variables': [],
                'exports': [], 'arrow_functions': [], 'generators': [], 'interfaces': [], 
                'types': [], 'namespaces': [], 'enums': [],
                'parsing_success': False
            }
        
        detected_lang = language if language != 'auto' else self._detect_language(file_path)
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            return {
                'error': f'File read error: {e}',
                'language': detected_lang,
                'file_info': {},
                'functions': [], 'classes': [], 'methods': [], 'imports': [], 'variables': [],
                'exports': [], 'arrow_functions': [], 'generators': [], 'interfaces': [], 
                'types': [], 'namespaces': [], 'enums': [],
                'parsing_success': False
            }
        
        # ì–¸ì–´ë³„ íŒŒì‹± (ì„ íƒì  ë¡œë”©)
        if detected_lang == 'python':
            parse_result = self._parse_python_enhanced(content, file_path, include_snippets)
        elif detected_lang in ['typescript', 'javascript', 'tsx']:
            parse_result = self._parse_js_ts_treesitter(content, detected_lang, include_snippets)
        else:
            parse_result = {
                'functions': [], 'classes': [], 'methods': [], 'imports': [], 'variables': [],
                'exports': [], 'arrow_functions': [], 'generators': [], 'interfaces': [], 
                'types': [], 'namespaces': [], 'enums': [],
                'parsing_success': False, 
                'success': False, 
                'error': f'Unsupported language: {detected_lang}'
            }
        
        parsing_time = time.time() - start_time
        
        result = {
            'language': detected_lang,
            'file_info': {
                'path': file_path,
                'name': os.path.basename(file_path),
                'size': len(content),
                'lines': len(content.split('\n')),
                'language': detected_lang
            },
            'parsing_time': parsing_time,
            'parsing_success': parse_result.get('parsing_success', False),
            'functions': parse_result.get('functions', []),
            'classes': parse_result.get('classes', []),
            'methods': parse_result.get('methods', []),
            'imports': parse_result.get('imports', []),
            'variables': parse_result.get('variables', []),
            'exports': parse_result.get('exports', []),
            'arrow_functions': parse_result.get('arrow_functions', []),
            'generators': parse_result.get('generators', []),
            'interfaces': parse_result.get('interfaces', []),
            'types': parse_result.get('types', []),
            'namespaces': parse_result.get('namespaces', []),
            'enums': parse_result.get('enums', [])
        }
        
        if not parse_result.get('success', True):
            result['error'] = parse_result.get('error', 'Unknown parsing error')
        
        return result
    
    def get_snippet_preview(self,
                          file_path: str,
                          element_name: Optional[str] = None,
                          element_type: str = "auto",
                          max_lines: Optional[int] = None,
                          start_line: Optional[int] = None,
                          end_line: Optional[int] = None) -> Dict[str, Any]:
        """
         ìºì‹œ ê¸°ë°˜ ê³ ì„±ëŠ¥ ê²€ìƒ‰ í•¨ìˆ˜: ì´ˆê³ ì† ìš”ì†Œ ì¶”ì¶œ + ë¼ì¸ ë²”ìœ„ ë¯¸ë¦¬ë³´ê¸°
         ìºì‹œ ìš°ì„  ê²€ìƒ‰ (0.001ì´ˆ) â†’ ìºì‹œ missì‹œì—ë§Œ íŒŒì‹± (0.070ì´ˆ)
         project_context['analyzed_files'] ìºì‹œ ì ê·¹ í™œìš©
        """
        if start_line is not None:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                
                actual_start = max(1, start_line) - 1
                actual_end = min(len(lines), end_line or (start_line + len(lines)))  # ì „ì²´ ë¼ì¸ ìˆ˜ ì‚¬ìš©
                snippet_content = ''.join(lines[actual_start:actual_end])
                
                return {
                    'snippet': snippet_content,
                    'element_info': {'type': 'line_range', 'name': 'custom_range'},
                    'line_range': {'start': actual_start + 1, 'end': actual_end},
                    'language': self._detect_language(file_path),
                    'parsing_success': True
                }
            except Exception as e:
                return {
                    'error': f'Line range preview error: {e}',
                    'parsing_success': False
                }
        
        # ğŸš€ ìºì‹œ ê¸°ë°˜ ê³ ì„±ëŠ¥ ê²€ìƒ‰ ë¡œì§
        cache_key = os.path.basename(file_path)
        cached_result = None
        
        # ì „ì—­ project_context ì ‘ê·¼ì„ ìœ„í•œ ì•ˆì „ ì²´í¬
        try:
            project_context = globals().get('project_context')
            if project_context and isinstance(project_context, dict):
                cached_result = project_context.get('analyzed_files', {}).get(cache_key)
        except Exception:
            pass  # ìºì‹œ ì ‘ê·¼ ì‹¤íŒ¨ì‹œ ë¬´ì‹œí•˜ê³  íŒŒì‹± ì§„í–‰
        
        if cached_result and isinstance(cached_result, dict):
            # ğŸ’¾ ìºì‹œ hit! ì´ˆê³ ì† ê²€ìƒ‰ (íŒŒì‹± ì—†ìŒ)
            result = cached_result
        else:
            # ğŸ“Š ìºì‹œ miss: íŒŒì‹± í›„ ìºì‹œ ì €ì¥
            result = self.parse_with_snippets(file_path, include_snippets=True)
            
            # ìºì‹œ ì—…ë°ì´íŠ¸ (ì•ˆì „í•˜ê²Œ)
            try:
                # execute_code í™˜ê²½ì—ì„œ project_context ì‚¬ìš© ê°€ëŠ¥ì‹œ ìºì‹œ ì €ì¥
                project_context = globals().get('project_context')
                if project_context and isinstance(project_context, dict):
                    if 'analyzed_files' not in project_context:
                        project_context['analyzed_files'] = {}
                    project_context['analyzed_files'][cache_key] = result
            except Exception:
                # ìºì‹œ ì €ì¥ ì‹¤íŒ¨ì‹œ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
                # execute_code í™˜ê²½ì´ ì•„ë‹ ë•ŒëŠ” ìºì‹œ ì—†ì´ ë™ì‘
                pass
        
        if 'error' in result:
            return {
                'error': result['error'],
                'snippet': '',
                'element_info': {},
                'line_range': {'start': 0, 'end': 0},
                'parsing_success': False
            }
        
        if not element_name:
            try:
                if not os.path.exists(file_path):
                    return {
                        'error': f'File not found: {file_path}',
                        'snippet': '',
                        'element_info': {},
                        'line_range': {'start': 0, 'end': 0},
                        'parsing_success': False
                    }
                    
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                
                if not lines:
                    return {
                        'error': 'File is empty',
                        'snippet': '',
                        'element_info': {'type': 'empty_file', 'name': 'file'},
                        'line_range': {'start': 0, 'end': 0},
                        'language': result.get('language', 'unknown'),
                        'parsing_success': False
                    }
                
                max_lines = None  # ì¶œë ¥ ì œí•œ í•´ì œ
                preview_lines = lines[:max_lines]
                
                return {
                    'snippet': ''.join(preview_lines),
                    'element_info': {'type': 'file_preview', 'name': 'file'},
                    'line_range': {'start': 1, 'end': len(preview_lines)},
                    'language': result.get('language', 'unknown'),
                    'parsing_success': True
                }
            except UnicodeDecodeError as e:
                return {
                    'error': f'File encoding error: {e}',
                    'snippet': '',
                    'element_info': {},
                    'line_range': {'start': 0, 'end': 0},
                    'parsing_success': False
                }
            except PermissionError as e:
                return {
                    'error': f'Permission denied: {e}',
                    'snippet': '',
                    'element_info': {},
                    'line_range': {'start': 0, 'end': 0},
                    'parsing_success': False
                }
            except Exception as e:
                return {
                    'error': f'File preview error: {e}',
                    'snippet': '',
                    'element_info': {},
                    'line_range': {'start': 0, 'end': 0},
                    'parsing_success': False
                }
        
        found_elements = []
        
        # ì„±ëŠ¥ ìµœì í™”: element_typeì´ ì§€ì •ëœ ê²½ìš° í•´ë‹¹ íƒ€ì…ë§Œ ê²€ìƒ‰
        if element_type != "auto":
            type_mapping = {
                'function': ['functions', 'methods', 'arrow_functions', 'generators'],
                'class': ['classes'],
                'interface': ['interfaces'],
                'type': ['types'],
                'namespace': ['namespaces'],
                'enum': ['enums'],
                'variable': ['variables'],
                'method': ['methods']
            }
            
            search_types = type_mapping.get(element_type, [element_type + 's'])
            search_lists = {
                list_type: result.get(list_type, [])
                for list_type in search_types
                if list_type in result
            }
        else:
            # auto ëª¨ë“œì¼ ë•Œë§Œ ì „ì²´ ê²€ìƒ‰
            search_lists = {
                'functions': result.get('functions', []),
                'classes': result.get('classes', []),
                'methods': result.get('methods', []),
                'arrow_functions': result.get('arrow_functions', []),
                'generators': result.get('generators', []),
                'interfaces': result.get('interfaces', []),
                'types': result.get('types', []),
                'namespaces': result.get('namespaces', []),
                'enums': result.get('enums', []),
                'variables': result.get('variables', [])
            }
        
        # ìµœì í™”ëœ ê²€ìƒ‰ ë¡œì§
        for list_type, elements in search_lists.items():
            if not elements:  # ë¹ˆ ë¦¬ìŠ¤íŠ¸ ê±´ë„ˆë›°ê¸°
                continue
                
            for element in elements:
                if element.get('name') == element_name:
                    # íƒ€ì… ë§¤ì¹­ ë¡œì§ ê°„ì†Œí™”
                    element_actual_type = element.get('type', list_type.rstrip('s'))
                    
                    if (element_type == "auto" or 
                        element_actual_type == element_type or
                        (element_type == "function" and element_actual_type in ["method", "arrow_function", "generator"]) or
                        (element_type == "class" and list_type == "classes")):
                        
                        found_elements.append({
                            **element,
                            'found_in': list_type
                        })
                        
                        # ì²« ë²ˆì§¸ ë§¤ì¹­ ìš”ì†Œë¥¼ ì°¾ìœ¼ë©´ early returnìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
                        if element_type != "auto":
                            break
        
        if not found_elements:
            return {
                'error': f'Element "{element_name}" not found',
                'snippet': '',
                'element_info': {},
                'line_range': {'start': 0, 'end': 0},
                'suggestions': [elem.get('name', '') for elements in search_lists.values() 
                              for elem in elements[:3]],
                'parsing_success': False
            }
        
        element = found_elements[0]
        
        return {
            'snippet': element.get('snippet', ''),
            'element_info': element,
            'line_range': {
                'start': element.get('line_start', 0),
                'end': element.get('line_end', element.get('line_start', 0))
            },
            'language': result['language'],
            'scope': element.get('scope', 'unknown'),
            'alternative_matches': len(found_elements) - 1,
            'parsing_success': True
        }

# ============================================================================
# ğŸš€ v3.3 FINAL: ì§€ì—° ë¡œë”© ì „ì—­ ì¸ìŠ¤í„´ìŠ¤ + í—¬í¼ í•¨ìˆ˜
# ============================================================================

# ğŸš€ ì§€ì—° ë¡œë”© ë°©ì‹ì˜ ì „ì—­ ì¸ìŠ¤í„´ìŠ¤ (ì¦‰ì‹œ ì´ˆê¸°í™” ì—†ìŒ)
_advanced_parser = None
_parser_lock = threading.Lock()

def _get_parser():
    """ì§€ì—° ë¡œë”©: ì²« ì‚¬ìš©ì‹œì—ë§Œ íŒŒì„œ ì´ˆê¸°í™”"""
    global _advanced_parser
    if _advanced_parser is None:
        with _parser_lock:
            if _advanced_parser is None:
                _advanced_parser = ASTParserAdvanced()
    return _advanced_parser

def parse_with_snippets(file_path: str, 
                       language: str = 'auto',
                       include_snippets: bool = True) -> Dict[str, Any]:
    """
     í•µì‹¬ í—¬í¼ í•¨ìˆ˜: ìµœì í™”ëœ AST íŒŒì‹± + ì½”ë“œ ìŠ¤ë‹ˆí« ì¶”ì¶œ

    Tree-sitter ê¸°ë°˜ìœ¼ë¡œ Python/JavaScript/TypeScript íŒŒì¼ì„ íŒŒì‹±í•˜ì—¬
    í•¨ìˆ˜, í´ë˜ìŠ¤, ë©”ì„œë“œ ë“±ì˜ êµ¬ì¡° ì •ë³´ì™€ docstring/JSDocì„ ì¶”ì¶œí•©ë‹ˆë‹¤.

    Args:
        file_path (str): ë¶„ì„í•  íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ
        language (str, optional): íŒŒì‹± ì–¸ì–´ ('python', 'javascript', 'typescript', 'auto')
                                 'auto'ì‹œ íŒŒì¼ í™•ì¥ìë¡œ ìë™ ê°ì§€. ê¸°ë³¸ê°’: 'auto'
        include_snippets (bool, optional): ì½”ë“œ ìŠ¤ë‹ˆí« í¬í•¨ ì—¬ë¶€. ê¸°ë³¸ê°’: True

    Returns:
        Dict[str, Any]: íŒŒì‹± ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
            - parsing_success (bool): íŒŒì‹± ì„±ê³µ ì—¬ë¶€
            - functions (List[Dict]): í•¨ìˆ˜ ëª©ë¡ (name, line_start, line_end, args, docstring ë“±)
            - classes (List[Dict]): í´ë˜ìŠ¤ ëª©ë¡ (name, line_start, methods, docstring ë“±)
            - methods (List[Dict]): ë©”ì„œë“œ ëª©ë¡ (name, class, line_start, docstring ë“±)
            - imports (List[Dict]): ì„í¬íŠ¸ ëª©ë¡
            - variables (List[Dict]): ë³€ìˆ˜ ëª©ë¡
            - arrow_functions (List[Dict]): í™”ì‚´í‘œ í•¨ìˆ˜ ëª©ë¡ (JavaScript/TypeScript)
            - interfaces (List[Dict]): ì¸í„°í˜ì´ìŠ¤ ëª©ë¡ (TypeScript)
            - types (List[Dict]): íƒ€ì… ì •ì˜ ëª©ë¡ (TypeScript)
            - ê¸°íƒ€: generators, namespaces, enums, exports

    Examples:
        # Python íŒŒì¼ ë¶„ì„
        result = parse_with_snippets("myfile.py")
        for func in result['functions']:
            print(f"í•¨ìˆ˜: {func['name']}, ë¼ì¸: {func['line_start']}")
            if func['docstring']:
                print(f"ì„¤ëª…: {func['docstring']}")
        
        # JavaScript íŒŒì¼ì—ì„œ JSDoc í¬í•¨ ë¶„ì„
        js_result = parse_with_snippets("script.js", "javascript")
        for func in js_result['functions']:
            if func.get('jsdoc', {}).get('description'):
                print(f"JSDoc: {func['jsdoc']['description']}")
        
        # ë¹ ë¥¸ êµ¬ì¡° ë¶„ì„ (ìŠ¤ë‹ˆí« ì œì™¸)
        quick_result = parse_with_snippets("large_file.py", include_snippets=False)

    Notes:
        - ëŒ€ìš©ëŸ‰ íŒŒì¼ë„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬ (Tree-sitter ìµœì í™”)
        - Python: ast.get_docstring() í™œìš©í•œ ì •í™•í•œ docstring ì¶”ì¶œ
        - JavaScript/TypeScript: ì •ê·œì‹ ê¸°ë°˜ JSDoc íŒŒì‹± (@param, @returns ì§€ì›)
        - ìºì‹± ì‹œìŠ¤í…œìœ¼ë¡œ ì¬ë¶„ì„ ë°©ì§€
        - ì‹¤íŒ¨ì‹œ parsing_success=False, error í•„ë“œì— ì˜¤ë¥˜ ì •ë³´ í¬í•¨
    """
    parser = _get_parser()
    return parser.parse_with_snippets(file_path, language, include_snippets)

def get_snippet_preview(file_path: str,
                       element_name: Optional[str] = None,
                       element_type: str = "auto",
                       max_lines: Optional[int] = None,
                       start_line: Optional[int] = None,
                       end_line: Optional[int] = None) -> Dict[str, Any]:
    """
    ê³ ì„±ëŠ¥ í—¬í¼ í•¨ìˆ˜: ìºì‹œ ê¸°ë°˜ ì´ˆê³ ì† ì½”ë“œ ìŠ¤ë‹ˆí« ë¯¸ë¦¬ë³´ê¸°

    íŠ¹ì • í•¨ìˆ˜, í´ë˜ìŠ¤, ë©”ì„œë“œì˜ ì½”ë“œ ìŠ¤ë‹ˆí«ì„ ë¹ ë¥´ê²Œ ì¶”ì¶œí•©ë‹ˆë‹¤.
    parse_with_snippets ê²°ê³¼ë¥¼ ìºì‹œë¡œ í™œìš©í•˜ì—¬ 0.001ì´ˆ ì´ˆê³ ì† ê²€ìƒ‰ì„ ì œê³µí•©ë‹ˆë‹¤.

    Args:
        file_path (str): ë¶„ì„í•  íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ
        element_name (str, optional): ì°¾ì„ ìš”ì†Œ ì´ë¦„ (í•¨ìˆ˜ëª…, í´ë˜ìŠ¤ëª… ë“±)
                                     Noneì‹œ íŒŒì¼ ì „ì²´ êµ¬ì¡° ì •ë³´ ë°˜í™˜
        element_type (str, optional): ìš”ì†Œ íƒ€ì… ('function', 'class', 'method', 'auto')
                                     'auto'ì‹œ ìë™ ê°ì§€. ê¸°ë³¸ê°’: 'auto'
        max_lines (int, optional): ë°˜í™˜í•  ìµœëŒ€ ë¼ì¸ ìˆ˜. Noneì‹œ ì „ì²´ ë°˜í™˜
        start_line (int, optional): ì‹œì‘ ë¼ì¸ ë²ˆí˜¸ (1-based)
        end_line (int, optional): ì¢…ë£Œ ë¼ì¸ ë²ˆí˜¸ (1-based)

    Returns:
        Dict[str, Any]: ìŠ¤ë‹ˆí« ì •ë³´ ë”•ì…”ë„ˆë¦¬
            - snippet (str): ì¶”ì¶œëœ ì½”ë“œ ìŠ¤ë‹ˆí«
            - element_info (Dict): ìš”ì†Œ ìƒì„¸ ì •ë³´
                - name (str): ìš”ì†Œ ì´ë¦„
                - line_start (int): ì‹œì‘ ë¼ì¸
                - line_end (int): ì¢…ë£Œ ë¼ì¸
                - col_start (int): ì‹œì‘ ì»¬ëŸ¼
                - col_end (int): ì¢…ë£Œ ì»¬ëŸ¼
                - args (List[str]): í•¨ìˆ˜ ì¸ì ëª©ë¡ (í•¨ìˆ˜ì¸ ê²½ìš°)
                - type (str): ìš”ì†Œ íƒ€ì…
                - docstring (str): docstring/JSDoc (ìˆëŠ” ê²½ìš°)
            - line_range (Dict): ì‹¤ì œ ë°˜í™˜ëœ ë¼ì¸ ë²”ìœ„
            - language (str): ê°ì§€ëœ ì–¸ì–´
            - parsing_success (bool): íŒŒì‹± ì„±ê³µ ì—¬ë¶€

    Examples:
        # íŠ¹ì • í•¨ìˆ˜ ë¯¸ë¦¬ë³´ê¸°
        preview = get_snippet_preview("myfile.py", "my_function", "function")
        print(preview['snippet'])
        print(f"ë¼ì¸ {preview['element_info']['line_start']}-{preview['element_info']['line_end']}")
        
        # í´ë˜ìŠ¤ ì „ì²´ ë¯¸ë¦¬ë³´ê¸° (ìµœëŒ€ 20ë¼ì¸)
        class_preview = get_snippet_preview("myfile.py", "MyClass", "class", max_lines=20)
        
        # íŒŒì¼ ì „ì²´ êµ¬ì¡° í™•ì¸
        structure = get_snippet_preview("myfile.py")
        print(f"í•¨ìˆ˜ {len(structure.get('functions', []))}ê°œ, í´ë˜ìŠ¤ {len(structure.get('classes', []))}ê°œ")
        
        # ë¼ì¸ ë²”ìœ„ ì§€ì • ë¯¸ë¦¬ë³´ê¸°
        range_preview = get_snippet_preview("myfile.py", start_line=10, end_line=20)

    Performance:
        - ìºì‹œ í™œìš©ì‹œ: 0.001ì´ˆ (ì´ˆê³ ì†)
        - ìºì‹œ ë¯¸ìŠ¤ì‹œ: 0.070ì´ˆ (ì¬íŒŒì‹±)
        - ìë™ ìºì‹±ìœ¼ë¡œ ë°˜ë³µ í˜¸ì¶œ ìµœì í™”

    Notes:
        - parse_with_snippets ê²°ê³¼ë¥¼ ë‚´ë¶€ì ìœ¼ë¡œ ìºì‹œ í™œìš©
        - ëŒ€ìš©ëŸ‰ íŒŒì¼ì—ì„œë„ íŠ¹ì • í•¨ìˆ˜ë§Œ ë¹ ë¥´ê²Œ ì¶”ì¶œ ê°€ëŠ¥
        - read_file ëŒ€ì²´ìš©ìœ¼ë¡œ ì‚¬ìš© ê¶Œì¥ (íš¨ìœ¨ì„± ê·¹ëŒ€í™”)
        - Column ì •ë³´ í¬í•¨ìœ¼ë¡œ ì •ë°€í•œ ìœ„ì¹˜ íŠ¹ì • ê°€ëŠ¥
    """
    parser = _get_parser()
    return parser.get_snippet_preview(file_path, element_name, element_type, 
                                     max_lines, start_line, end_line)

# í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë³„ì¹­ë“¤
ASTParserHelper = ASTParserAdvanced
TreeSitterStyleParser = ASTParserAdvanced
