# ===========================================
# Public API - Only these 7 functions are exposed
# ===========================================
__all__ = [
    'sync_to_files',          # ìºì‹œ â†’ íŒŒì¼ ë™ê¸°í™”
    'sync_from_files',        # íŒŒì¼ â†’ ìºì‹œ ë™ê¸°í™” (deprecated)
    'auto_save',              # ìë™ ì €ì¥
    'force_sync',             # ê°•ì œ ì–‘ë°©í–¥ ë™ê¸°í™”
    'save_coding_experience', # ê°œë°œ ê²½í—˜ ì €ì¥
    'search_coding_solutions',# ê³¼ê±° í•´ê²°ì±… ê²€ìƒ‰
    'get_coding_insights'     # í”„ë¡œì íŠ¸ ì¸ì‚¬ì´íŠ¸
]

"""
ğŸ”¥ ë°”ì´ë¸Œ ì½”ë”© ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ v2.0
========================

ë°”ì´ë¸Œì½”ë”©ì— ìµœì í™”ëœ ë©”ëª¨ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œ
- VibeMemoryManager: ë°”ì´ë¸Œ ë©”ëª¨ë¦¬ ê´€ë¦¬ í•µì‹¬
- VibeCommandSystem: ë°”ì´ë¸Œ ëª…ë ¹ì–´ ì‹œìŠ¤í…œ (/task, /flow ë“±)
- íŒŒì¼ êµ¬ì¡° ìµœì í™”: 7ê°œ â†’ 3ê°œ íŒŒì¼ë¡œ ê°„ì†Œí™”

ì‘ì„±ì: Claude + ì‚¬ìš©ì í˜‘ì—…  
ìƒì„±ì¼: 2025-06-04
ë¦¬ëª¨ë¸ë§: 2025-06-12 (v2.0)
"""

import os
import json
import datetime as dt
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import sys


def _get_memory_bank_root_from_claude_config() -> str:
    """Claude Desktop ì„¤ì •ì—ì„œ MEMORY_BANK_ROOT ë™ì  ì½ê¸°"""
    import os
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        # ai-coding-brain-mcp ì„œë²„ ì„¤ì •ì—ì„œ MEMORY_BANK_ROOT ì¶”ì¶œ
        memory_root = config['mcpServers']['ai-coding-brain-mcp']['env']['MEMORY_BANK_ROOT']
        print(f"âœ… Claude Desktop ì„¤ì •ì—ì„œ ë©”ëª¨ë¦¬ ë£¨íŠ¸ ë¡œë“œ: {memory_root}")
        return memory_root
    except Exception as e:
        print(f"âš ï¸ Claude ì„¤ì • ì½ê¸° ì‹¤íŒ¨: {e}")
        # í´ë°± ê²½ë¡œ
        fallback_path = r"C:\Users\Administrator\Desktop\memory"
        print(f"ğŸ“ í´ë°± ê²½ë¡œ ì‚¬ìš©: {fallback_path}")
        return fallback_path

def _sync_project_context_with_memory_bank(project_context: Dict[str, Any]) -> None:
    """project_contextë¥¼ ë©”ëª¨ë¦¬ ë±…í¬ì™€ ë™ê¸°í™”"""
    memory_root = _get_memory_bank_root_from_claude_config()
    project_name = project_context.get('name', 'common')
    project_memory_path = os.path.join(memory_root, project_name)
    
    # í”„ë¡œì íŠ¸ ë©”ëª¨ë¦¬ í´ë” ìƒì„±
    os.makedirs(project_memory_path, exist_ok=True)
    
    # project_contextì— ë©”ëª¨ë¦¬ ê²½ë¡œ ì •ë³´ ì €ì¥
    project_context['memory_bank'] = {
        'root': memory_root,
        'project_path': project_memory_path,
        'project_name': project_name,
        'last_sync': datetime.now().isoformat(),
        'sync_enabled': True
    }
    
    # sync_status ì´ˆê¸°í™”
    if 'sync_status' not in project_context:
        project_context['sync_status'] = {
            'last_sync': datetime.now().isoformat(),
            'pending_changes': [],
            'auto_sync': True
        }
    
    return project_memory_path

def _ensure_data_compatibility(project_context: Dict[str, Any]) -> Dict[str, Any]:
    """ë‘ ì‹œìŠ¤í…œì˜ ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥"""
    # AI Coding Brain êµ¬ì¡° -> Vibe System êµ¬ì¡° ë§¤í•‘
    if 'vibe_system' not in project_context:
        project_context['vibe_system'] = {}
    
    vibe_sys = project_context['vibe_system']
    
    # current_focus ë™ê¸°í™”
    if 'current_focus' in project_context and project_context['current_focus']:
        vibe_sys['current_focus'] = project_context['current_focus']
    elif 'current_focus' not in vibe_sys:
        vibe_sys['current_focus'] = ''
    
    # next_tasks ë™ê¸°í™”
    if 'next_tasks' in project_context and project_context['next_tasks']:
        # AI Brainì˜ ë‹¨ìˆœ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ë¥¼ Vibe í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        vibe_tasks = []
        for task in project_context['next_tasks']:
            if isinstance(task, str):
                vibe_tasks.append({
                    'description': task,
                    'added_time': datetime.now().strftime("%H:%M"),
                    'status': 'pending'
                })
            else:
                vibe_tasks.append(task)
        vibe_sys['next_tasks'] = vibe_tasks
    elif 'next_tasks' not in vibe_sys:
        vibe_sys['next_tasks'] = []
    
    # work_tracking ì •ë³´ë„ í™œìš©
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        if 'current_focus' in wt and wt['current_focus']:
            vibe_sys['current_focus'] = wt['current_focus']
        if 'next_tasks' in wt and wt['next_tasks']:
            # work_trackingì˜ tasksë„ ë³‘í•©
            for task in wt['next_tasks']:
                if isinstance(task, str) and task not in [t.get('description', t) for t in vibe_sys['next_tasks']]:
                    vibe_sys['next_tasks'].append({
                        'description': task,
                        'added_time': datetime.now().strftime("%H:%M"),
                        'status': 'pending'
                    })
    
    # completed_tasks ì´ˆê¸°í™”
    if 'completed_tasks' not in vibe_sys:
        vibe_sys['completed_tasks'] = []
    
    # session_activities ì´ˆê¸°í™”
    if 'session_activities' not in vibe_sys:
        vibe_sys['session_activities'] = []
    
    return project_context

def _parse_coding_flow_md(file_path: str) -> Dict[str, Any]:
    """coding_flow.md íŒŒì¼ì„ íŒŒì‹±í•´ì„œ ë”•ì…”ë„ˆë¦¬ë¡œ ë°˜í™˜"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        coding_flow = {
            'current_focus': '',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }
        
        lines = content.split('\n')
        current_section = None
        
        for line in lines:
            line_stripped = line.strip()
            
            # ì„¹ì…˜ ê°ì§€
            if any(marker in line for marker in ['ğŸ”¥ Current Focus', 'Current Focus', '## ğŸ¯ Current Focus']):
                current_section = 'focus'
            elif any(marker in line for marker in ['â­ï¸ Next Up', 'Next Up', '## ğŸ“‹ Next Tasks']):
                current_section = 'next_up'
            elif any(marker in line for marker in ['âœ… Completed', 'Completed']):
                current_section = 'completed'
            elif any(marker in line for marker in ['ğŸ“ Quick Notes', 'Quick Notes']):
                current_section = 'notes'
            
            # ë‚´ìš© íŒŒì‹±
            elif current_section == 'focus' and line_stripped and not line_stripped.startswith('#') and not line_stripped.startswith('*'):
                if not coding_flow['current_focus']:
                    coding_flow['current_focus'] = line_stripped
            
            elif current_section == 'next_up':
                if line_stripped.startswith('- [ ]') or line_stripped.startswith('â€¢ [ ]'):
                    task = line_stripped[5:].strip()
                    if task and task not in coding_flow['next_up']:
                        coding_flow['next_up'].append(task)
            
            elif current_section == 'completed' and (line_stripped.startswith('- [x]') or line_stripped.startswith('â€¢ [x]')):
                task = line_stripped[5:].strip()
                if task and task not in coding_flow['completed']:
                    coding_flow['completed'].append(task)
            
            elif current_section == 'notes' and line_stripped and not line_stripped.startswith('#'):
                coding_flow['quick_notes'] += line_stripped + '\n'
        
        coding_flow['quick_notes'] = coding_flow['quick_notes'].strip()
        
        return coding_flow
        
    except Exception as e:
        print(f"âš ï¸ coding_flow.md íŒŒì‹± ì‹¤íŒ¨: {e}")
        return {
            'current_focus': 'memory_cache_persistence_system',
            'next_up': [],
            'completed': [],
            'quick_notes': '',
            'last_updated': datetime.now().isoformat()
        }

def _ensure_vibe_memory_structure(memory_path: str) -> bool:
    """ë°”ì´ë¸Œ ë©”ëª¨ë¦¬ êµ¬ì¡° í™•ì¸ ë° ìƒì„±"""
    try:
        os.makedirs(memory_path, exist_ok=True)
        return True
    except Exception as e:
        print(f"âŒ Error ensuring vibe memory structure: {e}")
        return False

# ===========================================
# ìƒˆë¡œìš´ í—¬í¼ í•¨ìˆ˜ë“¤ (v2.0)
# ===========================================

def calculate_weekly_progress(project_context):
    """ì£¼ê°„ ì§„í–‰ë¥  ê³„ì‚°"""
    today = datetime.now()
    week_start = today - timedelta(days=today.weekday())
    
    weekly_completed = 0
    total_active = 0
    
    # vibe_systemì—ì„œ ì´ë²ˆ ì£¼ ì™„ë£Œ ì‘ì—… ê³„ì‚°
    if 'vibe_system' in project_context:
        vibe_sys = project_context['vibe_system']
        
        # í™œì„± ì‘ì—… ìˆ˜
        total_active = len(vibe_sys.get('next_tasks', []))
        
        # ì´ë²ˆ ì£¼ ì™„ë£Œëœ ì‘ì—… ìˆ˜ (ê°„ë‹¨íˆ ì „ì²´ ì™„ë£Œ ì‘ì—… ìˆ˜ë¡œ ëŒ€ì²´)
        weekly_completed = len(vibe_sys.get('completed_tasks', []))
    
    # tasksì—ì„œë„ ì¹´ìš´íŠ¸
    if 'tasks' in project_context:
        total_active += len(project_context['tasks'].get('next', []))
        weekly_completed += len(project_context['tasks'].get('done', []))
    
    total_tasks = weekly_completed + total_active
    progress_percentage = (weekly_completed / total_tasks * 100) if total_tasks > 0 else 0
    
    return {
        'completed_this_week': weekly_completed,
        'total_active': total_active,
        'total_tasks': total_tasks,
        'progress_percentage': round(progress_percentage, 1)
    }

def get_development_statistics(project_context):
    """ê°œë°œ í†µê³„ ìƒì„±"""
    stats = {
        'total_completed': 0,
        'total_active': 0,
        'most_edited_files': [],
        'most_edited_functions': [],
        'analyzed_files': 0,
        'total_functions': 0,
        'total_classes': 0
    }
    
    # vibe_system í†µê³„
    if 'vibe_system' in project_context:
        vibe_sys = project_context['vibe_system']
        stats['total_completed'] += len(vibe_sys.get('completed_tasks', []))
        stats['total_active'] += len(vibe_sys.get('next_tasks', []))
    
    # tasks í†µê³„
    if 'tasks' in project_context:
        stats['total_completed'] += len(project_context['tasks'].get('done', []))
        stats['total_active'] += len(project_context['tasks'].get('next', []))
    
    # work_tracking í†µê³„
    if 'work_tracking' in project_context:
        wt = project_context['work_tracking']
        
        # ê°€ì¥ ë§ì´ í¸ì§‘ëœ íŒŒì¼
        file_edits = wt.get('file_edits', {})
        if file_edits:
            sorted_files = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)[:5]
            stats['most_edited_files'] = [(os.path.basename(f), c) for f, c in sorted_files]
        
        # ê°€ì¥ ë§ì´ í¸ì§‘ëœ í•¨ìˆ˜
        function_edits = wt.get('function_edits', {})
        if function_edits:
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1].get('count', 0), reverse=True)[:5]
            stats['most_edited_functions'] = [(f, info.get('count', 0)) for f, info in sorted_funcs]
    
    # analyzed_files í†µê³„
    if 'analyzed_files' in project_context:
        analyzed = project_context['analyzed_files']
        stats['analyzed_files'] = len(analyzed)
        
        for file_info in analyzed.values():
            stats['total_functions'] += len(file_info.get('functions', []))
            stats['total_classes'] += len(file_info.get('classes', []))
    
    return stats

def extract_learned_patterns(project_context):
    """ì½”ë”© ê²½í—˜ì—ì„œ íŒ¨í„´ ì¶”ì¶œ"""
    patterns = {
        'bug_fixes': [],
        'optimizations': [],
        'new_features': [],
        'refactoring': [],
        'general': []
    }
    
    # coding_experiencesì—ì„œ íŒ¨í„´ ë¶„ë¥˜
    experiences = project_context.get('coding_experiences', [])
    for exp in experiences[-50:]:  # ìµœê·¼ 50ê°œë§Œ
        if isinstance(exp, dict):
            task = exp.get('task', '').lower()
            solution = exp.get('solution', '')
            
            # íŒ¨í„´ ë¶„ë¥˜
            if any(word in task for word in ['error', 'fix', 'bug', 'issue']):
                patterns['bug_fixes'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            elif any(word in task for word in ['improve', 'optimize', 'performance']):
                patterns['optimizations'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            elif any(word in task for word in ['add', 'create', 'new', 'feature']):
                patterns['new_features'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            elif any(word in task for word in ['refactor', 'restructure', 'reorganize']):
                patterns['refactoring'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
            else:
                patterns['general'].append({
                    'task': exp.get('task', ''),
                    'solution': solution[:100] + '...' if len(solution) > 100 else solution
                })
    
    # ê° ì¹´í…Œê³ ë¦¬ë³„ë¡œ ìµœëŒ€ 5ê°œë§Œ ìœ ì§€
    for category in patterns:
        patterns[category] = patterns[category][:5]
    
    return patterns

# ===========================================
# í…œí”Œë¦¿ í•¨ìˆ˜ë“¤ (v2.0 - í™•ì¥ëœ êµ¬ì¡°)
# ===========================================

def get_vibe_coding_flow_template() -> str:
    """coding_flow.md í…œí”Œë¦¿ ìƒì„± (í™•ì¥ëœ ë²„ì „)"""
    timestamp = dt.datetime.now().strftime("%Y-%m-%d %H:%M")
    return f"""# ğŸ”¥ Current Focus
*ì§€ê¸ˆ ë­í•˜ê³  ìˆëŠ”ì§€*

í˜„ì¬ ì„¸ì…˜ ì‹œì‘: {timestamp}

## ğŸ“… Today's Tasks
*ì˜¤ëŠ˜ í•  ì¼*

### Must Do Today
- [ ] 

### In Progress
- 

## â­ï¸ Next Up
*ë‹¤ìŒ ì‘ì—…ë“¤*

- [ ] 

## âœ… Today's Completed
*ì˜¤ëŠ˜ ì™„ë£Œí•œ ì¼*

- [x] 

## ğŸ“ Quick Notes
*ë¹ ë¥¸ ë©”ëª¨*



## ğŸ“Š This Week Progress
*ì£¼ê°„ ì§„í–‰ë¥ *

- ì´ë²ˆ ì£¼ ì™„ë£Œ: 0ê°œ
- ì§„í–‰ë¥ : 0%

## ğŸ• Session Activity
*ì„¸ì…˜ í™œë™ ë¡œê·¸*

- {timestamp[:5]} Session started
"""

def get_vibe_feature_roadmap_template() -> str:
    """feature_roadmap.md í…œí”Œë¦¿ ìƒì„± (í™•ì¥ëœ ë²„ì „)"""
    return """# ğŸ—ºï¸ Feature Roadmap & History

## ğŸ¯ This Sprint Goals
*ì´ë²ˆ ìŠ¤í”„ë¦°íŠ¸ ëª©í‘œ*

1. 
2. 
3. 

## âœ… Completed Features
*ì™„ë£Œëœ ê¸°ëŠ¥ë“¤*



## ğŸš€ Planned Features  
*ê³„íšëœ ê¸°ëŠ¥ë“¤*



## ğŸ“Š Development Statistics
*ê°œë°œ í†µê³„*

### Overall Stats
- Total Completed: 0
- Total Active: 0
- Files Analyzed: 0

### Most Active Files
1. 

### Productivity Insights
- 

## ğŸ’¡ Learned Patterns
*í•™ìŠµëœ íŒ¨í„´*

### Bug Fixes

### Optimizations

### New Features

## ğŸ—‚ï¸ Task Archive
*ì•„ì¹´ì´ë¸Œëœ ì‘ì—…ë“¤*

"""

def get_vibe_project_vision_template() -> str:
    """project_vision.md í…œí”Œë¦¿ ìƒì„± (í™•ì¥ëœ ë²„ì „)"""
    return """# ğŸ¯ Project Overview
*ì´ í”„ë¡œì íŠ¸ê°€ ë­”ì§€*

## AI-Coding-Brain-MCP
execute_code ê¸°ë°˜ 24ê°œ í—¬í¼ í•¨ìˆ˜ì™€ ì§€ì†ì  ì„¸ì…˜ì„ í™œìš©í•œ ì§€ëŠ¥í˜• ê°œë°œ ì–´ì‹œìŠ¤í„´íŠ¸

## ğŸ—ï¸ Architecture
*ì „ì²´ êµ¬ì¡°ì™€ ì„¤ê³„*

### Core Components
- execute_code ì‹œìŠ¤í…œ (24ê°œ í—¬í¼ í•¨ìˆ˜)
- parse_with_snippets ì¤‘ì‹¬ ë¶„ì„
- ì—°ì† ì„¸ì…˜ ìƒíƒœ ê´€ë¦¬
- í”¼ë“œë°± ê¸°ë°˜ í•™ìŠµ

## ğŸ› ï¸ Tech Stack
*ì‚¬ìš©í•˜ëŠ” ê¸°ìˆ ë“¤*

- Python (core logic)
- JavaScript/TypeScript (MCP)
- JSON (data storage)
- Markdown (documentation)

## ğŸ“ˆ Overall Progress
*ì „ì²´ ì§„í–‰ë¥ *

### Current Status
- Progress: 0%
- Active Tasks: 0
- Completed: 0

### Progress Bar
[â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 0%

## ğŸ† Major Milestones
*ì£¼ìš” ë§ˆì¼ìŠ¤í†¤*

- [x] Basic helper functions
- [x] parse_with_snippets êµ¬í˜„
- [x] í”¼ë“œë°± ì‹œìŠ¤í…œ
- [x] Vibe Memory System êµ¬í˜„
- [ ] íŒŒì¼ êµ¬ì¡° ìµœì í™” (v2.0)

## ğŸ”® Future Direction
*ì•ìœ¼ë¡œì˜ ë°©í–¥*

- ë” ì§€ëŠ¥ì ì¸ ì½”ë“œ ë¶„ì„
- ìë™í™” í™•ëŒ€
- ê°œë°œì ê²½í—˜ ê°œì„ 
"""

# ===========================================
# ë™ì  ê²½ë¡œ ì²˜ë¦¬ í—¬í¼ í•¨ìˆ˜ë“¤
# ===========================================

def get_dynamic_project_paths(project_context: dict) -> dict:
    """í”„ë¡œì íŠ¸ì˜ ë™ì  ê²½ë¡œ ì •ë³´ ìƒì„±"""
    # 1. í”„ë¡œì íŠ¸ëª… ê°€ì ¸ì˜¤ê¸°
    project_name = (project_context.get('project_name') or 
                   project_context.get('name') or 
                   'ai-coding-brain-mcp')
    
    # 2. ë©”ëª¨ë¦¬ ë£¨íŠ¸ ê°€ì ¸ì˜¤ê¸° (Claude ì„¤ì •ì—ì„œ)
    memory_root = _get_memory_bank_root_from_claude_config()
    memory_path = os.path.join(memory_root, project_name)
    
    # 3. ì½”ë“œ ê²½ë¡œ (contextì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ í˜„ì¬ ë””ë ‰í† ë¦¬)
    code_path = (project_context.get('code_path') or 
                 project_context.get('base_path') or
                 os.getcwd())
    
    # 4. í•„ìš”í•œ íŒŒì¼ ê²½ë¡œë“¤
    return {
        'project_name': project_name,
        'memory_root': memory_root,
        'memory_path': memory_path,
        'code_path': code_path,
        'cache_file': os.path.join(memory_path, '.cache', f'cache_{project_name}.json'),
        'flow_file': os.path.join(memory_path, 'coding_flow.md'),
        'roadmap_file': os.path.join(memory_path, 'feature_roadmap.md'),
        'vision_file': os.path.join(memory_path, 'project_vision.md')
    }

def load_cache_and_sync_flow(paths: dict, project_context: dict) -> dict:
    """ìºì‹œì™€ coding_flow.mdë¥¼ ë¡œë“œí•˜ê³  ë™ê¸°í™”"""
    # 1. ìºì‹œ íŒŒì¼ ë¡œë“œ
    if os.path.exists(paths['cache_file']):
        try:
            with open(paths['cache_file'], 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                # ì¤‘ìš”í•œ ë°ì´í„°ë§Œ ì—…ë°ì´íŠ¸ (ì „ì²´ ë®ì–´ì“°ê¸° ë°©ì§€)
                for key in ['analyzed_files', 'work_tracking', 'symbol_index', 'coding_experiences']:
                    if key in cache_data:
                        project_context[key] = cache_data[key]
        except Exception as e:
            print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    # 2. coding_flow.md ë¡œë“œ ë° ë™ê¸°í™”
    if os.path.exists(paths['flow_file']):
        try:
            flow_data = _parse_coding_flow_md(paths['flow_file'])
            # tasks ë™ê¸°í™”
            if 'tasks' not in project_context:
                project_context['tasks'] = {}
            project_context['tasks']['next'] = flow_data.get('next_up', [])
            project_context['tasks']['done'] = flow_data.get('completed', [])
            if flow_data.get('current_focus'):
                project_context['current_focus'] = flow_data['current_focus']
        except Exception as e:
            print(f"âš ï¸ coding_flow.md ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    return project_context

# ===========================================
# ëª…ë ¹ì–´ ê´€ë ¨ í•¨ìˆ˜ë“¤
# ===========================================

def vibe_task_capture(description: str, project_context: dict) -> str:
    """'/task "ì„¤ëª…"' - ì¦‰ì‹œ íƒœìŠ¤í¬ ì¶”ê°€"""
    if not description.strip():
        return "âŒ Task description required"
    
    _ensure_data_compatibility(project_context)
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    task_entry = {
        'description': description.strip(),
        'added_time': timestamp,
        'status': 'pending'
    }
    
    # vibe_systemì— ì¶”ê°€
    if 'vibe_system' in project_context:
        project_context['vibe_system']['next_tasks'].append(task_entry)
    
    # ìµœìƒìœ„ next_tasksì—ë„ ì¶”ê°€ (AI Brain í˜¸í™˜)
    if 'next_tasks' not in project_context:
        project_context['next_tasks'] = []
    project_context['next_tasks'].append(description.strip())
    
    # work_trackingì—ë„ ì¶”ê°€
    if 'work_tracking' in project_context:
        if 'next_tasks' not in project_context['work_tracking']:
            project_context['work_tracking']['next_tasks'] = []
        if description.strip() not in project_context['work_tracking']['next_tasks']:
            project_context['work_tracking']['next_tasks'].append(description.strip())
    
    return f"âœ… Task added: {description.strip()}"

def vibe_task_complete(task_description: str, project_context: dict) -> str:
    """'/done "íƒœìŠ¤í¬"' - íƒœìŠ¤í¬ ì™„ë£Œ ì²˜ë¦¬"""
    if not task_description.strip():
        return "âŒ Task description required"
    
    if 'vibe_system' not in project_context:
        return "âŒ Vibe system not initialized"
    
    task_desc = task_description.strip()
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    # ì§„í–‰ì¤‘ì¸ íƒœìŠ¤í¬ì—ì„œ ì œê±°
    vibe_sys = project_context['vibe_system']
    remaining_tasks = []
    task_found = False
    
    for task in vibe_sys.get('next_tasks', []):
        if task.get('description', '') == task_desc:
            task_found = True
            # ì™„ë£Œëœ íƒœìŠ¤í¬ë¡œ ì´ë™
            completed_task = task.copy()
            completed_task['completed_time'] = timestamp
            completed_task['status'] = 'completed'
            
            if 'completed_tasks' not in vibe_sys:
                vibe_sys['completed_tasks'] = []
            vibe_sys['completed_tasks'].append(completed_task)
        else:
            remaining_tasks.append(task)
    
    vibe_sys['next_tasks'] = remaining_tasks
    
    if task_found:
        return f"âœ… Task completed: {task_desc}"
    else:
        return f"âŒ Task not found: {task_desc}"

def vibe_update_focus(new_focus: str, project_context: dict) -> str:
    """'/focus "ìƒˆí¬ì»¤ìŠ¤"' - í˜„ì¬ ì§‘ì¤‘ ì˜ì—­ ë³€ê²½"""
    if not new_focus.strip():
        return "âŒ Focus description required"
    
    _ensure_data_compatibility(project_context)
    
    # ì—¬ëŸ¬ ìœ„ì¹˜ì— ì—…ë°ì´íŠ¸
    if 'vibe_system' in project_context:
        project_context['vibe_system']['current_focus'] = new_focus.strip()
    
    project_context['current_focus'] = new_focus.strip()
    
    if 'work_tracking' in project_context:
        project_context['work_tracking']['current_focus'] = new_focus.strip()
    
    return f"âœ… Focus updated: {new_focus.strip()}"

def vibe_get_current_flow(project_context: dict) -> str:
    """'/flow' - ë™ì  ê²½ë¡œ ì²˜ë¦¬ì™€ UserPreferences í˜•ì‹ì˜ ì „ì²´ í”„ë¡œì íŠ¸ ìƒíƒœ"""
    _ensure_data_compatibility(project_context)
    
    # 1. ë™ì  ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
    paths = get_dynamic_project_paths(project_context)
    
    # 2. í˜„ì¬ ë””ë ‰í† ë¦¬ ì €ì¥
    original_cwd = os.getcwd()
    
    try:
        # 3. ë©”ëª¨ë¦¬ ê²½ë¡œë¡œ ì´ë™í•˜ì—¬ ìºì‹œì™€ .md íŒŒì¼ ë¡œë“œ
        if os.path.exists(paths['memory_path']):
            os.chdir(paths['memory_path'])
            project_context = load_cache_and_sync_flow(paths, project_context)
        
        # 4. UserPreferences í˜•ì‹ìœ¼ë¡œ ì¶œë ¥ ìƒì„±
        result = []
        result.append("\nğŸ”¥ AI Coding Brain - Project Status")
        result.append("="*70)
        
        # í”„ë¡œì íŠ¸ ìƒíƒœ ìš”ì•½
        # ê²½ë¡œ ì •ë³´ ì„¹ì…˜ (í”„ë¡œì íŠ¸ ë£¨íŠ¸ì™€ ë©”ëª¨ë¦¬ ë±…í¬ êµ¬ë¶„)
        result.append("\nğŸ“ ê²½ë¡œ ì •ë³´")
        result.append("-" * 60)
        
        # 1. í”„ë¡œì íŠ¸ ë£¨íŠ¸ (ì‹¤ì œ ì½”ë“œ)
        project_root = project_context.get("project_path", os.getcwd())
        result.append("í”„ë¡œì íŠ¸ ë£¨íŠ¸ (ì†ŒìŠ¤ ì½”ë“œ):")
        result.append(f"   ğŸ“‚ {project_root}")
        if os.path.exists(project_root):
            result.append("   âœ… ì¡´ì¬í•¨")
            # ì£¼ìš” ë””ë ‰í† ë¦¬ í‘œì‹œ
            subdirs = []
            for d in ["python", "backup", "tests", ".vscode"]:
                if os.path.exists(os.path.join(project_root, d)):
                    subdirs.append(d)
            if subdirs:
                result.append(f"   â””â”€â”€ í•˜ìœ„ ë””ë ‰í† ë¦¬: {', '.join(subdirs)}")
        else:
            result.append("   âŒ ì¡´ì¬í•˜ì§€ ì•ŠìŒ - ê²½ë¡œ í™•ì¸ í•„ìš”!")
        
        # 2. ë©”ëª¨ë¦¬ ë±…í¬ (ìºì‹œ/ìƒíƒœ)
        memory_bank_root = _get_memory_bank_root_from_claude_config()
        project_memory = os.path.join(memory_bank_root, project_context.get("project_name", "unknown"))
        
        result.append("\në©”ëª¨ë¦¬ ë±…í¬ (ìºì‹œ/ìƒíƒœ):")
        result.append(f"   ğŸ’¾ {project_memory}")
        if os.path.exists(project_memory):
            result.append("   âœ… ì¡´ì¬í•¨")
            # ìºì‹œ íŒŒì¼ í™•ì¸
            cache_files = []
            cache_dir = os.path.join(project_memory, ".cache")
            if os.path.exists(cache_dir):
                cache_files = [f for f in os.listdir(cache_dir) if f.endswith(".json")]
            if cache_files:
                result.append(f"   â””â”€â”€ ìºì‹œ íŒŒì¼: {', '.join(cache_files)}")
        else:
            result.append("   âš ï¸ ì•„ì§ ìƒì„±ë˜ì§€ ì•ŠìŒ")
        
        result.append("\nğŸ“Œ í”„ë¡œì íŠ¸ ìƒíƒœ")
        result.append("-" * 60)
        result.append(f"í”„ë¡œì íŠ¸: {paths['project_name']}")
        result.append(f"í˜„ì¬ Focus: {project_context.get('current_focus', 'Not set')}")
        
        # ì‘ì—… ì§„í–‰ë¥ 
        tasks = project_context.get('tasks', {})
        done_count = len(tasks.get('done', []))
        next_count = len(tasks.get('next', []))
        total_count = done_count + next_count
        progress = (done_count / total_count * 100) if total_count > 0 else 0
        result.append(f"ì‘ì—… ì§„í–‰ë¥ : {progress:.1f}% ({done_count}/{total_count})")
        
        # ë¶„ì„ëœ ì½”ë“œ êµ¬ì¡°
        result.append("\nğŸ“Š ë¶„ì„ëœ ì½”ë“œ êµ¬ì¡° (í”„ë¡œì íŠ¸ ë£¨íŠ¸)")
        result.append("-" * 60)
        
        analyzed_files = project_context.get('analyzed_files', {})
        if analyzed_files:
            total_functions = 0
            total_classes = 0
            
            # íŒŒì¼ëª…ìœ¼ë¡œ ì •ë ¬
            sorted_files = sorted(analyzed_files.items(), key=lambda x: os.path.basename(x[0]))[:5]
            
            for file_path, info in sorted_files:
                file_name = os.path.basename(file_path)
                
                # infoê°€ dictì¸ì§€ í™•ì¸
                if isinstance(info, dict):
                    functions = info.get('functions', [])
                    classes = info.get('classes', [])
                    
                    total_functions += len(functions)
                    total_classes += len(classes)
                    
                    result.append(f"\nğŸ“„ {file_name}")
                    result.append(f"   â€¢ í•¨ìˆ˜: {len(functions)}ê°œ")
                    if functions[:3]:
                        for func in functions[:3]:
                            func_name = func.get('name', func) if isinstance(func, dict) else str(func)
                            result.append(f"     - {func_name}")
                        if len(functions) > 3:
                            result.append(f"     ... ì™¸ {len(functions)-3}ê°œ")
                    
                    if classes:
                        result.append(f"   â€¢ í´ë˜ìŠ¤: {len(classes)}ê°œ")
                        for cls in classes[:2]:
                            cls_name = cls.get('name', cls) if isinstance(cls, dict) else str(cls)
                            result.append(f"     - {cls_name}")
                        if len(classes) > 2:
                            result.append(f"     ... ì™¸ {len(classes)-2}ê°œ")
                else:
                    # infoê°€ stringì´ê±°ë‚˜ ë‹¤ë¥¸ íƒ€ì…ì¸ ê²½ìš°
                    result.append(f"\nğŸ“„ {file_name}")
                    result.append(f"   â€¢ íƒ€ì…: {type(info).__name__}")
                    if isinstance(info, str):
                        result.append(f"   â€¢ ì •ë³´: {info[:50]}...") if len(str(info)) > 50 else result.append(f"   â€¢ ì •ë³´: {info}")
            
            # ì „ì²´ íŒŒì¼ í†µê³„ ê³„ì‚°
            all_analyzed = project_context.get('analyzed_files', {})
            all_total_functions = 0
            all_total_classes = 0
            
            for file_info in all_analyzed.values():
                if isinstance(file_info, dict):
                    all_total_functions += len(file_info.get('functions', []))
                    all_total_classes += len(file_info.get('classes', []))
            
            result.append(f"\nğŸ“ˆ ì „ì²´ í†µê³„:")
            result.append(f"   â€¢ ë¶„ì„ëœ íŒŒì¼: {len(analyzed_files)}ê°œ")
            result.append(f"   â€¢ ì´ í•¨ìˆ˜: {all_total_functions}ê°œ")
            result.append(f"   â€¢ ì´ í´ë˜ìŠ¤: {all_total_classes}ê°œ")
        else:
            result.append("   âš ï¸ ì•„ì§ ë¶„ì„ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        
        # ì‘ì—… ì¶”ì  ì •ë³´
        result.append("\nğŸ”„ ì‘ì—… ì¶”ì  ì •ë³´")
        result.append("-" * 60)
        
        work_tracking = project_context.get('work_tracking', {})
        if work_tracking:
            file_edits = work_tracking.get('file_edits', {})
            if file_edits:
                result.append("ìµœê·¼ í¸ì§‘í•œ íŒŒì¼:")
                sorted_files = sorted(file_edits.items(), key=lambda x: x[1], reverse=True)[:5]
                for file_path, count in sorted_files:
                    result.append(f"   â€¢ {os.path.basename(file_path)}: {count}íšŒ í¸ì§‘")
            
            function_edits = work_tracking.get('function_edits', {})
            if function_edits:
                result.append("\nìµœê·¼ í¸ì§‘í•œ í•¨ìˆ˜:")
                sorted_funcs = sorted(function_edits.items(), 
                                    key=lambda x: x[1].get('count', 0), reverse=True)[:5]
                for func_key, info in sorted_funcs:
                    count = info.get('count', 0)
                    # íŒŒì¼ëª…ê³¼ í•¨ìˆ˜ëª… ë¶„ë¦¬
                    if ':' in func_key:
                        file_part, func_name = func_key.split(':', 1)
                        file_name = os.path.basename(file_part)
                        result.append(f"   â€¢ {file_name}:{func_name}: {count}íšŒ í¸ì§‘")
                    else:
                        result.append(f"   â€¢ {func_key}: {count}íšŒ í¸ì§‘")
        
        # ë©”ëª¨ë¦¬ë±…í¬ ì •ë³´
        result.append("\nğŸ’¾ ë©”ëª¨ë¦¬ë±…í¬ ì •ë³´ (ìºì‹œ/ìƒíƒœ)")
        result.append("-" * 60)
        
        experiences = project_context.get('coding_experiences', [])
        if experiences:
            result.append(f"ì €ì¥ëœ ê²½í—˜: {len(experiences)}ê°œ")
            for exp in experiences[-3:]:
                task = exp.get('task', 'Unknown')
                solution = exp.get('solution', 'N/A')[:50]
                result.append(f"   â€¢ {task}: {solution}...")
        else:
            result.append("   â„¹ï¸ ì•„ì§ ì €ì¥ëœ ê²½í—˜ì´ ì—†ìŠµë‹ˆë‹¤.")
        
        # ë¡œë“œë§µê³¼ ë‹¤ìŒ ë‹¨ê³„
        result.append("\nğŸ¯ ë¡œë“œë§µê³¼ ë‹¤ìŒ ë‹¨ê³„")
        result.append("-" * 60)
        
        if project_context.get('current_focus'):
            result.append(f"í˜„ì¬ Focus: {project_context['current_focus']}")
        
        next_tasks = tasks.get('next', [])
        if next_tasks:
            result.append("\nğŸ“‹ ë‹¤ìŒ ì‘ì—…ë“¤:")
            
            # Phaseë³„ë¡œ ê·¸ë£¹í™” ì‹œë„
            phases = {}
            no_phase_tasks = []
            
            for task in next_tasks:
                import re
                phase_match = re.match(r'\[(.+?)\]', task)
                if phase_match:
                    phase = phase_match.group(1)
                    if phase not in phases:
                        phases[phase] = []
                    phases[phase].append(task)
                else:
                    no_phase_tasks.append(task)
            
            # Phaseë³„ë¡œ í‘œì‹œ
            task_count = 0
            for phase, phase_tasks in phases.items():
                if task_count >= 10:
                    break
                result.append(f"\n   ğŸ“ {phase}:")
                for task in phase_tasks[:3]:
                    task_count += 1
                    task_name = task.split('] ')[1] if '] ' in task else task
                    result.append(f"      â€¢ {task_name}")
                    if task_count >= 10:
                        break
            
            # Phaseê°€ ì—†ëŠ” ì‘ì—…ë“¤
            for i, task in enumerate(no_phase_tasks[:max(0, 10-task_count)], task_count+1):
                result.append(f"   {i}. {task}")
        else:
            result.append("\n   â„¹ï¸ ë‹¤ìŒ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤. /task ëª…ë ¹ìœ¼ë¡œ ì¶”ê°€í•˜ì„¸ìš”.")
        
        done_tasks = tasks.get('done', [])
        if done_tasks:
            result.append("\nâœ… ìµœê·¼ ì™„ë£Œ:")
            for task in done_tasks[-3:]:
                result.append(f"   â€¢ {task}")
        
        # ê²½ë¡œ ì •ë³´ (ë””ë²„ê¹…ìš©)
        result.append("\n" + "="*70)
        result.append("ğŸ“ í”„ë¡œì íŠ¸ ê²½ë¡œ:")
        result.append(f"   â€¢ ì½”ë“œ: {paths['code_path']}")
        result.append(f"   â€¢ ë©”ëª¨ë¦¬: {paths['memory_path']}")
        
        return "\n".join(result)
        
    except Exception as e:
        return f"âŒ Error in /flow: {str(e)}\nê²½ë¡œ: {paths}"
    finally:
        # ì›ë˜ ë””ë ‰í† ë¦¬ë¡œ ë³µì›
        os.chdir(original_cwd)

def vibe_execute_code_hook(func_name: str, result: dict, project_context: dict):
    """execute_code ì‹¤í–‰ í›„ ìë™ í˜¸ì¶œ í›…"""
    if 'vibe_system' not in project_context:
        return
    
    timestamp = dt.datetime.now().strftime("%H:%M")
    
    activity = {
        'function': func_name,
        'timestamp': timestamp,
        'summary': f"Executed {func_name}"
    }
    
    # í•¨ìˆ˜ë³„ íŠ¹ë³„ ì²˜ë¦¬
    if func_name == 'parse_with_snippets' and isinstance(result, dict):
        file_path = result.get('file_path', 'unknown')
        functions_count = len(result.get('functions', []))
        activity['summary'] = f"Analyzed {functions_count} functions in {os.path.basename(file_path)}"
        project_context['vibe_system']['current_focus'] = f"Analyzing: {os.path.basename(file_path)}"
    
    elif func_name in ['safe_replace', 'insert_line', 'delete_lines']:
        file_path = result.get('file_path', 'unknown')
        activity['summary'] = f"Code modification: {func_name}"
        project_context['vibe_system']['current_focus'] = f"Modifying: {os.path.basename(file_path)}"
    
    # ì„¸ì…˜ í™œë™ì— ì¶”ê°€
    if 'session_activities' not in project_context['vibe_system']:
        project_context['vibe_system']['session_activities'] = []
    
    project_context['vibe_system']['session_activities'].append(activity)
    
    # ìµœê·¼ 20ê°œë§Œ ìœ ì§€
    if len(project_context['vibe_system']['session_activities']) > 20:
        project_context['vibe_system']['session_activities'] = project_context['vibe_system']['session_activities'][-20:]

# ===========================================
# VibeMemoryManager í´ë˜ìŠ¤ (v2.0)
# ===========================================

class VibeMemoryManager:
    """ë°”ì´ë¸Œì½”ë”© ë©”ëª¨ë¦¬ ê´€ë¦¬ì (v2.0 - 3ê°œ íŒŒì¼ë¡œ ìµœì í™”)"""
    
    def __init__(self, project_context: dict, project_name: str = None):
        """Claude Desktop ì„¤ì • ê¸°ë°˜ VibeMemoryManager ì´ˆê¸°í™”"""
        self.project_context = project_context

        # ë°ì´í„° êµ¬ì¡° í˜¸í™˜ì„± ë³´ì¥
        _ensure_data_compatibility(self.project_context)

        # project_contextì—ì„œ í”„ë¡œì íŠ¸ëª… ê°€ì ¸ì˜¤ê¸°
        self.project_name = project_name or project_context.get("name", "ai-coding-brain-mcp")

        # Claude Desktop ì„¤ì • ê¸°ë°˜ ê²½ë¡œ ì„¤ì •
        self.memory_bank_root = _get_memory_bank_root_from_claude_config()
        self.memory_path = os.path.join(self.memory_bank_root, self.project_name)

        # project_contextì™€ ì—°ë™
        _sync_project_context_with_memory_bank(self.project_context)

        # 3ê°œ íŒŒì¼ í…œí”Œë¦¿ ì„¤ì • (v2.0)
        self.templates = {
            "coding_flow.md": get_vibe_coding_flow_template(),
            "feature_roadmap.md": get_vibe_feature_roadmap_template(),
            "project_vision.md": get_vibe_project_vision_template()
        }

        # ë©”ëª¨ë¦¬ ë±…í¬ ì´ˆê¸°í™”
        self.initialize()

        print(f"âœ… VibeMemoryManager v2.0 ì´ˆê¸°í™” ì™„ë£Œ: {self.memory_path}")
    
    def initialize(self) -> bool:
        """ë°”ì´ë¸Œ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
        try:
            # ë©”ëª¨ë¦¬ í´ë” ìƒì„±
            _ensure_vibe_memory_structure(self.memory_path)
            
            # project_contextì— vibe_system ì´ˆê¸°í™”
            if 'vibe_system' not in self.project_context:
                self.project_context['vibe_system'] = {
                    'next_tasks': [],
                    'completed_tasks': [],
                    'current_focus': 'Vibe Memory System v2.0 activated',
                    'session_activities': [],
                    'status': 'active',
                    'initialized_at': dt.datetime.now().isoformat()
                }
            
            # ë§ˆí¬ë‹¤ìš´ íŒŒì¼ë“¤ ìƒì„± (3ê°œë§Œ)
            created_files = []
            for filename, template in self.templates.items():
                filepath = os.path.join(self.memory_path, filename)
                if not os.path.exists(filepath):
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(template)
                    created_files.append(filename)
            
            print(f"âœ… Vibe Memory System v2.0 initialized")
            print(f"   ğŸ“ Path: {self.memory_path}")
            print(f"   ğŸ“„ Files: {len(self.templates)} markdown files")
            if created_files:
                print(f"   ğŸ†• Created: {', '.join(created_files)}")
            
            return True
            
        except Exception as e:
            print(f"âŒ Vibe initialization error: {e}")
            return False
    
    def get_status(self) -> dict:
        """í˜„ì¬ ë°”ì´ë¸Œ ì‹œìŠ¤í…œ ìƒíƒœ ë°˜í™˜"""
        if 'vibe_system' not in self.project_context:
            return {'status': 'not_initialized'}
        
        vibe_sys = self.project_context['vibe_system']
        weekly_stats = calculate_weekly_progress(self.project_context)
        
        return {
            'status': vibe_sys.get('status', 'unknown'),
            'current_focus': vibe_sys.get('current_focus', ''),
            'pending_tasks': len(vibe_sys.get('next_tasks', [])),
            'completed_tasks': len(vibe_sys.get('completed_tasks', [])),
            'recent_activities': len(vibe_sys.get('session_activities', [])),
            'weekly_progress': weekly_stats['progress_percentage'],
            'memory_path': self.memory_path
        }

    def sync_to_files(self):
        """ìºì‹œë©”ëª¨ë¦¬ â†’ .md íŒŒì¼ ë™ê¸°í™” (3ê°œ íŒŒì¼ë§Œ)"""
        try:
            _ensure_data_compatibility(self.project_context)
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            sync_results = []
            
            # 1. coding_flow.md ì—…ë°ì´íŠ¸ (í™•ì¥ëœ ë²„ì „)
            flow_content = self._generate_enhanced_flow_content(vibe_sys)
            flow_path = os.path.join(self.memory_path, 'coding_flow.md')
            with open(flow_path, 'w', encoding='utf-8') as f:
                f.write(flow_content)
            sync_results.append("âœ… Updated coding_flow.md")
            
            # 2. feature_roadmap.md ì—…ë°ì´íŠ¸ (í†µê³„ í¬í•¨)
            roadmap_content = self._generate_enhanced_roadmap_content(vibe_sys)
            roadmap_path = os.path.join(self.memory_path, 'feature_roadmap.md')
            with open(roadmap_path, 'w', encoding='utf-8') as f:
                f.write(roadmap_content)
            sync_results.append("âœ… Updated feature_roadmap.md")
            
            # 3. project_vision.md ì—…ë°ì´íŠ¸ (ì§„í–‰ë¥  í¬í•¨)
            vision_content = self._generate_enhanced_vision_content(vibe_sys)
            vision_path = os.path.join(self.memory_path, 'project_vision.md')
            with open(vision_path, 'w', encoding='utf-8') as f:
                f.write(vision_content)
            sync_results.append("âœ… Updated project_vision.md")
            
            # ë™ê¸°í™” ì‹œê°„ ê¸°ë¡
            vibe_sys['last_sync_to_files'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'synced_files': len(sync_results),
                'results': sync_results,
                'timestamp': vibe_sys['last_sync_to_files']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def sync_from_files(self):
        """.md íŒŒì¼ì„ ìºì‹œë©”ëª¨ë¦¬ë¡œ ë™ê¸°í™” (deprecated)"""
        print("âš ï¸ [DEPRECATED] sync_from_files: v2.0ë¶€í„° ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        print("   ë°ì´í„° íë¦„ì€ í•­ìƒ 'Context Manager -> .mdíŒŒì¼' ë‹¨ë°©í–¥ìœ¼ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.")
        return {
            'status': 'deprecated', 
            'message': 'This function is deprecated in v2.0'
        }
    
    def auto_save(self, interval=300):
        """ìë™ ì €ì¥ (ê¸°ë³¸ 5ë¶„ ê°„ê²©)"""
        try:
            sync_result = self.sync_to_files()
            
            if 'vibe_system' not in self.project_context:
                return {'status': 'error', 'message': 'vibe_system not initialized'}
            
            vibe_sys = self.project_context['vibe_system']
            vibe_sys['auto_save_interval'] = interval
            vibe_sys['last_auto_save'] = dt.datetime.now().isoformat()
            
            return {
                'status': 'success',
                'message': f'Auto-save completed (interval: {interval}s)',
                'sync_result': sync_result,
                'timestamp': vibe_sys['last_auto_save']
            }
            
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    def force_sync(self):
        """ê°•ì œ ë™ê¸°í™” (ìºì‹œ -> íŒŒì¼)"""
        try:
            print("ğŸ”„ ê°•ì œ ë™ê¸°í™” (Cache -> Files) ì‹¤í–‰...")
            
            to_files_result = self.sync_to_files()
            
            if to_files_result:
                print("âœ… ë‹¨ë°©í–¥ ë™ê¸°í™” ì™„ë£Œ (Cache â†’ Files)")
                return {
                    'status': 'success',
                    'message': 'Unidirectional sync completed (cache to files)',
                    'direction': 'cache_to_files',
                    'to_files': to_files_result,
                    'timestamp': dt.datetime.now().isoformat()
                }
            else:
                return {'status': 'failed', 'message': 'sync_to_files failed'}
                
        except Exception as e:
            print(f"âŒ ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return {'status': 'error', 'message': str(e)}
    
    def _generate_enhanced_flow_content(self, vibe_sys):
        """coding_flow.md ë‚´ìš© ìƒì„± (í™•ì¥ëœ ë²„ì „)"""
        current_focus = vibe_sys.get('current_focus', '')
        if not current_focus and 'work_tracking' in self.project_context:
            current_focus = self.project_context['work_tracking'].get('current_focus', '')
        if not current_focus:
            current_focus = 'No current focus set'
        
        # ì£¼ê°„ ì§„í–‰ë¥ 
        weekly_stats = calculate_weekly_progress(self.project_context)
        
        # ì˜¤ëŠ˜ì˜ ì‘ì—… ë¶„ë¥˜
        today_tasks = []
        next_tasks = []
        completed_today = []
        
        # ëª¨ë“  ì‘ì—…ì„ ì˜¤ëŠ˜ ì‘ì—…ìœ¼ë¡œ ê°„ì£¼ (ì‹œê°„ ì •ë³´ê°€ ì—†ìœ¼ë¯€ë¡œ)
        for task in vibe_sys.get('next_tasks', []):
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            today_tasks.append(desc)
        
        for task in vibe_sys.get('completed_tasks', []):
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            completed_today.append(desc)
        
        content = f"""# ğŸ”¥ Current Focus
*ì§€ê¸ˆ ë­í•˜ê³  ìˆëŠ”ì§€*

{current_focus}

## ğŸ“… Today's Tasks
*ì˜¤ëŠ˜ í•  ì¼*

### Must Do Today
"""
        for task in today_tasks[:5]:  # ìƒìœ„ 5ê°œ
            content += f"- [ ] {task}\n"
        
        content += f"""
### In Progress
- {current_focus}

## â­ï¸ Next Up ({len(today_tasks)} tasks)
*ë‹¤ìŒ ì‘ì—…ë“¤*

"""
        for task in today_tasks[5:15]:  # 6-15ë²ˆì§¸ ì‘ì—…
            content += f"- [ ] {task}\n"
        
        content += f"""
## âœ… Today's Completed ({len(completed_today)} tasks)
*ì˜¤ëŠ˜ ì™„ë£Œí•œ ì¼*

"""
        for task in completed_today[-10:]:  # ìµœê·¼ 10ê°œ
            content += f"- [x] {task}\n"
        
        content += f"""
## ğŸ“ Quick Notes
*ë¹ ë¥¸ ë©”ëª¨*



## ğŸ“Š This Week Progress
*ì£¼ê°„ ì§„í–‰ë¥ *

- ì´ë²ˆ ì£¼ ì™„ë£Œ: {weekly_stats['completed_this_week']}ê°œ
- í™œì„± ì‘ì—…: {weekly_stats['total_active']}ê°œ
- ì§„í–‰ë¥ : {weekly_stats['progress_percentage']}%

Progress: [{'â–ˆ' * int(weekly_stats['progress_percentage']/10)}{'â–‘' * (10-int(weekly_stats['progress_percentage']/10))}] {weekly_stats['progress_percentage']}%

## ğŸ• Session Activity
*ì„¸ì…˜ í™œë™ ë¡œê·¸*

"""
        # ì„¸ì…˜ í™œë™
        activities = vibe_sys.get('session_activities', [])
        for activity in activities[-10:]:  # ìµœê·¼ 10ê°œ
            content += f"- {activity.get('timestamp', '')}: {activity.get('summary', '')}\n"
        
        content += f"\në§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        
        return content
    
    def _generate_enhanced_roadmap_content(self, vibe_sys):
        """feature_roadmap.md ë‚´ìš© ìƒì„± (í†µê³„ í¬í•¨)"""
        # ê°œë°œ í†µê³„
        stats = get_development_statistics(self.project_context)
        
        # í•™ìŠµëœ íŒ¨í„´
        patterns = extract_learned_patterns(self.project_context)
        
        content = """# ğŸ—ºï¸ Feature Roadmap & History

## ğŸ¯ This Sprint Goals
*ì´ë²ˆ ìŠ¤í”„ë¦°íŠ¸ ëª©í‘œ*

"""
        # ìƒìœ„ 3ê°œ ì‘ì—…ì„ ìŠ¤í”„ë¦°íŠ¸ ëª©í‘œë¡œ
        next_tasks = vibe_sys.get('next_tasks', [])
        for i, task in enumerate(next_tasks[:3], 1):
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            content += f"{i}. {desc}\n"
        
        content += f"""
## âœ… Completed Features ({len(vibe_sys.get('completed_tasks', []))})
*ì™„ë£Œëœ ê¸°ëŠ¥ë“¤*

"""
        # ìµœê·¼ ì™„ë£Œ ì‘ì—…
        for task in vibe_sys.get('completed_tasks', [])[-20:]:
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            content += f"- [x] {desc}\n"
        
        content += """
## ğŸš€ Planned Features  
*ê³„íšëœ ê¸°ëŠ¥ë“¤*

"""
        # í–¥í›„ ê³„íš
        for task in next_tasks[3:10]:  # 4-10ë²ˆì§¸ ì‘ì—…
            desc = task.get('description', task) if isinstance(task, dict) else str(task)
            content += f"- [ ] {desc}\n"
        
        content += f"""
## ğŸ“Š Development Statistics
*ê°œë°œ í†µê³„*

### Overall Stats
- Total Completed: {stats['total_completed']}
- Total Active: {stats['total_active']}
- Files Analyzed: {stats['analyzed_files']}
- Total Functions: {stats['total_functions']}
- Total Classes: {stats['total_classes']}

### Most Active Files
"""
        for i, (file, count) in enumerate(stats['most_edited_files'], 1):
            content += f"{i}. {file} ({count}íšŒ í¸ì§‘)\n"
        
        content += """
### Most Edited Functions
"""
        for i, (func, count) in enumerate(stats['most_edited_functions'], 1):
            content += f"{i}. {func} ({count}íšŒ ìˆ˜ì •)\n"
        
        content += """
## ğŸ’¡ Learned Patterns
*í•™ìŠµëœ íŒ¨í„´*

"""
        # íŒ¨í„´ë³„ ì¶œë ¥
        for category, items in patterns.items():
            if items:
                content += f"### {category.replace('_', ' ').title()}\n"
                for item in items:
                    content += f"- **{item['task']}**: {item['solution']}\n"
                content += "\n"
        
        content += f"""
## ğŸ—‚ï¸ Task Archive
*30ì¼ ì´ìƒ ëœ ì‘ì—…ë“¤ì€ ìë™ìœ¼ë¡œ ì•„ì¹´ì´ë¸Œë©ë‹ˆë‹¤*

ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        return content
    
    def _generate_enhanced_vision_content(self, vibe_sys):
        """project_vision.md ë‚´ìš© ìƒì„± (ì§„í–‰ë¥  í¬í•¨)"""
        # ì „ì²´ ì§„í–‰ë¥  ê³„ì‚°
        weekly_stats = calculate_weekly_progress(self.project_context)
        
        # ê°œë°œ í†µê³„
        stats = get_development_statistics(self.project_context)
        
        content = f"""# ğŸ¯ Project Overview
*ì´ í”„ë¡œì íŠ¸ê°€ ë­”ì§€*

## AI-Coding-Brain-MCP v2.0
execute_code ê¸°ë°˜ í—¬í¼ í•¨ìˆ˜ì™€ ì§€ì†ì  ì„¸ì…˜ì„ í™œìš©í•œ ì§€ëŠ¥í˜• ê°œë°œ ì–´ì‹œìŠ¤í„´íŠ¸
- íŒŒì¼ êµ¬ì¡° ìµœì í™”: 7ê°œ â†’ 3ê°œ íŒŒì¼ë¡œ ê°„ì†Œí™”
- ì‹¤ì‹œê°„ ìƒíƒœ ì¶”ì  ë° ìë™ ë™ê¸°í™”
- ê°œë°œ íŒ¨í„´ í•™ìŠµ ë° ì¬ì‚¬ìš©

## ğŸ—ï¸ Architecture
*ì „ì²´ êµ¬ì¡°ì™€ ì„¤ê³„*

### Core Components
- execute_code ì‹œìŠ¤í…œ (24ê°œ í—¬í¼ í•¨ìˆ˜)
- parse_with_snippets ì¤‘ì‹¬ ë¶„ì„
- Vibe Memory System v2.0 (3ê°œ íŒŒì¼ êµ¬ì¡°)
- ì—°ì† ì„¸ì…˜ ìƒíƒœ ê´€ë¦¬
- í”¼ë“œë°± ê¸°ë°˜ í•™ìŠµ

### File Structure (v2.0)
```
memory_bank/
â””â”€â”€ {self.project_name}/
    â”œâ”€â”€ coding_flow.md      # ì¼ì¼ ì‘ì—… & ì‹¤ì‹œê°„ ìƒíƒœ
    â”œâ”€â”€ feature_roadmap.md  # ê¸°ëŠ¥ ì´ë ¥ & ì¥ê¸° ê³„íš
    â””â”€â”€ project_vision.md   # í”„ë¡œì íŠ¸ ì •ì²´ì„± & í˜„í™©
```

## ğŸ› ï¸ Tech Stack
*ì‚¬ìš©í•˜ëŠ” ê¸°ìˆ ë“¤*

- Python (core logic)
- JavaScript/TypeScript (MCP)
- JSON (data storage)
- Markdown (documentation)

## ğŸ“ˆ Overall Progress
*ì „ì²´ ì§„í–‰ë¥ *

### Current Status
- Progress: {weekly_stats['progress_percentage']}%
- Active Tasks: {stats['total_active']}
- Completed: {stats['total_completed']}
- Analyzed Files: {stats['analyzed_files']}

### Progress Bar
[{'â–ˆ' * int(weekly_stats['progress_percentage']/10)}{'â–‘' * (10-int(weekly_stats['progress_percentage']/10))}] {weekly_stats['progress_percentage']}%

### Key Metrics
- Total Functions: {stats['total_functions']}
- Total Classes: {stats['total_classes']}
- Code Coverage: {stats['analyzed_files']} files analyzed

## ğŸ† Major Milestones
*ì£¼ìš” ë§ˆì¼ìŠ¤í†¤*

- [x] Basic helper functions
- [x] parse_with_snippets êµ¬í˜„
- [x] í”¼ë“œë°± ì‹œìŠ¤í…œ
- [x] Vibe Memory System v1.0 êµ¬í˜„
- [x] íŒŒì¼ êµ¬ì¡° ìµœì í™” v2.0 (3ê°œ íŒŒì¼)
- [ ] ì‹¤ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ
- [ ] AI íŒ¨í„´ í•™ìŠµ ê°•í™”
- [ ] ë‹¤ì¤‘ í”„ë¡œì íŠ¸ ì§€ì›

## ğŸ”® Future Direction
*ì•ìœ¼ë¡œì˜ ë°©í–¥*

### Short Term (1-2 weeks)
- ì‹¤ì‹œê°„ íŒŒì¼ ë³€ê²½ ê°ì§€
- ìë™ ì½”ë“œ ë¦¬ë·° ì‹œìŠ¤í…œ
- í…ŒìŠ¤íŠ¸ ìë™í™”

### Long Term (1-3 months)  
- AI ê¸°ë°˜ ì½”ë“œ ìƒì„±
- íŒ€ í˜‘ì—… ê¸°ëŠ¥
- í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ

ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        return content

# ===========================================
# VibeCommandSystem í´ë˜ìŠ¤ (v2.0)
# ===========================================

class VibeCommandSystem:
    """ë°”ì´ë¸Œ ëª…ë ¹ì–´ ì‹œìŠ¤í…œ"""
    
    def __init__(self, project_context: dict):
        self.project_context = project_context
        self.commands = {
            '/task': self._cmd_task,
            '/flow': self._cmd_flow,
            '/done': self._cmd_done,
            '/focus': self._cmd_focus,
            '/roadmap': self._cmd_roadmap,
            '/vision': self._cmd_vision,
            '/stats': self._cmd_stats,
            'help': self._cmd_help
        }
    
    def execute(self, command_line: str) -> str:
        """ëª…ë ¹ì–´ ì‹¤í–‰"""
        if not isinstance(command_line, str):
            return f"âŒ Invalid command type: expected str, got {type(command_line).__name__}"
        
        if not command_line.strip():
            return "âŒ Command required. Type 'help' for usage."
        
        command_line = command_line.strip()
        
        # ëª…ë ¹ì–´ íŒŒì‹±
        if command_line == 'help':
            return self._cmd_help()
        elif command_line.startswith('/'):
            parts = command_line.split(' ', 1)
            cmd = parts[0]
            arg = parts[1].strip('\"') if len(parts) > 1 else ""
            
            if cmd in self.commands:
                try:
                    return self.commands[cmd](arg)
                except Exception as e:
                    return f"âŒ Error executing {cmd}: {e}"
            else:
                return f"âŒ Unknown command: {cmd}. Type 'help' for available commands."
        else:
            return f"âŒ Commands must start with '/'. Type 'help' for usage."
    
    def _cmd_task(self, description: str) -> str:
        """'/task "ì„¤ëª…"' ëª…ë ¹ì–´"""
        return vibe_task_capture(description, self.project_context)
    
    def _cmd_flow(self, _: str = "") -> str:
        """'/flow' ëª…ë ¹ì–´"""
        return vibe_get_current_flow(self.project_context)
    
    def _cmd_done(self, task_description: str) -> str:
        """'/done "íƒœìŠ¤í¬"' ëª…ë ¹ì–´"""
        return vibe_task_complete(task_description, self.project_context)
    
    def _cmd_focus(self, new_focus: str) -> str:
        """'/focus "ìƒˆí¬ì»¤ìŠ¤"' ëª…ë ¹ì–´"""
        return vibe_update_focus(new_focus, self.project_context)
    
    def _cmd_roadmap(self, _: str = "") -> str:
        """'/roadmap' ëª…ë ¹ì–´"""
        stats = get_development_statistics(self.project_context)
        
        result = "ğŸ—‚ï¸ FEATURE ROADMAP:\n" + "="*40 + "\n"
        result += f"\nğŸ“Š Statistics:\n"
        result += f"  â€¢ Completed: {stats['total_completed']}\n"
        result += f"  â€¢ Active: {stats['total_active']}\n"
        result += f"  â€¢ Files Analyzed: {stats['analyzed_files']}\n"
        
        return result
    
    def _cmd_vision(self, _: str = "") -> str:
        """'/vision' ëª…ë ¹ì–´"""
        return """ğŸ¯ PROJECT VISION:
AI-Coding-Brain-MCP v2.0
- Optimized file structure (3 files)
- Real-time sync and tracking
- Pattern learning system
"""
    
    def _cmd_stats(self, _: str = "") -> str:
        """'/stats' ëª…ë ¹ì–´ - ê°œë°œ í†µê³„"""
        stats = get_development_statistics(self.project_context)
        weekly = calculate_weekly_progress(self.project_context)
        
        result = "ğŸ“Š DEVELOPMENT STATISTICS:\n" + "="*40 + "\n"
        result += f"\nğŸ“ˆ Progress: {weekly['progress_percentage']}%\n"
        result += f"  â€¢ Completed: {stats['total_completed']}\n"
        result += f"  â€¢ Active: {stats['total_active']}\n"
        result += f"\nğŸ“ Code Analysis:\n"
        result += f"  â€¢ Files: {stats['analyzed_files']}\n"
        result += f"  â€¢ Functions: {stats['total_functions']}\n"
        result += f"  â€¢ Classes: {stats['total_classes']}\n"
        
        return result
    
    def _cmd_help(self) -> str:
        """ë„ì›€ë§ ëª…ë ¹ì–´"""
        return """ğŸ”¥ VIBE CODING MEMORY SYSTEM v2.0
================================================================

ğŸ“‹ ë°”ì´ë¸Œ ëª…ë ¹ì–´:
  /task "ì„¤ëª…"        â†’ ì¦‰ì‹œ íƒœìŠ¤í¬ ì¶”ê°€
  /flow              â†’ í˜„ì¬ ì½”ë”© í”Œë¡œìš° ë³´ê¸°
  /done "íƒœìŠ¤í¬"      â†’ íƒœìŠ¤í¬ ì™„ë£Œ ì²˜ë¦¬
  /focus "ìƒˆí¬ì»¤ìŠ¤"   â†’ í˜„ì¬ ì§‘ì¤‘ ì˜ì—­ ë³€ê²½
  /roadmap           â†’ ê¸°ëŠ¥ ë¡œë“œë§µ ë³´ê¸°
  /vision            â†’ í”„ë¡œì íŠ¸ ë¹„ì „ ë³´ê¸°
  /stats             â†’ ê°œë°œ í†µê³„ ë³´ê¸°
  help               â†’ ì´ ë„ì›€ë§

âš¡ v2.0 ê°œì„ ì‚¬í•­:
  â€¢ íŒŒì¼ êµ¬ì¡° ìµœì í™” (7ê°œ â†’ 3ê°œ)
  â€¢ ì£¼ê°„ ì§„í–‰ë¥  ì¶”ì 
  â€¢ ê°œë°œ í†µê³„ ê°•í™”
  â€¢ íŒ¨í„´ í•™ìŠµ ì‹œìŠ¤í…œ

ğŸš€ ì‹œì‘í•˜ê¸°: vibe_system.initialize() ì‹¤í–‰ í›„ ì‚¬ìš©!
================================================================"""

# ===========================================
# ì „ì—­ í•¨ìˆ˜ë“¤
# ===========================================

def initialize_vibe_system(project_context: dict, project_name: str = 'ai-coding-brain-mcp') -> tuple:
    """ë°”ì´ë¸Œ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ë° ë°˜í™˜"""
    vibe_manager = VibeMemoryManager(project_context, project_name)
    vibe_commands = VibeCommandSystem(project_context)
    
    success = vibe_manager.initialize()
    
    return vibe_manager, vibe_commands, success

def register_vibe_helpers():
    """ë°”ì´ë¸Œ í—¬í¼ í•¨ìˆ˜ë“¤ì„ ì „ì—­ì— ë“±ë¡"""
    # í—¬í¼ í•¨ìˆ˜ë“¤ì„ globalsì— ì¶”ê°€
    globals()['_ensure_data_compatibility'] = _ensure_data_compatibility
    globals()['_parse_coding_flow_md'] = _parse_coding_flow_md
    globals()['calculate_weekly_progress'] = calculate_weekly_progress
    globals()['get_development_statistics'] = get_development_statistics
    globals()['extract_learned_patterns'] = extract_learned_patterns
    
    print("âœ… Vibe helper functions registered globally", file=sys.stderr)
    return True

def enable_auto_sync_for_project_context(project_context):
    """project_contextì— auto_sync í™œì„±í™”"""
    try:
        if 'sync_status' not in project_context:
            project_context['sync_status'] = {
                'last_sync': datetime.now().isoformat(),
                'pending_changes': [],
                'auto_sync': True
            }
        
        project_context['sync_status']['auto_sync'] = True
        print("âœ… Auto-sync í™œì„±í™”ë¨")
        
        return True
    except Exception as e:
        print(f"âŒ Auto-sync í™œì„±í™” ì‹¤íŒ¨: {e}")
        return False

# ===========================================
# Global Claude Memory Functions
# ===========================================

def save_coding_experience(data, project_context=None, tech_stack=None, importance=0.7):
    """ê°œë°œ ê²½í—˜ ìë™ ì €ì¥"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        # ë°ì´í„° êµ¬ì¡°í™”
        if isinstance(data, str):
            structured_data = {
                'task': data,
                'solution': '',
                'tech_stack': tech_stack or ['Python'],
                'importance': importance,
                'timestamp': datetime.now().isoformat()
            }
        else:
            structured_data = data
            structured_data['importance'] = importance
            structured_data['timestamp'] = datetime.now().isoformat()
        
        # coding_experiencesì— ì¶”ê°€
        if 'coding_experiences' not in project_context:
            project_context['coding_experiences'] = []
        
        project_context['coding_experiences'].append(structured_data)
        
        # ìµœê·¼ 100ê°œë§Œ ìœ ì§€
        if len(project_context['coding_experiences']) > 100:
            project_context['coding_experiences'] = project_context['coding_experiences'][-100:]
        
        return {"status": "success", "message": "Experience saved"}
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

def search_coding_solutions(query, project_context=None, tech_stack=None, limit=10):
    """ê³¼ê±° í•´ê²°ì±… ê²€ìƒ‰"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        experiences = project_context.get('coding_experiences', [])
        results = []
        
        # ê°„ë‹¨í•œ í‚¤ì›Œë“œ ë§¤ì¹­
        query_lower = query.lower()
        for exp in experiences:
            if isinstance(exp, dict):
                task = exp.get('task', '').lower()
                solution = exp.get('solution', '').lower()
                
                if query_lower in task or query_lower in solution:
                    results.append(exp)
        
        # ìµœê·¼ ê²ƒë¶€í„° ë°˜í™˜
        results = results[-limit:]
        results.reverse()
        
        return {"status": "success", "results": results}
        
    except Exception as e:
        return {"status": "error", "message": str(e), "results": []}

def get_coding_insights(project_context=None, tech_stack=None, time_range=30):
    """í”„ë¡œì íŠ¸ë³„ ì¸ì‚¬ì´íŠ¸"""
    try:
        if project_context is None:
            project_context = globals().get('project_context', {})
        
        stats = get_development_statistics(project_context)
        patterns = extract_learned_patterns(project_context)
        
        insights = {
            "status": "success",
            "statistics": stats,
            "patterns": patterns,
            "recommendations": []
        }
        
        # ì¶”ì²œì‚¬í•­ ìƒì„±
        if stats['total_active'] > 20:
            insights['recommendations'].append("í™œì„± ì‘ì—…ì´ ë§ìŠµë‹ˆë‹¤. ìš°ì„ ìˆœìœ„ë¥¼ ì •ë¦¬í•˜ì„¸ìš”.")
        
        if stats['analyzed_files'] < 5:
            insights['recommendations'].append("ë” ë§ì€ íŒŒì¼ì„ ë¶„ì„í•˜ì—¬ ì „ì²´ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ì„¸ìš”.")
        
        return insights
        
    except Exception as e:
        return {"status": "error", "message": str(e)}

# ===========================================
# __all__ ì„ ì–¸ëœ í•¨ìˆ˜ë“¤ êµ¬í˜„ (VibeMemoryManager ë˜í¼)
# ===========================================

def sync_to_files():
    """ìºì‹œë©”ëª¨ë¦¬ë¥¼ .md íŒŒì¼ë¡œ ë™ê¸°í™”"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].sync_to_files()
    else:
        print('âš ï¸ vibe_managerê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ')
        return False

def sync_from_files():
    """.md íŒŒì¼ì„ ìºì‹œë©”ëª¨ë¦¬ë¡œ ë™ê¸°í™” (deprecated)"""
    print("âš ï¸ [DEPRECATED] sync_from_files: v2.0ë¶€í„° ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
    return {'status': 'deprecated', 'message': 'This function is deprecated in v2.0'}

def auto_save(interval=300):
    """ìë™ ì €ì¥ í™œì„±í™”"""
    if 'vibe_manager' in globals():
        return globals()['vibe_manager'].auto_save(interval)
    else:
        print('âš ï¸ vibe_managerê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ')
        return False

def force_sync():
    """ê°•ì œ ë™ê¸°í™”"""
    project_context = globals().get('project_context', {})
    if not project_context:
        return {'status': 'error', 'message': 'project_context not found'}
    
    _ensure_data_compatibility(project_context)
    
    if 'vibe_manager' not in globals():
        globals()['vibe_manager'] = VibeMemoryManager(project_context)
    
    return globals()['vibe_manager'].force_sync()

# ìë™ ë“±ë¡
if __name__ == "__main__":
    register_vibe_helpers()
    print("ğŸ”¥ Vibe Memory System v2.0 loaded!")
