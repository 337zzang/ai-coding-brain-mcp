import sys
"""
ğŸ” Search Helper - ê¸°ì¡´ Search MCP ë„êµ¬ë“¤ í†µí•©

ê¸°ì¡´ Search 2ê°œ MCP ë„êµ¬ë“¤ì„ í—¬í¼ í•¨ìˆ˜ë¡œ í†µí•©:
- search_files(): search_files MCP ë„êµ¬ ê¸°ëŠ¥ (ê³ ê¸‰)
- search_code(): search_code MCP ë„êµ¬ ê¸°ëŠ¥ (AST ê¸°ë°˜)
"""

import os
import glob
import re
from typing import Dict, List, Any, Optional

class SearchHelper:
    """
    ê²€ìƒ‰ ê´€ë ¨ í—¬í¼ í•¨ìˆ˜ë“¤ì„ ì œê³µí•˜ëŠ” í´ë˜ìŠ¤
    ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„í•˜ì—¬ ì¤‘ë³µ ì´ˆê¸°í™” ë°©ì§€
    """
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(SearchHelper, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """ì‹±ê¸€í†¤ ì´ˆê¸°í™” - í•œ ë²ˆë§Œ ì‹¤í–‰ë¨"""
        if self._initialized:
            return
            
        self.supported_text_extensions = {
            '.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.c', '.cpp', '.h', '.hpp',
            '.cs', '.php', '.rb', '.go', '.rs', '.kt', '.swift', '.m', '.scala',
            '.txt', '.md', '.rst', '.json', '.xml', '.yaml', '.yml', '.toml',
            '.ini', '.cfg', '.conf', '.sh', '.bash', '.zsh', '.fish', '.ps1',
            '.bat', '.cmd', '.html', '.htm', '.css', '.scss', '.sass', '.less',
            '.sql', '.r', '.R', '.jl', '.lua', '.vim', '.el'
        }
        
        self.default_ignore_dirs = {
            '.git', '.svn', '.hg', '.bzr', '_darcs', '.fossil',
            'node_modules', '__pycache__', '.pytest_cache', '.tox',
            'venv', 'env', '.env', '.venv', 'virtualenv',
            'build', 'dist', '.egg-info', '.eggs',
            '.idea', '.vscode', '.vs', '.atom', '.sublime',
            'target', 'out', 'bin', 'obj',
            '.gradle', '.m2', '.ivy2', '.sbt',
            'vendor', 'packages', 'bower_components'
        }
        
        self.binary_extensions = {
            '.exe', '.dll', '.so', '.dylib', '.a', '.lib', '.o', '.obj',
            '.pyc', '.pyo', '.pyd', '.class', '.jar', '.war', '.ear',
            '.zip', '.tar', '.gz', '.bz2', '.xz', '.7z', '.rar',
            '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.svg',
            '.mp3', '.mp4', '.avi', '.mov', '.wmv', '.flv', '.webm',
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
            '.db', '.sqlite', '.sqlite3', '.mdb', '.accdb'
        }
        
        self._initialized = True
        print("ğŸ” Search Helper ì´ˆê¸°í™” ì™„ë£Œ")
    
    def is_text_file(self, filepath: str) -> bool:
        """íŒŒì¼ì´ í…ìŠ¤íŠ¸ íŒŒì¼ì¸ì§€ í™•ì¸"""
        ext = os.path.splitext(filepath)[1].lower()
        return ext in self.supported_text_extensions
    
    def is_binary_file(self, filepath: str) -> bool:
        """íŒŒì¼ì´ ë°”ì´ë„ˆë¦¬ íŒŒì¼ì¸ì§€ í™•ì¸"""
        ext = os.path.splitext(filepath)[1].lower()
        return ext in self.binary_extensions
    
    def should_ignore_dir(self, dirname: str) -> bool:
        """ë””ë ‰í† ë¦¬ë¥¼ ë¬´ì‹œí•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸"""
        return dirname in self.default_ignore_dirs or dirname.startswith('.')
    
    def format_size(self, size: int) -> str:
        """íŒŒì¼ í¬ê¸°ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f}{unit}"
            size /= 1024.0
        return f"{size:.1f}PB"
    
    def search_content_in_file(self, filepath: str, pattern: str, 
                              case_sensitive: bool = False,
                              whole_word: bool = False,
                              max_matches: int = 100) -> List[Dict[str, Any]]:
        """íŒŒì¼ ë‚´ìš©ì—ì„œ íŒ¨í„´ ê²€ìƒ‰"""
        if not self.is_text_file(filepath):
            return []
        
        matches = []
        flags = 0 if case_sensitive else re.IGNORECASE
        
        if whole_word:
            pattern = r'\b' + re.escape(pattern) + r'\b'
        else:
            pattern = re.escape(pattern)
        
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    for match in re.finditer(pattern, line, flags):
                        matches.append({
                            'line_start': line_num,
                            'line_content': line.rstrip(),
                            'match_start': match.start(),
                            'match_end': match.end(),
                            'match_text': match.group()
                        })
                        
                        if len(matches) >= max_matches:
                            return matches
        except Exception:
            # ì½ê¸° ì˜¤ë¥˜ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
            pass
        
        return matches
    

def scan_directory(path: str = '.', level: int = 1) -> List[str]:
    """ğŸ“ ë””ë ‰í† ë¦¬ ìŠ¤ìº” (ê°œì„ ëœ ë²„ì „)
    
    Args:
        path: ìŠ¤ìº”í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ
        level: ìŠ¤ìº” ê¹Šì´ ë ˆë²¨ (1=í˜„ì¬ ë ˆë²¨ë§Œ, 2=1ë‹¨ê³„ í•˜ìœ„ê¹Œì§€)
    
    Returns:
        íŒŒì¼ ë° ë””ë ‰í† ë¦¬ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
    """
    import os
    
    try:
        if not os.path.exists(path):
            return [f"ERROR: ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {path}"]
        
        if not os.path.isdir(path):
            return [f"ERROR: ë””ë ‰í† ë¦¬ê°€ ì•„ë‹™ë‹ˆë‹¤: {path}"]
        
        results = []
        
        def scan_recursive(current_path: str, current_level: int, max_level: int):
            if current_level > max_level:
                return
            
            try:
                items = os.listdir(current_path)
                items.sort()  # ì•ŒíŒŒë²³ ìˆœ ì •ë ¬
                
                for item in items:
                    item_path = os.path.join(current_path, item)
                    relative_path = os.path.relpath(item_path, path)
                    
                    if os.path.isdir(item_path):
                        results.append(f"[DIR]  {relative_path}")
                        if current_level < max_level:
                            scan_recursive(item_path, current_level + 1, max_level)
                    else:
                        # íŒŒì¼ í¬ê¸° ì •ë³´ ì¶”ê°€
                        try:
                            size = os.path.getsize(item_path)
                            if size > 1024*1024:  # 1MB ì´ìƒ
                                size_str = f"{size/(1024*1024):.1f}MB"
                            elif size > 1024:  # 1KB ì´ìƒ
                                size_str = f"{size/1024:.1f}KB"
                            else:
                                size_str = f"{size}B"
                            results.append(f"[FILE] {relative_path} ({size_str})")
                        except:
                            results.append(f"[FILE] {relative_path}")
                            
            except PermissionError:
                results.append(f"[ERROR] ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ: {current_path}")
            except Exception as e:
                results.append(f"[ERROR] {current_path}: {str(e)}")
        
        scan_recursive(path, 1, level)
        
        if not results:
            results.append(f"INFO: ë¹ˆ ë””ë ‰í† ë¦¬ì…ë‹ˆë‹¤: {path}")
        
        return results
        
    except Exception as e:
        return [f"ERROR: scan_directory ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}"]


# ================================================================
# ğŸ¯ SearchHelper ë˜í¼ í•¨ìˆ˜ë“¤ (AI Coding Brain MCP í™•ì¥)
# ================================================================

def search_files_advanced(path: str = '.', pattern: str = '*', 
                         recursive: bool = True, max_results: int = 100,
                         include_dirs: bool = False, project_context: Optional[Dict] = None) -> Dict[str, Any]:
    """ğŸ“ ê³ ê¸‰ íŒŒì¼ëª… íŒ¨í„´ ê²€ìƒ‰ (SearchHelper.search_files ë˜í¼)
    
    ğŸ¯ ëª©ì :
        íŒŒì¼ëª… íŒ¨í„´ ê¸°ë°˜ ê³ ê¸‰ ê²€ìƒ‰ ê¸°ëŠ¥ ì œê³µ
        ê¸°ì¡´ MCP search_filesë³´ë‹¤ ê°•í™”ëœ ê¸°ëŠ¥
        scan_directory ê¸°ëŠ¥ë„ ì™„ì „íˆ ì»¤ë²„
    
    ğŸ“Š ì£¼ìš” ê¸°ëŠ¥:
        â€¢ glob íŒ¨í„´ ì§€ì› (*, ?, [abc], **/*.py ë“±)
        â€¢ ì¬ê·€/ë¹„ì¬ê·€ ê²€ìƒ‰ ì„ íƒ
        â€¢ ë””ë ‰í† ë¦¬ í¬í•¨/ì œì™¸ ì˜µì…˜
        â€¢ íŒŒì¼ ë©”íƒ€ë°ì´í„° ìë™ ìˆ˜ì§‘ (í¬ê¸°, ìˆ˜ì •ì¼, í™•ì¥ì)
        â€¢ ê²°ê³¼ ìˆ˜ ì œí•œ ë° ì •ë ¬
        â€¢ ê²½ë¡œ ì •ê·œí™” ë° ì˜¤ë¥˜ ì²˜ë¦¬
    
    ğŸ“‹ ë§¤ê°œë³€ìˆ˜:
        path (str): ê²€ìƒ‰í•  ê¸°ë³¸ ê²½ë¡œ (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)
        pattern (str): íŒŒì¼ëª… íŒ¨í„´ (ê¸°ë³¸ê°’: '*' - ëª¨ë“  íŒŒì¼)
        recursive (bool): í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¬ê·€ ê²€ìƒ‰ ì—¬ë¶€ (ê¸°ë³¸ê°’: True)
        max_results (int): ìµœëŒ€ ê²°ê³¼ ìˆ˜ ì œí•œ (ê¸°ë³¸ê°’: 100)
        include_dirs (bool): ë””ë ‰í† ë¦¬ë„ ê²°ê³¼ì— í¬í•¨ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
    
    ğŸ“¤ ë°˜í™˜ê°’:
        Dict[str, Any]: ê²€ìƒ‰ ê²°ê³¼ ì •ë³´
        {
            'search_path': str,           # ê²€ìƒ‰í•œ ì ˆëŒ€ê²½ë¡œ
            'pattern': str,               # ì‚¬ìš©ëœ íŒ¨í„´
            'recursive': bool,            # ì¬ê·€ ê²€ìƒ‰ ì—¬ë¶€
            'results': List[Dict],        # íŒŒì¼/ë””ë ‰í† ë¦¬ ëª©ë¡
            'total_found': int,           # ë°œê²¬ëœ í•­ëª© ìˆ˜
            'max_results': int,           # ì œí•œ ì„¤ì •ê°’
            'truncated': bool,            # ê²°ê³¼ ì˜ë¦¼ ì—¬ë¶€
            'error': str                  # ì˜¤ë¥˜ ë°œìƒì‹œ
        }
        
        results ê° í•­ëª©:
        {
            'path': str,                  # ì ˆëŒ€ê²½ë¡œ
            'name': str,                  # íŒŒì¼/ë””ë ‰í† ë¦¬ëª…
            'type': str,                  # 'file' ë˜ëŠ” 'directory'
            'size': int,                  # íŒŒì¼ í¬ê¸° (ë°”ì´íŠ¸, ë””ë ‰í† ë¦¬ëŠ” None)
            'directory': str,             # ìƒìœ„ ë””ë ‰í† ë¦¬
            'extension': str,             # íŒŒì¼ í™•ì¥ì (ë””ë ‰í† ë¦¬ëŠ” None)
            'modified': float             # ìˆ˜ì •ì¼ (timestamp)
        }
    
    ğŸ’¡ ì‚¬ìš© ì˜ˆì‹œ:
        # ëª¨ë“  Python íŒŒì¼ ê²€ìƒ‰
        search_files_advanced('.', '*.py')
        
        # í˜„ì¬ ë””ë ‰í† ë¦¬ë§Œ ê²€ìƒ‰ (ì¬ê·€ X)
        search_files_advanced('.', '*', recursive=False)
        
        # ë””ë ‰í† ë¦¬ë„ í¬í•¨í•˜ì—¬ ê²€ìƒ‰
        search_files_advanced('.', '*', include_dirs=True)
        
        # íŠ¹ì • íŒ¨í„´ìœ¼ë¡œ ì œí•œëœ ê²€ìƒ‰
        search_files_advanced('/project', '**/*.js', max_results=50)
    
    ğŸ”§ ê¸°ìˆ ì  íŠ¹ì§•:
        â€¢ SearchHelper ì¸ìŠ¤í„´ìŠ¤ ìë™ ìƒì„± ë° ê´€ë¦¬
        â€¢ ì˜ˆì™¸ ì²˜ë¦¬ ë° ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì¤€í™”
        â€¢ ê²½ë¡œ ì •ê·œí™” ë° í”Œë«í¼ í˜¸í™˜ì„±
        â€¢ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬
        â€¢ project_context í†µí•© ë° ìºì‹± ì§€ì›
    
    âš ï¸ ì£¼ì˜ì‚¬í•­:
        â€¢ ëŒ€ìš©ëŸ‰ ë””ë ‰í† ë¦¬ì—ì„œëŠ” max_resultsë¡œ ì œí•œ ê¶Œì¥
        â€¢ ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œì—ì„œëŠ” ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥
        â€¢ ê¶Œí•œ ì—†ëŠ” ë””ë ‰í† ë¦¬ëŠ” ìë™ìœ¼ë¡œ ìŠ¤í‚µ
    """
    try:
        # SearchHelper ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        helper = SearchHelper()
        
        # ë§¤ê°œë³€ìˆ˜ ê²€ì¦
        if not isinstance(path, str) or not path.strip():
            return {'error': 'Invalid path parameter'}
            
        if not isinstance(pattern, str):
            return {'error': 'Invalid pattern parameter'}
        
        # SearchHelper.search_files í˜¸ì¶œ
        result = helper.search_files(
            path=path.strip(),
            pattern=pattern,
            recursive=recursive,
            max_results=max_results,
            include_dirs=include_dirs
        )
        
        # project_contextì— ê²€ìƒ‰ ê¸°ë¡ ì €ì¥ (ìˆì„ ê²½ìš°ì—ë§Œ)
        if project_context is not None:
            if 'search_history' not in project_context:
                project_context['search_history'] = []
            
            project_context['search_history'].append({
            'type': 'file_search',
            'path': path,
            'pattern': pattern,
            'results_count': result.get('total_found', 0),
            'timestamp': __import__('time').time()
            })
        
        return result
        
    except Exception as e:
        error_msg = f"search_files_advanced failed: {str(e)}"
        print(f"âŒ {error_msg}")
        return {'error': error_msg}


def search_code_content(path: str = '.', pattern: str = '', 
                       file_pattern: str = '*', max_results: int = 50,
                       case_sensitive: bool = False, whole_word: bool = False,
                       project_context: Optional[Dict] = None) -> Dict[str, Any]:
    """ğŸ“ ì½”ë“œ ë‚´ìš© í…ìŠ¤íŠ¸ ê²€ìƒ‰ (SearchHelper.search_code ë˜í¼)
    
    ğŸ¯ ëª©ì :
        íŒŒì¼ ë‚´ìš©ì—ì„œ í…ìŠ¤íŠ¸ íŒ¨í„´ ê²€ìƒ‰
        ê¸°ì¡´ MCP search_codeë³´ë‹¤ ê°•í™”ëœ AST ê¸°ë°˜ ê¸°ëŠ¥
        ì •ê·œì‹ ì§€ì› ë° ìƒì„¸í•œ ë§¤ì¹˜ ì •ë³´ ì œê³µ
    
    ğŸ“Š ì£¼ìš” ê¸°ëŠ¥:
        â€¢ ì •ê·œì‹ íŒ¨í„´ ì§€ì› (re.escape ìë™ ì²˜ë¦¬)
        â€¢ ëŒ€ì†Œë¬¸ì êµ¬ë¶„/ë¬´ì‹œ ì„ íƒ
        â€¢ ë‹¨ì–´ ë‹¨ìœ„ ê²€ìƒ‰ ì˜µì…˜ (\b ê²½ê³„ ì‚¬ìš©)
        â€¢ íŒŒì¼ íƒ€ì… í•„í„°ë§ (file_pattern)
        â€¢ ë¼ì¸ ë²ˆí˜¸ ë° ë§¤ì¹˜ ìœ„ì¹˜ ì •ë³´
        â€¢ íŒŒì¼ë³„ ë§¤ì¹˜ ì¹´ìš´íŠ¸ ë° ì •ë ¬
        â€¢ ë°”ì´ë„ˆë¦¬ íŒŒì¼ ìë™ ìŠ¤í‚µ
    
    ğŸ“‹ ë§¤ê°œë³€ìˆ˜:
        path (str): ê²€ìƒ‰í•  ê¸°ë³¸ ê²½ë¡œ (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)
        pattern (str): ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ íŒ¨í„´ (í•„ìˆ˜)
        file_pattern (str): íŒŒì¼ëª… í•„í„° íŒ¨í„´ (ê¸°ë³¸ê°’: '*' - ëª¨ë“  íŒŒì¼)
        max_results (int): ìµœëŒ€ íŒŒì¼ ìˆ˜ ì œí•œ (ê¸°ë³¸ê°’: 50)
        case_sensitive (bool): ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
        whole_word (bool): ë‹¨ì–´ ë‹¨ìœ„ ê²€ìƒ‰ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
    
    ğŸ“¤ ë°˜í™˜ê°’:
        Dict[str, Any]: ê²€ìƒ‰ ê²°ê³¼ ì •ë³´
        {
            'search_path': str,           # ê²€ìƒ‰í•œ ì ˆëŒ€ê²½ë¡œ
            'pattern': str,               # ê²€ìƒ‰ íŒ¨í„´
            'file_pattern': str,          # íŒŒì¼ í•„í„° íŒ¨í„´
            'case_sensitive': bool,       # ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì„¤ì •
            'whole_word': bool,           # ë‹¨ì–´ ë‹¨ìœ„ ê²€ìƒ‰ ì„¤ì •
            'results': List[Dict],        # ë§¤ì¹˜ëœ íŒŒì¼ë“¤
            'total_files': int,           # ë§¤ì¹˜ëœ íŒŒì¼ ìˆ˜
            'total_matches': int,         # ì „ì²´ ë§¤ì¹˜ ìˆ˜
            'max_results': int,           # ì œí•œ ì„¤ì •ê°’
            'truncated': bool,            # ê²°ê³¼ ì˜ë¦¼ ì—¬ë¶€
            'error': str                  # ì˜¤ë¥˜ ë°œìƒì‹œ
        }
        
        results ê° íŒŒì¼:
        {
            'file_path': str,             # íŒŒì¼ ì ˆëŒ€ê²½ë¡œ
            'file_name': str,             # íŒŒì¼ëª…
            'matches': List[Dict],        # ë§¤ì¹˜ ì •ë³´ë“¤
            'match_count': int,           # íŒŒì¼ ë‚´ ë§¤ì¹˜ ìˆ˜
            'file_size': int              # íŒŒì¼ í¬ê¸°
        }
        
        matches ê° ë§¤ì¹˜:
        {
            'line_start': int,            # ë¼ì¸ ë²ˆí˜¸ (1ë¶€í„° ì‹œì‘)
            'line_content': str,          # ë¼ì¸ ì „ì²´ ë‚´ìš©
            'match_start': int,           # ë¼ì¸ ë‚´ ë§¤ì¹˜ ì‹œì‘ ìœ„ì¹˜
            'match_end': int,             # ë¼ì¸ ë‚´ ë§¤ì¹˜ ë ìœ„ì¹˜  
            'match_text': str             # ë§¤ì¹˜ëœ í…ìŠ¤íŠ¸
        }
    
    ğŸ’¡ ì‚¬ìš© ì˜ˆì‹œ:
        # í•¨ìˆ˜ëª… ê²€ìƒ‰
        search_code_content('.', 'def process_data', '*.py')
        
        # ëŒ€ì†Œë¬¸ì êµ¬ë¶„í•˜ì—¬ í´ë˜ìŠ¤ëª… ê²€ìƒ‰
        search_code_content('.', 'MyClass', case_sensitive=True)
        
        # ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë³€ìˆ˜ëª… ê²€ìƒ‰
        search_code_content('.', 'user_id', whole_word=True)
        
        # JavaScript íŒŒì¼ì—ì„œ íŠ¹ì • í•¨ìˆ˜ ê²€ìƒ‰
        search_code_content('./src', 'function.*login', '*.js')
    
    ğŸ”§ ê¸°ìˆ ì  íŠ¹ì§•:
        â€¢ re.compileì„ ì‚¬ìš©í•œ íš¨ìœ¨ì ì¸ ì •ê·œì‹ ì²˜ë¦¬
        â€¢ UTF-8 ì¸ì½”ë”© ë° ì˜¤ë¥˜ ë¬´ì‹œ (errors='ignore')
        â€¢ ë°”ì´ë„ˆë¦¬ íŒŒì¼ ë° ì ‘ê·¼ ë¶ˆê°€ íŒŒì¼ ìë™ ìŠ¤í‚µ
        â€¢ ë§¤ì¹˜ ìˆ˜ ê¸°ì¤€ ì •ë ¬ë¡œ ê´€ë ¨ì„± ë†’ì€ ê²°ê³¼ ìš°ì„ 
        â€¢ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë¼ì¸ ë‹¨ìœ„ ì²˜ë¦¬
    
    âš ï¸ ì£¼ì˜ì‚¬í•­:
        â€¢ patternì´ ë¹„ì–´ìˆìœ¼ë©´ ì˜¤ë¥˜ ë°˜í™˜
        â€¢ ëŒ€ìš©ëŸ‰ íŒŒì¼ì´ ë§ì€ ê²½ìš° max_resultsë¡œ ì œí•œ ê¶Œì¥
        â€¢ ì •ê·œì‹ íŠ¹ìˆ˜ë¬¸ìëŠ” re.escapeë¡œ ìë™ ì´ìŠ¤ì¼€ì´í”„
        â€¢ ë°”ì´ë„ˆë¦¬ íŒŒì¼ì€ ê²€ìƒ‰ì—ì„œ ì œì™¸ë¨
    """
    try:
        # ë§¤ê°œë³€ìˆ˜ ê²€ì¦
        if not pattern or not isinstance(pattern, str):
            return {'error': 'Search pattern is required and must be a string'}
            
        if not isinstance(path, str) or not path.strip():
            return {'error': 'Invalid path parameter'}
        
        # SearchHelper ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        helper = SearchHelper()
        
        # SearchHelper.search_code í˜¸ì¶œ
        result = helper.search_code(
            path=path.strip(),
            pattern=pattern,
            file_pattern=file_pattern,
            max_results=max_results,
            case_sensitive=case_sensitive,
            whole_word=whole_word
        )
        
        # project_contextì— ê²€ìƒ‰ ê¸°ë¡ ì €ì¥ (ìˆì„ ê²½ìš°ì—ë§Œ)
        if project_context is not None:
            if 'search_history' not in project_context:
                project_context['search_history'] = []
            
            project_context['search_history'].append({
            'type': 'code_search',
            'path': path,
            'pattern': pattern,
            'file_pattern': file_pattern,
            'total_matches': result.get('total_matches', 0),
            'total_files': result.get('total_files', 0),
            'timestamp': __import__('time').time()
            })
        
        return result
        
    except Exception as e:
        error_msg = f"search_code_content failed: {str(e)}"
        print(f"âŒ {error_msg}")
        return {'error': error_msg}


# ================================================================
# ğŸ”„ helper í•¨ìˆ˜ ë“±ë¡ ì—…ë°ì´íŠ¸
# ================================================================

print("ğŸ“ ë˜í¼ í•¨ìˆ˜ 2ê°œ ì •ì˜ ì™„ë£Œ:", file=sys.stderr)
print("ğŸ“ ë˜í¼ í•¨ìˆ˜ 2ê°œ ì •ì˜ ì™„ë£Œ:", file=sys.stderr)
print("  1. search_files_advanced() - íŒŒì¼ëª… íŒ¨í„´ ê²€ìƒ‰ ì™„ì „ì²´", file=sys.stderr)
print("  2. search_code_content() - ì½”ë“œ ë‚´ìš© ê²€ìƒ‰ ì „ìš©", file=sys.stderr)
print("âœ… ìƒì„¸í•œ ë…ìŠ¤íŠ¸ë§ ë° ì‚¬ìš© ì˜ˆì‹œ í¬í•¨", file=sys.stderr)
