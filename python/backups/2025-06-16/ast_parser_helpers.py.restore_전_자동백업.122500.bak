# -*- coding: utf-8 -*-
"""
AST Parser Helper - Refactored Version
Python: ast.parse() ê¸°ë°˜ íŒŒì‹±
JavaScript/TypeScript: Tree-sitter ì§€ì—° ë¡œë”© íŒŒì‹±  
"""

import ast
import os
import time
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional, Union, Tuple, cast
import textwrap
import re

# ============================================================================
# ì „ì—­ ì„¤ì • ë° ìºì‹œ
# ============================================================================

# Tree-sitter ì§€ì—° ë¡œë”©
TREE_SITTER_AVAILABLE = False
_tree_sitter_modules = {}
_advanced_parser = None
_parser_lock = threading.Lock()

# ë¡œê¹… ì„¤ì •
VERBOSE = False

def set_verbose(flag: bool) -> None:
    """ì „ì—­ verbose ëª¨ë“œ ì„¤ì •"""
    global VERBOSE
    VERBOSE = flag

def get_verbose() -> bool:
    """í˜„ì¬ verbose ëª¨ë“œ ìƒíƒœ ë°˜í™˜"""
    return VERBOSE

def _log(msg: str, level: str = "INFO") -> None:
    """ì¡°ê±´ë¶€ ë¡œê¹…"""
    if VERBOSE:
        print(f"[{level}] {msg}")

# ============================================================================
# í†µí•© ìºì‹œ ì‹œìŠ¤í…œ
# ============================================================================

class CacheManager:
    """ëª¨ë“  ìºì‹œë¥¼ ì¤‘ì•™ì—ì„œ ê´€ë¦¬"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.ast_cache: Dict[str, Any] = {}
            self.file_mtime_cache: Dict[str, float] = {}
            self.language_cache: Dict[str, Any] = {}
            self.parser_cache: Dict[str, Any] = {}
            self.initialized = True
    
    def get_cached_ast(self, file_path: str) -> Optional[Any]:
        """ìºì‹œëœ AST ë°˜í™˜"""
        if file_path not in self.ast_cache:
            return None
            
        # íŒŒì¼ ìˆ˜ì • ì‹œê°„ í™•ì¸
        try:
            current_mtime = os.path.getmtime(file_path)
            cached_mtime = self.file_mtime_cache.get(file_path, 0)
            
            if current_mtime > cached_mtime:
                # ìºì‹œ ë¬´íš¨í™”
                del self.ast_cache[file_path]
                return None
                
            return self.ast_cache[file_path]
        except:
            return None
    
    def set_cached_ast(self, file_path: str, ast_data: Any):
        """AST ìºì‹œ ì €ì¥"""
        self.ast_cache[file_path] = ast_data
        self.file_mtime_cache[file_path] = os.path.getmtime(file_path)
    
    def clear_all(self):
        """ëª¨ë“  ìºì‹œ ì´ˆê¸°í™”"""
        self.ast_cache.clear()
        self.file_mtime_cache.clear()
        self.language_cache.clear()
        self.parser_cache.clear()

# ============================================================================
# Tree-sitter ì§€ì—° ë¡œë”©
# ============================================================================

def _lazy_import_tree_sitter() -> bool:
    """Tree-sitter ëª¨ë“ˆ ì§€ì—° ì„í¬íŠ¸"""
    global TREE_SITTER_AVAILABLE, _tree_sitter_modules
    
    if _tree_sitter_modules:
        return True
        
    try:
        import tree_sitter
        import tree_sitter_python
        import tree_sitter_javascript
        
        _tree_sitter_modules['tree_sitter'] = tree_sitter
        _tree_sitter_modules['python'] = tree_sitter_python
        _tree_sitter_modules['javascript'] = tree_sitter_javascript
        
        TREE_SITTER_AVAILABLE = True
        _log("Tree-sitter ëª¨ë“ˆ ë¡œë“œ ì„±ê³µ")
        return True
    except ImportError as e:
        _log(f"Tree-sitter ë¡œë“œ ì‹¤íŒ¨: {e}", "WARNING")
        return False

class TreeSitterManager:
    """Tree-sitter íŒŒì„œ ê´€ë¦¬"""
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self._parsers = {}
            self.initialized = True
    
    def get_parser(self, language: str):
        """ì–¸ì–´ë³„ íŒŒì„œ ë°˜í™˜"""
        if not _lazy_import_tree_sitter():
            return None
            
        if language not in self._parsers:
            self._parsers[language] = self._create_parser(language)
            
        return self._parsers[language]
    
    def _create_parser(self, language: str):
        """íŒŒì„œ ìƒì„±"""
        tree_sitter = _tree_sitter_modules.get('tree_sitter')
        if not tree_sitter:
            return None
            
        parser = tree_sitter.Parser()
        
        lang_map = {
            'python': 'python',
            'javascript': 'javascript',
            'typescript': 'javascript'
        }
        
        lang_key = lang_map.get(language)
        if not lang_key:
            return None
            
        lang_module = _tree_sitter_modules.get(lang_key)
        if lang_module:
            parser.set_language(lang_module.Language())
            return parser
            
        return None

# ============================================================================
# AST Parser ë©”ì¸ í´ë˜ìŠ¤
# ============================================================================

class FunctionReplacer(ast.NodeTransformer):
    """
    AST íŠ¸ë¦¬ì—ì„œ íŠ¹ì • ì´ë¦„ì„ ê°€ì§„ í•¨ìˆ˜/ë©”ì„œë“œë¥¼ ì°¾ì•„
    ìƒˆë¡œìš´ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ êµì²´í•˜ëŠ” NodeTransformerì…ë‹ˆë‹¤.
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        # ìƒˆë¡œìš´ ì½”ë“œë¥¼ íŒŒì‹±í•˜ì—¬ êµì²´í•  ë…¸ë“œë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.
        # ì—¬ëŸ¬ ë¬¸ì¥ì´ í¬í•¨ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ bodyì—ì„œ ë…¸ë“œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        self.new_nodes = ast.parse(new_code).body

    def visit_FunctionDef(self, node: ast.FunctionDef) -> Union[ast.FunctionDef, List[ast.AST]]:
        """ì¼ë°˜ í•¨ìˆ˜(def) ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤."""
        # ìì‹ ë…¸ë“œë“¤ë„ ê³„ì† ë°©ë¬¸
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # í•¨ìˆ˜ì˜ ì´ë¦„ì´ ì¼ì¹˜í•˜ë©´ ì¤€ë¹„ëœ ìƒˆ ë…¸ë“œë“¤ë¡œ êµì²´í•©ë‹ˆë‹¤.
            return self.new_nodes
        return node  # ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì›ë˜ ë…¸ë“œë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Union[ast.AsyncFunctionDef, List[ast.AST]]:
        """ë¹„ë™ê¸° í•¨ìˆ˜(async def) ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤."""
        # ìì‹ ë…¸ë“œë“¤ë„ ê³„ì† ë°©ë¬¸
        self.generic_visit(node)
        
        if node.name == self.target_name:
            # í•¨ìˆ˜ì˜ ì´ë¦„ì´ ì¼ì¹˜í•˜ë©´ ì¤€ë¹„ëœ ìƒˆ ë…¸ë“œë“¤ë¡œ êµì²´í•©ë‹ˆë‹¤.
            return self.new_nodes
        return node  # ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì›ë˜ ë…¸ë“œë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.


class EnhancedFunctionReplacer(ast.NodeTransformer):
    """
    í´ë˜ìŠ¤ëª….ë©”ì„œë“œëª… í˜•ì‹ì„ ì§€ì›í•˜ëŠ” í–¥ìƒëœ NodeTransformer
    """
    def __init__(self, target_name: str, new_code: str):
        self.target_name = target_name
        
        # ClassName.method_name í˜•ì‹ íŒŒì‹±
        if '.' in target_name:
            parts = target_name.split('.')
            self.target_class = parts[0]
            self.target_method = parts[1]
            self.is_class_method = True
        else:
            self.target_class = None
            self.target_method = target_name
            self.is_class_method = False
            
        # ìƒˆë¡œìš´ ì½”ë“œ ì¤€ë¹„
        self.new_nodes = ast.parse(new_code).body
        
        # í˜„ì¬ í´ë˜ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì¶”ì 
        self.current_class = None
        self.found_and_replaced = False

    def visit_ClassDef(self, node: ast.ClassDef):
        """í´ë˜ìŠ¤ ì •ì˜ ë°©ë¬¸"""
        # í˜„ì¬ í´ë˜ìŠ¤ ì´ë¦„ ì €ì¥
        old_class = self.current_class
        self.current_class = node.name
        
        # í´ë˜ìŠ¤ ë‚´ë¶€ ë°©ë¬¸
        self.generic_visit(node)
        
        # í´ë˜ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ë³µì›
        self.current_class = old_class
        
        # í´ë˜ìŠ¤ ìì²´ë¥¼ êµì²´í•˜ëŠ” ê²½ìš°
        if not self.is_class_method and node.name == self.target_name:
            self.found_and_replaced = True
            return self.new_nodes
            
        return node

    def visit_FunctionDef(self, node: ast.FunctionDef):
        """ì¼ë°˜ í•¨ìˆ˜(def) ë…¸ë“œ ë°©ë¬¸"""
        self.generic_visit(node)
        
        # í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ì°¾ëŠ” ê²½ìš°
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # ì¼ë°˜ í•¨ìˆ˜ë¥¼ ì°¾ëŠ” ê²½ìš°
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef):
        """ë¹„ë™ê¸° í•¨ìˆ˜(async def) ë…¸ë“œ ë°©ë¬¸"""
        self.generic_visit(node)
        
        # í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ì°¾ëŠ” ê²½ìš°
        if self.is_class_method:
            if (self.current_class == self.target_class and 
                node.name == self.target_method):
                self.found_and_replaced = True
                return self.new_nodes
        else:
            # ì¼ë°˜ í•¨ìˆ˜ë¥¼ ì°¾ëŠ” ê²½ìš°
            if node.name == self.target_method and self.current_class is None:
                self.found_and_replaced = True
                return self.new_nodes
                
        return node


class ScopedFunctionReplacer(ast.NodeTransformer):
    """
    AST íŠ¸ë¦¬ì—ì„œ íŠ¹ì • ìŠ¤ì½”í”„ ë‚´ì˜ í•¨ìˆ˜/ë©”ì„œë“œë¥¼ ì°¾ì•„ êµì²´í•˜ê³ ,
    ì°¾ì€ ìœ„ì¹˜ì˜ ì¤„ ë²ˆí˜¸ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
    """
    def __init__(self, target_name: str, new_code: str):
        # ClassName.method_name í˜•ì‹ íŒŒì‹±
        parts = target_name.split('.')
        self.target_method = parts[-1]
        self.target_class_path = parts[:-1]
        
        self.new_nodes = ast.parse(new_code).body
        self.current_class_path = []
        
        # ì°¾ì€ ë…¸ë“œì˜ ì •ë³´ë¥¼ ì €ì¥í•  ë³€ìˆ˜
        self.found_node_info = None
        self._match_found = False  # ì²« ë²ˆì§¸ ì¼ì¹˜ í•­ëª©ë§Œ ì²˜ë¦¬

    def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:
        """í´ë˜ìŠ¤ ì •ì˜ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ì—¬ í˜„ì¬ ê²½ë¡œë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤."""
        self.current_class_path.append(node.name)
        # í´ë˜ìŠ¤ì˜ ìì‹ ë…¸ë“œë“¤ì„ ë°©ë¬¸
        self.generic_visit(node)
        # í´ë˜ìŠ¤ ìŠ¤ì½”í”„ë¥¼ ë¹ ì ¸ë‚˜ì˜¤ë©´ ê²½ë¡œì—ì„œ ì œê±°
        self.current_class_path.pop()
        return node

    def _is_target_match(self, node_name: str) -> bool:
        """í˜„ì¬ ë…¸ë“œê°€ êµì²´ ëŒ€ìƒì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        # ë©”ì„œë“œ ì´ë¦„ì´ ì¼ì¹˜í•˜ê³ , í´ë˜ìŠ¤ ê²½ë¡œë„ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
        return (node_name == self.target_method and 
                self.current_class_path == self.target_class_path)

    def _process_node(self, node: Union[ast.FunctionDef, ast.AsyncFunctionDef]):
        """ë…¸ë“œ ì²˜ë¦¬ ë¡œì§ì„ í†µí•©í•©ë‹ˆë‹¤."""
        # ìì‹ ë…¸ë“œ ë°©ë¬¸
        self.generic_visit(node)
        
        # ì•„ì§ ì°¾ì§€ ëª»í–ˆê³ , í˜„ì¬ ë…¸ë“œê°€ íƒ€ê²Ÿê³¼ ì¼ì¹˜í•œë‹¤ë©´
        if not self._match_found and self._is_target_match(node.name):
            self._match_found = True
            # ì°¾ì€ ë…¸ë“œì˜ ì •ë³´ë¥¼ ì €ì¥ (ì¤„ ë²ˆí˜¸, ì¢…ë£Œ ì¤„ ë²ˆí˜¸ ë“±)
            self.found_node_info = {
                "name": node.name,
                "lineno": node.lineno,
                "end_lineno": getattr(node, 'end_lineno', node.lineno),  # í•˜ìœ„ í˜¸í™˜ì„±
                "class_path": list(self.current_class_path)
            }
            return self.new_nodes
        return node

    def visit_FunctionDef(self, node: ast.FunctionDef) -> Union[ast.FunctionDef, List[ast.AST]]:
        """ì¼ë°˜ í•¨ìˆ˜(def) ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤."""
        return self._process_node(node)

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> Union[ast.AsyncFunctionDef, List[ast.AST]]:
        """ë¹„ë™ê¸° í•¨ìˆ˜(async def) ë…¸ë“œë¥¼ ë°©ë¬¸í•©ë‹ˆë‹¤."""
        return self._process_node(node)


class ASTCodeEditor:
    """
    ASTë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì½”ë“œì˜ ìƒíƒœë¥¼ ê´€ë¦¬í•˜ë©° ì—¬ëŸ¬ ìˆ˜ì • ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ì—ë””í„° í´ë˜ìŠ¤.
    """
    def __init__(self, file_path: str):
        """
        ì—ë””í„°ë¥¼ ì´ˆê¸°í™”í•˜ê³  ëŒ€ìƒ íŒŒì¼ì„ ë¡œë“œí•˜ì—¬ ASTë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        """
        self.file_path = file_path
        self.tree = None
        self.modified = False
        self.modification_history = []  # ìˆ˜ì • ì´ë ¥ ì¶”ì 
        
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                self.source = f.read()
            self.tree = ast.parse(self.source)
            self.original_tree = ast.parse(self.source)  # ì›ë³¸ ë³´ê´€
            print(f"INFO: '{file_path}' íŒŒì¼ì„ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            print(f"ERROR: íŒŒì¼ ë¡œë“œ ë˜ëŠ” íŒŒì‹± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            raise

    def replace_block(self, block_name: str, new_code: str) -> Optional[Dict[str, Any]]:
        """
        í˜„ì¬ AST ìƒíƒœì—ì„œ ë¸”ë¡ì„ ì°¾ì•„ êµì²´í•©ë‹ˆë‹¤.
        
        Returns:
            Optional[dict]: ì°¾ì€ ë¸”ë¡ì˜ ìœ„ì¹˜ ì •ë³´. ì‹¤íŒ¨ ì‹œ None.
        """
        if not self.tree:
            print("ERROR: ASTê°€ ë¡œë“œë˜ì§€ ì•Šì•„ ì‘ì—…ì„ ì§„í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return None

        # ScopedFunctionReplacer ì‚¬ìš©
        transformer = ScopedFunctionReplacer(block_name, new_code)
        
        # í˜„ì¬ treeë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜ ìˆ˜í–‰
        new_tree = transformer.visit(self.tree)

        if not transformer.found_node_info:
            print(f"WARN: í˜„ì¬ ì½”ë“œ ìƒíƒœì—ì„œ ë¸”ë¡ '{block_name}'ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return None
        
        # ìˆ˜ì • ì´ë ¥ ê¸°ë¡
        self.modification_history.append({
            'block_name': block_name,
            'found_info': transformer.found_node_info,
            'timestamp': __import__('datetime').datetime.now().isoformat()
        })
        
        self.tree = new_tree
        self.modified = True
        ast.fix_missing_locations(self.tree)
        
        found_info = transformer.found_node_info
        print(f"INFO: ë¸”ë¡ '{block_name}'ì„(ë¥¼) ë¼ì¸ {found_info['lineno']}ì—ì„œ ì°¾ì•„ êµì²´í–ˆìŠµë‹ˆë‹¤.")
        return found_info

    def get_modified_code(self) -> Optional[str]:
        """í˜„ì¬ AST ìƒíƒœë¥¼ ì†ŒìŠ¤ ì½”ë“œë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤."""
        if not self.tree:
            return None
        return ast.unparse(self.tree)

    def preview_changes(self) -> None:
        """ìˆ˜ì • ì´ë ¥ì„ í‘œì‹œí•©ë‹ˆë‹¤."""
        if not self.modification_history:
            print("INFO: ìˆ˜ì • ì´ë ¥ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
            
        print("
ğŸ“‹ ìˆ˜ì • ì´ë ¥:")
        print("="*60)
        for i, mod in enumerate(self.modification_history, 1):
            info = mod['found_info']
            print(f"{i}. {mod['block_name']}")
            print(f"   ìœ„ì¹˜: ë¼ì¸ {info['lineno']}-{info['end_lineno']}")
            print(f"   ì‹œê°„: {mod['timestamp']}")

    def save(self, output_path: str = None, create_backup: bool = True) -> bool:
        """
        ìˆ˜ì •ëœ ë‚´ìš©ì„ íŒŒì¼ì— ì €ì¥í•©ë‹ˆë‹¤.

        Args:
            output_path (str, optional): ì €ì¥í•  íŒŒì¼ ê²½ë¡œ. ë¯¸ì§€ì • ì‹œ ì›ë³¸ íŒŒì¼ì— ë®ì–´ì”ë‹ˆë‹¤.
            create_backup (bool): ë°±ì—… ìƒì„± ì—¬ë¶€.
        """
        if not self.modified:
            print("INFO: ë³€ê²½ ì‚¬í•­ì´ ì—†ì–´ íŒŒì¼ì„ ì €ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return True

        if not self.tree:
            print("ERROR: ì €ì¥í•  ASTê°€ ì—†ìŠµë‹ˆë‹¤.")
            return False

        save_path = output_path if output_path else self.file_path
        
        # ë°±ì—… ìƒì„±
        if create_backup and not output_path:
            import shutil
            from datetime import datetime
            backup_path = f"{self.file_path}.{datetime.now().strftime('%Y%m%d_%H%M%S')}.bak"
            try:
                shutil.copy2(self.file_path, backup_path)
                print(f"INFO: ë°±ì—… ìƒì„±: {backup_path}")
            except Exception as e:
                print(f"WARN: ë°±ì—… ìƒì„± ì‹¤íŒ¨: {e}")
        
        try:
            modified_code = self.get_modified_code()
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(modified_code)
            print(f"INFO: ìˆ˜ì •ëœ ë‚´ìš©ì´ '{save_path}'ì— ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
            print(f"     ì´ {len(self.modification_history)}ê°œì˜ ë¸”ë¡ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.")
            self.modified = False  # ì €ì¥ í›„ ìƒíƒœ ì´ˆê¸°í™”
            return True
        except Exception as e:
            print(f"ERROR: íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return False

    def reset(self) -> None:
        """ëª¨ë“  ìˆ˜ì • ì‚¬í•­ì„ ì·¨ì†Œí•˜ê³  ì›ë³¸ ìƒíƒœë¡œ ë˜ëŒë¦½ë‹ˆë‹¤."""
        if self.original_tree:
            self.tree = ast.parse(self.source)  # ì›ë³¸ ì†ŒìŠ¤ì—ì„œ ë‹¤ì‹œ íŒŒì‹±
            self.modified = False
            self.modification_history.clear()
            print("INFO: ëª¨ë“  ìˆ˜ì • ì‚¬í•­ì´ ì·¨ì†Œë˜ê³  ì›ë³¸ ìƒíƒœë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.")



class ASTParser:
    """í†µí•© AST íŒŒì„œ"""
    
    def __init__(self):
        self.cache_manager = CacheManager()
        self.ts_manager = TreeSitterManager()
        
    def _detect_language(self, file_path: str, language: str = 'auto') -> str:
        """íŒŒì¼ ì–¸ì–´ ê°ì§€"""
        if language != 'auto':
            return language
            
        ext = Path(file_path).suffix.lower()
        ext_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.ts': 'typescript',
            '.tsx': 'typescript'
        }
        
        return ext_map.get(ext, 'unknown')
    
    def _extract_docstring(self, node: ast.AST) -> Optional[str]:
        """Python docstring ì¶”ì¶œ"""
        # body ì†ì„±ì´ ìˆëŠ” ë…¸ë“œ íƒ€ì…ë“¤ë§Œ ì²˜ë¦¬
        if not isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef, ast.Module)):
            return None
            
        if not hasattr(node, 'body') or not node.body:
            return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, (ast.Str, ast.Constant)):
            # Python 3.8+ì—ì„œëŠ” ast.Constant ì‚¬ìš©
            if isinstance(first.value, ast.Str):
                return textwrap.dedent(first.value.s).strip()
            elif isinstance(first.value, ast.Constant) and isinstance(first.value.value, str):
                return textwrap.dedent(first.value.value).strip()
                
        return None
            
        first = node.body[0]
        if isinstance(first, ast.Expr) and isinstance(first.value, ast.Str):
            return textwrap.dedent(first.value.s).strip()
            
        return None
    
    def _extract_function_info(self, node: ast.FunctionDef, source_lines: List[str]) -> Dict:
        """í•¨ìˆ˜ ì •ë³´ ì¶”ì¶œ"""
        info = {
            'type': 'function',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'args': [arg.arg for arg in node.args.args],
            'docstring': self._extract_docstring(node),
            'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list if d],
            'is_async': isinstance(node, ast.AsyncFunctionDef)
        }
        
        # ì½”ë“œ ìŠ¤ë‹ˆí« ì¶”ì¶œ
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def _extract_class_info(self, node: ast.ClassDef, source_lines: List[str]) -> Dict:
        """í´ë˜ìŠ¤ ì •ë³´ ì¶”ì¶œ"""
        info = {
            'type': 'class',
            'name': node.name,
            'line_start': node.lineno,
            'line_end': node.end_lineno or node.lineno,
            'bases': [base.id if isinstance(base, ast.Name) else str(base) for base in node.bases],
            'docstring': self._extract_docstring(node),
            'methods': []
        }
        
        # ë©”ì„œë“œ ì¶”ì¶œ
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                method_info = self._extract_function_info(item, source_lines)
                method_info['type'] = 'method'
                info['methods'].append(method_info)
        
        # ì½”ë“œ ìŠ¤ë‹ˆí« ì¶”ì¶œ
        if source_lines and node.lineno and node.end_lineno:
            start = max(0, node.lineno - 1)
            end = min(len(source_lines), node.end_lineno)
            info['snippet'] = '\n'.join(source_lines[start:end])
            
        return info
    
    def parse_python(self, file_path: str, include_snippets: bool = True) -> Dict[str, Any]:
        """Python íŒŒì¼ íŒŒì‹±"""
        try:
            # ìºì‹œ í™•ì¸
            cached = self.cache_manager.get_cached_ast(file_path)
            if cached and not include_snippets:
                return cached
                
            # íŒŒì¼ ì½ê¸°
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # AST íŒŒì‹±
            tree = ast.parse(content, filename=file_path)
            source_lines = content.split('\n') if include_snippets else []
            
            # ê²°ê³¼ ìˆ˜ì§‘
            result = {
                'parsing_success': True,
                'language': 'python',
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # AST ìˆœíšŒ
            for node in ast.walk(tree):  
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    result['functions'].append(self._extract_function_info(node, source_lines))
                elif isinstance(node, ast.ClassDef):
                    result['classes'].append(self._extract_class_info(node, source_lines))
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            result['imports'].append(alias.name)
                    else:
                        result['imports'].append(node.module or '')
            
            # ìºì‹œ ì €ì¥
            if not include_snippets:
                self.cache_manager.set_cached_ast(file_path, result)
                
            return result
            
        except Exception as e:
            _log(f"Python íŒŒì‹± ì˜¤ë¥˜: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': 'python',
                'error': str(e)
            }
    
    def parse_javascript(self, file_path: str, language: str = 'javascript', 
                        include_snippets: bool = True) -> Dict[str, Any]:
        """JavaScript/TypeScript íŒŒì¼ íŒŒì‹±"""
        parser = self.ts_manager.get_parser(language)
        if not parser:
            return {
                'parsing_success': False,
                'language': language,
                'error': 'Tree-sitter not available'
            }
            
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
                
            tree = parser.parse(content)
            
            # ê°„ë‹¨í•œ ê²°ê³¼ ë°˜í™˜ (ì‹¤ì œ êµ¬í˜„ì€ ë” ë³µì¡í•¨)
            result = {
                'parsing_success': True,
                'language': language,
                'functions': [],
                'classes': [],
                'imports': []
            }
            
            # Tree-sitter ë…¸ë“œ ìˆœíšŒ ë¡œì§ (ê°„ëµí™”)
            # ì‹¤ì œë¡œëŠ” traverse_node ê°™ì€ ë³µì¡í•œ í•¨ìˆ˜ê°€ í•„ìš”í•˜ì§€ë§Œ
            # ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ì²˜ë¦¬
            
            return result
            
        except Exception as e:
            _log(f"JavaScript íŒŒì‹± ì˜¤ë¥˜: {e}", "ERROR")
            return {
                'parsing_success': False,
                'language': language,
                'error': str(e)
            }
    
    def parse_with_snippets(self, file_path: str, language: str = 'auto', 
                          include_snippets: bool = True) -> Dict[str, Any]:
        """íŒŒì¼ íŒŒì‹± ë©”ì¸ ë©”ì„œë“œ"""
        # ì–¸ì–´ ê°ì§€
        detected_lang = self._detect_language(file_path, language)
        
        if detected_lang == 'python':
            return self.parse_python(file_path, include_snippets)
        elif detected_lang in ['javascript', 'typescript']:
            return self.parse_javascript(file_path, detected_lang, include_snippets)
        else:
            return {
                'parsing_success': False,
                'language': detected_lang,
                'error': f'Unsupported language: {detected_lang}'
            }
    
    def get_snippet_preview(self, file_path: str, element_name: str, 
                          element_type: str = 'function', max_lines: int = 10) -> str:
        """ì½”ë“œ ìŠ¤ë‹ˆí« ë¯¸ë¦¬ë³´ê¸°"""
        result = self.parse_with_snippets(file_path, include_snippets=True)
        
        if not result.get('parsing_success'):
            return f"Error: {result.get('error', 'Unknown error')}"
            
        # ìš”ì†Œ ì°¾ê¸°
        element_key = f'{element_type}s'
        if element_type == 'class':
            element_key = 'classes'
        elif element_type == 'function':
            element_key = 'functions'
            
        elements = result.get(element_key, [])
        for elem in elements:
            if elem.get('name') == element_name:
                snippet = elem.get('snippet', '')
                if not snippet:
                    # snippetì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì •ë³´ ë°˜í™˜
                    return f"{element_type} '{element_name}' found at line {elem.get('line_start', '?')}"
                    
                lines = snippet.split('\n')
                if len(lines) > max_lines:
                    return '\n'.join(lines[:max_lines]) + '\n...'
                return snippet
                

    def replace_block(self, file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
        """
        íŒŒì¼ ë‚´ì—ì„œ ì´ë¦„ì´ ì¼ì¹˜í•˜ëŠ” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ ì°¾ì•„ ìƒˆ ì½”ë“œë¡œ êµì²´í•©ë‹ˆë‹¤.
        
        ì§€ì› í˜•ì‹:
        - 'function_name' : ìµœìƒìœ„ í•¨ìˆ˜ ë˜ëŠ” ì²« ë²ˆì§¸ ë§¤ì¹­ë˜ëŠ” ë©”ì„œë“œ
        - 'ClassName' : í´ë˜ìŠ¤ ì „ì²´
        - 'ClassName.method_name' : íŠ¹ì • í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ (ì •í™•í•œ ì§€ì •)

        Args:
            file_path (str): ìˆ˜ì •í•  íŒŒì¼ì˜ ê²½ë¡œ.
            block_name (str): êµì²´í•  ë¸”ë¡ì˜ ì´ë¦„.
            new_code (str): êµì²´í•  ìƒˆë¡œìš´ ì½”ë“œ ë¸”ë¡.
            output_path (str, optional): ê²°ê³¼ë¥¼ ì €ì¥í•  íŒŒì¼ ê²½ë¡œ.

        Returns:
            str: ì„±ê³µ ì‹œ "SUCCESS: ...", ì‹¤íŒ¨ ì‹œ "ERROR: ..." ë©”ì‹œì§€
        """
        try:
            # 1. íŒŒì¼ì„ ì½ê³  ASTë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
            with open(file_path, 'r', encoding='utf-8') as f:
                source = f.read()
            tree = ast.parse(source, filename=file_path)

            # 2. ì ì ˆí•œ Replacer ì„ íƒ
            if '.' in block_name:
                # ClassName.method_name í˜•ì‹ì¸ ê²½ìš°
                transformer = EnhancedFunctionReplacer(block_name, new_code)
            else:
                # ë‹¨ìˆœ ì´ë¦„ì¸ ê²½ìš°
                transformer = FunctionReplacer(block_name, new_code)
            
            # 3. AST ë³€í™˜
            new_tree = transformer.visit(tree)

            # 4. êµì²´ ì„±ê³µ ì—¬ë¶€ í™•ì¸
            if hasattr(transformer, 'found_and_replaced') and not transformer.found_and_replaced:
                return f"ERROR: ë¸”ë¡ '{block_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"

            # 5. ë³€ê²½ëœ AST í›„ì²˜ë¦¬
            ast.fix_missing_locations(new_tree)

            # 6. ìˆ˜ì •ëœ ASTë¥¼ ì†ŒìŠ¤ ì½”ë“œë¡œ ë³€í™˜
            modified_code = ast.unparse(new_tree)
            
            # 7. ê²°ê³¼ ì €ì¥
            save_path = output_path or file_path
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(modified_code)
            
            return f"SUCCESS: ë¸”ë¡ '{block_name}' êµì²´ ì™„ë£Œ (íŒŒì¼: {save_path})"

        except FileNotFoundError:
            return f"ERROR: íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {file_path}"
        except Exception as e:
            return f"ERROR: ì½”ë“œ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"

# ============================================================================
# ì „ì—­ íŒŒì„œ ì¸ìŠ¤í„´ìŠ¤
# ============================================================================

def _get_parser() -> ASTParser:
    """ì‹±ê¸€í†¤ íŒŒì„œ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜"""
    global _advanced_parser, _parser_lock
    
    if _advanced_parser is None:
        with _parser_lock:
            if _advanced_parser is None:
                _advanced_parser = ASTParser()
                
    return _advanced_parser

# ============================================================================
# ê³µê°œ API
# ============================================================================

def parse_with_snippets(file_path: str, language: str = 'auto', 
                       include_snippets: bool = True) -> Dict[str, Any]:
    """íŒŒì¼ íŒŒì‹± (ê³µê°œ API)"""
    parser = _get_parser()
    return parser.parse_with_snippets(file_path, language, include_snippets)

def get_snippet_preview(file_path: str, element_name: str, 
                       element_type: str = 'function', max_lines: int = 10,
                       start_line: int = -1, end_line: int = -1) -> str:
    """ì½”ë“œ ìŠ¤ë‹ˆí« ë¯¸ë¦¬ë³´ê¸° (ê³µê°œ API)"""
    parser = _get_parser()
    return parser.get_snippet_preview(file_path, element_name, element_type, max_lines)

# ============================================================================
# ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™” (ì„ íƒì )
# ============================================================================

def init_background():
    """ë°±ê·¸ë¼ìš´ë“œì—ì„œ Tree-sitter ì´ˆê¸°í™”"""
    def _init():
        _lazy_import_tree_sitter()
        _log("ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™” ì™„ë£Œ")
        
    thread = threading.Thread(target=_init, daemon=True)
    thread.start()

# ìë™ ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™”
init_background()

def replace_block(file_path: str, block_name: str, new_code: str, output_path: str = None) -> str:
    """
    íŒŒì¼ ë‚´ì—ì„œ ì´ë¦„ì´ ì¼ì¹˜í•˜ëŠ” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œë¥¼ ì°¾ì•„ ìƒˆ ì½”ë“œë¡œ êµì²´í•©ë‹ˆë‹¤.
    (í´ë˜ìŠ¤ ë‚´ë¶€ ë©”ì„œë“œë„ ì§€ì›)
    """
    parser = ASTParser()
    return parser.replace_block(file_path, block_name, new_code, output_path)

def replace_block_with_info(file_path: str, block_name: str, new_code: str, output_path: str = None) -> Tuple[Optional[str], Optional[Dict[str, Any]]]:
    """
    íŒŒì¼ ë‚´ì—ì„œ ë¸”ë¡ì„ ì°¾ì•„ êµì²´í•˜ê³ , ìˆ˜ì •ëœ ì½”ë“œì™€ ë¸”ë¡ì˜ ìœ„ì¹˜ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    Returns:
        Tuple[Optional[str], Optional[dict]]: (ìˆ˜ì • ê²°ê³¼ ë©”ì‹œì§€, ì°¾ì€ ë¸”ë¡ ì •ë³´)
    """
    parser = ASTParser()
    result = parser.replace_block(file_path, block_name, new_code, output_path)
    
    # ê²°ê³¼ê°€ íŠœí”Œì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
    if isinstance(result, tuple):
        return result
    # ë¬¸ìì—´ì´ë©´ ì •ë³´ ì—†ì´ ë°˜í™˜
    else:
        return result, None


def batch_replace_blocks(file_path: str, replacements: List[Tuple[str, str]], output_path: str = None) -> bool:
    """
    ì—¬ëŸ¬ ë¸”ë¡ì„ ì—°ì†ì ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ êµì²´í•©ë‹ˆë‹¤.
    
    Args:
        file_path (str): ìˆ˜ì •í•  íŒŒì¼ ê²½ë¡œ
        replacements (List[Tuple[str, str]]): [(block_name, new_code), ...] í˜•íƒœì˜ êµì²´ ëª©ë¡
        output_path (str, optional): ìµœì¢… ê²°ê³¼ë¥¼ ì €ì¥í•  ê²½ë¡œ
        
    Returns:
        bool: ëª¨ë“  êµì²´ê°€ ì„±ê³µí•˜ë©´ True
    """
    try:
        editor = ASTCodeEditor(file_path)
        
        success_count = 0
        for block_name, new_code in replacements:
            found_info = editor.replace_block(block_name, new_code)
            if found_info:
                success_count += 1
            else:
                print(f"WARN: '{block_name}' ë¸”ë¡ êµì²´ ì‹¤íŒ¨")
        
        if success_count > 0:
            editor.preview_changes()
            editor.save(output_path)
            return True
        else:
            print("ERROR: êµì²´ëœ ë¸”ë¡ì´ ì—†ìŠµë‹ˆë‹¤.")
            return False
            
    except Exception as e:
        print(f"ERROR: ë°°ì¹˜ êµì²´ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return False
