import sys
"""
ğŸ” Search Helper - ê¸°ì¡´ Search MCP ë„êµ¬ë“¤ í†µí•©

ê¸°ì¡´ Search 2ê°œ MCP ë„êµ¬ë“¤ì„ í—¬í¼ í•¨ìˆ˜ë¡œ í†µí•©:
- search_files(): search_files MCP ë„êµ¬ ê¸°ëŠ¥ (ê³ ê¸‰)
- search_code(): search_code MCP ë„êµ¬ ê¸°ëŠ¥ (AST ê¸°ë°˜)
"""

import os
import glob
import re
from typing import Dict, List, Any, Optional

class SearchHelper:
    """ğŸ” Search í†µí•© í—¬í¼"""
    
    _instance = None
    _initialized = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(SearchHelper, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        # ì´ë¯¸ ì´ˆê¸°í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸
        if hasattr(self, '_initialized'):
            return
        self._initialized = True
        
        # í•œ ë²ˆë§Œ ì¶œë ¥
        # print("ğŸ” Search Helper ì´ˆê¸°í™” ì™„ë£Œ")  # ì´ˆê¸°í™” ë©”ì‹œì§€ ì œê±°
        
        # ê²€ìƒ‰ ê²°ê³¼ ìºì‹œ
        self._search_cache = {}
        self._cache_ttl = 300  # 5ë¶„
    def search_files(self, path: str = '.', pattern: str = '*', 
                    recursive: bool = True, max_results: int = 100,
                    include_dirs: bool = False) -> Dict[str, Any]:
        """ğŸ“ íŒŒì¼ëª… íŒ¨í„´ ê²€ìƒ‰ (search_files MCP ë„êµ¬ ê³ ê¸‰ ë²„ì „)"""
        try:
            if not os.path.exists(path):
                return {'error': f'Search path not found: {path}'}
            
            results = []
            search_pattern = os.path.join(path, '**', pattern) if recursive else os.path.join(path, pattern)
            
            for file_path in glob.glob(search_pattern, recursive=recursive):
                is_dir = os.path.isdir(file_path)
                
                if is_dir and not include_dirs:
                    continue
                if not is_dir and not os.path.isfile(file_path):
                    continue
                
                results.append({
                    'path': os.path.abspath(file_path),
                    'name': os.path.basename(file_path),
                    'type': 'directory' if is_dir else 'file',
                    'size': None if is_dir else os.path.getsize(file_path),
                    'directory': os.path.dirname(file_path),
                    'extension': os.path.splitext(file_path)[1] if not is_dir else None,
                    'modified': os.path.getmtime(file_path)
                })
                
                if len(results) >= max_results:
                    break
            
            # ì •ë ¬: íƒ€ì…ë³„, ì´ë¦„ë³„
            results.sort(key=lambda x: (x['type'], x['name']))
            
            return {
                'search_path': os.path.abspath(path),
                'pattern': pattern,
                'recursive': recursive,
                'results': results,
                'total_found': len(results),
                'max_results': max_results,
                'truncated': len(results) >= max_results
            }
            
        except Exception as e:
            return {'error': f'File search failed: {str(e)}'}
    
    def search_code(self, path: str = '.', pattern: str = '', 
                   file_pattern: str = '*', max_results: int = 50,
                   case_sensitive: bool = False, whole_word: bool = False) -> Dict[str, Any]:
        """ğŸ“ ì½”ë“œ ë‚´ìš© ê²€ìƒ‰ (search_code MCP ë„êµ¬ AST ê¸°ë°˜ í™•ì¥)"""
        try:
            if not pattern:
                return {'error': 'Search pattern is required'}
            
            if not os.path.exists(path):
                return {'error': f'Search path not found: {path}'}
            
            results = []
            flags = 0 if case_sensitive else re.IGNORECASE
            
            # ì •ê·œì‹ íŒ¨í„´ ì¤€ë¹„
            if whole_word:
                regex_pattern = rf'\b{re.escape(pattern)}\b'
            else:
                regex_pattern = re.escape(pattern)
            
            compiled_pattern = re.compile(regex_pattern, flags)
            
            # íŒŒì¼ ê²€ìƒ‰ ë° ë‚´ìš© ìŠ¤ìº”
            search_pattern = os.path.join(path, '**', file_pattern)
            
            for file_path in glob.glob(search_pattern, recursive=True):
                if not os.path.isfile(file_path):
                    continue
                
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        lines = f.readlines()
                    
                    file_matches = []
                    for line_num, line in enumerate(lines, 1):
                        matches = compiled_pattern.finditer(line)
                        for match in matches:
                            file_matches.append({
                                'line_start': line_num,
                                'line_content': line.rstrip(),
                                'match_start': match.start(),
                                'match_end': match.end(),
                                'match_text': match.group()
                            })
                    
                    if file_matches:
                        results.append({
                            'file_path': os.path.abspath(file_path),
                            'file_name': os.path.basename(file_path),
                            'matches': file_matches,
                            'match_count': len(file_matches),
                            'file_size': os.path.getsize(file_path)
                        })
                    
                    if len(results) >= max_results:
                        break
                        
                except (UnicodeDecodeError, PermissionError):
                    continue  # ë°”ì´ë„ˆë¦¬ íŒŒì¼ì´ë‚˜ ì ‘ê·¼ ë¶ˆê°€ íŒŒì¼ ìŠ¤í‚µ
            
            # ë§¤ì¹˜ ìˆ˜ë¡œ ì •ë ¬
            results.sort(key=lambda x: x['match_count'], reverse=True)
            
            total_matches = sum(r['match_count'] for r in results)
            
            return {
                'search_path': os.path.abspath(path),
                'pattern': pattern,
                'file_pattern': file_pattern,
                'case_sensitive': case_sensitive,
                'whole_word': whole_word,
                'results': results,
                'total_files': len(results),
                'total_matches': total_matches,
                'max_results': max_results,
                'truncated': len(results) >= max_results
            }
            
        except Exception as e:
            return {'error': f'Code search failed: {str(e)}'}
    



# ì „ì—­ SearchHelper ì¸ìŠ¤í„´ìŠ¤ (ì‹±ê¸€í†¤)
_search_helper = SearchHelper()

# ì „ì—­ SearchHelper ì¸ìŠ¤í„´ìŠ¤ (ì‹±ê¸€í†¤)


def scan_directory(path: str = '.', level: int = 1) -> dict:
    """ğŸ“ ë””ë ‰í† ë¦¬ ìŠ¤ìº” (ê°œì„ ëœ ë²„ì „)
    
    Args:
        path: ìŠ¤ìº”í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ
        level: ìŠ¤ìº” ê¹Šì´ ë ˆë²¨ (1=í˜„ì¬ ë ˆë²¨ë§Œ, 2=1ë‹¨ê³„ í•˜ìœ„ê¹Œì§€)
    
    Returns:
        íŒŒì¼ê³¼ ë””ë ‰í† ë¦¬ë¥¼ êµ¬ë¶„í•œ ë”•ì…”ë„ˆë¦¬ {"files": [...], "directories": [...]}
    """
    result = {"files": [], "directories": []}
    
    def _scan_level(current_path: str, current_level: int = 1):
        try:
            items = os.listdir(current_path)
            
            for item in sorted(items):
                if item.startswith('.'):
                    continue
                    
                item_path = os.path.join(current_path, item)
                relative_path = os.path.relpath(item_path, path)
                
                if os.path.isfile(item_path):
                    size = os.path.getsize(item_path)
                    size_str = _format_size(size)
                    result["files"].append(f"{relative_path} ({size_str})")
                elif os.path.isdir(item_path):
                    result["directories"].append(relative_path)
                    
                    # ì¬ê·€ì ìœ¼ë¡œ í•˜ìœ„ ë””ë ‰í† ë¦¬ ìŠ¤ìº”
                    if current_level < level:
                        _scan_level(item_path, current_level + 1)
                        
        except PermissionError:
            logger.warning(f"ê¶Œí•œ ì—†ìŒ: {current_path}")
        except Exception as e:
            logger.error(f"ìŠ¤ìº” ì˜¤ë¥˜ {current_path}: {e}")
    
    def _format_size(size: int) -> str:
        """íŒŒì¼ í¬ê¸°ë¥¼ ì½ê¸° ì‰¬ìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024.0:
                return f"{size:.1f}{unit}"
            size /= 1024.0
        return f"{size:.1f}TB"
    
    _scan_level(path)
    return result
# ================================================================
# ğŸ¯ SearchHelper ë˜í¼ í•¨ìˆ˜ë“¤ (AI Coding Brain MCP í™•ì¥)
# ================================================================

def search_files_advanced(path: str = '.', pattern: str = '*', 
                         recursive: bool = True, max_results: int = 100,
                         include_dirs: bool = False, timeout_ms: int = 30000,
                         project_context: Optional[Dict] = None) -> Dict[str, Any]:
    """ğŸ“ ê³ ê¸‰ íŒŒì¼ëª… íŒ¨í„´ ê²€ìƒ‰ (SearchHelper.search_files ë˜í¼)
    
    ğŸ¯ ëª©ì :
        íŒŒì¼ëª… íŒ¨í„´ ê¸°ë°˜ ê³ ê¸‰ ê²€ìƒ‰ ê¸°ëŠ¥ ì œê³µ
        ê¸°ì¡´ MCP search_filesë³´ë‹¤ ê°•í™”ëœ ê¸°ëŠ¥
        scan_directory ê¸°ëŠ¥ë„ ì™„ì „íˆ ì»¤ë²„
    
    ğŸ“Š ì£¼ìš” ê¸°ëŠ¥:
        â€¢ glob íŒ¨í„´ ì§€ì› (*, ?, [abc], **/*.py ë“±)
        â€¢ ì¬ê·€/ë¹„ì¬ê·€ ê²€ìƒ‰ ì„ íƒ
        â€¢ ë””ë ‰í† ë¦¬ í¬í•¨/ì œì™¸ ì˜µì…˜
        â€¢ íŒŒì¼ ë©”íƒ€ë°ì´í„° ìë™ ìˆ˜ì§‘ (í¬ê¸°, ìˆ˜ì •ì¼, í™•ì¥ì)
        â€¢ ê²°ê³¼ ìˆ˜ ì œí•œ ë° ì •ë ¬
        â€¢ ê²½ë¡œ ì •ê·œí™” ë° ì˜¤ë¥˜ ì²˜ë¦¬
    
    ğŸ“‹ ë§¤ê°œë³€ìˆ˜:
        path (str): ê²€ìƒ‰í•  ê¸°ë³¸ ê²½ë¡œ (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)
        pattern (str): íŒŒì¼ëª… íŒ¨í„´ (ê¸°ë³¸ê°’: '*' - ëª¨ë“  íŒŒì¼)
        recursive (bool): í•˜ìœ„ ë””ë ‰í† ë¦¬ ì¬ê·€ ê²€ìƒ‰ ì—¬ë¶€ (ê¸°ë³¸ê°’: True)
        max_results (int): ìµœëŒ€ ê²°ê³¼ ìˆ˜ ì œí•œ (ê¸°ë³¸ê°’: 100)
        include_dirs (bool): ë””ë ‰í† ë¦¬ë„ ê²°ê³¼ì— í¬í•¨ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
    
    ğŸ“¤ ë°˜í™˜ê°’:
        Dict[str, Any]: ê²€ìƒ‰ ê²°ê³¼ ì •ë³´
        {
            'search_path': str,           # ê²€ìƒ‰í•œ ì ˆëŒ€ê²½ë¡œ
            'pattern': str,               # ì‚¬ìš©ëœ íŒ¨í„´
            'recursive': bool,            # ì¬ê·€ ê²€ìƒ‰ ì—¬ë¶€
            'results': List[Dict],        # íŒŒì¼/ë””ë ‰í† ë¦¬ ëª©ë¡
            'total_found': int,           # ë°œê²¬ëœ í•­ëª© ìˆ˜
            'max_results': int,           # ì œí•œ ì„¤ì •ê°’
            'truncated': bool,            # ê²°ê³¼ ì˜ë¦¼ ì—¬ë¶€
            'error': str                  # ì˜¤ë¥˜ ë°œìƒì‹œ
        }
        
        results ê° í•­ëª©:
        {
            'path': str,                  # ì ˆëŒ€ê²½ë¡œ
            'name': str,                  # íŒŒì¼/ë””ë ‰í† ë¦¬ëª…
            'type': str,                  # 'file' ë˜ëŠ” 'directory'
            'size': int,                  # íŒŒì¼ í¬ê¸° (ë°”ì´íŠ¸, ë””ë ‰í† ë¦¬ëŠ” None)
            'directory': str,             # ìƒìœ„ ë””ë ‰í† ë¦¬
            'extension': str,             # íŒŒì¼ í™•ì¥ì (ë””ë ‰í† ë¦¬ëŠ” None)
            'modified': float             # ìˆ˜ì •ì¼ (timestamp)
        }
    
    ğŸ’¡ ì‚¬ìš© ì˜ˆì‹œ:
        # ëª¨ë“  Python íŒŒì¼ ê²€ìƒ‰
        search_files_advanced('.', '*.py')
        
        # í˜„ì¬ ë””ë ‰í† ë¦¬ë§Œ ê²€ìƒ‰ (ì¬ê·€ X)
        search_files_advanced('.', '*', recursive=False)
        
        # ë””ë ‰í† ë¦¬ë„ í¬í•¨í•˜ì—¬ ê²€ìƒ‰
        search_files_advanced('.', '*', include_dirs=True)
        
        # íŠ¹ì • íŒ¨í„´ìœ¼ë¡œ ì œí•œëœ ê²€ìƒ‰
        search_files_advanced('/project', '**/*.js', max_results=50)
    
    ğŸ”§ ê¸°ìˆ ì  íŠ¹ì§•:
        â€¢ SearchHelper ì¸ìŠ¤í„´ìŠ¤ ìë™ ìƒì„± ë° ê´€ë¦¬
        â€¢ ì˜ˆì™¸ ì²˜ë¦¬ ë° ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì¤€í™”
        â€¢ ê²½ë¡œ ì •ê·œí™” ë° í”Œë«í¼ í˜¸í™˜ì„±
        â€¢ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬
        â€¢ project_context í†µí•© ë° ìºì‹± ì§€ì›
    
    âš ï¸ ì£¼ì˜ì‚¬í•­:
        â€¢ ëŒ€ìš©ëŸ‰ ë””ë ‰í† ë¦¬ì—ì„œëŠ” max_resultsë¡œ ì œí•œ ê¶Œì¥
        â€¢ ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œì—ì„œëŠ” ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥
        â€¢ ê¶Œí•œ ì—†ëŠ” ë””ë ‰í† ë¦¬ëŠ” ìë™ìœ¼ë¡œ ìŠ¤í‚µ
    """
    try:
        # SearchHelper ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        helper = _search_helper
        
        # ë§¤ê°œë³€ìˆ˜ ê²€ì¦
        if not isinstance(path, str) or not path.strip():
            return {'error': 'Invalid path parameter'}
            
        if not isinstance(pattern, str):
            return {'error': 'Invalid pattern parameter'}
        
        # SearchHelper.search_files í˜¸ì¶œ
        result = helper.search_files(
            path=path.strip(),
            pattern=pattern,
            recursive=recursive,
            max_results=max_results,
            include_dirs=include_dirs
        )
        
        # project_contextì— ê²€ìƒ‰ ê¸°ë¡ ì €ì¥ (ìˆì„ ê²½ìš°ì—ë§Œ)
        if project_context is not None:
            if 'search_history' not in project_context:
                project_context['search_history'] = []
            
            project_context['search_history'].append({
            'type': 'file_search',
            'path': path,
            'pattern': pattern,
            'results_count': result.get('total_found', 0),
            'timestamp': __import__('time').time()
            })
        
        return result
        
    except Exception as e:
        error_msg = f"search_files_advanced failed: {str(e)}"
        print(f"âŒ {error_msg}")
        return {'error': error_msg}


def search_code_content(path: str = '.', pattern: str = '', 
                       file_pattern: str = '*', max_results: int = 50,
                       case_sensitive: bool = False, whole_word: bool = False,
                       project_context: Optional[Dict] = None) -> Dict[str, Any]:
    """ğŸ“ ì½”ë“œ ë‚´ìš© í…ìŠ¤íŠ¸ ê²€ìƒ‰ (SearchHelper.search_code ë˜í¼)
    
    ğŸ¯ ëª©ì :
        íŒŒì¼ ë‚´ìš©ì—ì„œ í…ìŠ¤íŠ¸ íŒ¨í„´ ê²€ìƒ‰
        ê¸°ì¡´ MCP search_codeë³´ë‹¤ ê°•í™”ëœ AST ê¸°ë°˜ ê¸°ëŠ¥
        ì •ê·œì‹ ì§€ì› ë° ìƒì„¸í•œ ë§¤ì¹˜ ì •ë³´ ì œê³µ
    
    ğŸ“Š ì£¼ìš” ê¸°ëŠ¥:
        â€¢ ì •ê·œì‹ íŒ¨í„´ ì§€ì› (re.escape ìë™ ì²˜ë¦¬)
        â€¢ ëŒ€ì†Œë¬¸ì êµ¬ë¶„/ë¬´ì‹œ ì„ íƒ
        â€¢ ë‹¨ì–´ ë‹¨ìœ„ ê²€ìƒ‰ ì˜µì…˜ (\b ê²½ê³„ ì‚¬ìš©)
        â€¢ íŒŒì¼ íƒ€ì… í•„í„°ë§ (file_pattern)
        â€¢ ë¼ì¸ ë²ˆí˜¸ ë° ë§¤ì¹˜ ìœ„ì¹˜ ì •ë³´
        â€¢ íŒŒì¼ë³„ ë§¤ì¹˜ ì¹´ìš´íŠ¸ ë° ì •ë ¬
        â€¢ ë°”ì´ë„ˆë¦¬ íŒŒì¼ ìë™ ìŠ¤í‚µ
    
    ğŸ“‹ ë§¤ê°œë³€ìˆ˜:
        path (str): ê²€ìƒ‰í•  ê¸°ë³¸ ê²½ë¡œ (ê¸°ë³¸ê°’: í˜„ì¬ ë””ë ‰í† ë¦¬)
        pattern (str): ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ íŒ¨í„´ (í•„ìˆ˜)
        file_pattern (str): íŒŒì¼ëª… í•„í„° íŒ¨í„´ (ê¸°ë³¸ê°’: '*' - ëª¨ë“  íŒŒì¼)
        max_results (int): ìµœëŒ€ íŒŒì¼ ìˆ˜ ì œí•œ (ê¸°ë³¸ê°’: 50)
        case_sensitive (bool): ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
        whole_word (bool): ë‹¨ì–´ ë‹¨ìœ„ ê²€ìƒ‰ ì—¬ë¶€ (ê¸°ë³¸ê°’: False)
    
    ğŸ“¤ ë°˜í™˜ê°’:
        Dict[str, Any]: ê²€ìƒ‰ ê²°ê³¼ ì •ë³´
        {
            'search_path': str,           # ê²€ìƒ‰í•œ ì ˆëŒ€ê²½ë¡œ
            'pattern': str,               # ê²€ìƒ‰ íŒ¨í„´
            'file_pattern': str,          # íŒŒì¼ í•„í„° íŒ¨í„´
            'case_sensitive': bool,       # ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì„¤ì •
            'whole_word': bool,           # ë‹¨ì–´ ë‹¨ìœ„ ê²€ìƒ‰ ì„¤ì •
            'results': List[Dict],        # ë§¤ì¹˜ëœ íŒŒì¼ë“¤
            'total_files': int,           # ë§¤ì¹˜ëœ íŒŒì¼ ìˆ˜
            'total_matches': int,         # ì „ì²´ ë§¤ì¹˜ ìˆ˜
            'max_results': int,           # ì œí•œ ì„¤ì •ê°’
            'truncated': bool,            # ê²°ê³¼ ì˜ë¦¼ ì—¬ë¶€
            'error': str                  # ì˜¤ë¥˜ ë°œìƒì‹œ
        }
        
        results ê° íŒŒì¼:
        {
            'file_path': str,             # íŒŒì¼ ì ˆëŒ€ê²½ë¡œ
            'file_name': str,             # íŒŒì¼ëª…
            'matches': List[Dict],        # ë§¤ì¹˜ ì •ë³´ë“¤
            'match_count': int,           # íŒŒì¼ ë‚´ ë§¤ì¹˜ ìˆ˜
            'file_size': int              # íŒŒì¼ í¬ê¸°
        }
        
        matches ê° ë§¤ì¹˜:
        {
            'line_start': int,            # ë¼ì¸ ë²ˆí˜¸ (1ë¶€í„° ì‹œì‘)
            'line_content': str,          # ë¼ì¸ ì „ì²´ ë‚´ìš©
            'match_start': int,           # ë¼ì¸ ë‚´ ë§¤ì¹˜ ì‹œì‘ ìœ„ì¹˜
            'match_end': int,             # ë¼ì¸ ë‚´ ë§¤ì¹˜ ë ìœ„ì¹˜  
            'match_text': str             # ë§¤ì¹˜ëœ í…ìŠ¤íŠ¸
        }
    
    ğŸ’¡ ì‚¬ìš© ì˜ˆì‹œ:
        # í•¨ìˆ˜ëª… ê²€ìƒ‰
        search_code_content('.', 'def process_data', '*.py')
        
        # ëŒ€ì†Œë¬¸ì êµ¬ë¶„í•˜ì—¬ í´ë˜ìŠ¤ëª… ê²€ìƒ‰
        search_code_content('.', 'MyClass', case_sensitive=True)
        
        # ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë³€ìˆ˜ëª… ê²€ìƒ‰
        search_code_content('.', 'user_id', whole_word=True)
        
        # JavaScript íŒŒì¼ì—ì„œ íŠ¹ì • í•¨ìˆ˜ ê²€ìƒ‰
        search_code_content('./src', 'function.*login', '*.js')
    
    ğŸ”§ ê¸°ìˆ ì  íŠ¹ì§•:
        â€¢ re.compileì„ ì‚¬ìš©í•œ íš¨ìœ¨ì ì¸ ì •ê·œì‹ ì²˜ë¦¬
        â€¢ UTF-8 ì¸ì½”ë”© ë° ì˜¤ë¥˜ ë¬´ì‹œ (errors='ignore')
        â€¢ ë°”ì´ë„ˆë¦¬ íŒŒì¼ ë° ì ‘ê·¼ ë¶ˆê°€ íŒŒì¼ ìë™ ìŠ¤í‚µ
        â€¢ ë§¤ì¹˜ ìˆ˜ ê¸°ì¤€ ì •ë ¬ë¡œ ê´€ë ¨ì„± ë†’ì€ ê²°ê³¼ ìš°ì„ 
        â€¢ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë¼ì¸ ë‹¨ìœ„ ì²˜ë¦¬
    
    âš ï¸ ì£¼ì˜ì‚¬í•­:
        â€¢ patternì´ ë¹„ì–´ìˆìœ¼ë©´ ì˜¤ë¥˜ ë°˜í™˜
        â€¢ ëŒ€ìš©ëŸ‰ íŒŒì¼ì´ ë§ì€ ê²½ìš° max_resultsë¡œ ì œí•œ ê¶Œì¥
        â€¢ ì •ê·œì‹ íŠ¹ìˆ˜ë¬¸ìëŠ” re.escapeë¡œ ìë™ ì´ìŠ¤ì¼€ì´í”„
        â€¢ ë°”ì´ë„ˆë¦¬ íŒŒì¼ì€ ê²€ìƒ‰ì—ì„œ ì œì™¸ë¨
    """
    try:
        # ë§¤ê°œë³€ìˆ˜ ê²€ì¦
        if not pattern or not isinstance(pattern, str):
            return {'error': 'Search pattern is required and must be a string'}
            
        if not isinstance(path, str) or not path.strip():
            return {'error': 'Invalid path parameter'}
        
        # SearchHelper ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        helper = _search_helper
        
        # SearchHelper.search_code í˜¸ì¶œ
        result = helper.search_code(
            path=path.strip(),
            pattern=pattern,
            file_pattern=file_pattern,
            max_results=max_results,
            case_sensitive=case_sensitive,
            whole_word=whole_word
        )
        
        # project_contextì— ê²€ìƒ‰ ê¸°ë¡ ì €ì¥ (ìˆì„ ê²½ìš°ì—ë§Œ)
        if project_context is not None:
            if 'search_history' not in project_context:
                project_context['search_history'] = []
            
            project_context['search_history'].append({
            'type': 'code_search',
            'path': path,
            'pattern': pattern,
            'file_pattern': file_pattern,
            'total_matches': result.get('total_matches', 0),
            'total_files': result.get('total_files', 0),
            'timestamp': __import__('time').time()
            })
        
        return result
        
    except Exception as e:
        error_msg = f"search_code_content failed: {str(e)}"
        print(f"âŒ {error_msg}")
        return {'error': error_msg}


# ================================================================
# ğŸ”„ helper í•¨ìˆ˜ ë“±ë¡ ì—…ë°ì´íŠ¸
# ================================================================

# print("ğŸ“ ë˜í¼ í•¨ìˆ˜ 2ê°œ ì •ì˜ ì™„ë£Œ:", file=sys.stderr)
# print("ğŸ“ ë˜í¼ í•¨ìˆ˜ 2ê°œ ì •ì˜ ì™„ë£Œ:", file=sys.stderr)
print("  1. search_files_advanced() - íŒŒì¼ëª… íŒ¨í„´ ê²€ìƒ‰ ì™„ì „ì²´", file=sys.stderr)
print("  2. search_code_content() - ì½”ë“œ ë‚´ìš© ê²€ìƒ‰ ì „ìš©", file=sys.stderr)
print("âœ… ìƒì„¸í•œ ë…ìŠ¤íŠ¸ë§ ë° ì‚¬ìš© ì˜ˆì‹œ í¬í•¨", file=sys.stderr)
