#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  AI Coding Brain - í†µí•© ë²„ì „ v7.0 (ìºì‹œ êµ¬ì¡° ê°œì„ )
==========================================

ì£¼ìš” íŠ¹ì§•:
- cache í‚¤ ì—†ì´ í”Œë«í•œ êµ¬ì¡°
- 5ê°œì˜ ê°œë³„ JSON íŒŒì¼ë¡œ ë¶„ë¦¬ ì €ì¥
- ë” ë¹ ë¥¸ ë¡œë“œ/ì €ì¥ ë° ë¶€ë¶„ ì—…ë°ì´íŠ¸ ì§€ì›

ì‘ì„±ì¼: 2025-06-18
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy


# ===========================================
# í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================

class UnifiedContextManager:
    """í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì - ì‹±ê¸€í†¤ íŒ¨í„´"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None
            self.base_path = None
            self.memory_path = None
            self.cache_dir = None
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str = None, memory_root: str = None,
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
        self.project_path = project_path
        
        # project_nameì´ Noneì´ë©´ ê²½ë¡œì—ì„œ ìë™ ì¶”ì¶œ
        if project_name is None:
            project_name = os.path.basename(os.path.abspath(project_path))
            print(f"âœ… í”„ë¡œì íŠ¸ ì´ë¦„ ìë™ ì¶”ì¶œ: {project_name}")
        
        self.project_name = project_name
        self.base_path = project_path
        
        # ë©”ëª¨ë¦¬ ë£¨íŠ¸ ì„¤ì •
        if memory_root:
            self.memory_root = memory_root
        else:
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # ë©”ëª¨ë¦¬ ê²½ë¡œ ì„¤ì •
        self.memory_path = os.path.join(self.memory_root, self.project_name)
        self.cache_dir = os.path.join(self.memory_path, '.cache')
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # ê¸°ì¡´ contextê°€ ìˆìœ¼ë©´ ì‚¬ìš©
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"âœ… ê¸°ì¡´ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©: {project_name}")
        else:
            # ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"âœ… ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"âœ… ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±: {project_name}")
        
        # êµ¬ì¡° ì •ê·œí™”
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_paths(self) -> Dict[str, str]:
        """ê° ìºì‹œ íŒŒì¼ ê²½ë¡œ ë°˜í™˜"""
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        
        return {
            'core': os.path.join(cache_dir, 'cache_core.json'),
            'analyzed_files': os.path.join(cache_dir, 'cache_analyzed_files.json'),
            'work_tracking': os.path.join(cache_dir, 'cache_work_tracking.json'),
            'tasks': os.path.join(cache_dir, 'cache_tasks.json'),
            'plan': os.path.join(cache_dir, 'cache_plan.json')
        }
    
    def _create_new_context(self) -> Dict[str, Any]:
        """ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ìƒì„± (ê°œì„ ëœ êµ¬ì¡°)"""
        return {
            # ê¸°ë³¸ ì •ë³´ (cache_core.json)
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '7.0',
            'current_focus': '',
            'current_task': None,
            
            # ë¶„ì„ íŒŒì¼ ì •ë³´ (cache_analyzed_files.json)
            'analyzed_files': {},
            
            # ì‘ì—… ì¶”ì  (cache_work_tracking.json)
            'work_tracking': {
                'file_access': {},
                'file_edits': {},
                'function_edits': {},
                'session_start': dt.datetime.now().isoformat(),
                'total_operations': 0,
                'task_tracking': {},
                'current_task_work': {
                    'task_id': None,
                    'start_time': None,
                    'files_accessed': [],
                    'functions_edited': [],
                    'operations': []
                }
            },
            
            # ì‘ì—… ê´€ë¦¬ (cache_tasks.json)
            'tasks': {'next': [], 'done': []},
            
            # ê³„íš ê´€ë¦¬ (cache_plan.json)
            'plan': None,
            'plan_history': [],
            
            # ê¸°íƒ€ ë°ì´í„°
            'coding_experiences': [],
            'progress': {
                'completed_tasks': 0,
                'total_tasks': 0,
                'percentage': 0.0
            },
            'phase_reports': {},
            'error_log': [],
            'file_access_history': [],
            'metadata': {
                'version': '7.0',
                'last_saved': dt.datetime.now().isoformat()
            }
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ (ì—¬ëŸ¬ íŒŒì¼ì—ì„œ)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_paths = self._get_cache_file_paths()
        
        # í•µì‹¬ íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸
        if not os.path.exists(cache_paths['core']):
            return None
        
        try:
            # 1. í•µì‹¬ ì •ë³´ ë¡œë“œ
            with open(cache_paths['core'], 'r', encoding='utf-8') as f:
                context = json.load(f)
            
            # 2. ê° ë¶€ë¶„ë³„ íŒŒì¼ ë¡œë“œ
            # analyzed_files
            if os.path.exists(cache_paths['analyzed_files']):
                with open(cache_paths['analyzed_files'], 'r', encoding='utf-8') as f:
                    context['analyzed_files'] = json.load(f)
            else:
                context['analyzed_files'] = {}
            
            # work_tracking
            if os.path.exists(cache_paths['work_tracking']):
                with open(cache_paths['work_tracking'], 'r', encoding='utf-8') as f:
                    context['work_tracking'] = json.load(f)
            else:
                context['work_tracking'] = self._create_new_context()['work_tracking']
            
            # tasks
            if os.path.exists(cache_paths['tasks']):
                with open(cache_paths['tasks'], 'r', encoding='utf-8') as f:
                    context['tasks'] = json.load(f)
            else:
                context['tasks'] = {'next': [], 'done': []}
            
            # plan
            if os.path.exists(cache_paths['plan']):
                with open(cache_paths['plan'], 'r', encoding='utf-8') as f:
                    plan_data = json.load(f)
                    context['plan'] = plan_data.get('plan')
                    context['plan_history'] = plan_data.get('plan_history', [])
            else:
                context['plan'] = None
                context['plan_history'] = []
            
            # ê²½ë¡œ ì—…ë°ì´íŠ¸
            context['project_path'] = self.project_path
            context['memory_root'] = self.memory_root
            
            return context
            
        except Exception as e:
            print(f"âš ï¸ ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
            return None
    
    def _normalize_context_structure(self):
        """ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ì •ê·œí™”"""
        if not self.context:
            return
        
        # í•„ìˆ˜ í‚¤ í™•ì¸
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('plan', None)
        self.context.setdefault('plan_history', [])
        self.context.setdefault('file_access_history', [])
        self.context.setdefault('progress', {
            'completed_tasks': 0,
            'total_tasks': 0,
            'percentage': 0.0
        })
        
        # work_tracking êµ¬ì¡°
        work_tracking = self.context.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        work_tracking.setdefault('task_tracking', {})
        work_tracking.setdefault('current_task_work', {
            'task_id': None,
            'start_time': None,
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        })
        
        # ê²½ë¡œ ì •ë³´ ì—…ë°ì´íŠ¸
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root

    def save(self) -> bool:
        """ì»¨í…ìŠ¤íŠ¸ ì €ì¥ (ì—¬ëŸ¬ íŒŒì¼ë¡œ ë¶„ë¦¬)"""
        # ë²„ì „ íŒ¨í„´ í”„ë¡œì íŠ¸ëŠ” ì €ì¥í•˜ì§€ ì•ŠìŒ
        import re
        if self.project_name:
            version_patterns = [
                r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
                r'^app-\d+\.\d+\.\d+$',
                r'^project-\d+\.\d+\.\d+$',
                r'^v\d+\.\d+\.\d+$'
            ]
            for pattern in version_patterns:
                if re.match(pattern, self.project_name):
                    print(f"âš ï¸ ë²„ì „ íŒ¨í„´ í”„ë¡œì íŠ¸ '{self.project_name}'ëŠ” ì €ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
                    return False
        
        if not self.context:
            print("âš ï¸ ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        try:
            # ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
            self.context['updated_at'] = dt.datetime.now().isoformat()
            self.context.setdefault('metadata', {})['last_saved'] = dt.datetime.now().isoformat()
            
            # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
            self._update_progress()
            
            cache_paths = self._get_cache_file_paths()
            
            # 1. í•µì‹¬ ì •ë³´ ì €ì¥ (cache_core.json)
            core_data = {
                'project_name': self.context.get('project_name'),
                'project_id': self.context.get('project_id'),
                'project_path': self.context.get('project_path'),
                'memory_root': self.context.get('memory_root'),
                'created_at': self.context.get('created_at'),
                'updated_at': self.context.get('updated_at'),
                'version': self.context.get('version', '7.0'),
                'current_focus': self.context.get('current_focus', ''),
                'current_task': self.context.get('current_task'),
                'coding_experiences': self.context.get('coding_experiences', []),
                'progress': self.context.get('progress', {}),
                'phase_reports': self.context.get('phase_reports', {}),
                'error_log': self.context.get('error_log', []),
                'file_access_history': self.context.get('file_access_history', []),
                'metadata': self.context.get('metadata', {})
            }
            
            with open(cache_paths['core'], 'w', encoding='utf-8') as f:
                json.dump(core_data, f, indent=2, ensure_ascii=False)
            
            # 2. ë¶„ì„ íŒŒì¼ ì €ì¥ (cache_analyzed_files.json)
            with open(cache_paths['analyzed_files'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('analyzed_files', {}), f, indent=2, ensure_ascii=False)
            
            # 3. ì‘ì—… ì¶”ì  ì €ì¥ (cache_work_tracking.json)
            with open(cache_paths['work_tracking'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('work_tracking', {}), f, indent=2, ensure_ascii=False)
            
            # 4. ì‘ì—… ì €ì¥ (cache_tasks.json)
            with open(cache_paths['tasks'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('tasks', {}), f, indent=2, ensure_ascii=False)
            
            # 5. ê³„íš ì €ì¥ (cache_plan.json)
            plan_data = {
                'plan': self.context.get('plan'),
                'plan_history': self.context.get('plan_history', [])
            }
            with open(cache_paths['plan'], 'w', encoding='utf-8') as f:
                json.dump(plan_data, f, indent=2, ensure_ascii=False)
            
            print(f"âœ… ìºì‹œ ì €ì¥ ì™„ë£Œ:")
            for name, path in cache_paths.items():
                if os.path.exists(path):
                    size = os.path.getsize(path)
                    print(f"   â€¢ {name}: {size:,} bytes")
            
            # í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹œë„
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"âš ï¸ í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            return True
            
        except Exception as e:
            print(f"âŒ ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False

    def _update_progress(self):
        """ì§„í–‰ë¥  ì—…ë°ì´íŠ¸"""
        if not self.context:
            return
        
        # í˜„ì¬ ê³„íšì—ì„œ ì‘ì—… ìˆ˜ ê³„ì‚°
        plan = self.context.get('plan')
        if plan:
            total_tasks = 0
            completed_tasks = 0
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    total_tasks += 1
                    if task.get('status') == 'completed':
                        completed_tasks += 1
            
            progress = self.context.setdefault('progress', {})
            progress['total_tasks'] = total_tasks
            progress['completed_tasks'] = completed_tasks
            progress['percentage'] = (completed_tasks / max(1, total_tasks)) * 100
    
    def _update_project_docs(self):
        """í”„ë¡œì íŠ¸ ë¬¸ì„œ ì—…ë°ì´íŠ¸"""
        if not self.context or not self.project_path:
            return
        
        if not self.memory_root or not self.project_name:
            print("âš ï¸ memory_root ë˜ëŠ” project_nameì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return
            
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(str(self.memory_root), str(self.project_name), filename)
            try:
                os.makedirs(os.path.dirname(doc_path), exist_ok=True)
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"âš ï¸ {filename} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = len(self.context.get('analyzed_files', {}))
        progress = self.context.get('progress', {})
        
        content = f"""# AI Coding Brain MCP - í”„ë¡œì íŠ¸ ë¹„ì „

## ğŸ¯ í”„ë¡œì íŠ¸ ê°œìš”
MCP (Model Context Protocol) ê¸°ë°˜ í†µí•© ê°œë°œ ì§€ì› ì‹œìŠ¤í…œ

## ğŸ“Š í˜„ì¬ ìƒíƒœ
- ë¶„ì„ëœ íŒŒì¼: {analyzed}ê°œ
- ì™„ë£Œëœ ì‘ì—…: {progress.get('completed_tasks', 0)}ê°œ
- ì „ì²´ ì‘ì—…: {progress.get('total_tasks', 0)}ê°œ
- ì§„í–‰ë¥ : {progress.get('percentage', 0):.1f}%

## ğŸ”§ í•µì‹¬ ê¸°ëŠ¥
1. **ìë™ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬**: ì‘ì—… ìƒíƒœ ìë™ ì €ì¥/ë³µì›
2. **í†µí•© ê²€ìƒ‰ ì‹œìŠ¤í…œ**: ì½”ë“œ, ë©”ëª¨ë¦¬, ìºì‹œ í†µí•© ê²€ìƒ‰
3. **Phase ê¸°ë°˜ ì‘ì—… ê´€ë¦¬**: ì²´ê³„ì ì¸ í”„ë¡œì íŠ¸ ì§„í–‰
4. **SimplEdit ì•ˆì „ ìˆ˜ì •**: ë°±ì—…ê³¼ í•¨ê»˜í•˜ëŠ” ì•ˆì „í•œ ì½”ë“œ ìˆ˜ì •
"""
        
        plan = self.context.get('plan')
        if plan:
            content += f"""
## ğŸ“‹ í˜„ì¬ ê³„íš: {plan.get('name', 'N/A')}
{plan.get('description', '')}

### Phase êµ¬ì¡°:
"""
            for phase_id, phase in plan.get('phases', {}).items():
                task_count = len(phase.get('tasks', []))
                completed = sum(1 for t in phase.get('tasks', []) if t.get('status') == 'completed')
                content += f"- **{phase.get('name', phase_id)}** ({completed}/{task_count} ì™„ë£Œ)\n"
        
        content += f"""
ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í˜„ì¬ ì‘ì—…\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        focus = self.context.get('current_focus', '')
        current_task_id = self.context.get('current_task')
        current_task = None
        current_phase = None
        
        plan = self.context.get('plan')
        if current_task_id and plan:
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        current_task = task
                        current_phase = phase
                        break
                if current_task:
                    break
        
        content = f"""# AI Coding Brain - í˜„ì¬ ì‘ì—…

## ğŸ¯ í˜„ì¬ Focus
{focus or 'ì„¤ì •ë˜ì§€ ì•ŠìŒ'}

## ğŸ”„ ì§„í–‰ ì¤‘ì¸ ì‘ì—…
"""
        
        if current_task:
            content += f"""### [{current_task['id']}] {current_task['title']}
- ìƒíƒœ: {current_task.get('status', 'pending')}
- Phase: {current_phase.get('name', 'N/A')}
- ì„¤ëª…: {current_task.get('description', 'N/A')}
"""
        else:
            content += "í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.\n"
        
        content += f"""
ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_file_directory(self) -> str:
        """file_directory.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        analyzed = self.context.get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - í”„ë¡œì íŠ¸ êµ¬ì¡°

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## ğŸ“ Python ëª¨ë“ˆ ëª©ë¡

| ê²½ë¡œ | ì„¤ëª… | ìˆ˜ì •ì¼ |
|------|------|--------|
"""
        
        def to_relative_path(path):
            path = path.replace('\\', '/')
            if self.project_path:
                project_path = self.project_path.replace('\\', '/')
                if path.startswith(project_path):
                    return path[len(project_path):].lstrip('/')
            return path
        
        sorted_files = sorted(analyzed.items(), key=lambda x: to_relative_path(x[0]))
        
        for file_path, info in sorted_files:
            display_path = to_relative_path(file_path)
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            mod_time = info.get('last_modified', 'Unknown')
            
            description = ""
            if func_count > 0 or class_count > 0:
                parts = []
                if func_count > 0:
                    parts.append(f"{func_count}ê°œ í•¨ìˆ˜")
                if class_count > 0:
                    parts.append(f"{class_count}ê°œ í´ë˜ìŠ¤")
                description = ", ".join(parts)
            else:
                description = "-"
                
            content += f"| {display_path} | {description} | {mod_time} |\n"
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md ìƒì„±"""
        if not self.context:
            return "# AI Coding Brain - ì§„í–‰ ìƒí™©\n\ní”„ë¡œì íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n"
        
        progress = self.context.get('progress', {})
        done_count = progress.get('completed_tasks', 0)
        total_count = progress.get('total_tasks', 0)
        percentage = progress.get('percentage', 0)
        
        content = f"""# AI Coding Brain - ì§„í–‰ ìƒí™©

## ğŸ“Š ì „ì²´ ì§„í–‰ë¥ 
- ì™„ë£Œ: {done_count}ê°œ
- ì „ì²´: {total_count}ê°œ
- ì§„í–‰ë¥ : {percentage:.1f}%

### ì§„í–‰ë¥  ì°¨íŠ¸
[{'â–ˆ' * int(percentage / 5)}{'â–‘' * (20 - int(percentage / 5))}] {percentage:.1f}%

ìµœì¢… ì—…ë°ì´íŠ¸: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    # ===========================================
    # ìºì‹œ ê´€ë¦¬ ë©”ì„œë“œ (ê°œì„ ë¨)
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """ìºì‹œ ì—…ë°ì´íŠ¸ (cache í‚¤ ì—†ì´ ì§ì ‘ ì ‘ê·¼)"""
        if not self.context:
            return
        
        keys = key.split('.')
        current = self.context
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """ê°’ ì¡°íšŒ (cache í‚¤ ì—†ì´ ì§ì ‘ ì ‘ê·¼)"""
        if not self.context:
            return default
        
        keys = key.split('.')
        current = self.context
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # ì‘ì—… ì¶”ì  ë©”ì„œë“œë“¤
    # ===========================================
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.setdefault('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        work_tracking['file_access_count'] = work_tracking.get('file_access_count', 0) + 1
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        if file_path not in file_access:
            file_access[file_path] = {
                'read_count': 0,
                'write_count': 0,
                'first_access': dt.datetime.now().isoformat(),
                'last_read': None,
                'last_write': None
            }
        
        if operation == 'read':
            file_access[file_path]['read_count'] += 1
            file_access[file_path]['last_read'] = dt.datetime.now().isoformat()
        elif operation in ['write', 'modify']:
            file_access[file_path]['write_count'] += 1
            file_access[file_path]['last_write'] = dt.datetime.now().isoformat()
            
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # í˜„ì¬ task ì‘ì—…ì—ë„ ì¶”ê°€
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            files_accessed = current_task_work.setdefault('files_accessed', [])
            if file_path not in files_accessed:
                files_accessed.append(file_path)
            
            self.track_task_operation('file_access', {
                'file': file_path,
                'operation': operation
            })
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.setdefault('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        if func_key not in function_edits:
            function_edits[func_key] = {
                'file_path': file_path,
                'edit_count': 0,
                'first_edit': dt.datetime.now().isoformat(),
                'last_edit': None
            }
        
        function_edits[func_key]['edit_count'] += 1
        function_edits[func_key]['last_edit'] = dt.datetime.now().isoformat()
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # í˜„ì¬ task ì‘ì—…ì—ë„ ì¶”ê°€
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            functions_edited = current_task_work.setdefault('functions_edited', [])
            if func_key not in functions_edited:
                functions_edited.append(func_key)
            
            self.track_task_operation('function_edit', {
                'file': file_path,
                'function': func_key,
                'class': class_name
            })
    
    def get_work_tracking_summary(self) -> str:
        """ì‘ì—… ì¶”ì  ìš”ì•½"""
        if not self.context:
            return "ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        
        work_tracking = self.context.get('work_tracking', {})
        
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        task_tracking = work_tracking.get('task_tracking', {})
        
        summary = f"""
ğŸ“Š ì‘ì—… ì¶”ì  ìš”ì•½
================
â€¢ í”„ë¡œì íŠ¸: {self.project_name}
â€¢ ì‘ì—… ê²½ë¡œ: {self.project_path}
â€¢ ìºì‹œ ê²½ë¡œ: {self.memory_root}
â€¢ ì„¸ì…˜ ì‹œê°„: {duration_str}
â€¢ ì „ì²´ ì‘ì—…: {total_ops}íšŒ
â€¢ ì ‘ê·¼í•œ íŒŒì¼: {len(file_access)}ê°œ
â€¢ ìˆ˜ì •í•œ íŒŒì¼: {len(file_edits)}ê°œ
â€¢ ìˆ˜ì •í•œ í•¨ìˆ˜: {len(function_edits)}ê°œ
â€¢ ìˆ˜í–‰í•œ Task: {len(task_tracking)}ê°œ
"""
        
        if file_access:
            summary += "\nğŸ”¥ ê°€ì¥ ë§ì´ ì ‘ê·¼í•œ íŒŒì¼:\n"
            sorted_files = sorted(file_access.items(), 
                                key=lambda x: x[1].get('read_count', 0) + x[1].get('write_count', 0), 
                                reverse=True)[:5]
            for file_path, info in sorted_files:
                total_access = info.get('read_count', 0) + info.get('write_count', 0)
                summary += f"  â€¢ {file_path}: {total_access}íšŒ\n"
        
        return summary
    
    def start_task_tracking(self, task_id: str):
        """Task ì‘ì—… ì¶”ì  ì‹œì‘"""
        if not self.context:
            return
        
        work_tracking = self.context.get('work_tracking', {})
        
        # ì´ì „ task ì‘ì—… ì €ì¥
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_work['task_id']] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
        
        # ìƒˆ task ì‘ì—… ì‹œì‘
        work_tracking['current_task_work'] = {
            'task_id': task_id,
            'start_time': dt.datetime.now().isoformat(),
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        }
    
    def track_task_operation(self, operation_type: str, details: dict = None):
        """í˜„ì¬ Taskì˜ ì‘ì—… ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        
        if current_task_work and current_task_work.get('task_id'):
            operation = {
                'type': operation_type,
                'timestamp': dt.datetime.now().isoformat(),
                'details': details or {}
            }
            current_task_work.setdefault('operations', []).append(operation)


# ===========================================
# ê¸€ë¡œë²Œ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str = None, memory_root: str = None,
                      existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
    return _context_manager.initialize(project_path, project_name, memory_root, existing_context)

def save_context() -> bool:
    """ì»¨í…ìŠ¤íŠ¸ ì €ì¥"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """ìºì‹œ ì—…ë°ì´íŠ¸ (cache í‚¤ ì—†ì´ ì§ì ‘ ì ‘ê·¼)"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """ê°’ ì¡°íšŒ (cache í‚¤ ì—†ì´ ì§ì ‘ ì ‘ê·¼)"""
    return _context_manager.get_value(key, default)

def track_file_access(file_path: str, operation: str = 'read'):
    """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """ì‘ì—… ì¶”ì  ìš”ì•½"""
    return _context_manager.get_work_tracking_summary()

def start_task_tracking(task_id: str):
    """Task ì‘ì—… ì¶”ì  ì‹œì‘"""
    _context_manager.start_task_tracking(task_id)

def track_task_operation(operation_type: str, details: dict = None):
    """í˜„ì¬ Taskì˜ ì‘ì—… ì¶”ì """
    _context_manager.track_task_operation(operation_type, details)

def get_current_context() -> Optional[Dict[str, Any]]:
    """í˜„ì¬ context ë°˜í™˜ (auto_tracking_wrapperìš©)"""
    return _context_manager.context if _context_manager else None


# ===========================================
# Claude Desktop ì„¤ì • ë° ëª…ë ¹ì–´ ì²˜ë¦¬
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop ì„¤ì •ì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_path': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_path'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"âš ï¸ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    return paths




def cmd_plan(plan_name: str = None, description: str = None) -> Dict[str, Any]:
    """/plan ëª…ë ¹ì–´ - ìƒˆë¡œìš´ ê³„íš ìƒì„±"""
    if not _context_manager.context:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¨¼ì € /flow [í”„ë¡œì íŠ¸ëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return None
    
    if not plan_name:
        # í˜„ì¬ ê³„íš í‘œì‹œ
        plan = _context_manager.context.get('plan')
        if plan:
            print(f"\nğŸ“‹ í˜„ì¬ ê³„íš: {plan.get('name', 'N/A')}")
            print(f"   ì„¤ëª…: {plan.get('description', 'N/A')}")
            print(f"   ìƒì„±: {plan.get('created_at', 'N/A')}")
            print(f"   Phase ìˆ˜: {len(plan.get('phases', {}))}ê°œ")
            
            for phase_id, phase in plan.get('phases', {}).items():
                tasks = phase.get('tasks', [])
                completed = sum(1 for t in tasks if t.get('status') == 'completed')
                print(f"\n   ğŸ“Œ {phase.get('name', phase_id)} ({completed}/{len(tasks)} ì™„ë£Œ)")
        else:
            print("\nâš ï¸ í˜„ì¬ ì„¤ì •ëœ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤.")
            print("ì‚¬ìš©ë²•: /plan [ê³„íšëª…] [ì„¤ëª…]")
        return None
    
    # ìƒˆ ê³„íš ìƒì„±
    timestamp = dt.datetime.now().isoformat()
    
    new_plan = {
        'name': plan_name,
        'description': description or f"{_context_manager.project_name} ì‘ì—… ê³„íš",
        'created_at': timestamp,
        'updated_at': timestamp,
        'phases': {},
        'current_phase': None,
        'current_task': None
    }
    
    # ê¸°ë³¸ Phase 3ê°œ ìƒì„±
    default_phases = [
        ('phase-1', 'Phase 1: ë¶„ì„ ë° ì„¤ê³„', 'í˜„ì¬ ìƒíƒœ ë¶„ì„ê³¼ ê°œì„  ë°©í–¥ ì„¤ê³„'),
        ('phase-2', 'Phase 2: í•µì‹¬ êµ¬í˜„', 'ì£¼ìš” ê¸°ëŠ¥ êµ¬í˜„ ë° ê°œì„ '),
        ('phase-3', 'Phase 3: í…ŒìŠ¤íŠ¸ ë° ë¬¸ì„œí™”', 'í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ë¬¸ì„œ ì •ë¦¬')
    ]
    
    for phase_id, phase_name, phase_desc in default_phases:
        new_plan['phases'][phase_id] = {
            'id': phase_id,
            'name': phase_name,
            'description': phase_desc,
            'status': 'pending',
            'tasks': []
        }
    
    new_plan['current_phase'] = 'phase-1'
    
    _context_manager.context['plan'] = new_plan
    _context_manager.context['plan_history'].append({
        'name': plan_name,
        'created_at': timestamp,
        'id': f"plan-{len(_context_manager.context['plan_history']) + 1}"
    })
    
    save_context()
    print(f"\nâœ… ìƒˆ ê³„íš '{plan_name}' ìƒì„± ì™„ë£Œ!")
    print(f"   ì„¤ëª…: {new_plan['description']}")
    print(f"\n   3ê°œì˜ ê¸°ë³¸ Phaseê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤:")
    for phase_id, phase_name, _ in default_phases:
        print(f"   - {phase_name}")
    print(f"\n   /task add {default_phases[0][0]} [ì‘ì—…ëª…]ìœ¼ë¡œ ì‘ì—…ì„ ì¶”ê°€í•˜ì„¸ìš”.")
    
    return new_plan


def cmd_task(action: str, *args) -> None:
    """/task ëª…ë ¹ì–´ - ì‘ì—… ê´€ë¦¬"""
    if not _context_manager.context:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return
        
    plan = _context_manager.context.get('plan')
    if not plan:
        print("âŒ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € /plan [ê³„íšëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    if action == 'add':
        if len(args) < 2:
            print("ì‚¬ìš©ë²•: /task add [phase-id] [ì‘ì—…ëª…] [ì„¤ëª…(ì„ íƒ)]")
            return
            
        phase_id = args[0]
        task_title = args[1]
        task_desc = ' '.join(args[2:]) if len(args) > 2 else ""
        
        phase = plan['phases'].get(phase_id)
        if not phase:
            print(f"âŒ Phase '{phase_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            print(f"   ì‚¬ìš© ê°€ëŠ¥í•œ Phase: {', '.join(plan['phases'].keys())}")
            return
        
        phase_num = phase_id.split('-')[1]
        task_num = len(phase['tasks']) + 1
        new_task = {
            'id': f'{phase_num}-{task_num}',
            'title': task_title,
            'description': task_desc,
            'status': 'pending',
            'created_at': dt.datetime.now().isoformat(),
            'subtasks': []
        }
        
        phase['tasks'].append(new_task)
        plan['updated_at'] = dt.datetime.now().isoformat()
        
        _context_manager._update_progress()
        save_context()
        
        print(f"âœ… Task ì¶”ê°€ë¨: [{new_task['id']}] {task_title}")
        print(f"   Phase: {phase['name']}")
        
    elif action == 'edit':
        if len(args) < 3:
            print("ì‚¬ìš©ë²•: /task edit [task-id] status|title|desc [ìƒˆê°’]")
            print("   status ê°’: pending, in_progress, completed, blocked")
            return
            
        task_id = args[0]
        field = args[1]
        new_value = ' '.join(args[2:])
        
        task_found = False
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if field == 'status':
                        if new_value not in ['pending', 'in_progress', 'completed', 'blocked']:
                            print(f"âŒ ì˜ëª»ëœ ìƒíƒœê°’: {new_value}")
                            print("   ê°€ëŠ¥í•œ ê°’: pending, in_progress, completed, blocked")
                            return
                        task['status'] = new_value
                        
                        if new_value == 'in_progress':
                            _context_manager.context['current_task'] = task_id
                            plan['current_phase'] = phase_id
                            phase['status'] = 'in_progress'
                        elif new_value == 'completed' and _context_manager.context.get('current_task') == task_id:
                            _context_manager.context['current_task'] = None
                            
                    elif field == 'title':
                        task['title'] = new_value
                    elif field in ['desc', 'description']:
                        task['description'] = new_value
                    else:
                        print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” í•„ë“œ: {field}")
                        return
                    
                    task['updated_at'] = dt.datetime.now().isoformat()
                    task_found = True
                    plan['updated_at'] = dt.datetime.now().isoformat()
                    
                    _context_manager._update_progress()
                    save_context()
                    
                    print(f"âœ… Task [{task_id}] {field} ìˆ˜ì •ë¨")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"âŒ Task '{task_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    elif action == 'done':
        if len(args) < 1:
            print("ì‚¬ìš©ë²•: /task done [task-id]")
            return
            
        task_id = args[0]
        
        task_found = False
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if task['status'] == 'completed':
                        print(f"âš ï¸ Task [{task_id}]ëŠ” ì´ë¯¸ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
                        return
                    
                    # ì‘ì—…ì„ ì™„ë£Œë¡œ í‘œì‹œ
                    task['status'] = 'completed'
                    task['completed_at'] = dt.datetime.now().isoformat()
                    
                    # í˜„ì¬ ì‘ì—…ì´ì—ˆë‹¤ë©´ current_task í•´ì œ
                    if _context_manager.context.get('current_task') == task_id:
                        _context_manager.context['current_task'] = None
                        
                        # ì‘ì—… ì¶”ì  ì •ë³´ ì €ì¥
                        work_tracking = _context_manager.context.get('work_tracking', {})
                        current_task_work = work_tracking.get('current_task_work', {})
                        if current_task_work and current_task_work.get('task_id') == task_id:
                            task_tracking = work_tracking.setdefault('task_tracking', {})
                            task_tracking[task_id] = {
                                'start_time': current_task_work.get('start_time'),
                                'end_time': dt.datetime.now().isoformat(),
                                'files_accessed': current_task_work.get('files_accessed', []),
                                'functions_edited': current_task_work.get('functions_edited', []),
                                'operations': current_task_work.get('operations', [])
                            }
                            
                            # ì‘ì—… ìš”ì•½ ì €ì¥
                            task['work_summary'] = {
                                'files_accessed': len(current_task_work.get('files_accessed', [])),
                                'functions_edited': len(current_task_work.get('functions_edited', [])),
                                'operations': len(current_task_work.get('operations', []))
                            }
                    
                    task['updated_at'] = dt.datetime.now().isoformat()
                    task_found = True
                    plan['updated_at'] = dt.datetime.now().isoformat()
                    
                    _context_manager._update_progress()
                    save_context()
                    
                    print(f"âœ… Task [{task_id}] {task['title']} ì™„ë£Œ!")
                    
                    # ì‘ì—… ìš”ì•½ í‘œì‹œ
                    if task.get('work_summary'):
                        summary = task['work_summary']
                        print(f"   ğŸ“Š ì‘ì—… ìš”ì•½:")
                        print(f"      â€¢ ì ‘ê·¼ íŒŒì¼: {summary['files_accessed']}ê°œ")
                        print(f"      â€¢ ìˆ˜ì • í•¨ìˆ˜: {summary['functions_edited']}ê°œ")
                        print(f"      â€¢ ì´ ì‘ì—…: {summary['operations']}íšŒ")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"âŒ Task '{task_id}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    elif action == 'list':
        print(f"\nğŸ“‹ ê³„íš: {plan['name']}")
        print(f"ì§„í–‰ë¥ : {_context_manager.context['progress']['percentage']:.1f}%")
        print("\nì „ì²´ Task ëª©ë¡:")
        
        for phase_id, phase in plan['phases'].items():
            tasks = phase['tasks']
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            
            status_emoji = "âœ…" if phase.get('status') == 'completed' else "ğŸ”„" if phase.get('status') == 'in_progress' else "â³"
            print(f"\n{status_emoji} {phase['name']} ({completed}/{len(tasks)} ì™„ë£Œ)")
            
            if phase.get('description'):
                print(f"   ğŸ“ {phase['description']}")
            
            for task in tasks:
                task_emoji = "âœ…" if task['status'] == 'completed' else "ğŸ”„" if task['status'] == 'in_progress' else "ğŸš«" if task['status'] == 'blocked' else "â³"
                current = " ğŸ‘ˆ í˜„ì¬" if _context_manager.context.get('current_task') == task['id'] else ""
                print(f"   {task_emoji} [{task['id']}] {task['title']}{current}")
                if task.get('description'):
                    print(f"      ğŸ“ {task['description']}")
    
    else:
        print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ì•¡ì…˜: {action}")
        print("ì‚¬ìš© ê°€ëŠ¥í•œ ì•¡ì…˜: add, edit, done, list")


def cmd_next() -> None:
    """/next ëª…ë ¹ì–´ - ë‹¤ìŒ ì‘ì—…ìœ¼ë¡œ ì§„í–‰"""
    if not _context_manager.context:
        print("âŒ í”„ë¡œì íŠ¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return
        
    plan = _context_manager.context.get('plan')
    if not plan:
        print("âŒ ê³„íšì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € /plan [ê³„íšëª…]ì„ ì‹¤í–‰í•˜ì„¸ìš”.")
        return
    
    # í˜„ì¬ ì‘ì—…ì´ ìˆìœ¼ë©´ ì™„ë£Œë¡œ í‘œì‹œ
    current_task_id = _context_manager.context.get('current_task')
    if current_task_id:
        work_tracking = _context_manager.context.get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id') == current_task_id:
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_id] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
            
            print(f"\nğŸ“Š Task [{current_task_id}] ì‘ì—… ìš”ì•½:")
            print(f"   â€¢ ì ‘ê·¼ íŒŒì¼: {len(current_task_work.get('files_accessed', []))}ê°œ")
            print(f"   â€¢ ìˆ˜ì • í•¨ìˆ˜: {len(current_task_work.get('functions_edited', []))}ê°œ")
            print(f"   â€¢ ì´ ì‘ì—…: {len(current_task_work.get('operations', []))}íšŒ")
        
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == current_task_id:
                    if task['status'] != 'completed':
                        task['status'] = 'completed'
                        task['completed_at'] = dt.datetime.now().isoformat()
                        if current_task_work:
                            task['work_summary'] = {
                                'files_accessed': len(current_task_work.get('files_accessed', [])),
                                'functions_edited': len(current_task_work.get('functions_edited', [])),
                                'operations': len(current_task_work.get('operations', []))
                            }
                        print(f"âœ… Task [{task['id']}] {task['title']} ì™„ë£Œ!")
                    break
    
    # ë‹¤ìŒ pending ì‘ì—… ì°¾ê¸°
    next_task = None
    next_phase = None
    
    if plan.get('current_phase'):
        phase = plan['phases'].get(plan['current_phase'])
        if phase:
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
    
    if not next_task:
        for phase_id, phase in plan['phases'].items():
            if phase.get('status') == 'completed':
                continue
                
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
            
            if next_task:
                break
    
    if next_task:
        _context_manager.context['current_task'] = next_task['id']
        plan['current_phase'] = next_phase['id']
        next_task['status'] = 'in_progress'
        next_task['started_at'] = dt.datetime.now().isoformat()
        next_phase['status'] = 'in_progress'
        
        _context_manager.start_task_tracking(next_task['id'])
        
        plan['updated_at'] = dt.datetime.now().isoformat()
        
        _context_manager._update_progress()
        save_context()
        
        print(f"\nğŸ¯ ë‹¤ìŒ ì‘ì—…: [{next_task['id']}] {next_task['title']}")
        if next_task.get('description'):
            print(f"   ğŸ“ ì„¤ëª…: {next_task['description']}")
        print(f"   ğŸ“ Phase: {next_phase['name']}")
        
        if next_task.get('subtasks'):
            print(f"\n   ğŸ“Œ ì„œë¸ŒíƒœìŠ¤í¬:")
            for subtask in next_task['subtasks']:
                print(f"      - {subtask}")
        
        print(f"\nğŸ’¡ ì‘ì—… ì¶”ì ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ëª¨ë“  íŒŒì¼ ì ‘ê·¼ê³¼ í•¨ìˆ˜ ìˆ˜ì •ì´ ìë™ìœ¼ë¡œ ê¸°ë¡ë©ë‹ˆë‹¤.")
    else:
        all_done = True
        blocked_tasks = []
        
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['status'] == 'blocked':
                    blocked_tasks.append(task)
                elif task['status'] != 'completed':
                    all_done = False
        
        if all_done and not blocked_tasks:
            print("\nğŸ‰ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
            
            for phase in plan['phases'].values():
                phase['status'] = 'completed'
            
            _context_manager._update_progress()
            save_context()
        else:
            if blocked_tasks:
                print(f"\nâš ï¸ ì§„í–‰ ê°€ëŠ¥í•œ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤. {len(blocked_tasks)}ê°œì˜ ì‘ì—…ì´ blocked ìƒíƒœì…ë‹ˆë‹¤:")
                for task in blocked_tasks[:3]:
                    print(f"   - [{task['id']}] {task['title']}")
            else:
                print("\nâš ï¸ ì§„í–‰ ê°€ëŠ¥í•œ ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.")


def process_command(command: str, existing_context: Dict[str, Any] = None) -> Any:
    """ëª…ë ¹ì–´ ì²˜ë¦¬"""
    parts = command.strip().split()
    if not parts:
        return None
    
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    if cmd == '/flow':
        project_name = args[0] if args else None
        return cmd_flow(project_name, existing_context)
    
    elif cmd == '/plan':
        if len(args) == 0:
            return cmd_plan()
        elif len(args) == 1:
            return cmd_plan(args[0])
        else:
            return cmd_plan(args[0], ' '.join(args[1:]))
    
    elif cmd == '/task':
        if not args:
            print("ì‚¬ìš©ë²•: /task add|edit|list [ì¸ì...]")
            return None
        return cmd_task(args[0], *args[1:])
    
    elif cmd == '/next':
        return cmd_next()
    
    elif cmd == '/save':
        return save_context()
    
    else:
        print(f"ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {cmd}")
        print("ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´: /flow, /plan, /task, /next, /save")
        return None


def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """/flow ëª…ë ¹ì–´ - í”„ë¡œì íŠ¸ ì „í™˜"""
    
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    if not project_name:
        # í”„ë¡œì íŠ¸ ëª©ë¡ í‘œì‹œ
        print("\nğŸ“‹ ë“±ë¡ëœ í”„ë¡œì íŠ¸ ëª©ë¡:")
        print("="*60)
        
        project_count = 0
        if os.path.exists(memory_root):
            import re
            version_patterns = [
                r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
                r'^app-\d+\.\d+\.\d+$',
                r'^project-\d+\.\d+\.\d+$',
                r'^v\d+\.\d+\.\d+$'
            ]
            
            for item in sorted(os.listdir(memory_root)):
                is_version_pattern = any(re.match(pattern, item) for pattern in version_patterns)
                if is_version_pattern:
                    continue
                    
                item_path = os.path.join(memory_root, item)
                if os.path.isdir(item_path) and item != 'common':
                    # ìƒˆë¡œìš´ ìºì‹œ íŒŒì¼ ìœ„ì¹˜ í™•ì¸
                    cache_file = os.path.join(item_path, '.cache', 'cache_core.json')
                    if os.path.exists(cache_file):
                        try:
                            with open(cache_file, 'r', encoding='utf-8') as f:
                                cache_data = json.load(f)
                                actual_path = cache_data.get('project_path', 'Unknown')
                                last_accessed = cache_data.get('updated_at', 'Unknown')
                                
                                current_marker = " ğŸ”¥" if _context_manager.project_name == item else ""
                                print(f"  â€¢ {item}{current_marker}")
                                print(f"    ğŸ“ ê²½ë¡œ: {actual_path}")
                                print(f"    ğŸ• ìµœê·¼ ì ‘ê·¼: {last_accessed[:10] if last_accessed != 'Unknown' else 'Unknown'}")
                                project_count += 1
                        except:
                            print(f"  â€¢ {item} (ìºì‹œ ì½ê¸° ì‹¤íŒ¨)")
        
        if project_count == 0:
            print("  ë“±ë¡ëœ í”„ë¡œì íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
        else:
            print(f"\nì´ {project_count}ê°œì˜ í”„ë¡œì íŠ¸")
            
        print("\nì‚¬ìš©ë²•: /flow [í”„ë¡œì íŠ¸ëª…]")
        return {
            'success': True,
            'message': 'í”„ë¡œì íŠ¸ ëª©ë¡ í‘œì‹œ ì™„ë£Œ',
            'project_count': project_count,
            'action': 'list_projects'
        }
    
    # ì´ì „ ì»¨í…ìŠ¤íŠ¸ ì €ì¥
    if _context_manager.context and _context_manager.project_name:
        import re
        version_patterns = [
            r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
            r'^app-\d+\.\d+\.\d+$',
            r'^project-\d+\.\d+\.\d+$',
            r'^v\d+\.\d+\.\d+$'
        ]
        is_version_pattern = any(re.match(pattern, _context_manager.project_name) for pattern in version_patterns)
        
        if not is_version_pattern:
            prev_cache_dir = os.path.join(memory_root, _context_manager.project_name, '.cache')
            if os.path.exists(prev_cache_dir):
                save_context()
    
    # Memory í´ë”ì—ì„œ í”„ë¡œì íŠ¸ ìºì‹œ í™•ì¸
    project_cache_dir = os.path.join(memory_root, project_name, '.cache')
    cache_file = os.path.join(project_cache_dir, 'cache_core.json')
    
    project_path = None
    location = 'unknown'
    
    if os.path.exists(cache_file):
        # ìºì‹œì—ì„œ í”„ë¡œì íŠ¸ ê²½ë¡œ ì½ê¸°
        try:
            with open(cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                cached_path = cache_data.get('project_path')
                
                if cached_path and os.path.exists(cached_path):
                    project_path = Path(cached_path)
                    location = 'cached'
                    print(f"\nâœ… Memoryì—ì„œ í”„ë¡œì íŠ¸ ì°¾ìŒ: {project_name}")
        except Exception as e:
            print(f"\nâš ï¸ ìºì‹œ ì½ê¸° ì‹¤íŒ¨: {e}")
    
    # ìºì‹œì— ì—†ê±°ë‚˜ ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ìƒˆë¡œ ì°¾ê¸°
    if not project_path:
        desktop_path = paths['project_path'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            if os.path.basename(os.getcwd()) == project_name:
                project_path = Path(os.getcwd())
                location = 'current'
            else:
                if existing_context:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\nâŒ í”„ë¡œì íŠ¸ '{project_name}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                    return {
                        'success': False,
                        'message': f'í”„ë¡œì íŠ¸ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {project_name}',
                        'project_name': project_name
                    }
    
    # ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½
    directory_changed = False
    directory_error = None
    
    try:
        # ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
        if not os.path.exists(str(project_path)):
            print(f"âš ï¸ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {project_path}")
            # ë””ë ‰í† ë¦¬ ìƒì„± ì‹œë„
            try:
                os.makedirs(str(project_path), exist_ok=True)
                print(f"âœ… í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ìƒì„±ë¨: {project_path}")
            except Exception as create_err:
                print(f"âŒ ë””ë ‰í† ë¦¬ ìƒì„± ì‹¤íŒ¨: {create_err}")
                directory_error = str(create_err)
        
        # ë””ë ‰í† ë¦¬ ë³€ê²½ ì‹œë„
        os.chdir(str(project_path))
        current_dir = os.getcwd()
        if os.path.samefile(current_dir, str(project_path)):
            print(f"ğŸ“‚ ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½ ì„±ê³µ: {project_path}")
            directory_changed = True
        else:
            print(f"âš ï¸ ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½ ì‹¤íŒ¨: í˜„ì¬ {current_dir}")
            directory_error = "ë””ë ‰í† ë¦¬ ë³€ê²½ í›„ ê²½ë¡œ ë¶ˆì¼ì¹˜"
    except Exception as e:
        print(f"\nâš ï¸ ë””ë ‰í† ë¦¬ ë³€ê²½ ì‹¤íŒ¨: {e}")
        directory_error = str(e)
        # ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰ (ìºì‹œëŠ” ì‚¬ìš© ê°€ëŠ¥)
    
    # ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
    if 'context' in globals():
        globals()['context'].clear()
    
    context = initialize_context(
        project_path=str(project_path),
        project_name=project_name,
        memory_root=memory_root,
        existing_context=existing_context
    )
    
    print(f"\nâœ… í”„ë¡œì íŠ¸ '{project_name}'ë¡œ ì „í™˜ ì™„ë£Œ!")
    print(f"ğŸ“ ì‘ì—… ê²½ë¡œ: {project_path} ({location})")
    if directory_error:
        print(f"âš ï¸ ë””ë ‰í† ë¦¬ ê´€ë ¨ ê²½ê³ : {directory_error}")
    print(f"ğŸ’¾ ìºì‹œ ê²½ë¡œ: {memory_root}/{project_name}/.cache/")
    print(f"ğŸ“Š ìºì‹œ ë²„ì „: {context.get('version', 'unknown')}")
    print(f"ğŸ“ˆ ë¶„ì„ëœ íŒŒì¼: {len(context.get('analyzed_files', {}))}ê°œ")
    
    tasks = context.get('tasks', {})
    if isinstance(tasks, dict):
        next_count = len(tasks.get('next', []))
        done_count = len(tasks.get('done', []))
        print(f"ğŸ“‹ ë‚¨ì€ ì‘ì—…: {next_count}ê°œ")
        print(f"âœ… ì™„ë£Œëœ ì‘ì—…: {done_count}ê°œ")

    
    # í˜„ì¬ ê³„íš ì •ë³´ í‘œì‹œ
    plan = context.get('plan')
    if plan:
        print(f"\nğŸ“… í˜„ì¬ ê³„íš: {plan.get('name', 'N/A')}")
        current_task_id = context.get('current_task')
        if current_task_id:
            # í˜„ì¬ ì‘ì—… ì°¾ê¸°
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        print(f"ğŸ¯ í˜„ì¬ ì‘ì—…: [{task['id']}] {task.get('title', 'N/A')}")
                        print(f"   ìƒíƒœ: {task.get('status', 'pending')}")
                        break
        
        # Phaseë³„ ì§„í–‰ ìƒí™©
        print("\nğŸ“Š Phaseë³„ ì§„í–‰ ìƒí™©:")
        for phase_id, phase in plan.get('phases', {}).items():
            tasks = phase.get('tasks', [])
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            in_progress = sum(1 for t in tasks if t.get('status') == 'in_progress')
            
            status_icon = "âœ…" if phase.get('status') == 'completed' else "ğŸ”„" if in_progress > 0 else "ğŸ“"
            print(f"   {status_icon} {phase.get('name', phase_id)}: {completed}/{len(tasks)} ì™„ë£Œ")

    # ê¸€ë¡œë²Œ context ì—…ë°ì´íŠ¸
    if 'context' in globals():
        globals()['context'].update(context)
    else:
        globals()['context'] = context
    
    pending_count = len(tasks.get('next', [])) if isinstance(tasks, dict) else 0
    completed_count = len(tasks.get('done', [])) if isinstance(tasks, dict) else 0
    
    return {
        'success': True,
        'message': f'í”„ë¡œì íŠ¸ \'{project_name}\' ì „í™˜ ì™„ë£Œ',
        'project_name': project_name,
        'project_root': str(project_path),
        'directory_changed': directory_changed,
        'directory_error': directory_error,
        'cache_info': {
            'analyzed_files': len(context.get('analyzed_files', {})),
            'pending_tasks': pending_count,
            'completed_tasks': completed_count,
            'cache_version': context.get('version', 'unknown')
        }
    }
# ëª…ë ¹ì–´ ì²˜ë¦¬ í•¨ìˆ˜ë“¤ (cmd_plan, cmd_task, cmd_next)ì€ ë™ì¼í•˜ë¯€ë¡œ ìƒëµ...


# ===========================================
# ë©”ì¸ ì§„ì…ì 
# ===========================================

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        command = ' '.join(sys.argv[1:])
        # process_command(command)
    else:
        print("AI Coding Brain v7.0 (ìºì‹œ êµ¬ì¡° ê°œì„ )")
        print("ì‚¬ìš©ë²•: python claude_code_ai_brain.py [ëª…ë ¹ì–´]")
        print("ëª…ë ¹ì–´: /flow, /plan, /task, /next, /save")
