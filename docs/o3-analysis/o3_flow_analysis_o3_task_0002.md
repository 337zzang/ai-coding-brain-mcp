# Flow 시스템 o3 분석 결과 - o3_task_0002

생성일시: 2025-07-23T17:00:32.348977

## 분석 결과

{'answer': '원인 진단\n--------------------------------------------------\n1. FlowCommandRouter가 호출하는 핵심 메서드  \n   • switch_project()  \n   • get_status()  \n   • archive_flow()  \n   • create_project() / delete_flow() / list_flows() …  \n\n2. 실제로 주입된 객체  \n   workflow_wrapper.py 는  \n   FlowManager → FlowCommandRouter 순서로 직접 연결하고 있음.\n\n3. FlowManager 의 실제 인터페이스  \n   • current_project(), create_flow(), list_flows(), delete_flow() 등  \n   • Router가 기대하는 메서드명이 전혀 존재하지 않음.\n\n따라서  \n“FlowCommandRouter는 FlowManagerUnified(또는 LegacyFlowAdapter)” 를 전제로 작성되었는데,  \n현재는 원본 FlowManager 가 들어가 버리기 때문에 메서드 불일치 예외가 발생한다.\n\n해결 전략\n--------------------------------------------------\nA. “맞는 매니저를 연결” (권장, 코드 변경 최소)  \nB. “어댑터를 끼워서 이름만 맞춰 줌”  \nC. “FlowManager 쪽에 직접 메서드를 추가”  \n\n가장 파급이 적으면서 장기적으로도 유지보수가 쉬운 방법은 A + B 병행이다.\n즉,\n\n① Router <-- FlowManagerUnified ‑-(내부에서)-- FlowManager  \n\u2003또는  \n② Router <-- LegacyFlowAdapter(FlowManager)  \n\n중 하나로 고정하고, 이후 새 메서드는 Adapter/Unified 계층에만 추가한다.\n\n구현 가이드\n--------------------------------------------------\n1. workflow_wrapper.py 수정\n--------------------------------\n```python\ndef get_workflow_manager():\n    global _manager\n    if _manager is None:\n        try:\n            # 1순위: Unified 매니저\n            from ai_helpers_new.flow_manager_unified import FlowManagerUnified\n            from ai_helpers_new.flow_command_router import FlowCommandRouter\n            _manager = FlowCommandRouter(FlowManagerUnified(context_enabled=True))\n            print("✅ FlowManagerUnified + Router 초기화됨")\n\n        except ImportError:\n            # 2순위: 순정 FlowManager + Legacy Adapter\n            from ai_helpers_new.flow_manager import FlowManager\n            from ai_helpers_new.legacy_flow_adapter import LegacyFlowAdapter\n            from ai_helpers_new.flow_command_router import FlowCommandRouter\n\n            core = FlowManager(context_enabled=True)\n            _manager = FlowCommandRouter(LegacyFlowAdapter(core))\n            print("⚠️  LegacyAdapter 경유 초기화됨")\n\n    return _manager\n```\n\n2. LegacyFlowAdapter(간략 버전) 예시\n---------------------------------------\n```python\nclass LegacyFlowAdapter:\n    """\n    FlowManager → FlowCommandRouter 사이 ‘이름 번역기’\n    """\n    def __init__(self, fm):\n        self._fm = fm\n        self._prev_project = None\n\n    # === Router가 기대하는 메서드들 =========================\n    def switch_project(self, name: str):\n        self._prev_project = self._fm.current_project()\n        self._fm.current_project(name)\n        return {\'ok\': True, \'data\': f"Switched to \'{name}\'"}\n\n    def switch_to_previous(self):\n        if not self._prev_project:\n            return {\'ok\': False, \'error\': \'기록된 이전 Flow 없음\'}\n        current = self._fm.current_project()\n        self._fm.current_project(self._prev_project)\n        self._prev_project, current = current, self._prev_project\n        return {\'ok\': True, \'data\': f"Re-activated \'{self._fm.current_project()}\'"}\n\n    def list_flows(self, search=None, include_archived=False, sort_by=\'name\'):\n        flows = self._fm.list_flows()\n        # 간단 필터·정렬\n        if search:\n            flows = [f for f in flows if search.lower() in f.name.lower()]\n        if not include_archived:\n            flows = [f for f in flows if not getattr(f, \'archived\', False)]\n        flows.sort(key=lambda f: getattr(f, \'updated_at\', f.name),\n                   reverse=(sort_by == \'recent\'))\n        return flows\n\n    def create_project(self, name, template=\'default\'):\n        # template 미사용 → create_flow 로 우회\n        flow = self._fm.create_flow(name)\n        return {\'ok\': True, \'data\': f"Flow \'{flow.name}\' created"}\n\n    def delete_flow(self, name, force=False):\n        self._fm.delete_flow(name)\n        return {\'ok\': True, \'data\': f"Flow \'{name}\' removed"}\n\n    def archive_flow(self, name):\n        flow = self._fm.get_flow(name)\n        if not flow:\n            return {\'ok\': False, \'error\': \'존재하지 않는 Flow\'}\n        flow.archived = True\n        return {\'ok\': True, \'data\': f"Flow \'{name}\' archived"}\n\n    def get_status(self):\n        pj = self._fm.current_project()\n        stats = self._fm.get_statistics() or {}\n        return {\'ok\': True,\n                \'data\': {\'project\': {\'name\': pj,\n                                     \'path\': f"./{pj}" if pj else "N/A"},\n                         \'flow\': stats}}\n```\n(필요하면 추가 메서드/리턴형을 Router 규격에 맞춰 조정)\n\n3. FlowManagerUnified 유지보수 지침\n----------------------------------\nUnified 층은 “프로젝트/플로우/계층 간 용어 매핑 + 고수준 통계” 만 담당하도록 하고,  \n저수준 CRUD 로직은 순정 FlowManager 에만 추가한다.  \n새로운 명령이 Router에 들어오면 먼저 Unified/Adapter 쪽에 메서드를 추가하는 방식으로  \nAPI 표면을 한 곳에서만 관리할 수 있다.\n\n4. 단기 핫픽스(테스트용)\n------------------------\n배포가 시급하다면, 서버 부팅 스크립트 가장 처음에 다음을 넣어도 동작한다.\n\n```python\nfrom ai_helpers_new.flow_manager import FlowManager\nif not hasattr(FlowManager, \'switch_project\'):\n    FlowManager.switch_project = FlowManager.current_project        # 임시 별칭\n    FlowManager.get_status     = FlowManager.get_statistics        # 임시 별칭\n    # 필요 시 archive_flow 등도 람다로 더미 처리\n```\n단, 이 방식은 타입 안전·리턴포맷이 보장되지 않아 장기간 유지에는 부적합하다.\n\n요약\n--------------------------------------------------\n• FlowCommandRouter 는 FlowManagerUnified(또는 LegacyFlowAdapter) 레이어를 전제로 한다.  \n• 현재 workflow_wrapper.py 에서 순정 FlowManager 를 직접 주입해 메서드 불일치가 발생.  \n\n→ 해결책  \n1) Router 앞단에 Unified 매니저(또는 Adapter) 를 주입하도록 연결 구조를 수정.  \n2) Adapter/Unified 에 Router 가 요구하는 메서드 명세를 모두 구현·위임.  \n3) 긴급 패치가 필요하면 monkey-patch 로 임시 별칭을 넣되, 추후 정식 어댑터로 교체.\n\n이렇게 하면 기존 /flow 명령 세트는 그대로 유지되면서 내부 구현체(FlowManager)의 변화도 모듈 단위로 격리할 수 있다.', 'reasoning_effort': 'high', 'usage': {'prompt_tokens': 1976, 'completion_tokens': 4257, 'total_tokens': 6233, 'reasoning_tokens': 0}}
