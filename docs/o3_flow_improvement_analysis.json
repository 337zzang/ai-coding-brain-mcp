{
  "answer": "아래 제안은  \n\n• “기존 코드 한두 군데만 건드리면 곧바로 돌아가게 하면서”  \n• “추가적인 컨텍스트 정보를 지속적으로 확장·활용”  \n\n할 수 있도록 단계-별로 구성했습니다.  \n(Python 예시이지만 Go/TS 등으로 포팅해도 같은 개념 그대로 적용됩니다.)\n\n────────────────────────────────────────\n1. 자료 구조 설계\n────────────────────────────────────────\n① Task 스키마 (JSON-호환)\n{\n  id, name, description, status,\n  context,               # ← 새 필드 (nullable)\n  created_at, updated_at,\n  started_at, completed_at\n}\n\n② Context 기본값\nDEFAULT_CONTEXT = {\n  \"plan\":        \"\",\n  \"actions\":     [],     # list[dict]\n  \"results\":     {},\n  \"docs\":        [],\n  \"files\":       {\"analyzed\": [], \"created\": [], \"modified\": []},\n  \"errors\":      []\n}\n\n③ Action 스키마 예\n{\"time\": ISO8601, \"action\": str, \"result\": str, \"meta\": {...}}\n\n④ 역-호환 키포인트  \n• context가 없으면 {} 로 간주  \n• 읽기 접근 시 task.get(\"context\", {}) 형태 사용  \n────────────────────────────────────────\n2. 코드 변경 (요지)\n────────────────────────────────────────\n(1) create_task 수정\n------------------------------------------------\ndef create_task(self, name, description, **kw):\n    task_id = f\"task_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')[:19]}\"\n    \n    # kw.get('context') 가 있으면 그대로 사용, 없으면 DEFAULT_CONTEXT 딥카피\n    context = copy.deepcopy(kw.get(\"context\", DEFAULT_CONTEXT))\n\n    now = datetime.utcnow().isoformat()\n    new_task = {\n        \"id\":          task_id,\n        \"name\":        name,\n        \"description\": description,\n        \"status\":      \"todo\",\n        \"context\":     context,\n        \"created_at\":  now,\n        \"updated_at\":  now,\n        \"started_at\":  None,\n        \"completed_at\":None\n    }\n    self._save_task(new_task)\n    return new_task\n------------------------------------------------\n\n(2) update_task_context 추가\n------------------------------------------------\ndef update_task_context(self, task_id, **patch):\n    \"\"\"\n    patch는 context 하위구조(딥 머지)만 포함.\n    예) update_task_context(id, plan=\"…\", results={\"score\": 0.93})\n    \"\"\"\n    task = self._load_task(task_id)\n    ctx  = copy.deepcopy(task.get(\"context\", DEFAULT_CONTEXT))\n\n    # 딥 머지\n    def deep_merge(a, b):\n        for k, v in b.items():\n            if k in a and isinstance(a[k], dict) and isinstance(v, dict):\n                deep_merge(a[k], v)\n            else:\n                a[k] = v\n    deep_merge(ctx, patch)\n\n    task[\"context\"]  = ctx\n    task[\"updated_at\"]= datetime.utcnow().isoformat()\n    self._save_task(task)\n    return task\n------------------------------------------------\n\n(3) add_task_action\n------------------------------------------------\ndef add_task_action(self, task_id, action:str, result:str=\"\", **meta):\n    task = self._load_task(task_id)\n    ctx  = task.get(\"context\", DEFAULT_CONTEXT)\n    ctx.setdefault(\"actions\", [])\n    ctx[\"actions\"].append({\n        \"time\":  datetime.utcnow().isoformat(),\n        \"action\":action,\n        \"result\":result,\n        **({\"meta\": meta} if meta else {})\n    })\n    task[\"context\"]=ctx\n    task[\"updated_at\"]=datetime.utcnow().isoformat()\n    self._save_task(task)\n------------------------------------------------\n\n(4) /flow (CLI·채팅 봇) 출력 개선\n• 기본 출력은 종전과 동일  \n• ‑-verbose 혹은 /flow details  식으로 요청 시\n  - plan, 최근 action N개, 결과 요약 표시  \n• context가 없으면 “(no context)” 문구\n\n────────────────────────────────────────\n3. 점진적 배포 시나리오\n────────────────────────────────────────\n1단계 (D-Day)  \n  • DEFAULT_CONTEXT 상수, create_task 수정 → 새 Task부터 context 보유  \n  • 나머지 시스템은 기존 필드만 그대로 사용 가능\n\n2단계 (D+~7일)  \n  • add_task_action, update_task_context 메서드 배포  \n  • 새 로직에서만 호출; 레거시 코드 영향 無\n\n3단계 (D+2주)  \n  • /flow 명령 확장 배포  \n  • 사용자 피드백 확인 → 출력 형식 조정\n\n4단계 (선택)  \n  • DB로 저장 중이면 ALTER TABLE tasks ADD COLUMN context JSONB DEFAULT '{}'  \n  • 과거 레코드 migration → context='{}'\n\n────────────────────────────────────────\n4. 추가 권장 사항\n────────────────────────────────────────\n• pydantic/attrs/dataclass 로 Task, Context 모델을 명시해 타입 안정성 확보  \n• update_task_context 내부 deep_merge 로직을 util로 분리해 재사용  \n• actions 가 기하급수적으로 늘어나면 log 테이블(or 파일)로 스핀오프  \n• context.version 필드를 두어 스키마 진화(마이그레이션) 관리  \n• docs / files 경로는 프로젝트 root 기준 상대경로로 통일  \n• errors 발생 시 add_task_action과 동시에 ctx[\"errors\"].append(err)  \n\n────────────────────────────────────────\n5. 간단 사용 예\n────────────────────────────────────────\nt = flow.create_task(\"모듈 구조 분석\", \"ai_helpers_new 분석\")\nflow.update_task_context(t[\"id\"], plan=\"1. 모듈 파일 목록…\")\nflow.add_task_action(t[\"id\"], \"모듈 스캔 시작\", \"15개 파일 발견\")\nflow.add_task_action(t[\"id\"], \"AST 분석\",        \"50개 함수, 10개 클래스\",\n                     modules_scanned=15, functions=50)\nflow.update_task_context(t[\"id\"], results={\"modules_scanned\":15,\n                                           \"functions_found\":50,\n                                           \"classes_found\":10},\n                         docs=[\"module_structure.md\"],\n                         files={\"created\":[\"analysis_report.md\"]})\nprint(flow.get_task(t[\"id\"], verbose=True))\n\n────────────────────────────────────────\n정리\n• create_task 한 줄만 바꿔도 “context 필드를 갖는 새 Task” 생성  \n• 별도 API 두 개(update_task_context, add_task_action)로 로직/표현 분리  \n• 기존 데이터는 그대로 읽히므로 호환성 100%  \n• 추후 context 활용(검색, Dash-보드, 리포트 자동생성)까지 확장 가능",
  "reasoning_effort": "high",
  "usage": {
    "prompt_tokens": 627,
    "completion_tokens": 1893,
    "total_tokens": 2520,
    "reasoning_tokens": 0
  }
}