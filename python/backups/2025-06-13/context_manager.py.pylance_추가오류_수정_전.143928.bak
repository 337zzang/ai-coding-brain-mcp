#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
ğŸ§  ìŠ¤ë§ˆíŠ¸ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì v3.0 - í†µí•© ë©”ëª¨ë¦¬ ê´€ë¦¬
==========================================

project_contextì˜ ìƒì„±, ê´€ë¦¬, ì ‘ê·¼ì„ ì „ë‹´í•˜ëŠ” ëª¨ë“ˆ.
vibe_memory_systemê³¼ ì™„ì „ í†µí•©ëœ êµ¬ì¡°.

v3.0 ë³€ê²½ì‚¬í•­:
- VibeMemoryManagerì™€ ì™„ì „ í†µí•©
- ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤ ë³´ì¥
- í´ë˜ìŠ¤ êµ¬ì¡° ë‹¨ìˆœí™” ë° í†µí•©
"""

# ===========================================
# Public API - Only these 8 functions are exposed
# ===========================================
__all__ = [
    'initialize_context',      # í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
    'save_context',           # ì»¨í…ìŠ¤íŠ¸ ì €ì¥
    'update_cache',           # ìºì‹œ ì—…ë°ì´íŠ¸
    'get_value',              # ìºì‹œ ê°’ ì¡°íšŒ
    'find_symbol',            # ì‹¬ë³¼ ì°¾ê¸°
    'track_file_access',      # íŒŒì¼ ì ‘ê·¼ ì¶”ì 
    'track_function_edit',    # í•¨ìˆ˜ ìˆ˜ì • ì¶”ì 
    'get_work_tracking_summary' # ì‘ì—… ì¶”ì  ìš”ì•½
]

import os
import json
import datetime as dt
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path
import copy
import logging
from collections import defaultdict

# Vibe Memory System ë™ì  import
try:
    from vibe_memory_system import VibeMemoryManager
    VIBE_MEMORY_AVAILABLE = True
except ImportError:
    VIBE_MEMORY_AVAILABLE = False
    print("âš ï¸ vibe_memory_systemì„ importí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì €ì¥ ê¸°ëŠ¥ë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.")

# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class UnifiedContextManager:
    """
    í†µí•© ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ì - ëª¨ë“  ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ ê¸°ëŠ¥ì„ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë¡œ í†µí•©
    
    Features:
    - ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤ ë³´ì¥
    - ìºì‹œ ê´€ë¦¬, ì‘ì—… ì¶”ì , ì‹¬ë³¼ ì¸ë±ì‹± í†µí•©
    - VibeMemoryManagerì™€ ìë™ ì—°ë™
    """
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.vibe_manager = None
            self.initialized = True
            
    def initialize(self, project_path: str, project_name: str) -> Dict[str, Any]:
        """
        í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        
        Args:
            project_path: í”„ë¡œì íŠ¸ ê²½ë¡œ
            project_name: í”„ë¡œì íŠ¸ ì´ë¦„
            
        Returns:
            ì´ˆê¸°í™”ëœ ì»¨í…ìŠ¤íŠ¸
        """
        self.project_path = project_path
        self.project_name = project_name
        
        # ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„
        cached_context = self._try_load_cached_context()
        if cached_context:
            self.context = cached_context
            logger.info(f"âœ… ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì„±ê³µ: {project_name}")
        else:
            # ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
            self.context = self._create_new_context()
            logger.info(f"âœ… ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±: {project_name}")
        
        # êµ¬ì¡° ì •ê·œí™” ë° ê²€ì¦
        self._normalize_context_structure()
        self._ensure_cache_structure()
        
        # VibeMemoryManager ì´ˆê¸°í™” (ê°€ëŠ¥í•œ ê²½ìš°)
        if VIBE_MEMORY_AVAILABLE:
            try:
                self.vibe_manager = VibeMemoryManager(self.context, project_name)
                logger.info("âœ… VibeMemoryManager ì—°ë™ ì™„ë£Œ")
            except Exception as e:
                logger.warning(f"âš ï¸ VibeMemoryManager ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                self.vibe_manager = None
        
        return self.context
    
    def _create_new_context(self) -> Dict[str, Any]:
        """ìƒˆë¡œìš´ ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        return {
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '3.0',
            
            # ìºì‹œ êµ¬ì¡°
            'cache': {
                'analyzed_files': {},
                'symbol_index': {},
                'work_tracking': {
                    'file_access': defaultdict(int),
                    'file_edits': defaultdict(int),
                    'function_edits': defaultdict(lambda: {'count': 0, 'operations': []}),
                    'session_start': dt.datetime.now().isoformat(),
                    'total_operations': 0
                }
            },
            
            # ì‘ì—… ê´€ë¦¬
            'tasks': {
                'next': [],
                'done': []
            },
            'current_focus': '',
            
            # AI í•™ìŠµ ë°ì´í„°
            'coding_experiences': [],
            'ai_suggestions': []
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì‹œë„"""
        if not self.project_path:
            return None
            
        cache_dir = os.path.join(self.project_path, '.cache')
        cache_file = os.path.join(cache_dir, f'cache_{self.project_name}.json')
        
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.warning(f"ìºì‹œ ë¡œë“œ ì‹¤íŒ¨: {e}")
        
        return None
    
    def _normalize_context_structure(self):
        """ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ì •ê·œí™”"""
        # í•„ìˆ˜ í‚¤ í™•ì¸ ë° ìƒì„±
        required_keys = {
            'cache': {},
            'tasks': {'next': [], 'done': []},
            'coding_experiences': [],
            'ai_suggestions': []
        }
        
        for key, default_value in required_keys.items():
            if self.context and key not in self.context:
                self.context[key] = copy.deepcopy(default_value)
    
    def _ensure_cache_structure(self):
        """ìºì‹œ êµ¬ì¡° í™•ì¸ ë° ì´ˆê¸°í™”"""
        if not self.context:
            return
            
        cache = self.context.setdefault('cache', {})
        
        # ìºì‹œ í•˜ìœ„ êµ¬ì¡° ì´ˆê¸°í™”
        cache.setdefault('analyzed_files', {})
        cache.setdefault('symbol_index', {})
        
        # work_tracking êµ¬ì¡° ì´ˆê¸°í™”
        work_tracking = cache.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
    
    def save(self) -> bool:
        """
        ì»¨í…ìŠ¤íŠ¸ ì €ì¥ - ìºì‹œì™€ Vibe ì‹œìŠ¤í…œ ëª¨ë‘ ì‚¬ìš©
        
        Returns:
            ì„±ê³µ ì—¬ë¶€
        """
        if not self.context:
            logger.warning("âš ï¸ ì €ì¥í•  ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            return False
        
        try:
            # ì—…ë°ì´íŠ¸ ì‹œê°„ ê°±ì‹ 
            self.context['updated_at'] = dt.datetime.now().isoformat()
            
            # 1. ë¡œì»¬ ìºì‹œ ì €ì¥
            cache_saved = self._save_local_cache()
            
            # 2. VibeMemoryManagerë¥¼ í†µí•œ ì €ì¥ (ê°€ëŠ¥í•œ ê²½ìš°)
            vibe_saved = False
            if self.vibe_manager:
                try:
                    vibe_saved = self.vibe_manager.save_context()
                except Exception as e:
                    logger.error(f"VibeMemoryManager ì €ì¥ ì‹¤íŒ¨: {e}")
            
            # ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ ì„±ê³µí•˜ë©´ ì„±ê³µìœ¼ë¡œ ì²˜ë¦¬
            success = cache_saved or vibe_saved
            
            if success:
                logger.info("âœ… ì»¨í…ìŠ¤íŠ¸ ì €ì¥ ì™„ë£Œ")
            else:
                logger.error("âŒ ì»¨í…ìŠ¤íŠ¸ ì €ì¥ ì‹¤íŒ¨")
                
            return success
            
        except Exception as e:
            logger.error(f"ì»¨í…ìŠ¤íŠ¸ ì €ì¥ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
    
    def _save_local_cache(self) -> bool:
        """ë¡œì»¬ ìºì‹œ íŒŒì¼ì— ì €ì¥"""
        try:
            cache_dir = os.path.join(self.project_path, '.cache')
            os.makedirs(cache_dir, exist_ok=True)
            
            cache_file = os.path.join(cache_dir, f'cache_{self.project_name}.json')
            
            # JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜
            serializable_context = self._prepare_serializable_context()
            
            with open(cache_file, 'w', encoding='utf-8') as f:
                json.dump(serializable_context, f, indent=2, ensure_ascii=False)
            
            logger.info(f"âœ… ìºì‹œ ì €ì¥: {cache_file}")
            return True
            
        except Exception as e:
            logger.error(f"ìºì‹œ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def _prepare_serializable_context(self) -> Dict[str, Any]:
        """JSON ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ì»¨í…ìŠ¤íŠ¸ ë³€í™˜"""
        def convert_to_serializable(obj):
            if isinstance(obj, defaultdict):
                return dict(obj)
            elif isinstance(obj, set):
                return list(obj)
            elif isinstance(obj, (dt.datetime, dt.date)):
                return obj.isoformat()
            elif hasattr(obj, '__dict__'):
                return convert_to_serializable(obj.__dict__)
            elif isinstance(obj, dict):
                return {k: convert_to_serializable(v) for k, v in obj.items()}
            elif isinstance(obj, (list, tuple)):
                return [convert_to_serializable(item) for item in obj]
            else:
                return obj
        
        return convert_to_serializable(self.context)
    
    # ===========================================
    # ìºì‹œ ê´€ë¦¬ ë©”ì„œë“œ
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """ìºì‹œ ì—…ë°ì´íŠ¸"""
        if not self.context:
            logger.warning("ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            return
        
        cache = self.context.setdefault('cache', {})
        
        # ì¤‘ì²©ëœ í‚¤ ì²˜ë¦¬ (ì˜ˆ: "analyzed_files.main.py")
        keys = key.split('.')
        current = cache
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
        logger.debug(f"ìºì‹œ ì—…ë°ì´íŠ¸: {key}")
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """ìºì‹œ ê°’ ì¡°íšŒ"""
        if not self.context:
            return default
        
        cache = self.context.get('cache', {})
        
        # ì¤‘ì²©ëœ í‚¤ ì²˜ë¦¬
        keys = key.split('.')
        current = cache
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # ì‹¬ë³¼ ê´€ë¦¬ ë©”ì„œë“œ
    # ===========================================
    
    def find_symbol(self, symbol_name: str) -> Optional[Dict[str, Any]]:
        """ì‹¬ë³¼ ê²€ìƒ‰"""
        if not self.context:
            return None
        
        symbol_index = self.context.get('cache', {}).get('symbol_index', {})
        return symbol_index.get(symbol_name)
    
    def build_symbol_index(self, analyzed_files: Dict[str, Any]):
        """ì‹¬ë³¼ ì¸ë±ìŠ¤ êµ¬ì¶•"""
        symbol_index = {}
        
        for file_path, file_info in analyzed_files.items():
            # í•¨ìˆ˜ ì¸ë±ì‹±
            for func in file_info.get('functions', []):
                symbol_index[func] = {
                    'type': 'function',
                    'file': file_path,
                    'info': file_info.get('function_details', {}).get(func, {})
                }
            
            # í´ë˜ìŠ¤ ì¸ë±ì‹±
            for cls in file_info.get('classes', []):
                symbol_index[cls] = {
                    'type': 'class',
                    'file': file_path,
                    'info': file_info.get('class_details', {}).get(cls, {})
                }
        
        self.update_cache('symbol_index', symbol_index)
        logger.info(f"âœ… ì‹¬ë³¼ ì¸ë±ìŠ¤ êµ¬ì¶•: {len(symbol_index)}ê°œ")
    
    # ===========================================
    # ì‘ì—… ì¶”ì  ë©”ì„œë“œ
    # ===========================================
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        file_access[file_path] = file_access.get(file_path, 0) + 1
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        logger.debug(f"íŒŒì¼ ì ‘ê·¼ ì¶”ì : {file_path} ({operation})")
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None, operation: str = 'edit'):
        """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
        if not self.context:
            return
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        # í•¨ìˆ˜ í‚¤ ìƒì„±
        if class_name:
            func_key = f"{class_name}.{function_name}"
        else:
            func_key = function_name
        
        # ìƒëŒ€ ê²½ë¡œë¡œ ì •ê·œí™”
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        # í¸ì§‘ ì •ë³´ ì—…ë°ì´íŠ¸
        if func_key not in function_edits:
            function_edits[func_key] = {'count': 0, 'operations': []}
        
        function_edits[func_key]['count'] += 1
        function_edits[func_key]['operations'].append({
            'timestamp': dt.datetime.now().isoformat(),
            'operation': operation,
            'file': file_path
        })
        
        # íŒŒì¼ í¸ì§‘ë„ ì¶”ì 
        file_edits = work_tracking.setdefault('file_edits', {})
        file_edits[file_path] = file_edits.get(file_path, 0) + 1
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        logger.debug(f"í•¨ìˆ˜ í¸ì§‘ ì¶”ì : {func_key} in {file_path}")
    
    def get_work_tracking_summary(self) -> str:
        """ì‘ì—… ì¶”ì  ìš”ì•½ ìƒì„±"""
        if not self.context:
            return "ì»¨í…ìŠ¤íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
        
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # ì„¸ì…˜ ì‹œê°„ ê³„ì‚°
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        # í†µê³„ ìˆ˜ì§‘
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        
        # ìš”ì•½ ìƒì„±
        summary = f"""
ğŸ“Š ì‘ì—… ì¶”ì  ìš”ì•½
================
â€¢ ì„¸ì…˜ ì‹œê°„: {duration_str}
â€¢ ì „ì²´ ì‘ì—…: {total_ops}íšŒ
â€¢ ì ‘ê·¼í•œ íŒŒì¼: {len(file_access)}ê°œ
â€¢ ìˆ˜ì •í•œ íŒŒì¼: {len(file_edits)}ê°œ
â€¢ ìˆ˜ì •í•œ í•¨ìˆ˜: {len(function_edits)}ê°œ

ğŸ”¥ ê°€ì¥ ë§ì´ ì ‘ê·¼í•œ íŒŒì¼:
"""
        
        # Top 5 íŒŒì¼
        sorted_files = sorted(file_access.items(), key=lambda x: x[1], reverse=True)[:5]
        for file_path, count in sorted_files:
            summary += f"  â€¢ {file_path}: {count}íšŒ\n"
        
        # Top 5 í•¨ìˆ˜
        if function_edits:
            summary += "\nâœï¸ ê°€ì¥ ë§ì´ ìˆ˜ì •í•œ í•¨ìˆ˜:\n"
            sorted_funcs = sorted(function_edits.items(), 
                                key=lambda x: x[1]['count'], reverse=True)[:5]
            for func_name, info in sorted_funcs:
                summary += f"  â€¢ {func_name}: {info['count']}íšŒ\n"
        
        return summary
    
    # ===========================================
    # AI ì œì•ˆ ë©”ì„œë“œ
    # ===========================================
    
    def propose_next_steps(self, limit: int = 5) -> List[Dict[str, Any]]:
        """AI ê¸°ë°˜ ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ"""
        if not self.context:
            return []
        
        suggestions = []
        work_tracking = self.context.get('cache', {}).get('work_tracking', {})
        
        # 1. ìì£¼ ìˆ˜ì •í•˜ëŠ” íŒŒì¼ ê¸°ë°˜ ì œì•ˆ
        file_edits = work_tracking.get('file_edits', {})
        if file_edits:
            most_edited = max(file_edits.items(), key=lambda x: x[1])
            suggestions.append({
                'type': 'refactor',
                'priority': 'high',
                'text': f"{most_edited[0]}ì„(ë¥¼) {most_edited[1]}íšŒ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤. ë¦¬íŒ©í† ë§ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
                'file': most_edited[0]
            })
        
        # 2. í•¨ìˆ˜ ìˆ˜ì • íŒ¨í„´ ë¶„ì„
        function_edits = work_tracking.get('function_edits', {})
        if function_edits:
            hot_functions = [f for f, info in function_edits.items() if info['count'] >= 3]
            if hot_functions:
                suggestions.append({
                    'type': 'optimize',
                    'priority': 'medium',
                    'text': f"ë‹¤ìŒ í•¨ìˆ˜ë“¤ì´ ìì£¼ ìˆ˜ì •ë©ë‹ˆë‹¤: {', '.join(hot_functions[:3])}",
                    'functions': hot_functions
                })
        
        # 3. ì‘ì—… ê¸°ë°˜ ì œì•ˆ
        next_tasks = self.context.get('tasks', {}).get('next', [])
        if next_tasks:
            suggestions.append({
                'type': 'task',
                'priority': 'high',
                'text': f"ë‹¤ìŒ ì‘ì—…: {next_tasks[0]}",
                'task': next_tasks[0]
            })
        
        # 4. ë¶„ì„ë˜ì§€ ì•Šì€ íŒŒì¼ ì œì•ˆ
        analyzed = self.context.get('cache', {}).get('analyzed_files', {})
        if len(analyzed) < 10:  # ë¶„ì„ëœ íŒŒì¼ì´ ì ìœ¼ë©´
            suggestions.append({
                'type': 'analyze',
                'priority': 'medium',
                'text': "í”„ë¡œì íŠ¸ íŒŒì¼ ë¶„ì„ì´ í•„ìš”í•©ë‹ˆë‹¤. ì „ì²´ êµ¬ì¡°ë¥¼ íŒŒì•…í•´ë³´ì„¸ìš”.",
                'action': 'analyze_all_files'
            })
        
        # 5. ì„¸ì…˜ ì‹œê°„ ê¸°ë°˜ ì œì•ˆ
        if work_tracking.get('session_start'):
            start_time = dt.datetime.fromisoformat(work_tracking['session_start'])
            if (dt.datetime.now() - start_time).total_seconds() > 7200:  # 2ì‹œê°„ ì´ìƒ
                suggestions.append({
                    'type': 'break',
                    'priority': 'low',
                    'text': "2ì‹œê°„ ì´ìƒ ì‘ì—…í•˜ì…¨ìŠµë‹ˆë‹¤. ì ì‹œ íœ´ì‹ì„ ì·¨í•˜ëŠ” ê²ƒì´ ì–´ë–¨ê¹Œìš”?",
                    'action': 'take_break'
                })
        
        # ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬í•˜ê³  ì œí•œ
        priority_order = {'high': 0, 'medium': 1, 'low': 2}
        suggestions.sort(key=lambda x: priority_order.get(x['priority'], 3))
        
        return suggestions[:limit]


# ===========================================
# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API êµ¬í˜„
# ===========================================

def initialize_context(project_path: str, project_name: str) -> Dict[str, Any]:
    """í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”"""
    return _context_manager.initialize(project_path, project_name)


def save_context() -> bool:
    """ì»¨í…ìŠ¤íŠ¸ ì €ì¥"""
    return _context_manager.save()


def update_cache(context: Dict[str, Any], key: str, value: Any):
    """ìºì‹œ ì—…ë°ì´íŠ¸"""
    _context_manager.update_cache(key, value)


def get_value(context: Dict[str, Any], key: str, default: Any = None) -> Any:
    """ìºì‹œ ê°’ ì¡°íšŒ"""
    return _context_manager.get_value(key, default)


def find_symbol(context: Dict[str, Any], symbol_name: str) -> Optional[Dict[str, Any]]:
    """ì‹¬ë³¼ ì°¾ê¸°"""
    return _context_manager.find_symbol(symbol_name)


def track_file_access(context: Dict[str, Any], file_path: str, operation: str = 'read'):
    """íŒŒì¼ ì ‘ê·¼ ì¶”ì """
    _context_manager.track_file_access(file_path, operation)


def track_function_edit(context: Dict[str, Any], file_path: str, function_name: str,
                       class_name: Optional[str] = None, operation: str = 'edit'):
    """í•¨ìˆ˜ ìˆ˜ì • ì¶”ì """
    _context_manager.track_function_edit(file_path, function_name, class_name, operation)


def get_work_tracking_summary(context: Dict[str, Any]) -> str:
    """ì‘ì—… ì¶”ì  ìš”ì•½"""
    return _context_manager.get_work_tracking_summary()


# ===========================================
# ì¶”ê°€ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ (í•˜ìœ„ í˜¸í™˜ì„±)
# ===========================================

def build_index(context: Dict[str, Any], analyzed_files: Dict[str, Any]):
    """ì‹¬ë³¼ ì¸ë±ìŠ¤ êµ¬ì¶• (í•˜ìœ„ í˜¸í™˜ì„±)"""
    _context_manager.build_symbol_index(analyzed_files)


def propose_next_steps(context: Dict[str, Any], limit: int = 5) -> List[Dict[str, Any]]:
    """AI ê¸°ë°˜ ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ (í•˜ìœ„ í˜¸í™˜ì„±)"""
    return _context_manager.propose_next_steps(limit)


def save_project_cache(project_context: Dict[str, Any]) -> bool:
    """í”„ë¡œì íŠ¸ ìºì‹œ ì €ì¥ (í•˜ìœ„ í˜¸í™˜ì„±)"""
    return save_context()


# ===========================================
# ëª¨ë“ˆ ì´ˆê¸°í™” ì‹œ ì‹¤í–‰
# ===========================================
if __name__ == "__main__":
    # í…ŒìŠ¤íŠ¸ ì½”ë“œ
    test_context = initialize_context(".", "test_project")
    print("âœ… Context Manager v3.0 ì´ˆê¸°í™” ì™„ë£Œ")
    print(f"í”„ë¡œì íŠ¸: {test_context.get('project_name')}")
    print(f"ë²„ì „: {test_context.get('version')}")
