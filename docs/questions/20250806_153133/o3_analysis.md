# O3 AI 분석 결과

{'answer': '아래 내용을 “그대로 복사-붙여넣기”만 해도 동작할 수 있도록 최대한 간단하게 정리했습니다.   \n(Playwright 1.39+, Python 3.10 이상 기준)\n\n────────────────────────────────────\n1. 핵심 결론\n────────────────────────────────────\nA. “같은 브라우저 프로세스를 여러 터미널에서 제어”하려면 **하나의 브라우저 / 컨트롤러 프로세스**만 유지하고  \n   다른 파이썬 스크립트들은 그 컨트롤러에 **원격으로 붙는 구조**(RPC 또는 WebSocket)가 필요하다.  \n\nB. Playwright 는 이를 위해 이미  \n   - `launch_server()` (브라우저 + WebSocket 컨트롤 엔드포인트)  \n   - `browser_type.connect()` (엔드포인트에 재접속)  \n   을 제공하므로, 복잡한 CDP 포트 셋업 없이 **“파일 하나에 WS 주소만 써-두고”** 재접속하게 만들면 끝.  \n\nC. 세션을 번호(ID)로 식별하고, 쿠키·LocalStorage 는 `user_data_dir` 로 **자동 영속화**.  \n   즉,  \n      ① session 시작 → 서버 띄우고 WS 주소와 PID 를 `~/.web_sessions/<id>/meta.json` 에 저장  \n      ② 다른 프로세스 → 같은 파일을 읽어 `connect()`  \n      ③ 재부팅 후 → `launch_persistent_context()` 로 동일 `user_data_dir` 로 다시 열면 로그인 상태 유지  \n\nD. 사용자는 단 3개의 API 만 알면 된다.  \n```python\nfrom web_session import open_session, connect_session, close_session\nbrowser, context, page = open_session("work")      # 없으면 생성, 있으면 재접속\npage.goto("https://…")\n\n# 다른 터미널\npage = connect_session("work")                     # 바로 제어\n\nclose_session("work")                              # 세션 정리\n```\n\n────────────────────────────────────\n2. 디렉터리/파일 구조\n────────────────────────────────────\n~/.web_sessions/\n └─ work/              # <session_id>\n     ├─ user_data/     # 크롬 프로필 (cookies, localStorage…)\n     └─ meta.json      # { "ws": "...", "pid": 1234 }\n\n────────────────────────────────────\n3. 전체 코드\n────────────────────────────────────\n웹 프로젝트 폴더(또는 site-packages)에 `web_session.py` 하나만 두면 된다.\n\n```python\n# web_session.py\nimport json, os, signal, subprocess, sys, time\nfrom pathlib import Path\nfrom typing import Tuple\nfrom playwright.sync_api import sync_playwright, Browser, BrowserContext, Page\n\nBASE_DIR = Path.home() / ".web_sessions"\nBASE_DIR.mkdir(exist_ok=True)\n\n\ndef _meta_path(session_id: str) -> Path:\n    return BASE_DIR / session_id / "meta.json"\n\n\ndef _launch_server(session_id: str,\n                   headless: bool = False,\n                   browser: str = "chromium") -> Tuple[str, int]:\n    """\n    새 브라우저 서버를 띄우고 WS endpoint, pid 반환\n    """\n    session_dir = BASE_DIR / session_id\n    user_data_dir = session_dir / "user_data"\n    session_dir.mkdir(exist_ok=True)\n    user_data_dir.mkdir(exist_ok=True)\n\n    with sync_playwright() as p:\n        btype = getattr(p, browser)\n        # 1) 서버 모드로 실행\n        server = btype.launch_server(\n            headless=headless,\n            args=[f"--user-data-dir={user_data_dir}"]\n        )\n        ws = server.ws_endpoint\n        pid = server.process.pid\n\n        # 2) 메타데이터 저장\n        with _meta_path(session_id).open("w") as f:\n            json.dump({"ws": ws, "pid": pid, "browser": browser}, f)\n\n    return ws, pid\n\n\ndef _read_meta(session_id: str) -> dict | None:\n    try:\n        with _meta_path(session_id).open() as f:\n            return json.load(f)\n    except FileNotFoundError:\n        return None\n\n\ndef _is_alive(pid: int) -> bool:\n    try:\n        os.kill(pid, 0)\n        return True\n    except OSError:\n        return False\n\n\n# ───────────────────────────────────────\n# Public API\n# ───────────────────────────────────────\ndef open_session(session_id: str,\n                 headless: bool = False,\n                 browser: str = "chromium"\n                 ) -> Tuple[Browser, BrowserContext, Page]:\n    """\n    ① 이미 살아있는 세션이면 connect\n    ② 없으면 launch → connect\n    """\n    meta = _read_meta(session_id)\n\n    # 1. 살아있는 세션?\n    if meta and _is_alive(meta["pid"]):\n        ws = meta["ws"]\n    else:\n        ws, _ = _launch_server(session_id, headless=headless, browser=browser)\n\n    # 2. 이제 연결\n    pw = sync_playwright().start()\n    btype = getattr(pw, browser)\n    browser_obj = btype.connect(ws)\n    # launch_server 로 띄웠으므로 persistent context X → 새 context 필요\n    context = browser_obj.new_context()\n    page = context.new_page()\n    return browser_obj, context, page\n\n\ndef connect_session(session_id: str,\n                    browser: str = "chromium") -> Page:\n    """메타 정보만 있으면 바로 page 객체 반환"""\n    meta = _read_meta(session_id)\n    if not meta:\n        raise RuntimeError(f"세션 \'{session_id}\'가 존재하지 않습니다. 먼저 open_session을 호출하세요.")\n    if not _is_alive(meta["pid"]):\n        raise RuntimeError(f"세션 \'{session_id}\' 브라우저가 종료되었습니다. open_session으로 재시작하세요.")\n\n    pw = sync_playwright().start()\n    btype = getattr(pw, browser)\n    browser_obj = btype.connect(meta["ws"])\n    context = browser_obj.new_context()\n    return context.new_page()\n\n\ndef close_session(session_id: str):\n    """\n    • page.close 가 아니라 ‘브라우저 프로세스’를 종료\n    • PID 가 종료되지 않으면 SIGTERM → SIGKILL\n    """\n    meta = _read_meta(session_id)\n    if not meta:\n        print(f"[close_session] \'{session_id}\' not found")\n        return\n\n    pid = meta["pid"]\n    # 1) 정상 종료 시도\n    try:\n        os.kill(pid, signal.SIGTERM)\n    except OSError:\n        pass\n\n    for _ in range(10):\n        if not _is_alive(pid):\n            break\n        time.sleep(0.3)\n\n    if _is_alive(pid):\n        os.kill(pid, signal.SIGKILL)\n\n    # 2) 메타파일 삭제\n    try:\n        _meta_path(session_id).unlink()\n    except FileNotFoundError:\n        pass\n\n    print(f"[close_session] \'{session_id}\' 종료 완료")\n```\n\n────────────────────────────────────\n4. 사용 예시\n────────────────────────────────────\n첫 터미널\n```python\nfrom web_session import open_session\n\nbrowser, ctx, page = open_session("myjob")         # 새 세션 생성\npage.goto("https://google.com")\n```\n\n두 번째 터미널\n```python\nfrom web_session import connect_session\n\npage = connect_session("myjob")\nprint(page.title())                                # 같은 창을 제어\npage.fill("input[name=q]", "playwright\\n")\n```\n\n세션 종료\n```python\nfrom web_session import close_session\nclose_session("myjob")\n```\n\n────────────────────────────────────\n5. 요구사항 대응표\n────────────────────────────────────\n1) 다른 대화 세션 제어  \n   → `browser_type.connect(ws)` 로 동일 브라우저 제어\n\n2) 세션 ID  \n   → `~/.web_sessions/<id>/meta.json` 파일 존재 여부로 식별\n\n3) Chrome 디버깅 포트 X  \n   → 내부적으로 launch_server 가 랜덤 포트를 열고, WS 주소만 파일에 저장.  \n      사용자는 함수 3개면 끝.\n\n4) 작업 중단 후 재개  \n   → `user_data_dir` 프로필 유지. 프로세스가 죽어도 다시 `open_session()` 호출 시 같은 프로필로 재시작.\n\n────────────────────────────────────\n6. 보안 & 안정성\n────────────────────────────────────\n• 로컬 전용: meta.json, user_data_dir 디렉터리 권한 0700 로 생성(기본).  \n• 인증 토큰: 필요하면 meta.json 에 `"secret": <uuid>` 저장 → `connect_session()` 호출 시 WS 뒤에 `?token=…` 붙여주면 Playwright 에서 검증 가능.  \n• 충돌 방지: `pid` 체크 + `SIGTERM`→`SIGKILL` 2-단계 종료.  \n• 다중 접근 동시성: Playwright 자체가 한 브라우저에 여러 클라이언트 명령을 순차 처리하므로 큰 문제 없지만, 미세 충돌 방지용으로 `filelock` 정도 추가 가능.\n\n────────────────────────────────────\n7. 기존 BrowserManager 와 통합\n────────────────────────────────────\nBrowserManager 내부에서 실제 `set_instance()` 대신 위 API 를 호출하도록 래핑만 하면 된다.\n\n```python\n# BrowserManager 수정 예\ndef web_connect(self, project="default"):\n    browser, ctx, page = open_session(project)\n    self.set_instance(page, project)\n    return page\n\ndef web_disconnect(self, project="default"):\n    close_session(project)\n    self.remove_instance(project)\n```\n\n────────────────────────────────────\n8. 한-줄 요약\n────────────────────────────────────\n“브라우저를 서버 모드로 띄우고, 워크스페이스(WS endpoint)만 파일에 기록 → 다른 파이썬 프로세스는 그 파일을 읽어 `connect()` 하면 끝”  \nPlaywright 가 이미 준비해 둔 기능이라, 추가 라이브러리 없이 요구사항을 모두 충족할 수 있습니다.', 'reasoning_effort': 'high', 'usage': {'prompt_tokens': 866, 'completion_tokens': 4488, 'total_tokens': 5354, 'reasoning_tokens': 0}}