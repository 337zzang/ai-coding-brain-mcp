────────────────────────────────────────────────────────
1.  호환성 분석
────────────────────────────────────────────────────────
• 기존 호출 패턴
  - `h.parse() / h.safe_replace(text_mode=True)` 와 같은 함수가 이미 공개-API로 쓰이고 있음.
  - `search.find_function / find_class` 는 “정규식 기반” 결과(파일·라인·텍스트)를 이용하므로 프런트엔드, VSCode-익스텐션, CI-봇 등이 그대로 문자열을 보여 준다는 가정이 강함.

• Breaking changes 후보
  1. 텍스트 폴백 제거  
     → 기존에 `safe_replace(..., text_mode=True)` 로 “급한 패치”를 하던 스크립트 즉시 파손.
  2. `find_function / find_class` 결과 포맷이 변경될 가능성  
     (AST 노드를 내보내거나 indent 보존된 ‘code’ 필드를 추가하는 경우).

• 완화 방안
  - Deprecation 단계: v2.x 에서는 `text_mode=True` 를 기본값으로 남겨 두되, 실행 시 `DeprecationWarning` 과 교체 가이드를 로그로 출력. v3.x 에서 완전 제거.
  - `find_*` 의 반환 타입 유지(파일·라인·definition)는 그대로 두고, 필요하면 `node` 를 `extra` 필드로 추가.
  - `UnifiedASTParser` 내부에 “regex-search 어댑터”를 만들어 기존 구현을 호출할 수 있도록 한 뒤 점진적으로 교체.

• 점진적 마이그레이션 실현 가능성
  - 기능별 플래그(예: `h.set_feature("use_unified_parser", True)`) 로 단계적 전환 가능.
  - CI 에 `--legacy-mode` 를 추가해 구버전 소비자가 있는 레포를 검증.
  - 3-단계 릴리스 노트
    1) 2.9  : 신규 기능 + Deprecation 경고
    2) 3.0  : 기본값 AST, `text_mode` 는 opt-in
    3) 4.0+ : 완전 제거

────────────────────────────────────────────────────────
2.  구현 복잡도
────────────────────────────────────────────────────────
• UnifiedASTParser 난이도
  - “AST → CST 매핑” 자체가 쉬운 편이 아님.  
    libCST 노드는 line/col 보존이 잘 되지만, CPython AST 와 1:1 대응이 아니므로
    • 노드 식별자 유지(예: `ast.AST` 객체 id 저장)  
    • 변경 후 원문 갱신(whitespace, 코멘트, type-comment)  
    면에서 Glue 코드가 필요.
  - 파일 캐싱, LRU 관리, mtime 체크까지 넣으면 실제 코드량이 `300~400` 라인.

• ast + libcst 병용 복잡성
  - 동일 파일을 두 번 파싱 ⇒ 성능·메모리 증가(해당 파일당 2× 파싱 트리).
  - 타입 힌트: `ast.AST` 와 `cst.CSTNode` 는 호환 안 됨 → MyPy 기준으로 `@overload` 필요.

• 캐싱 메커니즘 메모리 영향
  - libCST 트리는 일반 AST 대비 약 2-3배 메모리.  
    10k 라인 기준 ≒ 3~4 MB/파일.  
    max_size=100 이면 300 MB 가능 → 서버/CLI 모두 부담.  
  - 현실적 max_size=20~50, 또는 “파일 크기 총합” 기반 캐시 에이징이 필요.

────────────────────────────────────────────────────────
3.  실제 효과 검증
────────────────────────────────────────────────────────
• 품질 향상
  - 주석/문자열 오탐 제거, 들여쓰기/주석 보존 → “코드 깨짐” 리스크 감소(가장 큰 이득).
  - `safe_replace` 실패 시 “유사 노드 추천” 기능은 실제 디버깅 시간을 줄일 확률이 높음.

• 성능 향상 주장
  - 동일 기능이라면 regex > AST 가 속도 이점; AST 캐시는 “두 번째 호출부터 빠르다”라는 의미.
  - 대규모 리포(수천 파일)에서 “첫 호출” 체감은 오히려 느려질 가능성이 높음.
  - 병렬 탐색(concurrent.futures) 로 전체 wall-time 을 줄일 수 있지만, CPU Util 100% → CI 병렬 작업 충돌 리스크.

• regex 대비 AST trade-off
  장점: 정확성, refactor-safe, false-positive 감소  
  단점: 초기 의존성(libbct), 속도, 구현 복잡도,  버전 차이(3.8+만 지원할 수도).

────────────────────────────────────────────────────────
4.  위험 요소
────────────────────────────────────────────────────────
• 부작용
  - 코멘트/형식 보존 로직이 실패하면 “파일 전체 re-write” 나 인코딩 깨짐.
  - `libcst` 가 3.12 미지원 상태일 경우 빌드 실패.

• 엣지 케이스
  - type-comment (`# type: ignore`) 나 `match/case`(Py3.10+) 구문.
  - 문법 오류 파일(`malformed.py`) 은 parse 실패 → 기존 regex 는 그냥 통과했음.

• 대규모 코드베이스
  - 수천 파일 병렬 파싱 시 Memory blow-up.  
  - AST 캐시가 프로세스 전역이라면 다중 쓰레드 동시 접근 race.

────────────────────────────────────────────────────────
5.  대안 및 우선순위 조정
────────────────────────────────────────────────────────
• 접근 방법 단순화
  1. “AST-only 검색” 을 `find_function_exact` 같은 별도 API 로 먼저 제공 → 기존 regex 버전 유지.  
  2. `safe_replace_ast()` 라는 신규 함수로 시작하고, 충분한 채택 후 기존 이름 교체.

• 단계별 우선순위
  1단계: 캐싱 없는 UnifiedASTParser β 버전 + 신규 API (2주)  
  2단계: 기존 API 백엔드 전환(옵트-인 플래그) + 회귀 테스트 (2주)  
  3단계: 캐싱·병렬화·텍스트 폴백 제거 (1주)  

• 기존 코드 재사용
  - 현재 `code.parse()` 의 ASTCollector 는 유지하고, UnifiedASTParser 내부에서 그대로 호출 → 로직 중복 최소화.
  - `search.search_files`·`search.search_code` 는 건드리지 않고, 파서 기반 `find_function_ast` 가 준비되면 내부적으로 둘 중 빠른 쪽 반환(Heuristic).

• 다른 라이브러리 고려
  - tree-sitter-python(빠르고 메모리 효율)  
    단점: Windows prebuilt, PyPI wheel 이슈.
  - parso(used by Jedi) → 이미 성숙, incremental parsing 지원.

────────────────────────────────────────────────────────
💡 결론 (호환성·실용성 관점)
────────────────────────────────────────────────────────
• 제안안은 코드 품질과 안정성을 크게 높일 수 있지만 “텍스트 모드 제거” 와 libCST 도입이 즉각적인 Breaking change 로 이어질 가능성이 높다.  
• 현실적인 로드맵은  
  (1) 신규 AST API 를 먼저 노출 → 실제 프로젝트에서 충분한 실사용 데이터를 얻고  
  (2) Deprecated 로그로 이용자에게 1~2개 minor 버전의 유예 기간을 준 뒤  
  (3) 완전 전환하는 “두 단계 마이그레이션” 이 가장 안전하다.  
• 성능 주장(캐시·병렬) 은 실측이 필요하며, 초기에는 오히려 느려질 것이라는 점을 문서화해야 한다.