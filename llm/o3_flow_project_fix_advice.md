# o3 조언: flow_project 문제 해결

## 질문 일시
2025-07-19 09:36:52

## 문제 설명
프로젝트 전환시 워크플로우가 자동으로 로드되지 않는 문제

## o3 조언
{'success': True, 'answer': '➊ helpers.flow_project에 “진짜” 구현을 물려주기  \n───────────────────────────────────────────────  \n가장 간단하고 코드 변화가 적은 방법은, 실제 REPL 세션이 올라올 때 json_repl_session 안에서 helper 함수를 덮어쓰는 것입니다.\n\npython/json_repl_session.py\n\n```python\n# (기존 코드 일부 생략)\n\nclass JsonReplSession:\n    def __init__(self, *args, **kwargs):\n        ...\n        # ‼️ 단 두 줄 추가 – 더미 함수 ↔ 실제 구현 바인딩\n        import ai_helpers_v2 as helpers\n        helpers.flow_project = self._flow_project   # API 유지\n        helpers.fp           = self._flow_project   # 기존 별칭도 유지\n```\n\n• 이렇게 하면 helpers.flow_project(…) 를 호출하는 모든 곳이 자동으로 self._flow_project 를 사용하게 됩니다.  \n• ai_helpers_v2 코드를 건드리지 않아도 되므로 역-호환성에 영향을 주지 않습니다.\n\n만약 json_repl_session을 수정하기 어렵다면, ai_helpers_v2 에 “지능형 프록시”를 넣어도 됩니다.\n\npython/ai_helpers_v2/__init__.py\n\n```python\ndef _resolve_flow_impl():\n    """가능한 실제 구현을 찾아서 리턴. 못 찾으면 None."""\n    import importlib\n    candidates = (\n        ("json_repl_session", "_flow_project"),      # REPL 안\n        ("flow_project_wrapper", "flow_project_with_workflow"),\n    )\n    for mod, attr in candidates:\n        try:\n            fn = getattr(importlib.import_module(mod), attr)\n            if callable(fn):\n                return fn\n        except (ImportError, AttributeError):\n            pass\n\ndef fp(project_name, *a, **kw):\n    print(f"[fp] Switched to project: {project_name}")\n    return f"Switched to project: {project_name}"\n\ndef flow_project(project_name, desktop=True):\n    impl = _resolve_flow_impl()\n    if impl:\n        return impl(project_name, desktop=desktop)\n    # fallback 더미\n    return fp(project_name)\n```\n\n➋ 프로젝트별 워크플로우 상태를 독립적으로 유지하기  \n───────────────────────────────────────────────  \njson_repl_session 내에서 WorkflowManager 인스턴스를 프로젝트별로 캐싱하면 가장 단순합니다.\n\n```python\nclass JsonReplSession:\n    def __init__(...):\n        ...\n        self._wm_cache = {}      # {project_path: WorkflowManager}\n\n    def _flow_project(self, project_name, desktop=True):\n        proj_dir = self._resolve_project_path(project_name, desktop)\n        if proj_dir not in self._wm_cache:\n            # 최초 진입 – 디렉터리 준비, 기본 워크플로우 복사 등\n            self._wm_cache[proj_dir] = WorkflowManager(project_dir=proj_dir)\n        self.workflow_manager = self._wm_cache[proj_dir]\n        self.current_project  = project_name\n        return self.workflow_manager          # helpers.flow_project 가 돌려주는 객체\n```\n\n장점  \n• 프로젝트를 다시 열면 이전 상태-메모리가 그대로 복원됩니다.  \n• 동일 세션 안에서 여러 프로젝트를 자유롭게 왕복 가능.  \n\n➌ 기존 코드 최소 수정으로 문제 해결 요약  \n───────────────────────────────────────────────  \n1. json_repl_session 측에서 helpers.flow_project(=fp) 를 self._flow_project 로 덮어쓴다.  \n2. _flow_project 안에 캐시 딕셔너리를 넣어 프로젝트별 WorkflowManager 를 분리한다.  \n3. 다른 코드는 그대로 사용 가능 → REPL, 기존 스크립트, 노트북 모두 호환.  \n\n➍ “get_execution_history not implemented” 오류의 근본 원인  \n───────────────────────────────────────────────  \nhelpers.flow_project 가 아직도 더미(fp)를 반환 → 더미는 문자열 or 아무것도 구현하지 않음 →  \n다음 단계에서 (예: some_obj.get_execution_history()) 를 호출하려고 하면  \n• 문자열은 그런 메서드가 없으므로 AttributeError → 프레임워크에서 “not implemented” 라는 완충 메시지로 치환.  \n\n⇒ helpers.flow_project 가 제대로 된 WorkflowManager 인스턴스를 반환하도록만 고치면 자연스럽게 사라집니다. (WorkflowManager 쪽에 get_execution_history 가 이미 구현되어 있다고 가정)  \n\n정리  \n• “연결”은 2~3줄의 런타임 monkey-patch 혹은 ai_helpers_v2 의 지능형 프록시로 충분.  \n• 워크플로우 상태는 세션-내 딕셔너리(cache) 로 분리 관리.  \n• 인터페이스(helpers.flow_project) 변경 없음 → 완전 백워드 호환.  \n• 오류 메시지는 연결 불일치에 따른 부수 현상. 연결만 맞추면 해결.', 'reasoning_effort': 'high', 'thinking_time': '66.27초', 'usage': {'prompt_tokens': 571, 'completion_tokens': 3691, 'total_tokens': 4262, 'reasoning_tokens': 0, 'input_cost': '$0.001142', 'output_cost': '$0.029528', 'total_cost': '$0.030670'}, 'timestamp': '2025-07-19T09:36:39.788237'}
