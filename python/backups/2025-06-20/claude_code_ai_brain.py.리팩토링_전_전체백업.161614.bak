#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
🧠 AI Coding Brain - 통합 버전 v7.0 (캐시 구조 개선)
==========================================

주요 특징:
- cache 키 없이 플랫한 구조
- 5개의 개별 JSON 파일로 분리 저장
- 더 빠른 로드/저장 및 부분 업데이트 지원

작성일: 2025-06-18
"""

import os
import json
import datetime as dt
from pathlib import Path
from typing import Dict, Any, Optional, List, Union
from collections import defaultdict
import copy


# ===========================================
# 통합 컨텍스트 관리자
# ===========================================

class UnifiedContextManager:
    """통합 컨텍스트 관리자 - 싱글톤 패턴"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.context = None
            self.project_path = None
            self.project_name = None
            self.memory_root = None
            self.base_path = None
            self.memory_path = None
            self.cache_dir = None
            self.initialized = True
    
    def initialize(self, project_path: str, project_name: str = None, memory_root: str = None,
                   existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """프로젝트 컨텍스트 초기화"""
        self.project_path = project_path
        
        # project_name이 None이면 경로에서 자동 추출
        if project_name is None:
            project_name = os.path.basename(os.path.abspath(project_path))
            print(f"✅ 프로젝트 이름 자동 추출: {project_name}")
        
        self.project_name = project_name
        self.base_path = project_path
        
        # 메모리 루트 설정
        if memory_root:
            self.memory_root = memory_root
        else:
            self.memory_root = str(Path.home() / "Desktop" / "memory")
        
        # 메모리 경로 설정
        self.memory_path = os.path.join(self.memory_root, self.project_name)
        self.cache_dir = os.path.join(self.memory_path, '.cache')
        os.makedirs(self.cache_dir, exist_ok=True)
        
        # 기존 context가 있으면 사용
        if existing_context:
            self.context = existing_context
            self._normalize_context_structure()
            print(f"✅ 기존 컨텍스트 사용: {project_name}")
        else:
            # 캐시된 컨텍스트 로드 시도
            cached_context = self._try_load_cached_context()
            if cached_context:
                self.context = cached_context
                print(f"✅ 캐시된 컨텍스트 로드: {project_name}")
            else:
                self.context = self._create_new_context()
                print(f"✅ 새 컨텍스트 생성: {project_name}")
        
        # 구조 정규화
        self._normalize_context_structure()
        return self.context
    
    def _get_cache_file_paths(self) -> Dict[str, str]:
        """각 캐시 파일 경로 반환"""
        cache_dir = os.path.join(self.memory_root, self.project_name, '.cache')
        os.makedirs(cache_dir, exist_ok=True)
        
        return {
            'core': os.path.join(cache_dir, 'cache_core.json'),
            'analyzed_files': os.path.join(cache_dir, 'cache_analyzed_files.json'),
            'work_tracking': os.path.join(cache_dir, 'cache_work_tracking.json'),
            'tasks': os.path.join(cache_dir, 'cache_tasks.json'),
            'plan': os.path.join(cache_dir, 'cache_plan.json')
        }
    
    def _create_new_context(self) -> Dict[str, Any]:
        """새로운 컨텍스트 생성 (개선된 구조)"""
        return {
            # 기본 정보 (cache_core.json)
            'project_name': self.project_name,
            'project_id': self.project_name,
            'project_path': self.project_path,
            'memory_root': self.memory_root,
            'created_at': dt.datetime.now().isoformat(),
            'updated_at': dt.datetime.now().isoformat(),
            'version': '7.0',
            'current_focus': '',
            'current_task': None,
            
            # 분석 파일 정보 (cache_analyzed_files.json)
            'analyzed_files': {},
            
            # 작업 추적 (cache_work_tracking.json)
            'work_tracking': {
                'file_access': {},
                'file_edits': {},
                'function_edits': {},
                'session_start': dt.datetime.now().isoformat(),
                'total_operations': 0,
                'task_tracking': {},
                'current_task_work': {
                    'task_id': None,
                    'start_time': None,
                    'files_accessed': [],
                    'functions_edited': [],
                    'operations': []
                }
            },
            
            # 작업 관리 (cache_tasks.json)
            'tasks': {'next': [], 'done': []},
            
            # 계획 관리 (cache_plan.json)
            'plan': None,
            'plan_history': [],
            
            # 기타 데이터
            'coding_experiences': [],
            'progress': {
                'completed_tasks': 0,
                'total_tasks': 0,
                'percentage': 0.0
            },
            'phase_reports': {},
            'error_log': [],
            'file_access_history': [],
            'metadata': {
                'version': '7.0',
                'last_saved': dt.datetime.now().isoformat()
            }
        }
    
    def _try_load_cached_context(self) -> Optional[Dict[str, Any]]:
        """캐시된 컨텍스트 로드 (여러 파일에서)"""
        if not self.memory_root or not self.project_name:
            return None
        
        cache_paths = self._get_cache_file_paths()
        
        # 핵심 파일이 있는지 확인
        if not os.path.exists(cache_paths['core']):
            return None
        
        try:
            # 1. 핵심 정보 로드
            with open(cache_paths['core'], 'r', encoding='utf-8') as f:
                context = json.load(f)
            
            # 2. 각 부분별 파일 로드
            # analyzed_files
            if os.path.exists(cache_paths['analyzed_files']):
                with open(cache_paths['analyzed_files'], 'r', encoding='utf-8') as f:
                    context['analyzed_files'] = json.load(f)
            else:
                context['analyzed_files'] = {}
            
            # work_tracking
            if os.path.exists(cache_paths['work_tracking']):
                with open(cache_paths['work_tracking'], 'r', encoding='utf-8') as f:
                    context['work_tracking'] = json.load(f)
            else:
                context['work_tracking'] = self._create_new_context()['work_tracking']
            
            # tasks
            if os.path.exists(cache_paths['tasks']):
                with open(cache_paths['tasks'], 'r', encoding='utf-8') as f:
                    context['tasks'] = json.load(f)
            else:
                context['tasks'] = {'next': [], 'done': []}
            
            # plan
            if os.path.exists(cache_paths['plan']):
                with open(cache_paths['plan'], 'r', encoding='utf-8') as f:
                    plan_data = json.load(f)
                    context['plan'] = plan_data.get('plan')
                    context['plan_history'] = plan_data.get('plan_history', [])
            else:
                context['plan'] = None
                context['plan_history'] = []
            
            # 경로 업데이트
            context['project_path'] = self.project_path
            context['memory_root'] = self.memory_root
            
            return context
            
        except Exception as e:
            print(f"⚠️ 캐시 로드 실패: {e}")
            return None
    
    def _normalize_context_structure(self):
        """컨텍스트 구조 정규화"""
        if not self.context:
            return
        
        # 필수 키 확인
        self.context.setdefault('analyzed_files', {})
        self.context.setdefault('tasks', {'next': [], 'done': []})
        self.context.setdefault('coding_experiences', [])
        self.context.setdefault('phase_reports', {})
        self.context.setdefault('error_log', [])
        self.context.setdefault('plan', None)
        self.context.setdefault('plan_history', [])
        self.context.setdefault('file_access_history', [])
        self.context.setdefault('progress', {
            'completed_tasks': 0,
            'total_tasks': 0,
            'percentage': 0.0
        })
        
        # work_tracking 구조
        work_tracking = self.context.setdefault('work_tracking', {})
        work_tracking.setdefault('file_access', {})
        work_tracking.setdefault('file_edits', {})
        work_tracking.setdefault('function_edits', {})
        work_tracking.setdefault('session_start', dt.datetime.now().isoformat())
        work_tracking.setdefault('total_operations', 0)
        work_tracking.setdefault('task_tracking', {})
        work_tracking.setdefault('current_task_work', {
            'task_id': None,
            'start_time': None,
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        })
        
        # 경로 정보 업데이트
        self.context['project_path'] = self.project_path
        self.context['memory_root'] = self.memory_root

    def save(self) -> bool:
        """컨텍스트 저장 (여러 파일로 분리)"""
        # 버전 패턴 프로젝트는 저장하지 않음
        import re
        if self.project_name:
            version_patterns = [
                r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
                r'^app-\d+\.\d+\.\d+$',
                r'^project-\d+\.\d+\.\d+$',
                r'^v\d+\.\d+\.\d+$'
            ]
            for pattern in version_patterns:
                if re.match(pattern, self.project_name):
                    print(f"⚠️ 버전 패턴 프로젝트 '{self.project_name}'는 저장하지 않습니다.")
                    return False
        
        if not self.context:
            print("⚠️ 저장할 컨텍스트가 없습니다")
            return False
        
        try:
            # 업데이트 시간 갱신
            self.context['updated_at'] = dt.datetime.now().isoformat()
            self.context.setdefault('metadata', {})['last_saved'] = dt.datetime.now().isoformat()
            
            # 진행률 업데이트
            self._update_progress()
            
            cache_paths = self._get_cache_file_paths()
            
            # 1. 핵심 정보 저장 (cache_core.json)
            core_data = {
                'project_name': self.context.get('project_name'),
                'project_id': self.context.get('project_id'),
                'project_path': self.context.get('project_path'),
                'memory_root': self.context.get('memory_root'),
                'created_at': self.context.get('created_at'),
                'updated_at': self.context.get('updated_at'),
                'version': self.context.get('version', '7.0'),
                'current_focus': self.context.get('current_focus', ''),
                'current_task': self.context.get('current_task'),
                'coding_experiences': self.context.get('coding_experiences', []),
                'progress': self.context.get('progress', {}),
                'phase_reports': self.context.get('phase_reports', {}),
                'error_log': self.context.get('error_log', []),
                'file_access_history': self.context.get('file_access_history', []),
                'metadata': self.context.get('metadata', {})
            }
            
            with open(cache_paths['core'], 'w', encoding='utf-8') as f:
                json.dump(core_data, f, indent=2, ensure_ascii=False)
            
            # 2. 분석 파일 저장 (cache_analyzed_files.json)
            with open(cache_paths['analyzed_files'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('analyzed_files', {}), f, indent=2, ensure_ascii=False)
            
            # 3. 작업 추적 저장 (cache_work_tracking.json)
            with open(cache_paths['work_tracking'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('work_tracking', {}), f, indent=2, ensure_ascii=False)
            
            # 4. 작업 저장 (cache_tasks.json)
            with open(cache_paths['tasks'], 'w', encoding='utf-8') as f:
                json.dump(self.context.get('tasks', {}), f, indent=2, ensure_ascii=False)
            
            # 5. 계획 저장 (cache_plan.json)
            plan_data = {
                'plan': self.context.get('plan'),
                'plan_history': self.context.get('plan_history', [])
            }
            with open(cache_paths['plan'], 'w', encoding='utf-8') as f:
                json.dump(plan_data, f, indent=2, ensure_ascii=False)
            
            print(f"✅ 캐시 저장 완료:")
            for name, path in cache_paths.items():
                if os.path.exists(path):
                    size = os.path.getsize(path)
                    print(f"   • {name}: {size:,} bytes")
            
            # 프로젝트 문서 업데이트 시도
            try:
                self._update_project_docs()
            except Exception as e:
                print(f"⚠️ 프로젝트 문서 업데이트 실패: {e}")
            
            return True
            
        except Exception as e:
            print(f"❌ 캐시 저장 실패: {e}")
            return False

    def _update_progress(self):
        """진행률 업데이트"""
        if not self.context:
            return
        
        # 현재 계획에서 작업 수 계산
        plan = self.context.get('plan')
        if plan:
            total_tasks = 0
            completed_tasks = 0
            
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    total_tasks += 1
                    if task.get('status') == 'completed':
                        completed_tasks += 1
            
            progress = self.context.setdefault('progress', {})
            progress['total_tasks'] = total_tasks
            progress['completed_tasks'] = completed_tasks
            progress['percentage'] = (completed_tasks / max(1, total_tasks)) * 100
    
    def _update_project_docs(self):
        """프로젝트 문서 업데이트"""
        if not self.context or not self.project_path:
            return
        
        if not self.memory_root or not self.project_name:
            print("⚠️ memory_root 또는 project_name이 설정되지 않았습니다.")
            return
            
        docs = {
            'project_vision.md': self._generate_project_vision(),
            'coding_flow.md': self._generate_coding_flow(),
            'file_directory.md': self._generate_file_directory(),
            'progress.md': self._generate_progress()
        }
        
        for filename, content in docs.items():
            doc_path = os.path.join(str(self.memory_root), str(self.project_name), filename)
            try:
                os.makedirs(os.path.dirname(doc_path), exist_ok=True)
                with open(doc_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            except Exception as e:
                print(f"⚠️ {filename} 업데이트 실패: {e}")
    
    def _generate_project_vision(self) -> str:
        """project_vision.md 생성"""
        if not self.context:
            return "# AI Coding Brain MCP - 프로젝트 비전\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        analyzed = len(self.context.get('analyzed_files', {}))
        progress = self.context.get('progress', {})
        
        content = f"""# AI Coding Brain MCP - 프로젝트 비전

## 🎯 프로젝트 개요
MCP (Model Context Protocol) 기반 통합 개발 지원 시스템

## 📊 현재 상태
- 분석된 파일: {analyzed}개
- 완료된 작업: {progress.get('completed_tasks', 0)}개
- 전체 작업: {progress.get('total_tasks', 0)}개
- 진행률: {progress.get('percentage', 0):.1f}%

## 🔧 핵심 기능
1. **자동 컨텍스트 관리**: 작업 상태 자동 저장/복원
2. **통합 검색 시스템**: 코드, 메모리, 캐시 통합 검색
3. **Phase 기반 작업 관리**: 체계적인 프로젝트 진행
4. **SimplEdit 안전 수정**: 백업과 함께하는 안전한 코드 수정
"""
        
        plan = self.context.get('plan')
        if plan:
            content += f"""
## 📋 현재 계획: {plan.get('name', 'N/A')}
{plan.get('description', '')}

### Phase 구조:
"""
            for phase_id, phase in plan.get('phases', {}).items():
                task_count = len(phase.get('tasks', []))
                completed = sum(1 for t in phase.get('tasks', []) if t.get('status') == 'completed')
                content += f"- **{phase.get('name', phase_id)}** ({completed}/{task_count} 완료)\n"
        
        content += f"""
최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_coding_flow(self) -> str:
        """coding_flow.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 현재 작업\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        focus = self.context.get('current_focus', '')
        current_task_id = self.context.get('current_task')
        current_task = None
        current_phase = None
        
        plan = self.context.get('plan')
        if current_task_id and plan:
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        current_task = task
                        current_phase = phase
                        break
                if current_task:
                    break
        
        content = f"""# AI Coding Brain - 현재 작업

## 🎯 현재 Focus
{focus or '설정되지 않음'}

## 🔄 진행 중인 작업
"""
        
        if current_task:
            content += f"""### [{current_task['id']}] {current_task['title']}
- 상태: {current_task.get('status', 'pending')}
- Phase: {current_phase.get('name', 'N/A')}
- 설명: {current_task.get('description', 'N/A')}
"""
        else:
            content += "현재 진행 중인 작업이 없습니다.\n"
        
        content += f"""
최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    def _generate_file_directory(self) -> str:
        """file_directory.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 프로젝트 구조\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        analyzed = self.context.get('analyzed_files', {})
        
        content = f"""# AI Coding Brain - 프로젝트 구조

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}

## 📁 Python 모듈 목록

| 경로 | 설명 | 수정일 |
|------|------|--------|
"""
        
        def to_relative_path(path):
            path = path.replace('\\', '/')
            if self.project_path:
                project_path = self.project_path.replace('\\', '/')
                if path.startswith(project_path):
                    return path[len(project_path):].lstrip('/')
            return path
        
        sorted_files = sorted(analyzed.items(), key=lambda x: to_relative_path(x[0]))
        
        for file_path, info in sorted_files:
            display_path = to_relative_path(file_path)
            func_count = len(info.get('functions', []))
            class_count = len(info.get('classes', []))
            mod_time = info.get('last_modified', 'Unknown')
            
            description = ""
            if func_count > 0 or class_count > 0:
                parts = []
                if func_count > 0:
                    parts.append(f"{func_count}개 함수")
                if class_count > 0:
                    parts.append(f"{class_count}개 클래스")
                description = ", ".join(parts)
            else:
                description = "-"
                
            content += f"| {display_path} | {description} | {mod_time} |\n"
        
        return content
    
    def _generate_progress(self) -> str:
        """progress.md 생성"""
        if not self.context:
            return "# AI Coding Brain - 진행 상황\n\n프로젝트가 초기화되지 않았습니다.\n"
        
        progress = self.context.get('progress', {})
        done_count = progress.get('completed_tasks', 0)
        total_count = progress.get('total_tasks', 0)
        percentage = progress.get('percentage', 0)
        
        content = f"""# AI Coding Brain - 진행 상황

## 📊 전체 진행률
- 완료: {done_count}개
- 전체: {total_count}개
- 진행률: {percentage:.1f}%

### 진행률 차트
[{'█' * int(percentage / 5)}{'░' * (20 - int(percentage / 5))}] {percentage:.1f}%

최종 업데이트: {dt.datetime.now().strftime('%Y-%m-%d %H:%M')}
"""
        
        return content
    
    # ===========================================
    # 캐시 관리 메서드 (개선됨)
    # ===========================================
    
    def update_cache(self, key: str, value: Any) -> None:
        """캐시 업데이트 (cache 키 없이 직접 접근)"""
        if not self.context:
            return
        
        keys = key.split('.')
        current = self.context
        
        for k in keys[:-1]:
            current = current.setdefault(k, {})
        
        current[keys[-1]] = value
    
    def get_value(self, key: str, default: Any = None) -> Any:
        """값 조회 (cache 키 없이 직접 접근)"""
        if not self.context:
            return default
        
        keys = key.split('.')
        current = self.context
        
        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return default
        
        return current
    
    # ===========================================
    # 작업 추적 메서드들
    # ===========================================
    
    def track_file_access(self, file_path: str, operation: str = 'read'):
        """파일 접근 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.setdefault('work_tracking', {})
        file_access = work_tracking.setdefault('file_access', {})
        
        work_tracking['file_access_count'] = work_tracking.get('file_access_count', 0) + 1
        
        # 상대 경로로 정규화
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        if file_path not in file_access:
            file_access[file_path] = {
                'read_count': 0,
                'write_count': 0,
                'first_access': dt.datetime.now().isoformat(),
                'last_read': None,
                'last_write': None
            }
        
        if operation == 'read':
            file_access[file_path]['read_count'] += 1
            file_access[file_path]['last_read'] = dt.datetime.now().isoformat()
        elif operation in ['write', 'modify']:
            file_access[file_path]['write_count'] += 1
            file_access[file_path]['last_write'] = dt.datetime.now().isoformat()
            
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # 현재 task 작업에도 추가
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            files_accessed = current_task_work.setdefault('files_accessed', [])
            if file_path not in files_accessed:
                files_accessed.append(file_path)
            
            self.track_task_operation('file_access', {
                'file': file_path,
                'operation': operation
            })
    
    def track_function_edit(self, file_path: str, function_name: str, 
                          class_name: Optional[str] = None):
        """함수 수정 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.setdefault('work_tracking', {})
        function_edits = work_tracking.setdefault('function_edits', {})
        
        func_key = f"{class_name}.{function_name}" if class_name else function_name
        
        if self.project_path and file_path.startswith(self.project_path):
            file_path = os.path.relpath(file_path, self.project_path)
        
        if func_key not in function_edits:
            function_edits[func_key] = {
                'file_path': file_path,
                'edit_count': 0,
                'first_edit': dt.datetime.now().isoformat(),
                'last_edit': None
            }
        
        function_edits[func_key]['edit_count'] += 1
        function_edits[func_key]['last_edit'] = dt.datetime.now().isoformat()
        
        work_tracking['total_operations'] = work_tracking.get('total_operations', 0) + 1
        
        # 현재 task 작업에도 추가
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            functions_edited = current_task_work.setdefault('functions_edited', [])
            if func_key not in functions_edited:
                functions_edited.append(func_key)
            
            self.track_task_operation('function_edit', {
                'file': file_path,
                'function': func_key,
                'class': class_name
            })
    
    def get_work_tracking_summary(self) -> str:
        """작업 추적 요약"""
        if not self.context:
            return "컨텍스트가 초기화되지 않았습니다."
        
        work_tracking = self.context.get('work_tracking', {})
        
        session_start = work_tracking.get('session_start')
        if session_start:
            start_time = dt.datetime.fromisoformat(session_start)
            duration = dt.datetime.now() - start_time
            duration_str = str(duration).split('.')[0]
        else:
            duration_str = "Unknown"
        
        file_access = work_tracking.get('file_access', {})
        file_edits = work_tracking.get('file_edits', {})
        function_edits = work_tracking.get('function_edits', {})
        total_ops = work_tracking.get('total_operations', 0)
        task_tracking = work_tracking.get('task_tracking', {})
        
        summary = f"""
📊 작업 추적 요약
================
• 프로젝트: {self.project_name}
• 작업 경로: {self.project_path}
• 캐시 경로: {self.memory_root}
• 세션 시간: {duration_str}
• 전체 작업: {total_ops}회
• 접근한 파일: {len(file_access)}개
• 수정한 파일: {len(file_edits)}개
• 수정한 함수: {len(function_edits)}개
• 수행한 Task: {len(task_tracking)}개
"""
        
        if file_access:
            summary += "\n🔥 가장 많이 접근한 파일:\n"
            sorted_files = sorted(file_access.items(), 
                                key=lambda x: x[1].get('read_count', 0) + x[1].get('write_count', 0), 
                                reverse=True)[:5]
            for file_path, info in sorted_files:
                total_access = info.get('read_count', 0) + info.get('write_count', 0)
                summary += f"  • {file_path}: {total_access}회\n"
        
        return summary
    
    def start_task_tracking(self, task_id: str):
        """Task 작업 추적 시작"""
        if not self.context:
            return
        
        work_tracking = self.context.get('work_tracking', {})
        
        # 이전 task 작업 저장
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id'):
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_work['task_id']] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
        
        # 새 task 작업 시작
        work_tracking['current_task_work'] = {
            'task_id': task_id,
            'start_time': dt.datetime.now().isoformat(),
            'files_accessed': [],
            'functions_edited': [],
            'operations': []
        }
    
    def track_task_operation(self, operation_type: str, details: dict = None):
        """현재 Task의 작업 추적"""
        if not self.context:
            return
        
        work_tracking = self.context.get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        
        if current_task_work and current_task_work.get('task_id'):
            operation = {
                'type': operation_type,
                'timestamp': dt.datetime.now().isoformat(),
                'details': details or {}
            }
            current_task_work.setdefault('operations', []).append(operation)


# ===========================================
# 글로벌 컨텍스트 관리자
# ===========================================
_context_manager = UnifiedContextManager()


# ===========================================
# Public API
# ===========================================

def initialize_context(project_path: str, project_name: str = None, memory_root: str = None,
                      existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """프로젝트 컨텍스트 초기화"""
    return _context_manager.initialize(project_path, project_name, memory_root, existing_context)

def save_context() -> bool:
    """컨텍스트 저장"""
    return _context_manager.save()

def update_cache(key: str, value: Any):
    """캐시 업데이트 (cache 키 없이 직접 접근)"""
    _context_manager.update_cache(key, value)

def get_value(key: str, default: Any = None) -> Any:
    """값 조회 (cache 키 없이 직접 접근)"""
    return _context_manager.get_value(key, default)

def track_file_access(file_path: str, operation: str = 'read'):
    """파일 접근 추적"""
    _context_manager.track_file_access(file_path, operation)

def track_function_edit(file_path: str, function_name: str, class_name: Optional[str] = None):
    """함수 수정 추적"""
    _context_manager.track_function_edit(file_path, function_name, class_name)

def get_work_tracking_summary() -> str:
    """작업 추적 요약"""
    return _context_manager.get_work_tracking_summary()

def start_task_tracking(task_id: str):
    """Task 작업 추적 시작"""
    _context_manager.start_task_tracking(task_id)

def track_task_operation(operation_type: str, details: dict = None):
    """현재 Task의 작업 추적"""
    _context_manager.track_task_operation(operation_type, details)

def get_current_context() -> Optional[Dict[str, Any]]:
    """현재 context 반환 (auto_tracking_wrapper용)"""
    return _context_manager.context if _context_manager else None


# ===========================================
# Claude Desktop 설정 및 명령어 처리
# ===========================================

def get_paths_from_config() -> dict:
    """Claude Desktop 설정에서 경로 가져오기"""
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    paths = {
        'project_path': Path.home() / "Desktop",
        'memory_root': Path.home() / "Desktop" / "memory"
    }
    
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            mcp_servers = config.get('mcpServers', {})
            for server_name, server_config in mcp_servers.items():
                if 'ai-coding-brain' in server_name.lower():
                    env = server_config.get('env', {})
                    if 'PROJECT_ROOT' in env:
                        paths['project_path'] = Path(env['PROJECT_ROOT'])
                    if 'MEMORY_BANK_ROOT' in env:
                        paths['memory_root'] = Path(env['MEMORY_BANK_ROOT'])
                    break
        except Exception as e:
            print(f"⚠️ 설정 로드 실패: {e}")
    
    return paths




def cmd_plan(plan_name: str = None, description: str = None) -> Dict[str, Any]:
    """/plan 명령어 - 새로운 계획 생성"""
    if not _context_manager.context:
        print("❌ 프로젝트가 선택되지 않았습니다. 먼저 /flow [프로젝트명]을 실행하세요.")
        return None
    
    if not plan_name:
        # 현재 계획 표시
        plan = _context_manager.context.get('plan')
        if plan:
            print(f"\n📋 현재 계획: {plan.get('name', 'N/A')}")
            print(f"   설명: {plan.get('description', 'N/A')}")
            print(f"   생성: {plan.get('created_at', 'N/A')}")
            print(f"   Phase 수: {len(plan.get('phases', {}))}개")
            
            for phase_id, phase in plan.get('phases', {}).items():
                tasks = phase.get('tasks', [])
                completed = sum(1 for t in tasks if t.get('status') == 'completed')
                print(f"\n   📌 {phase.get('name', phase_id)} ({completed}/{len(tasks)} 완료)")
        else:
            print("\n⚠️ 현재 설정된 계획이 없습니다.")
            print("사용법: /plan [계획명] [설명]")
        return None
    
    # 새 계획 생성
    timestamp = dt.datetime.now().isoformat()
    
    new_plan = {
        'name': plan_name,
        'description': description or f"{_context_manager.project_name} 작업 계획",
        'created_at': timestamp,
        'updated_at': timestamp,
        'phases': {},
        'current_phase': None,
        'current_task': None
    }
    
    # 기본 Phase 3개 생성
    default_phases = [
        ('phase-1', 'Phase 1: 분석 및 설계', '현재 상태 분석과 개선 방향 설계'),
        ('phase-2', 'Phase 2: 핵심 구현', '주요 기능 구현 및 개선'),
        ('phase-3', 'Phase 3: 테스트 및 문서화', '테스트 작성 및 문서 정리')
    ]
    
    for phase_id, phase_name, phase_desc in default_phases:
        new_plan['phases'][phase_id] = {
            'id': phase_id,
            'name': phase_name,
            'description': phase_desc,
            'status': 'pending',
            'tasks': []
        }
    
    new_plan['current_phase'] = 'phase-1'
    
    _context_manager.context['plan'] = new_plan
    _context_manager.context['plan_history'].append({
        'name': plan_name,
        'created_at': timestamp,
        'id': f"plan-{len(_context_manager.context['plan_history']) + 1}"
    })
    
    save_context()
    print(f"\n✅ 새 계획 '{plan_name}' 생성 완료!")
    print(f"   설명: {new_plan['description']}")
    print(f"\n   3개의 기본 Phase가 생성되었습니다:")
    for phase_id, phase_name, _ in default_phases:
        print(f"   - {phase_name}")
    print(f"\n   /task add {default_phases[0][0]} [작업명]으로 작업을 추가하세요.")
    
    return new_plan


def cmd_task(action: str, *args) -> None:
    """/task 명령어 - 작업 관리"""
    if not _context_manager.context:
        print("❌ 프로젝트가 선택되지 않았습니다.")
        return
        
    plan = _context_manager.context.get('plan')
    if not plan:
        print("❌ 계획이 없습니다. 먼저 /plan [계획명]을 실행하세요.")
        return
    
    if action == 'add':
        if len(args) < 2:
            print("사용법: /task add [phase-id] [작업명] [설명(선택)]")
            return
            
        phase_id = args[0]
        task_title = args[1]
        task_desc = ' '.join(args[2:]) if len(args) > 2 else ""
        
        phase = plan['phases'].get(phase_id)
        if not phase:
            print(f"❌ Phase '{phase_id}'를 찾을 수 없습니다.")
            print(f"   사용 가능한 Phase: {', '.join(plan['phases'].keys())}")
            return
        
        phase_num = phase_id.split('-')[1]
        task_num = len(phase['tasks']) + 1
        new_task = {
            'id': f'{phase_num}-{task_num}',
            'title': task_title,
            'description': task_desc,
            'status': 'pending',
            'created_at': dt.datetime.now().isoformat(),
            'subtasks': []
        }
        
        phase['tasks'].append(new_task)
        plan['updated_at'] = dt.datetime.now().isoformat()
        
        _context_manager._update_progress()
        save_context()
        
        print(f"✅ Task 추가됨: [{new_task['id']}] {task_title}")
        print(f"   Phase: {phase['name']}")
        
    elif action == 'edit':
        if len(args) < 3:
            print("사용법: /task edit [task-id] status|title|desc [새값]")
            print("   status 값: pending, in_progress, completed, blocked")
            return
            
        task_id = args[0]
        field = args[1]
        new_value = ' '.join(args[2:])
        
        task_found = False
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if field == 'status':
                        if new_value not in ['pending', 'in_progress', 'completed', 'blocked']:
                            print(f"❌ 잘못된 상태값: {new_value}")
                            print("   가능한 값: pending, in_progress, completed, blocked")
                            return
                        task['status'] = new_value
                        
                        if new_value == 'in_progress':
                            _context_manager.context['current_task'] = task_id
                            plan['current_phase'] = phase_id
                            phase['status'] = 'in_progress'
                        elif new_value == 'completed' and _context_manager.context.get('current_task') == task_id:
                            _context_manager.context['current_task'] = None
                            
                    elif field == 'title':
                        task['title'] = new_value
                    elif field in ['desc', 'description']:
                        task['description'] = new_value
                    else:
                        print(f"❌ 알 수 없는 필드: {field}")
                        return
                    
                    task['updated_at'] = dt.datetime.now().isoformat()
                    task_found = True
                    plan['updated_at'] = dt.datetime.now().isoformat()
                    
                    _context_manager._update_progress()
                    save_context()
                    
                    print(f"✅ Task [{task_id}] {field} 수정됨")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"❌ Task '{task_id}'를 찾을 수 없습니다.")
    
    elif action == 'done':
        if len(args) < 1:
            print("사용법: /task done [task-id]")
            return
            
        task_id = args[0]
        
        task_found = False
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == task_id:
                    if task['status'] == 'completed':
                        print(f"⚠️ Task [{task_id}]는 이미 완료되었습니다.")
                        return
                    
                    # 작업을 완료로 표시
                    task['status'] = 'completed'
                    task['completed_at'] = dt.datetime.now().isoformat()
                    
                    # 현재 작업이었다면 current_task 해제
                    if _context_manager.context.get('current_task') == task_id:
                        _context_manager.context['current_task'] = None
                        
                        # 작업 추적 정보 저장
                        work_tracking = _context_manager.context.get('work_tracking', {})
                        current_task_work = work_tracking.get('current_task_work', {})
                        if current_task_work and current_task_work.get('task_id') == task_id:
                            task_tracking = work_tracking.setdefault('task_tracking', {})
                            task_tracking[task_id] = {
                                'start_time': current_task_work.get('start_time'),
                                'end_time': dt.datetime.now().isoformat(),
                                'files_accessed': current_task_work.get('files_accessed', []),
                                'functions_edited': current_task_work.get('functions_edited', []),
                                'operations': current_task_work.get('operations', [])
                            }
                            
                            # 작업 요약 저장
                            task['work_summary'] = {
                                'files_accessed': len(current_task_work.get('files_accessed', [])),
                                'functions_edited': len(current_task_work.get('functions_edited', [])),
                                'operations': len(current_task_work.get('operations', []))
                            }
                    
                    task['updated_at'] = dt.datetime.now().isoformat()
                    task_found = True
                    plan['updated_at'] = dt.datetime.now().isoformat()
                    
                    _context_manager._update_progress()
                    save_context()
                    
                    print(f"✅ Task [{task_id}] {task['title']} 완료!")
                    
                    # 작업 요약 표시
                    if task.get('work_summary'):
                        summary = task['work_summary']
                        print(f"   📊 작업 요약:")
                        print(f"      • 접근 파일: {summary['files_accessed']}개")
                        print(f"      • 수정 함수: {summary['functions_edited']}개")
                        print(f"      • 총 작업: {summary['operations']}회")
                    break
            if task_found:
                break
        
        if not task_found:
            print(f"❌ Task '{task_id}'를 찾을 수 없습니다.")
    
    elif action == 'list':
        print(f"\n📋 계획: {plan['name']}")
        print(f"진행률: {_context_manager.context['progress']['percentage']:.1f}%")
        print("\n전체 Task 목록:")
        
        for phase_id, phase in plan['phases'].items():
            tasks = phase['tasks']
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            
            status_emoji = "✅" if phase.get('status') == 'completed' else "🔄" if phase.get('status') == 'in_progress' else "⏳"
            print(f"\n{status_emoji} {phase['name']} ({completed}/{len(tasks)} 완료)")
            
            if phase.get('description'):
                print(f"   📝 {phase['description']}")
            
            for task in tasks:
                task_emoji = "✅" if task['status'] == 'completed' else "🔄" if task['status'] == 'in_progress' else "🚫" if task['status'] == 'blocked' else "⏳"
                current = " 👈 현재" if _context_manager.context.get('current_task') == task['id'] else ""
                print(f"   {task_emoji} [{task['id']}] {task['title']}{current}")
                if task.get('description'):
                    print(f"      📝 {task['description']}")
    
    else:
        print(f"❌ 알 수 없는 액션: {action}")
        print("사용 가능한 액션: add, edit, done, list")


def cmd_next() -> None:
    """/next 명령어 - 다음 작업으로 진행"""
    if not _context_manager.context:
        print("❌ 프로젝트가 선택되지 않았습니다.")
        return
        
    plan = _context_manager.context.get('plan')
    if not plan:
        print("❌ 계획이 없습니다. 먼저 /plan [계획명]을 실행하세요.")
        return
    
    # 현재 작업이 있으면 완료로 표시
    current_task_id = _context_manager.context.get('current_task')
    if current_task_id:
        work_tracking = _context_manager.context.get('work_tracking', {})
        current_task_work = work_tracking.get('current_task_work', {})
        if current_task_work and current_task_work.get('task_id') == current_task_id:
            task_tracking = work_tracking.setdefault('task_tracking', {})
            task_tracking[current_task_id] = {
                'start_time': current_task_work.get('start_time'),
                'end_time': dt.datetime.now().isoformat(),
                'files_accessed': current_task_work.get('files_accessed', []),
                'functions_edited': current_task_work.get('functions_edited', []),
                'operations': current_task_work.get('operations', [])
            }
            
            print(f"\n📊 Task [{current_task_id}] 작업 요약:")
            print(f"   • 접근 파일: {len(current_task_work.get('files_accessed', []))}개")
            print(f"   • 수정 함수: {len(current_task_work.get('functions_edited', []))}개")
            print(f"   • 총 작업: {len(current_task_work.get('operations', []))}회")
        
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['id'] == current_task_id:
                    if task['status'] != 'completed':
                        task['status'] = 'completed'
                        task['completed_at'] = dt.datetime.now().isoformat()
                        if current_task_work:
                            task['work_summary'] = {
                                'files_accessed': len(current_task_work.get('files_accessed', [])),
                                'functions_edited': len(current_task_work.get('functions_edited', [])),
                                'operations': len(current_task_work.get('operations', []))
                            }
                        print(f"✅ Task [{task['id']}] {task['title']} 완료!")
                    break
    
    # 다음 pending 작업 찾기
    next_task = None
    next_phase = None
    
    if plan.get('current_phase'):
        phase = plan['phases'].get(plan['current_phase'])
        if phase:
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
    
    if not next_task:
        for phase_id, phase in plan['phases'].items():
            if phase.get('status') == 'completed':
                continue
                
            for task in phase['tasks']:
                if task['status'] == 'pending':
                    next_task = task
                    next_phase = phase
                    break
            
            if next_task:
                break
    
    if next_task:
        _context_manager.context['current_task'] = next_task['id']
        plan['current_phase'] = next_phase['id']
        next_task['status'] = 'in_progress'
        next_task['started_at'] = dt.datetime.now().isoformat()
        next_phase['status'] = 'in_progress'
        
        _context_manager.start_task_tracking(next_task['id'])
        
        plan['updated_at'] = dt.datetime.now().isoformat()
        
        _context_manager._update_progress()
        save_context()
        
        print(f"\n🎯 다음 작업: [{next_task['id']}] {next_task['title']}")
        if next_task.get('description'):
            print(f"   📝 설명: {next_task['description']}")
        print(f"   📍 Phase: {next_phase['name']}")
        
        if next_task.get('subtasks'):
            print(f"\n   📌 서브태스크:")
            for subtask in next_task['subtasks']:
                print(f"      - {subtask}")
        
        print(f"\n💡 작업 추적이 시작되었습니다. 모든 파일 접근과 함수 수정이 자동으로 기록됩니다.")
    else:
        all_done = True
        blocked_tasks = []
        
        for phase_id, phase in plan['phases'].items():
            for task in phase['tasks']:
                if task['status'] == 'blocked':
                    blocked_tasks.append(task)
                elif task['status'] != 'completed':
                    all_done = False
        
        if all_done and not blocked_tasks:
            print("\n🎉 모든 작업이 완료되었습니다!")
            
            for phase in plan['phases'].values():
                phase['status'] = 'completed'
            
            _context_manager._update_progress()
            save_context()
        else:
            if blocked_tasks:
                print(f"\n⚠️ 진행 가능한 작업이 없습니다. {len(blocked_tasks)}개의 작업이 blocked 상태입니다:")
                for task in blocked_tasks[:3]:
                    print(f"   - [{task['id']}] {task['title']}")
            else:
                print("\n⚠️ 진행 가능한 작업이 없습니다.")


def process_command(command: str, existing_context: Dict[str, Any] = None) -> Any:
    """명령어 처리"""
    parts = command.strip().split()
    if not parts:
        return None
    
    cmd = parts[0].lower()
    args = parts[1:] if len(parts) > 1 else []
    
    if cmd == '/flow':
        project_name = args[0] if args else None
        return cmd_flow(project_name, existing_context)
    
    elif cmd == '/plan':
        if len(args) == 0:
            return cmd_plan()
        elif len(args) == 1:
            return cmd_plan(args[0])
        else:
            return cmd_plan(args[0], ' '.join(args[1:]))
    
    elif cmd == '/task':
        if not args:
            print("사용법: /task add|edit|list [인자...]")
            return None
        return cmd_task(args[0], *args[1:])
    
    elif cmd == '/next':
        return cmd_next()
    
    elif cmd == '/save':
        return save_context()
    
    else:
        print(f"알 수 없는 명령어: {cmd}")
        print("사용 가능한 명령어: /flow, /plan, /task, /next, /save")
        return None


def cmd_flow(project_name: str = None, existing_context: Dict[str, Any] = None) -> Dict[str, Any]:
    """/flow 명령어 - 프로젝트 전환"""
    
    paths = get_paths_from_config()
    memory_root = str(paths['memory_root'])
    
    if not project_name:
        # 프로젝트 목록 표시
        print("\n📋 등록된 프로젝트 목록:")
        print("="*60)
        
        project_count = 0
        if os.path.exists(memory_root):
            import re
            version_patterns = [
                r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
                r'^app-\d+\.\d+\.\d+$',
                r'^project-\d+\.\d+\.\d+$',
                r'^v\d+\.\d+\.\d+$'
            ]
            
            for item in sorted(os.listdir(memory_root)):
                is_version_pattern = any(re.match(pattern, item) for pattern in version_patterns)
                if is_version_pattern:
                    continue
                    
                item_path = os.path.join(memory_root, item)
                if os.path.isdir(item_path) and item != 'common':
                    # 새로운 캐시 파일 위치 확인
                    cache_file = os.path.join(item_path, '.cache', 'cache_core.json')
                    if os.path.exists(cache_file):
                        try:
                            with open(cache_file, 'r', encoding='utf-8') as f:
                                cache_data = json.load(f)
                                actual_path = cache_data.get('project_path', 'Unknown')
                                last_accessed = cache_data.get('updated_at', 'Unknown')
                                
                                current_marker = " 🔥" if _context_manager.project_name == item else ""
                                print(f"  • {item}{current_marker}")
                                print(f"    📁 경로: {actual_path}")
                                print(f"    🕐 최근 접근: {last_accessed[:10] if last_accessed != 'Unknown' else 'Unknown'}")
                                project_count += 1
                        except:
                            print(f"  • {item} (캐시 읽기 실패)")
        
        if project_count == 0:
            print("  등록된 프로젝트가 없습니다.")
        else:
            print(f"\n총 {project_count}개의 프로젝트")
            
        print("\n사용법: /flow [프로젝트명]")
        return {
            'success': True,
            'message': '프로젝트 목록 표시 완료',
            'project_count': project_count,
            'action': 'list_projects'
        }
    
    # 이전 컨텍스트 저장
    if _context_manager.context and _context_manager.project_name:
        import re
        version_patterns = [
            r'^[a-zA-Z]+-\d+\.\d+\.\d+$',
            r'^app-\d+\.\d+\.\d+$',
            r'^project-\d+\.\d+\.\d+$',
            r'^v\d+\.\d+\.\d+$'
        ]
        is_version_pattern = any(re.match(pattern, _context_manager.project_name) for pattern in version_patterns)
        
        if not is_version_pattern:
            prev_cache_dir = os.path.join(memory_root, _context_manager.project_name, '.cache')
            if os.path.exists(prev_cache_dir):
                save_context()
    
    # Memory 폴더에서 프로젝트 캐시 확인
    project_cache_dir = os.path.join(memory_root, project_name, '.cache')
    cache_file = os.path.join(project_cache_dir, 'cache_core.json')
    
    project_path = None
    location = 'unknown'
    
    if os.path.exists(cache_file):
        # 캐시에서 프로젝트 경로 읽기
        try:
            with open(cache_file, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                cached_path = cache_data.get('project_path')
                
                if cached_path and os.path.exists(cached_path):
                    project_path = Path(cached_path)
                    location = 'cached'
                    print(f"\n✅ Memory에서 프로젝트 찾음: {project_name}")
        except Exception as e:
            print(f"\n⚠️ 캐시 읽기 실패: {e}")
    
    # 캐시에 없거나 경로가 유효하지 않으면 새로 찾기
    if not project_path:
        desktop_path = paths['project_path'] / project_name
        if desktop_path.exists():
            project_path = desktop_path
            location = 'desktop'
        else:
            if os.path.basename(os.getcwd()) == project_name:
                project_path = Path(os.getcwd())
                location = 'current'
            else:
                if existing_context:
                    project_path = Path(os.getcwd())
                    location = 'current'
                else:
                    print(f"\n❌ 프로젝트 '{project_name}'를 찾을 수 없습니다")
                    return {
                        'success': False,
                        'message': f'프로젝트 경로를 찾을 수 없습니다: {project_name}',
                        'project_name': project_name
                    }
    
    # 작업 디렉토리 변경
    directory_changed = False
    directory_error = None
    
    try:
        # 디렉토리 존재 확인
        if not os.path.exists(str(project_path)):
            print(f"⚠️ 프로젝트 디렉토리가 존재하지 않습니다: {project_path}")
            # 디렉토리 생성 시도
            try:
                os.makedirs(str(project_path), exist_ok=True)
                print(f"✅ 프로젝트 디렉토리 생성됨: {project_path}")
            except Exception as create_err:
                print(f"❌ 디렉토리 생성 실패: {create_err}")
                directory_error = str(create_err)
        
        # 디렉토리 변경 시도
        os.chdir(str(project_path))
        current_dir = os.getcwd()
        if os.path.samefile(current_dir, str(project_path)):
            print(f"📂 작업 디렉토리 변경 성공: {project_path}")
            directory_changed = True
        else:
            print(f"⚠️ 작업 디렉토리 변경 실패: 현재 {current_dir}")
            directory_error = "디렉토리 변경 후 경로 불일치"
    except Exception as e:
        print(f"\n⚠️ 디렉토리 변경 실패: {e}")
        directory_error = str(e)
        # 실패해도 계속 진행 (캐시는 사용 가능)
    
    # 컨텍스트 초기화
    if 'context' in globals():
        globals()['context'].clear()
    
    context = initialize_context(
        project_path=str(project_path),
        project_name=project_name,
        memory_root=memory_root,
        existing_context=existing_context
    )
    
    print(f"\n✅ 프로젝트 '{project_name}'로 전환 완료!")
    print(f"📁 작업 경로: {project_path} ({location})")
    if directory_error:
        print(f"⚠️ 디렉토리 관련 경고: {directory_error}")
    print(f"💾 캐시 경로: {memory_root}/{project_name}/.cache/")
    print(f"📊 캐시 버전: {context.get('version', 'unknown')}")
    print(f"📈 분석된 파일: {len(context.get('analyzed_files', {}))}개")
    
    tasks = context.get('tasks', {})
    if isinstance(tasks, dict):
        next_count = len(tasks.get('next', []))
        done_count = len(tasks.get('done', []))
        print(f"📋 남은 작업: {next_count}개")
        print(f"✅ 완료된 작업: {done_count}개")

    
    # 현재 계획 정보 표시
    plan = context.get('plan')
    if plan:
        print(f"\n📅 현재 계획: {plan.get('name', 'N/A')}")
        current_task_id = context.get('current_task')
        if current_task_id:
            # 현재 작업 찾기
            for phase_id, phase in plan.get('phases', {}).items():
                for task in phase.get('tasks', []):
                    if task.get('id') == current_task_id:
                        print(f"🎯 현재 작업: [{task['id']}] {task.get('title', 'N/A')}")
                        print(f"   상태: {task.get('status', 'pending')}")
                        break
        
        # Phase별 진행 상황
        print("\n📊 Phase별 진행 상황:")
        for phase_id, phase in plan.get('phases', {}).items():
            tasks = phase.get('tasks', [])
            completed = sum(1 for t in tasks if t.get('status') == 'completed')
            in_progress = sum(1 for t in tasks if t.get('status') == 'in_progress')
            
            status_icon = "✅" if phase.get('status') == 'completed' else "🔄" if in_progress > 0 else "📝"
            print(f"   {status_icon} {phase.get('name', phase_id)}: {completed}/{len(tasks)} 완료")

    # 글로벌 context 업데이트
    if 'context' in globals():
        globals()['context'].update(context)
    else:
        globals()['context'] = context
    
    pending_count = len(tasks.get('next', [])) if isinstance(tasks, dict) else 0
    completed_count = len(tasks.get('done', [])) if isinstance(tasks, dict) else 0
    
    return {
        'success': True,
        'message': f'프로젝트 \'{project_name}\' 전환 완료',
        'project_name': project_name,
        'project_root': str(project_path),
        'directory_changed': directory_changed,
        'directory_error': directory_error,
        'cache_info': {
            'analyzed_files': len(context.get('analyzed_files', {})),
            'pending_tasks': pending_count,
            'completed_tasks': completed_count,
            'cache_version': context.get('version', 'unknown')
        }
    }
# 명령어 처리 함수들 (cmd_plan, cmd_task, cmd_next)은 동일하므로 생략...


# ===========================================
# 메인 진입점
# ===========================================

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        command = ' '.join(sys.argv[1:])
        # process_command(command)
    else:
        print("AI Coding Brain v7.0 (캐시 구조 개선)")
        print("사용법: python claude_code_ai_brain.py [명령어]")
        print("명령어: /flow, /plan, /task, /next, /save")
