{
  "answer": "[1] 근본적인 구조적 문제점  \n──────────────────────────  \n① 두 개의 FlowManager 계층  \n   • flow_manager.py : “새로운” 구현.  \n   • flow_manager_unified.py : 레거시-호환용 래퍼.  \n   ⇒ 동일한 기능을 두 군데에서 제공하면서 인터페이스가 100 % 일치하지 않는다. (ex. get_project / set_project 미구현)  \n   ⇒ 어느 쪽을 인스턴스화 하느냐에 따라 동작이 달라지고 버그가 발생한다.  \n\n② 인터페이스-호출 불일치  \n   • workflow_commands.py 는 FlowManager.get_project / set_project 를 호출하지만 실제 FlowManager에는 없음 → 런타임 오류.  \n   • ContextIntegration 을 초기화만 하고 실제로 쓰지 않음. record_* 함수도 create_flow 에서만 호출.  \n\n③ 레거시 어댑터의 과도한 유지  \n   • FlowManagerUnified 가 내부적으로 FlowManager 를 감싸지만 다시 LegacyFlowAdapter 를 상속한다.  \n   • “handle_command” 같은 완전히 폐기된 API 가 남아 있어 혼선을 만든다.  \n\n④ 싱글톤 전역 변수 남용  \n   • workflow_commands.py 에서 전역 FlowManager, CommandRouter 를 보장 → 테스트 격리 불가, 멀티-프로세스/멀티-스레드 환경 문제.  \n\n⑤ 책임 분리가 모호  \n   • 데이터 저장(CachedFlowService) / 도메인 로직(FlowManager) / 프레젠테이션(CommandRouter, wf) / 컨텍스트 로깅(record_*) 이 뒤섞여 있다.  \n\n[2] 어떤 FlowManager 를 사용할 것인가?  \n──────────────────────────  \n• “새로운 구조”인 flow_manager.py 를 단일 출처(source of truth)로 삼고, FlowManagerUnified 는 더 이상 사용하지 않는 것이 바람직하다.  \n• 레거시 코드가 남아 있다면, adapter 로서 FlowManagerUnified 를 “한 단계 더 얇게” 유지하되 private 패키지로 이동하거나 DeprecationWarning 을 강제 출력하여 완전 제거를 준비한다.\n\n[3] 불필요하거나 제거 대상 파일  \n──────────────────────────  \n• flow_manager_unified.py  \n• legacy_flow_adapter.py (flow_manager_unified 가 사라지면 당연히 필요 없음)  \n• get_flow_manager_unified(), FlowManagerWithContext 별칭  \n• handle_command 관련 코드  \n• context_manager / repository 인자 처리 로직 (사용되지 않음)  \n\n[4] 개선 방안  \n──────────────────────────  \n1) 단일 Manager 확정  \n   - FlowManager 클래스에 레거시에서 요구했던 메서드(get_project, set_project, …)를 구현하거나,  \n     해당 메서드를 호출하는 코드(workflow_commands.py)에서 필요한 로직을 직접 수행하도록 수정.  \n   - FlowManagerUnified 는 thin-shim 으로 남기되, 내부에서 “self._manager = FlowManager()” 만 수행하고  \n     나머지는 DeprecationWarning 후 pass-through 하도록 축소 → 점진적 제거.\n\n2) 인터페이스 정합성 보강  \n   - CommandRouter 가 필요로 하는 모든 메서드를 FlowManager 가 명시적으로 제공.  \n   - 타입 힌트 & mypy / pyright 같은 정적 검사 도입 → 컴파일 시점에 누락된 메서드 탐지.\n\n3) Context 통합 제대로 구현  \n   - Flow / Plan / Task 의 CRUD 지점에 record_flow_action, record_plan_action, record_task_action 호출.  \n   - ContextIntegration 객체를 주입(inject) 받아 실제 로그 파일이나 모니터링 시스템에 쓰도록 DI 패턴 적용.\n\n4) 전역 싱글톤 제거  \n   - wf() 를 외부 인터페이스로 유지하되 내부적으로는 “@lru_cache” 나 앱 컨테이너(예: FastAPI Depends)로 FlowManager 를 주입.  \n   - 테스트 시 의존성 주입으로 Mock 서비스 교체 가능.\n\n5) 디렉터리/패키지 리레이아웃  \n   • domain      : 엔티티, 데이터 클래스, id 생성 헬퍼  \n   • service     : 저장소(CachedFlowService), ContextIntegration  \n   • application : FlowManager (유스케이스/도메인 서비스)  \n   • interface   : CommandRouter, CLI(wf)  \n   ⇒ 계층 간 의존성 단방향 유지.\n\n6) Deprecated API 관리  \n   - __init__.py 에서 “from .flow_manager_unified import FlowManagerUnified as FlowManagerWithContext” 같은 별칭 제거.  \n   - 문서 / CHANGELOG 에 명시적 파기 일정을 안내.\n\n7) 테스트 및 CI  \n   - 단일 FlowManager 기준 유닛테스트 재작성.  \n   - GitHub Actions or similar 로 PR 시 타입체크 + 테스트 자동 수행.  \n\n결과  \n• 클래스 중복 제거 → 유지보수 단순화  \n• 명확한 인터페이스 → 런타임 오류 감소  \n• Context 로깅 완전 구현 → 기능 요구사항 충족  \n• 전역 상태 축소 → 테스트/멀티스레드 안정성 향상",
  "reasoning_effort": "high",
  "usage": {
    "prompt_tokens": 1374,
    "completion_tokens": 1973,
    "total_tokens": 3347,
    "reasoning_tokens": 0
  }
}