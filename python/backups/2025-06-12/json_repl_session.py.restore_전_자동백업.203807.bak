#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os

# ì „ì—­ ê²½ë¡œ ì„¤ì • (ìµœìš°ì„  ì‹¤í–‰)
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if current_dir not in sys.path:
    sys.path.insert(0, current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

import json
import io
import traceback
import time
import threading
import datetime as dt
import importlib
import importlib.util
from contextlib import redirect_stdout, redirect_stderr



# ============================================================================
# ğŸš€ ê°œì„ ëœ Bootstrap ì‹œìŠ¤í…œ v2.0 - ê²½ë¡œ í•˜ë“œì½”ë”© ì œê±°
# ============================================================================

import platform
import subprocess
from pathlib import Path
from typing import Dict, Optional, Tuple, List

def find_project_in_memory_bank(project_name=None) -> Optional[Tuple[Path, Path]]:
    """ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ì°¾ëŠ” í•¨ìˆ˜
    
    Returns:
        Tuple[Path, Path]: (ë©”ëª¨ë¦¬ ê²½ë¡œ, ì½”ë“œ ê²½ë¡œ) ë˜ëŠ” None
    """
    # ë©”ëª¨ë¦¬ ë±…í¬ ë£¨íŠ¸ ê°€ì ¸ì˜¤ê¸°
    memory_bank_root = None
    
    # Claude Desktop ì„¤ì •ì—ì„œ í™•ì¸
    config_path = os.path.expanduser("~/AppData/Roaming/Claude/claude_desktop_config.json")
    if os.path.exists(config_path):
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            memory_bank_root = config['mcpServers']['ai-coding-brain-mcp']['env']['MEMORY_BANK_ROOT']
        except:
            pass
    
    # í™˜ê²½ ë³€ìˆ˜ì—ì„œ í™•ì¸
    if not memory_bank_root:
        memory_bank_root = os.environ.get('MEMORY_BANK_ROOT')
    
    # ê¸°ë³¸ê°’
    if not memory_bank_root:
        memory_bank_root = os.path.expanduser("~/Desktop/memory")
    
    if not os.path.exists(memory_bank_root):
        return None
    
    # í”„ë¡œì íŠ¸ ì´ë¦„ ê²°ì •
    if not project_name:
        # í˜„ì¬ íŒŒì¼ ê²½ë¡œì—ì„œ í”„ë¡œì íŠ¸ ì´ë¦„ ì¶”ì¸¡
        current_path = Path(__file__).resolve()
        for parent in current_path.parents:
            if 'ai-coding-brain' in parent.name.lower():
                project_name = parent.name
                break
    
    project_name = project_name or "ai-coding-brain-mcp"
    
    # ë©”ëª¨ë¦¬ í”„ë¡œì íŠ¸ ê²½ë¡œ
    memory_path = Path(memory_bank_root) / project_name
    
    if memory_path.exists():
        # project.json í™•ì¸
        project_json = memory_path / "project.json"
        code_path = None
        
        if project_json.exists():
            try:
                with open(project_json, 'r', encoding='utf-8') as f:
                    project_config = json.load(f)
                code_path_str = project_config.get('code_path')
                if code_path_str:
                    code_path = Path(code_path_str)
            except:
                pass
        
        # ì½”ë“œ ê²½ë¡œê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ì°¾ê¸°
        if not code_path:
            code_path = find_project_root()
        
        debug_log(f"  âœ… ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ ë°œê²¬: {project_name}")
        debug_log(f"     ë©”ëª¨ë¦¬ ê²½ë¡œ: {memory_path}")
        debug_log(f"     ì½”ë“œ ê²½ë¡œ: {code_path}")
        
        return memory_path, code_path
    
    return None

def find_project_root() -> Optional[Path]:
    """í”„ë¡œì íŠ¸ ë£¨íŠ¸ë¥¼ ë™ì ìœ¼ë¡œ ì°¾ëŠ” í•¨ìˆ˜"""
    strategies = []
    
    # ì „ëµ 1: í™˜ê²½ ë³€ìˆ˜ í™•ì¸
    if os.environ.get('AI_BRAIN_ROOT'):
        strategies.append(('ENV_VAR', Path(os.environ['AI_BRAIN_ROOT'])))
    
    # ì „ëµ 2: í˜„ì¬ íŒŒì¼ ê¸°ì¤€ ìƒìœ„ ë””ë ‰í† ë¦¬ íƒìƒ‰
    current_file = Path(__file__).resolve()
    for parent in current_file.parents:
        # í”„ë¡œì íŠ¸ ë§ˆì»¤ íŒŒì¼ë“¤ í™•ì¸
        markers = ['.ai-brain-project', 'project_cache.json', 'roadmap.md', '.git']
        if any((parent / marker).exists() for marker in markers):
            strategies.append(('MARKER_FILE', parent))
            break
    
    # ì „ëµ 3: íŒ¨í‚¤ì§€ êµ¬ì¡° ë¶„ì„
    for parent in current_file.parents:
        # python í´ë”ë‚˜ src í´ë”ê°€ ìˆëŠ”ì§€ í™•ì¸
        if any((parent / folder).is_dir() for folder in ['python', 'src', 'lib']):
            strategies.append(('PACKAGE_STRUCTURE', parent))
            break
    
    # ì „ëµ 4: í”„ë¡œì íŠ¸ ì´ë¦„ ê¸°ë°˜ íƒìƒ‰
    for parent in current_file.parents:
        if 'ai-coding-brain' in parent.name.lower():
            strategies.append(('PROJECT_NAME', parent))
            break
    
    # ì „ëµ 5: í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬ ê¸°ë°˜
    cwd = Path.cwd()
    if any(marker in cwd.name.lower() for marker in ['ai', 'brain', 'coding']):
        strategies.append(('WORKING_DIR', cwd))
    
    # ê°€ì¥ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì „ëµ ì„ íƒ
    debug_log("  ğŸ” í”„ë¡œì íŠ¸ ë£¨íŠ¸ íƒìƒ‰ ì¤‘...")
    for strategy_name, path in strategies:
        if path.exists():
            debug_log(f"    âœ“ {strategy_name}: {path}")
            return path
    
    return None


def setup_python_path(project_root: Path) -> Tuple[bool, str]:
    """Python ê²½ë¡œë¥¼ ì•ˆì „í•˜ê²Œ ì„¤ì •"""
    try:
        paths_to_add = []
        
        # í”„ë¡œì íŠ¸ ë£¨íŠ¸
        paths_to_add.append(project_root)
        
        # ê°€ëŠ¥í•œ ì†ŒìŠ¤ ë””ë ‰í† ë¦¬ë“¤
        for subdir in ['python', 'src', 'lib', 'modules']:
            candidate = project_root / subdir
            if candidate.exists():
                paths_to_add.append(candidate)
        
        added_paths = []
        for path in paths_to_add:
            path_str = str(path.resolve())
            if path_str not in sys.path:
                sys.path.insert(0, path_str)
                added_paths.append(path_str)
        
        if added_paths:
            return True, f"{len(added_paths)}ê°œ ê²½ë¡œ ì¶”ê°€ë¨"
        else:
            return True, "ì´ë¯¸ ëª¨ë“  ê²½ë¡œê°€ ì„¤ì •ë˜ì–´ ìˆìŒ"
            
    except Exception as e:
        return False, f"ê²½ë¡œ ì„¤ì • ì‹¤íŒ¨: {str(e)}"


def detect_execution_context() -> str:
    """ì‹¤í–‰ í™˜ê²½ì„ ìë™ìœ¼ë¡œ ê°ì§€"""
    
    # MCP ì„œë²„ ëª¨ë“œ
    if os.environ.get('MCP_SERVER_MODE'):
        return 'mcp_server'
    
    # Jupyter/IPython
    try:
        get_ipython()
        return 'notebook'
    except NameError:
        pass
    
    # í„°ë¯¸ë„ì—ì„œ ì§ì ‘ ì‹¤í–‰
    if hasattr(sys, 'ps1'):
        return 'interactive'
    
    # ìŠ¤í¬ë¦½íŠ¸ë¡œ ì‹¤í–‰
    if __name__ == '__main__':
        return 'script'
    
    # ëª¨ë“ˆë¡œ ì„í¬íŠ¸
    return 'imported'


def bootstrap_ai_brain_session(config: Optional[Dict] = None) -> Optional[Dict]:
    """
    ê°œì„ ëœ AI ë¸Œë ˆì¸ ì„¸ì…˜ ë¶€íŠ¸ìŠ¤íŠ¸ë©
    
    Args:
        config: ì„ íƒì  êµ¬ì„± ì˜µì…˜
            - force_root: ê°•ì œë¡œ ì‚¬ìš©í•  í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ
            - skip_vibe: Vibe ì‹œìŠ¤í…œ ì´ˆê¸°í™” ê±´ë„ˆë›°ê¸°
            - minimal: ìµœì†Œ ì´ˆê¸°í™” ëª¨ë“œ
            - verbose: ìƒì„¸ ë¡œê·¸ ì¶œë ¥ (ê¸°ë³¸ê°’: True)
    
    Returns:
        ì´ˆê¸°í™”ëœ project_context ë˜ëŠ” ì‹¤íŒ¨ ì‹œ None
    """
    config = config or {}
    verbose = config.get('verbose', True)
    
    if verbose:
        debug_log("ğŸš€ AI Coding Brain ìŠ¤ë§ˆíŠ¸ ë¶€íŠ¸ìŠ¤íŠ¸ë© v2.0")
        debug_log(f"   ì‹¤í–‰ í™˜ê²½: {detect_execution_context()}")
        debug_log(f"   í”Œë«í¼: {platform.system()}")
    
    # === Phase 1: í”„ë¡œì íŠ¸ ë£¨íŠ¸ íƒìƒ‰ ===
    if verbose:
        debug_log("\n[Phase 1/5] ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ íƒìƒ‰")
    
    # ë¨¼ì € ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ ì°¾ê¸°
    memory_project = find_project_in_memory_bank(config.get('project_name'))
    
    if memory_project:
        memory_path, code_path = memory_project
        project_root = code_path
        if verbose:
            debug_log(f"  âœ… ë©”ëª¨ë¦¬ ë±…í¬ì—ì„œ í”„ë¡œì íŠ¸ ë°œê²¬")
            debug_log(f"     ë©”ëª¨ë¦¬: {memory_path}")
            debug_log(f"     ì½”ë“œ: {code_path}")
    elif config.get('force_root'):
        project_root = Path(config['force_root']).resolve()
        if verbose:
            debug_log(f"  âœ… ê°•ì œ ì§€ì •ëœ ë£¨íŠ¸: {project_root}")
    else:
        project_root = find_project_root()
        
    if not project_root or not project_root.exists():
        debug_log("  âŒ í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        debug_log("\nğŸ’¡ í•´ê²° ë°©ë²•:")
        debug_log("  1. ë©”ëª¨ë¦¬ ë±…í¬ì— í”„ë¡œì íŠ¸ ìƒì„±")
        debug_log("  2. í™˜ê²½ë³€ìˆ˜ ì„¤ì •: set AI_BRAIN_ROOT=C:\\your\\project\\path")
        debug_log("  3. í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— .ai-brain-project íŒŒì¼ ìƒì„±")
        
        if config.get('minimal'):
            # ìµœì†Œ ëª¨ë“œì—ì„œëŠ” í˜„ì¬ ë””ë ‰í† ë¦¬ ì‚¬ìš©
            project_root = Path.cwd()
            debug_log(f"\n  âš ï¸ ìµœì†Œ ëª¨ë“œ: í˜„ì¬ ë””ë ‰í† ë¦¬ ì‚¬ìš© â†’ {project_root}")
        else:
            return None
    
    debug_log(f"  âœ… í”„ë¡œì íŠ¸ ë£¨íŠ¸ í™•ì •: {project_root}")
    
    # === Phase 2: Python ê²½ë¡œ ì„¤ì • ===
    if verbose:
        debug_log(f"\n[Phase 2/5] Python ê²½ë¡œ ì„¤ì •")
    
    success, message = setup_python_path(project_root)
    if not success:
        debug_log(f"  âŒ {message}")
        if not config.get('minimal'):
            return None
    elif verbose:
        debug_log(f"  âœ… {message}")
    
    # === Phase 3: Context Manager ì´ˆê¸°í™” ===
    if verbose:
        debug_log(f"\n[Phase 3/6] í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”")
    
    try:
        # Context Manager ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ìš°
        if CONTEXT_MANAGER_AVAILABLE:
            import context_manager
            
            # ë©”ëª¨ë¦¬ ë±…í¬ ì •ë³´ê°€ ìˆìœ¼ë©´ í”„ë¡œì íŠ¸ ì´ë¦„ ì‚¬ìš©
            if memory_project:
                project_name = memory_path.name
            else:
                project_name = project_root.name
                
            project_context = context_manager.initialize_context(
                project_path=str(project_root),
                project_name=project_name
            )
            project_context = context_manager.initialize_work_tracking(project_context)
            repl_globals['project_context'] = project_context
            if verbose:
                debug_log("  âœ… Context Managerë¥¼ í†µí•œ ì´ˆê¸°í™” ì„±ê³µ")
                if memory_project:
                    debug_log(f"     ë©”ëª¨ë¦¬ ë±…í¬ ì‚¬ìš©: {project_name}")
        else:
            # ê¸°ë³¸ êµ¬ì¡° ìƒì„±
            project_context = {
                'project_id': f"ai-brain-{dt.datetime.now().strftime('%Y%m%d%H%M%S')}",
                'project_name': project_root.name,
                'project_path': str(project_root),
                'session_id': f"session-{time.time()}",
                'work_tracking': {
                    'access_count': {},
                    'edit_history': [],
                    'function_edits': {}
                },
                'vibe_system': {
                    'next_tasks': [],
                    'completed_tasks': [],
                    'current_focus': 'ì„¸ì…˜ ì‹œì‘'
                }
            }
            repl_globals['project_context'] = project_context
            if verbose:
                debug_log("  âš ï¸ ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ êµ¬ì¡° ìƒì„±")
        
        # ë¶€íŠ¸ìŠ¤íŠ¸ë© ë©”íƒ€ë°ì´í„° ì¶”ê°€
        project_context['bootstrap_info'] = {
            'version': '2.0',
            'root_path': str(project_root),
            'python_paths': sys.path[:3],
            'timestamp': dt.datetime.now().isoformat(),
            'execution_context': detect_execution_context(),
            'config': config
        }
        
    except Exception as e:
        debug_log(f"  âŒ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        return None
    
    # === Phase 4: Vibe Memory ì´ˆê¸°í™” ===
    if not config.get('skip_vibe'):
        if verbose:
            debug_log(f"\n[Phase 4/6] Vibe Memory ì‹œìŠ¤í…œ ì´ˆê¸°í™”")
        try:
            from vibe_memory_system import VibeMemoryManager
            vibe_manager = VibeMemoryManager(project_context)
            repl_globals['vibe_manager'] = vibe_manager
            if verbose:
                debug_log("  âœ… Vibe Memory ì‹œìŠ¤í…œ í™œì„±í™”")
        except Exception as e:
            if verbose:
                debug_log(f"  âš ï¸ Vibe ì´ˆê¸°í™” ì‹¤íŒ¨ (ê³„ì† ì§„í–‰): {str(e)[:50]}...")
    
    # === Phase 5: Session Manager ì´ˆê¸°í™” (ìˆœì„œ ë³€ê²½) ===
    if verbose:
        debug_log(f"\n[Phase 5/6] Session Manager ì´ˆê¸°í™”")
    
    try:
        # SimpleSessionManager ì´ˆê¸°í™”
        session_manager = SimpleSessionManager(project_context)
        project_context['session_manager'] = session_manager
        
        # ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì—ë„ ë“±ë¡
        if 'repl_globals' in globals():
            repl_globals['session_manager'] = session_manager
            repl_globals['SimpleSessionManager'] = SimpleSessionManager
        
        # ë¶€íŠ¸ìŠ¤íŠ¸ë© ì™„ë£Œ ì„¸ì…˜ ì €ì¥
        bootstrap_session = {
            'type': 'bootstrap',
            'action': 'Bootstrap v2.0 ì´ˆê¸°í™” ì™„ë£Œ',
            'bootstrap_info': project_context.get('bootstrap_info', {}),
            'modules_loaded': list(sys.modules.keys())[:20],
            'status': 'success'
        }
        session_manager.save_session(bootstrap_session)
        
        if verbose:
            debug_log(f"  âœ… Session Manager ì´ˆê¸°í™” ì™„ë£Œ")
            debug_log(f"  - ì„¸ì…˜ ë””ë ‰í† ë¦¬: {session_manager.session_dir}")
            debug_log(f"  - ì´ ì„¸ì…˜ ìˆ˜: {session_manager.metadata.get('total_sessions', 0)}")
            
    except Exception as e:
        if verbose:
            debug_log(f"  âš ï¸ Session Manager ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
    
    # === Phase 6: Helper í•¨ìˆ˜ ë“±ë¡ (ìˆœì„œ ë³€ê²½) ===
    if verbose:
        debug_log(f"\n[Phase 6/6] Helper í•¨ìˆ˜ ë“±ë¡")
    try:
        # ì´ì œ session_managerê°€ í™•ì‹¤íˆ ì¡´ì¬í•˜ë¯€ë¡œ ì„¸ì…˜ ê´€ë ¨ í—¬í¼ë„ ì •ìƒ ë“±ë¡ë¨
        result = register_all_helpers()
        if verbose and result.get('success'):
            debug_log(f"  âœ… Helper í•¨ìˆ˜ {result.get('registered_count', 0)}ê°œ ë“±ë¡")
    except Exception as e:
        if verbose:
            debug_log(f"  âš ï¸ Helper ë“±ë¡ ì‹¤íŒ¨ (ê³„ì† ì§„í–‰): {str(e)[:50]}...")
    
    # === ìµœì¢… ë³´ê³ ì„œ ===
    if verbose:
        debug_log("\n" + "="*60)
        debug_log("ğŸ‰ ë¶€íŠ¸ìŠ¤íŠ¸ë© ì™„ë£Œ!")
        debug_log(f"   í”„ë¡œì íŠ¸: {project_context.get('project_name', 'Unknown')}")
        debug_log(f"   ë£¨íŠ¸ ê²½ë¡œ: {project_root}")
        debug_log(f"   ì„¸ì…˜ ID: {project_context.get('session_id', 'N/A')}")
        debug_log(f"   ì´ˆê¸°í™” ëª¨ë“œ: {'ìµœì†Œ' if config.get('minimal') else 'ì „ì²´'}")
        debug_log("="*60 + "\n")
    
    return project_context


# Smart Print Utils ì—°ë™ (ì„ íƒì )
try:
    from smart_print import smart_print, enhanced_smart_print, sp, esp, compress_content
    SMART_PRINT_AVAILABLE = True
    print("[INIT] Smart Print Utils ì—°ë™ ì„±ê³µ", file=sys.stderr, flush=True)
except ImportError:
    SMART_PRINT_AVAILABLE = False
    def smart_print(content, **kwargs): return str(content)  # fallback
    def enhanced_smart_print(content, **kwargs): return str(content)  # fallback
    def sp(content, **kwargs): return str(content)  # fallback
    def esp(content, **kwargs): return str(content)  # fallback
    def compress_content(content, **kwargs): return str(content)[:15000] + "..." if len(str(content)) > 15000 else str(content)  # fallback
    print("[INIT] Smart Print Utils ì—†ìŒ - fallback ì‚¬ìš©", file=sys.stderr, flush=True)

# Context Manager ì—°ë™ (ì„ íƒì )
try:
    import context_manager
    CONTEXT_MANAGER_AVAILABLE = True
    print("[INIT] Context Manager 2ê³„ì¸µ êµ¬ì¡° ì—°ë™ ì„±ê³µ", file=sys.stderr, flush=True)
except ImportError:
    CONTEXT_MANAGER_AVAILABLE = False
    print("[INIT] Context Manager ì—†ìŒ", file=sys.stderr, flush=True)

# ============================================================================
# SimpleSessionManager - í”„ë¡œì íŠ¸ë³„ ì„¸ì…˜ ê´€ë¦¬ì
# ============================================================================
from datetime import datetime

class SimpleSessionManager:
    """í”„ë¡œì íŠ¸ë³„ ì„¸ì…˜ ê´€ë¦¬ì - ê°„ë‹¨í•˜ê³  ì•ˆì •ì ì¸ êµ¬í˜„"""
    
    def __init__(self, project_context):
        self.project_context = project_context
        self.project_name = project_context.get('project_name', 'ai-coding-brain-mcp')
        self.project_path = project_context.get('project_path', '.')
        
        # ì„¸ì…˜ ì €ì¥ ê²½ë¡œ ì„¤ì •
        from pathlib import Path
        self.session_dir = Path(self.project_path) / '.sessions'
        self.session_dir.mkdir(exist_ok=True)
        
        # ì„¸ì…˜ ë©”íƒ€ë°ì´í„° íŒŒì¼
        self.meta_file = self.session_dir / 'session_meta.json'
        self.load_metadata()
        
        debug_log(f"SimpleSessionManager ì´ˆê¸°í™”: {self.session_dir}")
        
    def load_metadata(self):
        """ì„¸ì…˜ ë©”íƒ€ë°ì´í„° ë¡œë“œ"""
        if self.meta_file.exists():
            with open(self.meta_file, 'r', encoding='utf-8') as f:
                self.metadata = json.load(f)
        else:
            self.metadata = {
                'created': datetime.now().isoformat(),
                'total_sessions': 0,
                'last_session': None
            }
            
    def save_metadata(self):
        """ì„¸ì…˜ ë©”íƒ€ë°ì´í„° ì €ì¥"""
        with open(self.meta_file, 'w', encoding='utf-8') as f:
            json.dump(self.metadata, f, indent=2)
        
    def save_session(self, session_data):
        """ì„¸ì…˜ ë°ì´í„° ì €ì¥"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"session_{timestamp}.json"
        filepath = self.session_dir / filename
        
        # ì„¸ì…˜ ID ì¶”ê°€
        if 'session_id' not in session_data:
            session_data['session_id'] = self.project_context.get('session_id', 'unknown')
        
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
        if 'timestamp' not in session_data:
            session_data['timestamp'] = datetime.now().isoformat()
            
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, indent=2, ensure_ascii=False)
                
            # ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
            self.metadata['total_sessions'] += 1
            self.metadata['last_session'] = filename
            self.save_metadata()
            
            debug_log(f"ì„¸ì…˜ ì €ì¥ ì™„ë£Œ: {filename}")
            return True
        except Exception as e:
            debug_log(f"ì„¸ì…˜ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def get_latest_session(self):
        """ìµœì‹  ì„¸ì…˜ ë¡œë“œ"""
        session_files = list(self.session_dir.glob('session_*.json'))
        if not session_files:
            return None
            
        latest = max(session_files, key=lambda p: p.stat().st_mtime)
        with open(latest, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def get_all_sessions(self):
        """ëª¨ë“  ì„¸ì…˜ ëª©ë¡ ë°˜í™˜"""
        session_files = sorted(self.session_dir.glob('session_*.json'), reverse=True)
        return [f.name for f in session_files]

# ë””ë²„ê·¸ ë¡œê¹… í•¨ìˆ˜
def debug_log(message):
    timestamp = time.strftime("%H:%M:%S")
    print(f"[DEBUG {timestamp}] {message}", file=sys.stderr, flush=True)

# REPL ì„¸ì…˜ì„ ìœ„í•œ ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ (exec() ê¸°ë°˜)
repl_globals = {'__name__': '__console__', '__doc__': None}

# READY ì‹œê·¸ë„ ì „ì†¡
debug_log("Python REPL ì´ˆê¸°í™” ì‹œì‘")
print("__READY__", flush=True)
debug_log("READY ì‹ í˜¸ ì „ì†¡ ì™„ë£Œ")

# ============================================================================
# í—¬í¼ í•¨ìˆ˜ ìë™ ë¡œë“œ ì‹œìŠ¤í…œ (backup_finalì—ì„œ ê°€ì ¸ì˜´, exec() ê¸°ë°˜ìœ¼ë¡œ ìˆ˜ì •)
# ============================================================================

# ============================================================================
# ğŸ§  Enhanced AI Brain Integration for JSON REPL Session v2.0  
# claude_code_ai_brain.pyì™€ ì™„ì „ ì—°ë™ë˜ëŠ” JSON REPL ë§ì¶¤í˜• ì‹œìŠ¤í…œ
# ============================================================================

class JsonReplAIBrain:
    """
    JSON REPL í™˜ê²½ ì „ìš© AI Brain í´ë˜ìŠ¤
    claude_code_ai_brain.pyì˜ ClaudeCodeAIBrainê³¼ í˜¸í™˜ë˜ëŠ” ì¸í„°í˜ì´ìŠ¤ ì œê³µ
    """
    
    def __init__(self, project_path):
        self.project_path = project_path
        self.initialized = True
        self.session_id = f"json_repl_{int(time.time())}"
        self.capabilities = [
            'project_context_management',
            'helper_function_access', 
            'vibe_memory_integration',
            'context_manager_v2_support',
            'experience_learning',
            'solution_search'
        ]
        
        # project_context ì—°ê²° (Context Manager v2 ì§€ì›)
        if 'project_context' in repl_globals:
            self.project_context = repl_globals['project_context']
        else:
            self.project_context = self._create_default_context()
            repl_globals['project_context'] = self.project_context
        
        debug_log(f"JsonReplAIBrain ì´ˆê¸°í™” ì™„ë£Œ: {self.session_id}")
    
    def _create_default_context(self):
        """ê¸°ë³¸ í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ìƒì„± - 2ê³„ì¸µ êµ¬ì¡°"""
        return {
            'session_id': self.session_id,
            'name': 'ai-coding-brain-mcp',
            'base_path': self.project_path,
            'analyzed_files': {},
            'backup_history': [],
            'experiences': [],
            'ai_brain_type': 'JsonReplAIBrain',
            'created_at': time.strftime('%Y-%m-%d %H:%M:%S'),
            'version': '2tier',
            # 2ê³„ì¸µ êµ¬ì¡°: Cache + Storage
            'cache': {
                'current_focus': 'JSON REPL AI Brain í™œì„±',
                'active_file': None,
                'active_file_analysis': {},
                'last_command_result': None,
                'smart_index': {},
                'analyzed_files_summary': {},
                'vibe_session': {
                    'status': 'inactive',
                    'next_tasks': [],
                    'completed_tasks': []
                }
            },
            'storage': {
                'base_path': self.project_path,
                'backup_history_path': 'backups/history.json',
                'full_system_log_path': 'logs/session.log'
            }
        }
    
    def get_status(self):
        """AI Brain ìƒíƒœ ì •ë³´ ë°˜í™˜"""
        return {
            'type': 'JsonReplAIBrain',
            'session_id': self.session_id,
            'initialized': self.initialized,
            'project_path': self.project_path,
            'capabilities': self.capabilities,
            'context_available': 'project_context' in repl_globals,
            'helper_functions_available': 'protection_system' in repl_globals,
            'context_type': 'v2' if 'cache' in self.project_context else 'v1'
        }
    
    def save_experience(self, data, importance=0.5, tech_stack=None):
        """ê°œë°œ ê²½í—˜ ì €ì¥ (claude_code_ai_brain.py í˜¸í™˜)"""
        try:
            experience = {
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'data': data,
                'importance': importance,
                'tech_stack': tech_stack,
                'session_id': self.session_id,
                'type': 'coding_experience'
            }
            
            if 'experiences' not in self.project_context:
                self.project_context['experiences'] = []
            
            self.project_context['experiences'].append(experience)
            
            # Cache ì—…ë°ì´íŠ¸ (2ê³„ì¸µ êµ¬ì¡°)
            if 'cache' in self.project_context:
                self.project_context['cache']['last_command_result'] = {
                    'action': 'experience_saved',
                    'timestamp': experience['timestamp']
                }
            
            debug_log(f"ê²½í—˜ ì €ì¥ ì™„ë£Œ: {experience['timestamp']}")
            return {'success': True, 'saved_at': experience['timestamp']}
        except Exception as e:
            debug_log(f"ê²½í—˜ ì €ì¥ ì‹¤íŒ¨: {e}")
            return {'success': False, 'error': str(e)}
    
    def search_experiences(self, query, tech_stack=None):
        """ê²½í—˜ ê²€ìƒ‰ (claude_code_ai_brain.py í˜¸í™˜)"""
        try:
            experiences = self.project_context.get('experiences', [])
            results = []
            
            query_words = query.lower().split()
            
            for exp in experiences:
                if isinstance(exp.get('data'), (str, dict)):
                    exp_str = str(exp['data']).lower()
                    
                    # í‚¤ì›Œë“œ ë§¤ì¹­
                    if any(word in exp_str for word in query_words):
                        results.append(exp)
                    
                    # ê¸°ìˆ  ìŠ¤íƒ ë§¤ì¹­ (ìˆëŠ” ê²½ìš°)
                    if tech_stack and exp.get('tech_stack'):
                        if any(tech.lower() in str(exp['tech_stack']).lower() for tech in tech_stack):
                            if exp not in results:
                                results.append(exp)
            
            # ì¤‘ìš”ë„ ìˆœìœ¼ë¡œ ì •ë ¬
            results.sort(key=lambda x: x.get('importance', 0), reverse=True)
            
            debug_log(f"ê²½í—˜ ê²€ìƒ‰ ì™„ë£Œ: {len(results)}ê°œ ê²°ê³¼")
            return {'success': True, 'results': results, 'count': len(results), 'query': query}
        except Exception as e:
            debug_log(f"ê²½í—˜ ê²€ìƒ‰ ì‹¤íŒ¨: {e}")
            return {'success': False, 'error': str(e)}
    
    def auto_initialize(self, project_path=None, force_reinit=False):
        """
        claude_code_ai_brain.py í˜¸í™˜ ë©”ì„œë“œ - í–¥ìƒëœ ìë™ ì´ˆê¸°í™”
        ì‘ì—… ì¶”ì , ìºì‹œ, Vibe Memory ì™„ì „ í†µí•©
        """
        try:
            if project_path:
                self.project_path = project_path
                if 'storage' in self.project_context:
                    self.project_context['storage']['base_path'] = project_path
            
            # í—¬í¼ í•¨ìˆ˜ ì‹œìŠ¤í…œ ì—°ë™
            if 'protection_system' in repl_globals:
                self.protection_system = repl_globals['protection_system']
            
            # Context Manager í•¨ìˆ˜ë“¤ ì—°ë™
            if CONTEXT_MANAGER_AVAILABLE:
                # ì‘ì—… ì¶”ì  í•¨ìˆ˜ë“¤
                self.track_file_access = repl_globals.get('track_file_access')
                self.track_function_edit = repl_globals.get('track_function_edit')
                self.get_work_tracking_summary = repl_globals.get('get_work_tracking_summary')
                
                # ìºì‹œ í•¨ìˆ˜ë“¤
                self.update_cache = repl_globals.get('update_cache')
                self.get_cache_statistics = repl_globals.get('get_cache_statistics')
                
                # Vibe Memory í•¨ìˆ˜ë“¤
                self.sync_to_vibe_memory = repl_globals.get('sync_to_vibe_memory')
                self.update_vibe_focus = repl_globals.get('update_vibe_focus')
                
                debug_log("Context Manager í•¨ìˆ˜ ì—°ë™ ì™„ë£Œ")
            
            # Vibe Memory ì‹œìŠ¤í…œ ì—°ë™ (ìˆëŠ” ê²½ìš°)
            if 'vibe_manager' in repl_globals:
                self.vibe_manager = repl_globals['vibe_manager']
            if 'vibe_commands' in repl_globals:
                self.vibe_commands = repl_globals['vibe_commands']
            
            # ì´ˆê¸°í™” ì™„ë£Œ í›„ ì‘ì—… ì¶”ì 
            if self.track_file_access and 'project_context' in repl_globals:
                self.track_file_access(
                    repl_globals['project_context'],
                    __file__,
                    'ai_brain_init'
                )
            
            # Vibe Memoryì— ì´ˆê¸°í™” ìƒíƒœ ë™ê¸°í™”
            if self.update_vibe_focus and 'project_context' in repl_globals:
                self.update_vibe_focus(
                    repl_globals['project_context'],
                    f"AI Brain ì´ˆê¸°í™” ì™„ë£Œ - ì„¸ì…˜: {self.session_id}"
                )
            
            debug_log(f"JsonReplAIBrain auto_initialize ì™„ë£Œ - í†µí•© ê¸°ëŠ¥ í™œì„±í™”")
            self.initialized = True
            return True
            
        except Exception as e:
            debug_log(f"auto_initialize ì‹¤íŒ¨: {e}")
            return False
def init_helpers_sync():
    """
    Enhanced í—¬í¼ í•¨ìˆ˜ + AI Brain í†µí•© ì´ˆê¸°í™” v3.0
    ì‘ì—… ì¶”ì , ìºì‹œ ì‹œìŠ¤í…œ, Vibe Memory ì™„ì „ ìë™í™”
    """
    global _helper_initialization_status
    
    debug_log("=== Enhanced AI Brain + í†µí•© ì‹œìŠ¤í…œ ì´ˆê¸°í™” v3.0 ì‹œì‘ ===")
    
    # ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    if _helper_initialization_status.get('in_progress', False):
        debug_log("ì´ˆê¸°í™”ê°€ ì´ë¯¸ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤")
        return {"success": False, "message": "initialization_in_progress"}
    
    if _helper_initialization_status.get('initialized', False):
        debug_log("ì´ë¯¸ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤ - Enhanced v3.0")
        return {"success": True, "message": "already_initialized_v3"}
    
    _helper_initialization_status['in_progress'] = True
    _helper_initialization_status['timestamp'] = dt.datetime.now().isoformat()
    _helper_initialization_status['source'] = 'enhanced_init_v3'
    
    try:
        # 1. í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •
        project_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        debug_log(f"í”„ë¡œì íŠ¸ ê²½ë¡œ: {project_path}")
        
        # 2. Context Manager ì´ˆê¸°í™”
        debug_log("Context Manager 2ê³„ì¸µ êµ¬ì¡° ì´ˆê¸°í™”...")
        if CONTEXT_MANAGER_AVAILABLE:
            project_context = context_manager.initialize_context(
                project_path=project_path,
                project_name='ai-coding-brain-mcp'
            )
            repl_globals['project_context'] = project_context
            debug_log(f"âœ… Project ID: {project_context.get('project_id')}")
            
            # ì‘ì—… ì¶”ì  ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            project_context = context_manager.initialize_work_tracking(project_context)
            debug_log("âœ… ì‘ì—… ì¶”ì  ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ì‘ì—… ì¶”ì  í•¨ìˆ˜ë“¤ì„ ì „ì—­ìœ¼ë¡œ ë“±ë¡
            work_tracking_funcs = [
                'track_file_access', 'track_function_edit', 'track_code_analysis',
                'get_current_work_context', 'get_work_history', 'get_work_tracking_summary',
                'get_most_accessed_files', 'get_most_edited_functions'
            ]
            for func_name in work_tracking_funcs:
                if hasattr(context_manager, func_name):
                    repl_globals[func_name] = getattr(context_manager, func_name)
            debug_log(f"âœ… ì‘ì—… ì¶”ì  í•¨ìˆ˜ {len(work_tracking_funcs)}ê°œ ë“±ë¡")
            
            # ìºì‹œ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
            debug_log("ìºì‹œ ì‹œìŠ¤í…œ ì´ˆê¸°í™”...")
            # í•µì‹¬ íŒŒì¼ë“¤ ë¯¸ë¦¬ ìºì‹±
            core_files = [
                'python/context_manager.py',
                'python/file_system_helpers.py', 
                'python/ast_parser_helpers.py'
            ]
            cached_count = 0
            for rel_path in core_files:
                file_path = os.path.join(project_path, rel_path)
                if os.path.exists(file_path):
                    try:
                        # íŒŒì¼ ì ‘ê·¼ ì¶”ì 
                        context_manager.track_file_access(project_context, file_path, 'cache_init')
                        cached_count += 1
                    except:
                        pass
            debug_log(f"âœ… ìºì‹œ ì´ˆê¸°í™”: {cached_count}ê°œ í•µì‹¬ íŒŒì¼ ë“±ë¡")
            
            # Vibe Memory í†µí•©
            if hasattr(context_manager, 'integrate_vibe_memory'):
                debug_log("Vibe Memory ì‹œìŠ¤í…œ í†µí•©...")
                vibe_result = context_manager.integrate_vibe_memory(project_context, auto_sync=True)
                if vibe_result:
                    debug_log("âœ… Vibe Memory ì—°ë™ ì„±ê³µ")
                    # ì‹¤ì‹œê°„ ë™ê¸°í™” í™œì„±í™”
                    context_manager.enable_realtime_sync(project_context, enabled=True, write_immediately=True)
                    debug_log("âœ… ì‹¤ì‹œê°„ ë™ê¸°í™” í™œì„±í™”")
                    
                    # ì´ˆê¸° ìƒíƒœ ë™ê¸°í™”
                    context_manager.update_vibe_focus(project_context, "JSON REPL ì„¸ì…˜ ì‹œì‘")
                else:
                    debug_log("âš ï¸ Vibe Memory ì—°ë™ ì‹¤íŒ¨")
        else:
            # Context Managerê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ context ìƒì„±
            project_context = {
                'session_id': f'json_repl_{int(time.time())}',
                'name': 'ai-coding-brain-mcp',
                'base_path': project_path,
                'analyzed_files': {},
                'cache': {'current_focus': 'JSON REPL ì´ˆê¸°í™”'},
                'storage': {'base_path': project_path}
            }
            repl_globals['project_context'] = project_context
            debug_log("âš ï¸ Context Manager ì—†ìŒ - ê¸°ë³¸ context ìƒì„±")
        
        # 3. JSON REPL AI Brain ìƒì„±
        debug_log("JSON REPL AI Brain ìƒì„±...")
        ai_brain = JsonReplAIBrain(project_path)
        repl_globals['ai_brain'] = ai_brain
        repl_globals['claude_ai_brain'] = ai_brain
        
        # AI Brain ìë™ ì´ˆê¸°í™”
        ai_brain.auto_initialize(project_path)
        debug_log("âœ… AI Brain ìƒì„± ë° ì´ˆê¸°í™” ì™„ë£Œ")
        
        # 4. í—¬í¼ í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ ì‹¤í–‰
        debug_log("í—¬í¼ í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ ì‹¤í–‰...")
        helper_result = register_all_helpers(force_overwrite=False)
        
        # 5. ì¶”ê°€ í—¬í¼ í•¨ìˆ˜ ë“±ë¡ (í†µí•© ê²€ìƒ‰ ë“±)
        # 5. ì¶”ê°€ í—¬í¼ í•¨ìˆ˜ ë“±ë¡ (í†µí•© ê²€ìƒ‰ ë“±)
        try:
            # í†µí•© ê²€ìƒ‰ í•¨ìˆ˜ ë“±ë¡
            if CONTEXT_MANAGER_AVAILABLE:
                # integrated_search ëª¨ë“ˆì—ì„œ í•¨ìˆ˜ ê°€ì ¸ì˜¤ê¸°
                try:
                    from integrated_search import integrated_search
                    repl_globals['integrated_search'] = integrated_search
                    debug_log("âœ… í†µí•© ê²€ìƒ‰ í•¨ìˆ˜ ë“±ë¡")
                except ImportError as e:
                    debug_log(f"í†µí•© ê²€ìƒ‰ í•¨ìˆ˜ import ì‹¤íŒ¨: {e}")
                
                # ìºì‹œ ê´€ë ¨ í•¨ìˆ˜ ë“±ë¡
                cache_funcs = [
                    'update_cache', 'update_file_cache', 'get_cached_analysis',
                    'validate_cache_entry', 'get_cache_statistics', 'save_project_cache'
                ]
                for func_name in cache_funcs:
                    if hasattr(context_manager, func_name):
                        repl_globals[func_name] = getattr(context_manager, func_name)
                debug_log(f"âœ… ìºì‹œ í•¨ìˆ˜ {len(cache_funcs)}ê°œ ì¶”ê°€ ë“±ë¡")
        except Exception as e:
            debug_log(f"ì¶”ê°€ í•¨ìˆ˜ ë“±ë¡ ì¤‘ ì˜¤ë¥˜: {e}")
        
        # 6. ì‹œìŠ¤í…œ ìƒíƒœ ë³´ê³ 
        debug_log("=== ğŸ¯ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ ë³´ê³  ===")
        debug_log(f"Project ID: {project_context.get('project_id', 'N/A')}")
        debug_log(f"Session ID: {ai_brain.session_id}")
        debug_log(f"ì‘ì—… ì¶”ì : {'í™œì„±í™”' if 'track_file_access' in repl_globals else 'ë¹„í™œì„±í™”'}")
        debug_log(f"ìºì‹œ ì‹œìŠ¤í…œ: {'í™œì„±í™”' if 'cache' in project_context else 'ë¹„í™œì„±í™”'}")
        debug_log(f"Vibe Memory: {'ì—°ë™ë¨' if project_context.get('cache', {}).get('vibe_integrated') else 'ë¯¸ì—°ë™'}")
        debug_log(f"í—¬í¼ í•¨ìˆ˜: {helper_result.get('registered_count', 0)}ê°œ ë³´í˜¸ë¨")
        
        # 7. ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
        _helper_initialization_status['initialized'] = True
        _helper_initialization_status['in_progress'] = False
        
        success_result = {
            "success": True,
            "version": "enhanced_v3.0",
            "ai_brain_session_id": ai_brain.session_id,
            "project_id": project_context.get('project_id'),
            "work_tracking": 'track_file_access' in repl_globals,
            "cache_system": 'cache' in project_context,
            "vibe_memory": project_context.get('cache', {}).get('vibe_integrated', False),
            "helper_functions_protected": helper_result.get('registered_count', 0),
            "timestamp": _helper_initialization_status['timestamp']
        }
        
        debug_log("=== Enhanced í†µí•© ì‹œìŠ¤í…œ ì´ˆê¸°í™” v3.0 ì™„ë£Œ ===")
        return success_result
        
    except Exception as e:
        debug_log(f"Enhanced ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        import traceback
        debug_log(traceback.format_exc())
        _helper_initialization_status['in_progress'] = False
        return {"success": False, "error": str(e)}

def read_eot_framed_input():
    """EOT(\\x04) ë¬¸ìë¡œ í”„ë ˆì´ë°ëœ ì…ë ¥ ì½ê¸°"""
    debug_log("EOT í”„ë ˆì´ë° ì…ë ¥ ì½ê¸° ì‹œì‘")
    
    buffer = ""
    while True:
        try:
            char = sys.stdin.read(1)
            
            if not char:  # EOF
                debug_log("EOF ê°ì§€ - ì…ë ¥ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ")
                return None
                
            if char == '\x04':  # EOT ë¬¸ì
                debug_log(f"EOT ê°ì§€ - ë²„í¼ ê¸¸ì´: {len(buffer)}")
                debug_log(f"ìˆ˜ì‹ ëœ ë°ì´í„°: {repr(buffer[:100])}...")
                return buffer
                
            buffer += char
            
            if len(buffer) > 10000:
                debug_log(f"WARNING: ë²„í¼ í¬ê¸° {len(buffer)} - EOT ëˆ„ë½ ê°€ëŠ¥ì„±")
                
        except Exception as e:
            debug_log(f"ì…ë ¥ ì½ê¸° ì—ëŸ¬: {e}")
            return None

def send_eot_framed_response(response_data):
    """EOT(\\x04) ë¬¸ìë¡œ í”„ë ˆì´ë°ëœ ì‘ë‹µ ì „ì†¡"""
    try:
        # ì›ë³¸: json_response = json.dumps(response_data, ensure_ascii=False)
        # ëŒ€ìš©ëŸ‰ JSON ì‘ë‹µ smart_print ì²˜ë¦¬
        if SMART_PRINT_AVAILABLE and len(str(response_data)) > 20000:
            # ëŒ€ìš©ëŸ‰ ì‘ë‹µì¼ ë•Œ smart_printë¡œ ì••ì¶•
            debug_log(f"ëŒ€ìš©ëŸ‰ ì‘ë‹µ ê°ì§€ - smart_print ì••ì¶• ì ìš©: {len(str(response_data))} ë¬¸ì")
            compressed_response = compress_content(str(response_data), level=1)
            if isinstance(compressed_response, str) and len(compressed_response) < len(str(response_data)):
                # ì••ì¶•ì´ íš¨ê³¼ì ì¸ ê²½ìš° ì••ì¶•ëœ ë²„ì „ ì‚¬ìš©
                response_data_to_serialize = {"compressed": True, "content": compressed_response, "original_size": len(str(response_data))}
                debug_log(f"smart_print ì••ì¶• ì„±ê³µ: {len(str(response_data))} â†’ {len(compressed_response)} ë¬¸ì")
            else:
                # ì••ì¶•ì´ íš¨ê³¼ì ì´ì§€ ì•Šì€ ê²½ìš° ì›ë³¸ ì‚¬ìš©
                response_data_to_serialize = response_data
                debug_log("smart_print ì••ì¶• íš¨ê³¼ ì—†ìŒ - ì›ë³¸ ì‚¬ìš©")
        else:
            # ì¼ë°˜ í¬ê¸° ì‘ë‹µì€ ê·¸ëŒ€ë¡œ ì²˜ë¦¬
            response_data_to_serialize = response_data
        
        json_response = json.dumps(response_data_to_serialize, ensure_ascii=False)
        debug_log(f"ì‘ë‹µ ì „ì†¡ ì¤€ë¹„ - ê¸¸ì´: {len(json_response)}")
        debug_log(f"ì‘ë‹µ ë‚´ìš©: {repr(json_response[:200])}...")
        
        sys.stdout.write(json_response)
        sys.stdout.write('\x04')
        sys.stdout.flush()
        
        debug_log("EOT í”„ë ˆì´ë° ì‘ë‹µ ì „ì†¡ ì™„ë£Œ")
        return True
        
    except Exception as e:
        debug_log(f"ì‘ë‹µ ì „ì†¡ ì—ëŸ¬: {e}")
        return False

def execute_code_block(code):
    """exec()ì„ ì‚¬ìš©í•œ ë‹¤ì¤‘ ë¬¸ì¥ ì½”ë“œ ë¸”ë¡ ì‹¤í–‰"""
    debug_log("ì½”ë“œ ë¸”ë¡ ì‹¤í–‰ ì‹œì‘")
    debug_log(f"ì½”ë“œ ê¸¸ì´: {len(code)} ë¬¸ì")
    
    stdout_capture = io.StringIO()
    stderr_capture = io.StringIO()
    
    execution_start = time.time()
    
    try:
        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
            debug_log("ì½”ë“œ ì»´íŒŒì¼ ì‹œì‘")
            compiled_code = compile(code, '<string>', 'exec')
            debug_log("ì½”ë“œ ì»´íŒŒì¼ ì„±ê³µ")
            
            debug_log("exec() ì‹¤í–‰ ì‹œì‘")
            exec(compiled_code, repl_globals)
            debug_log("exec() ì‹¤í–‰ ì™„ë£Œ")
        
        execution_time = time.time() - execution_start
        debug_log(f"ì‹¤í–‰ ì‹œê°„: {execution_time:.3f}ì´ˆ")
        
        stdout_content = stdout_capture.getvalue()
        stderr_content = stderr_capture.getvalue()
        
        # ì„¸ì…˜ ìë™ ì €ì¥ (Session Manager í†µí•©)
        if 'session_manager' in repl_globals:
            try:
                session_data = {
                    'type': 'code_execution',
                    'code_snippet': code[:500] + '...' if len(code) > 500 else code,
                    'success': True,
                    'execution_time': execution_time,
                    'variable_count': len(repl_globals),
                    'stdout_length': len(stdout_content),
                    'stderr_length': len(stderr_content),
                    'has_output': bool(stdout_content.strip())
                }
                repl_globals['session_manager'].save_session(session_data)
            except Exception as e:
                debug_log(f"ì„¸ì…˜ ìë™ ì €ì¥ ì‹¤íŒ¨ (ë¬´ì‹œ): {e}")
# Smart Print ìµœì í™”: ëŒ€ìš©ëŸ‰ stdout/stderr ì••ì¶•
        if SMART_PRINT_AVAILABLE:
            if len(stdout_content) > 100000:  # Increased from 15000 to prevent truncation
                debug_log(f"ëŒ€ìš©ëŸ‰ stdout ê°ì§€ - smart_print ì••ì¶•: {len(stdout_content)} ë¬¸ì")
                compressed_stdout = compress_content(stdout_content, level=1)
                if isinstance(compressed_stdout, str) and len(compressed_stdout) < len(stdout_content):
                    stdout_content = f"[COMPRESSED] {compressed_stdout}\n\n[ORIGINAL_SIZE: {len(stdout_content)} chars]"
                    debug_log(f"stdout ì••ì¶• ì™„ë£Œ: {len(stdout_content)} ë¬¸ìë¡œ ì¶•ì†Œ")
        debug_log(f"stdout ê¸¸ì´: {len(stdout_content)}")
        debug_log(f"stderr ê¸¸ì´: {len(stderr_content)}")
        debug_log(f"ì „ì—­ ë³€ìˆ˜ ê°œìˆ˜: {len(repl_globals)}")
        
        return {
            'success': True,
            'stdout': stdout_content,
            'stderr': stderr_content,
            'execution_time': execution_time,
            'variable_count': len(repl_globals) - 2,  # __name__, __doc__ ì œì™¸
            'result': 'executed'
        }
        
    except SyntaxError as syntax_error:
        debug_log(f"êµ¬ë¬¸ ì—ëŸ¬: {syntax_error}")
        return {
            'success': False,
            'error': str(syntax_error),
            'error_type': 'SyntaxError',
            'stdout': stdout_capture.getvalue(),
            'stderr': stderr_capture.getvalue(),
            'lineno': syntax_error.lineno,
            'offset': syntax_error.offset
        }


    except Exception as e:
        debug_log(f"ì‹¤í–‰ ì—ëŸ¬: {type(e).__name__}: {e}")
        import traceback
        tb_str = traceback.format_exc()
        
        # ì¤‘ìš”: stdout/stderr ë‚´ìš©ì„ ë³´ì¡´í•˜ì—¬ ë°˜í™˜
        return {
            'success': False,
            'error': str(e),
            'error_type': type(e).__name__,
            'stdout': stdout_capture.getvalue(),  # ì—ëŸ¬ ì „ê¹Œì§€ì˜ ì¶œë ¥ ë³´ì¡´
            'stderr': stderr_capture.getvalue() + f"\n{tb_str}",  # ì—ëŸ¬ ì •ë³´ ì¶”ê°€
            'traceback': tb_str,
            'execution_time': time.time() - execution_start,
            'result': 'error'
        }


# ============================================================================
# ğŸš€ ìë™ ì¶”ì  ì‹œìŠ¤í…œ í™œì„±í™” í—¬í¼
# ============================================================================

def activate_auto_tracking():
    """
    ìë™ ì¶”ì  ì‹œìŠ¤í…œì„ í™œì„±í™”í•˜ê³  ìƒíƒœë¥¼ ë³´ê³ í•©ë‹ˆë‹¤.
    protection_systemì´ ìˆì„ ë•Œë§Œ ì‘ë™í•©ë‹ˆë‹¤.
    """
    try:
        if 'protection_system' not in repl_globals:
            debug_log("ë³´í˜¸ ì‹œìŠ¤í…œì´ ì—†ì–´ ìë™ ì¶”ì ì„ í™œì„±í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return False
            
        protection_system = repl_globals['protection_system']
        
        # ìë™ ì¶”ì  í™œì„±í™”
        protection_system.enable_auto_tracking(True)
        
        # ìƒíƒœ ë³´ê³ 
        status = protection_system.get_protection_status()
        call_stats = status.get('call_statistics', {})
        
        debug_log("=== ğŸ¯ ìë™ ì¶”ì  ì‹œìŠ¤í…œ í™œì„±í™” ===")
        debug_log(f"ë³´í˜¸ëœ í•¨ìˆ˜: {status['total_protected']}ê°œ")
        debug_log(f"ì¹´í…Œê³ ë¦¬: {', '.join(status['categories'].keys())}")
        debug_log(f"ìë™ ì¶”ì : {'í™œì„±í™”' if status['auto_tracking_enabled'] else 'ë¹„í™œì„±í™”'}")
        debug_log(f"ì´ í˜¸ì¶œ íšŸìˆ˜: {call_stats.get('total_calls', 0)}")
        
        # project_context í™•ì¸
        if 'project_context' in repl_globals:
            ctx = repl_globals['project_context']
            debug_log(f"Project Context ì—°ê²°: {ctx.get('project_id', 'N/A')}")
            
            # ì‘ì—… ì¶”ì  í•¨ìˆ˜ë“¤ í™•ì¸
            tracking_funcs = ['track_file_access', 'track_function_edit', 'track_code_analysis']
            available_tracking = [f for f in tracking_funcs if f in repl_globals]
            debug_log(f"ì‚¬ìš© ê°€ëŠ¥í•œ ì¶”ì  í•¨ìˆ˜: {', '.join(available_tracking)}")
        
        debug_log("=== ìë™ ì¶”ì  ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ ===")
        return True
        
    except Exception as e:
        debug_log(f"ìë™ ì¶”ì  í™œì„±í™” ì‹¤íŒ¨: {e}")
        return False

def get_tracking_report():
    """
    í˜„ì¬ê¹Œì§€ì˜ ì¶”ì  ì •ë³´ë¥¼ ì¢…í•©í•˜ì—¬ ë³´ê³ í•©ë‹ˆë‹¤.
    """
    try:
        report = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'session_info': {},
            'protection_status': {},
            'work_tracking': {},
            'call_statistics': {}
        }
        
        # ì„¸ì…˜ ì •ë³´
        if 'project_context' in repl_globals:
            ctx = repl_globals['project_context']
            report['session_info'] = {
                'project_id': ctx.get('project_id', 'N/A'),
                'session_id': ctx.get('session_id', 'N/A'),
                'project_name': ctx.get('name', 'N/A')
            }
        
        # ë³´í˜¸ ì‹œìŠ¤í…œ ìƒíƒœ
        if 'protection_system' in repl_globals:
            status = repl_globals['protection_system'].get_protection_status()
            report['protection_status'] = {
                'protected_functions': status['total_protected'],
                'auto_tracking': status['auto_tracking_enabled'],
                'categories': status['categories']
            }
            report['call_statistics'] = status['call_statistics']
        
        # ì‘ì—… ì¶”ì  ì •ë³´
        if 'get_work_tracking_summary' in repl_globals:
            work_summary = repl_globals['get_work_tracking_summary'](repl_globals.get('project_context'))
            if work_summary:
                report['work_tracking'] = work_summary
        
        return report
        
    except Exception as e:
        debug_log(f"ì¶”ì  ë³´ê³ ì„œ ìƒì„± ì‹¤íŒ¨: {e}")
        return None

# ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì— ë“±ë¡
repl_globals['activate_auto_tracking'] = activate_auto_tracking
repl_globals['get_tracking_report'] = get_tracking_report
def main_loop():

    # ìë™ ì¶”ì  ì‹œìŠ¤í…œ í™œì„±í™”
    try:
        debug_log("ìë™ ì¶”ì  ì‹œìŠ¤í…œ í™œì„±í™” ì‹œë„...")
        if activate_auto_tracking():
            debug_log("âœ… ìë™ ì¶”ì  ì‹œìŠ¤í…œ í™œì„±í™” ì„±ê³µ")

            # ì´ˆê¸° ì¶”ì  ë³´ê³ ì„œ ìƒì„±
            initial_report = get_tracking_report()
            if initial_report:
                debug_log(f"ì´ˆê¸° ì¶”ì  ë³´ê³ ì„œ ìƒì„± ì™„ë£Œ")
        else:
            debug_log("âš ï¸ ìë™ ì¶”ì  ì‹œìŠ¤í…œ í™œì„±í™” ì‹¤íŒ¨")
    except Exception as e:
        debug_log(f"ìë™ ì¶”ì  í™œì„±í™” ì¤‘ ì˜¤ë¥˜: {e}")
    """exec() + EOT í”„ë ˆì´ë° + í—¬í¼ ìë™ ë¡œë“œ ë©”ì¸ ë£¨í”„"""
    debug_log("ë©”ì¸ ë£¨í”„ ì‹œì‘ - exec() + í†µí•© ì‹œìŠ¤í…œ v3.0")
    
    # ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸ ë° í‘œì‹œ
    debug_log("=== ğŸš€ JSON REPL ì‹œìŠ¤í…œ ìƒíƒœ ===")
    
    # 1. í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ í™•ì¸
    if 'project_context' in repl_globals:
        ctx = repl_globals['project_context']
        debug_log(f"âœ… Project Context: {ctx.get('project_id', 'N/A')}")
        debug_log(f"âœ… Session ID: {ctx.get('session_id', 'N/A')}")
        
        # ì‘ì—… ì¶”ì  ìƒíƒœ
        if 'work_tracking' in ctx.get('cache', {}):
            tracking = ctx['cache']['work_tracking']
            debug_log(f"âœ… ì‘ì—… ì¶”ì : í™œì„±í™” (ì„¸ì…˜ ì‹œì‘: {tracking.get('session_start', 'N/A')})")
        else:
            debug_log("âš ï¸ ì‘ì—… ì¶”ì : ë¹„í™œì„±í™”")
        
        # ìºì‹œ ìƒíƒœ
        if 'cache' in ctx:
            cache_stats = ctx.get('stats', {})
            debug_log(f"âœ… ìºì‹œ ì‹œìŠ¤í…œ: í™œì„±í™” (íˆíŠ¸ìœ¨: {cache_stats.get('cache_hits', 0)}/{cache_stats.get('cache_misses', 0)})")
        
        # Vibe Memory ìƒíƒœ  
        if ctx.get('cache', {}).get('vibe_integrated'):
            debug_log(f"âœ… Vibe Memory: ì—°ë™ë¨ (ê²½ë¡œ: {ctx.get('cache', {}).get('vibe_memory_path', 'N/A')})")
        else:
            debug_log("âš ï¸ Vibe Memory: ë¯¸ì—°ë™")
    else:
        debug_log("âŒ Project Contextê°€ ì—†ìŠµë‹ˆë‹¤")
    
    # 2. í—¬í¼ í•¨ìˆ˜ ìƒíƒœ
    if 'protection_system' in repl_globals:
        status = repl_globals['protection_system'].get_protection_status()
        debug_log(f"âœ… í—¬í¼ í•¨ìˆ˜: {status['total_protected']}ê°œ ë³´í˜¸ë¨")
    else:
        debug_log("âš ï¸ í—¬í¼ í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ ì—†ìŒ")
    
    # 3. AI Brain ìƒíƒœ
    if 'ai_brain' in repl_globals:
        brain_status = repl_globals['ai_brain'].get_status()
        debug_log(f"âœ… AI Brain: {brain_status['type']} (ì„¸ì…˜: {brain_status['session_id']})")
    else:
        debug_log("âš ï¸ AI Brainì´ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ")
    
    debug_log("=== ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸ ì™„ë£Œ ===\n")
    debug_log("ë©”ì¸ ë£¨í”„ ì‹œì‘ - exec() + í—¬í¼ ìë™ ë¡œë“œ")
    
    # v40.0: ì„¸ì…˜ ì‹œì‘ì‹œ ì¦‰ì‹œ 29ê°œ í—¬í¼ í•¨ìˆ˜ ìë™ ë¡œë“œ
    # âœ… ì¤‘ë³µ ì œê±°: Helper í•¨ìˆ˜ ë“±ë¡ì€ lazy_import_ai_brain_system()ì—ì„œ ì²˜ë¦¬
    # ë°±ê·¸ë¼ìš´ë“œ ì´ˆê¸°í™”ë¡œ ì¼ì›í™”í•˜ì—¬ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
    
    
    request_count = 0
    
    while True:
        try:
            debug_log(f"ìš”ì²­ ëŒ€ê¸° ì¤‘... (ìš”ì²­ #{request_count + 1})")
            
            raw_input = read_eot_framed_input()
            
            if raw_input is None:
                debug_log("ì…ë ¥ì´ None - ë£¨í”„ ì¢…ë£Œ")
                break
                
            request_count += 1
            debug_log(f"ìš”ì²­ #{request_count} ìˆ˜ì‹  ì™„ë£Œ")
            
            if not raw_input.strip():
                debug_log("ë¹ˆ ìš”ì²­ - ë¬´ì‹œ")
                continue
                
            try:
                debug_log("JSON íŒŒì‹± ì‹œì‘")
                request = json.loads(raw_input)
                command_id = request.get('id', f'req_{request_count}')
                code = request.get('code', '')
                
                debug_log(f"ìš”ì²­ ID: {command_id}")
                debug_log(f"ì½”ë“œ ê¸¸ì´: {len(code)}")
                debug_log(f"ì½”ë“œ ë‚´ìš©: {repr(code[:100])}...")
                
                if not code.strip():
                    debug_log("ë¹ˆ ì½”ë“œ - ê¸°ë³¸ ì‘ë‹µ")
                    response = {
                        'id': command_id,
                        'success': True,
                        'result': None,
                        'stdout': '',
                        'stderr': '',
                        'variable_count': len(repl_globals) - 2,
                        'debug': 'empty_code',
                        'helpers_loaded': 'ai_file_helpers' in repl_globals
                    }
                    send_eot_framed_response(response)
                    continue
                
                # exec() ê¸°ë°˜ ì½”ë“œ ì‹¤í–‰
                execution_result = execute_code_block(code)
                
                # ì‘ë‹µ êµ¬ì„±
                response = {
                    'id': command_id,
                    **execution_result,
                    'debug': f'executed_req_{request_count}',
                    'execution_method': 'exec',
                    'helpers_loaded': 'ai_file_helpers' in repl_globals,
                    'project_context_available': 'project_context' in repl_globals
                }
                
            except json.JSONDecodeError as json_error:
                debug_log(f"JSON íŒŒì‹± ì—ëŸ¬: {json_error}")
                debug_log(f"íŒŒì‹± ì‹¤íŒ¨ ë°ì´í„°: {repr(raw_input[:200])}...")
                response = {
                    'id': f'parse_error_{request_count}',
                    'success': False,
                    'error': f"JSON parsing error: {json_error}",
                    'error_type': 'JSONDecodeError',
                    'raw_input_preview': raw_input[:200],
                    'debug': f'json_error_req_{request_count}'
                }
            
            debug_log("ì‘ë‹µ ì „ì†¡ ì‹œì‘")
            if send_eot_framed_response(response):
                debug_log(f"ìš”ì²­ #{request_count} ì²˜ë¦¬ ì™„ë£Œ")
            else:
                debug_log(f"ìš”ì²­ #{request_count} ì‘ë‹µ ì „ì†¡ ì‹¤íŒ¨")
            
        except EOFError:
            debug_log("EOFError - ì •ìƒ ì¢…ë£Œ")
            break
        except KeyboardInterrupt:
            debug_log("KeyboardInterrupt ê°ì§€")
            break
        except Exception as e:
            debug_log(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}")
            debug_log(f"ì—ëŸ¬ íƒ€ì…: {type(e).__name__}")
            debug_log(f"íŠ¸ë ˆì´ìŠ¤ë°±: {traceback.format_exc()}")
            
            error_response = {
                'id': command_id,  # ìˆ˜ì •: ì›ë˜ ìš”ì²­ ID ì‚¬ìš©
                'success': False,
                'error': str(e),
                'error_type': type(e).__name__,
                'traceback': traceback.format_exc(),
                'debug': f'critical_error_req_{request_count}'
            }
            
            try:
                send_eot_framed_response(error_response)
            except:
                debug_log("ì—ëŸ¬ ì‘ë‹µ ì „ì†¡ë„ ì‹¤íŒ¨")
    
    debug_log(f"JSON REPL ì¢…ë£Œ - ì´ {request_count}ê°œ ìš”ì²­ ì²˜ë¦¬")

# ============================================================================
# ğŸ¯ Public API ì‹œìŠ¤í…œ v3.0 - ì„ ë³„ì  ì„í¬íŠ¸ ê´€ë¦¬
# ============================================================================



class UltimateHelperProtection:
    """
    ê¶ê·¹ì˜ í—¬í¼ í•¨ìˆ˜ ë³´í˜¸ ì‹œìŠ¤í…œ v8.0 - ìë™ ì¶”ì  í†µí•©
    ëª¨ë“  í—¬í¼ í•¨ìˆ˜ í˜¸ì¶œì„ ìë™ìœ¼ë¡œ ì¶”ì í•˜ë©° ì ˆëŒ€ ë®ì–´ì“°ê¸° ë°©ì§€
    """
    
    def __init__(self, repl_globals_ref):
        self.repl_globals = repl_globals_ref
        self._protected_functions = {}
        self._protected_names = set()
        self._is_locked = False
        self._direct_wrappers = {}
        self._categories = {}
        self._auto_tracking_enabled = True
        self._call_count = {}  # í•¨ìˆ˜ë³„ í˜¸ì¶œ íšŸìˆ˜ ì¶”ì 
        
        # Context Manager í•¨ìˆ˜ë“¤ ì—°ê²°
        self._track_file_access = None
        self._track_function_edit = None
        self._track_code_analysis = None
        
        # Context Manager í•¨ìˆ˜ íƒìƒ‰
        if 'track_file_access' in self.repl_globals:
            self._track_file_access = self.repl_globals['track_file_access']
        if 'track_function_edit' in self.repl_globals:
            self._track_function_edit = self.repl_globals['track_function_edit']
        if 'track_code_analysis' in self.repl_globals:
            self._track_code_analysis = self.repl_globals['track_code_analysis']
            
        debug_log("UltimateHelperProtection v8.0 ì´ˆê¸°í™” - ìë™ ì¶”ì  í†µí•©")
    
    def register_helper(self, name, func, category="GENERAL"):
        """í—¬í¼ í•¨ìˆ˜ ì•ˆì „ ë“±ë¡ with ìë™ ì¶”ì """
        if self._is_locked:
            raise RuntimeError(f"ğŸš« ë³´í˜¸ ì‹œìŠ¤í…œ ì ê¹€: '{name}' ë“±ë¡ ë¶ˆê°€")
        
        # ë³´í˜¸ëœ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì— ì €ì¥
        self._protected_functions[name] = {
            'function': func,
            'category': category,
            'protected': True,
            'registered_at': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        self._protected_names.add(name)
        self._categories[category] = self._categories.get(category, []) + [name]
        self._call_count[name] = 0
        
        # ì½ê¸° ì „ìš© ì†ì„±ìœ¼ë¡œ ì„¤ì •
        setattr(self, name, func)
        
        # ìë™ ì¶”ì ì´ í¬í•¨ëœ wrapper ìƒì„±
        def create_tracking_wrapper(original_func, func_name, func_category):
            def wrapper(*args, **kwargs):
                # ë³´í˜¸ í™•ì¸
                if func_name not in self._protected_functions:
                    raise RuntimeError(f"ğŸš« í—¬í¼ í•¨ìˆ˜ '{func_name}'ì´ ì†ìƒë¨!")
                
                # í˜¸ì¶œ íšŸìˆ˜ ì¦ê°€
                self._call_count[func_name] += 1
                
                # ìë™ ì¶”ì  - íŒŒì¼ ê´€ë ¨ í•¨ìˆ˜
                if self._auto_tracking_enabled and self._track_file_access and 'project_context' in self.repl_globals:
                    project_context = self.repl_globals['project_context']
                    
                    # íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ ì‹œë„
                    file_path = None
                    if func_category == "FILE" and args:
                        # ì²« ë²ˆì§¸ ì¸ìê°€ íŒŒì¼ ê²½ë¡œì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
                        potential_path = str(args[0])
                        if os.path.exists(potential_path) or '\\' in potential_path or '/' in potential_path:
                            file_path = potential_path
                    
                    # íŒŒì¼ ì ‘ê·¼ ì¶”ì 
                    if file_path:
                        try:
                            action = func_name.replace('_', ' ')
                            self._track_file_access(project_context, file_path, action)
                            debug_log(f"ìë™ ì¶”ì : {func_name} â†’ {file_path}")
                        except Exception as track_error:
                            debug_log(f"ìë™ ì¶”ì  ì‹¤íŒ¨: {track_error}")
                
                # ì›ë³¸ í•¨ìˆ˜ ì‹¤í–‰
                try:
                    result = original_func(*args, **kwargs)
                    
                    # ê²°ê³¼ ê¸°ë°˜ ì¶”ê°€ ì¶”ì  (AST ë¶„ì„ ë“±)
                    if self._auto_tracking_enabled and func_category == "AST" and self._track_code_analysis:
                        if isinstance(result, dict) and result.get('parsing_success'):
                            try:
                                if 'project_context' in self.repl_globals and file_path:
                                    self._track_code_analysis(self.repl_globals['project_context'], file_path, result)
                                    debug_log(f"ìë™ ì½”ë“œ ë¶„ì„ ì¶”ì : {file_path}")
                            except:
                                pass
                    
                    return result
                    
                except Exception as e:
                    debug_log(f"í—¬í¼ í•¨ìˆ˜ {func_name} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
                    raise
                    
            wrapper.__name__ = func_name
            wrapper.__doc__ = f"ìë™ ì¶”ì  ë³´í˜¸ëœ í—¬í¼ í•¨ìˆ˜: {func_name}"
            wrapper._is_protected_helper = True
            wrapper._original_func = original_func
            return wrapper
        
        self._direct_wrappers[name] = create_tracking_wrapper(func, name, category)
        debug_log(f"í—¬í¼ í•¨ìˆ˜ '{name}' ({category}) ìë™ ì¶”ì  ë³´í˜¸ ë“±ë¡ ì™„ë£Œ")
        return True
    
    def enable_auto_tracking(self, enabled=True):
        """ìë™ ì¶”ì  í™œì„±í™”/ë¹„í™œì„±í™”"""
        self._auto_tracking_enabled = enabled
        debug_log(f"ìë™ ì¶”ì : {'í™œì„±í™”' if enabled else 'ë¹„í™œì„±í™”'}")
        return self._auto_tracking_enabled
    
    def get_call_statistics(self):
        """í•¨ìˆ˜ í˜¸ì¶œ í†µê³„ ë°˜í™˜"""
        return {
            'total_calls': sum(self._call_count.values()),
            'function_calls': dict(self._call_count),
            'most_used': max(self._call_count.items(), key=lambda x: x[1]) if self._call_count else None,
            'categories': {cat: sum(self._call_count.get(func, 0) for func in funcs) 
                          for cat, funcs in self._categories.items()}
        }
    
    def lock_system(self, enable_direct_access=True):
        """ë³´í˜¸ ì‹œìŠ¤í…œ ì˜êµ¬ ì ê¸ˆ"""
        self._is_locked = True
        
        if enable_direct_access:
            for name, wrapper in self._direct_wrappers.items():
                if name in self.repl_globals:
                    debug_log(f"'{name}'ì´ ì´ë¯¸ ì¡´ì¬ - ìë™ ì¶”ì  ë³´í˜¸ ë²„ì „ìœ¼ë¡œ ëŒ€ì²´")
                
                self.repl_globals[name] = wrapper
        
        debug_log(f"{len(self._protected_functions)}ê°œ í—¬í¼ í•¨ìˆ˜ ìë™ ì¶”ì  ì˜êµ¬ ë³´í˜¸ ì™„ë£Œ!")
        return True
    
    def __setattr__(self, name, value):
        """ì†ì„± ìˆ˜ì • ì°¨ë‹¨"""
        if hasattr(self, '_is_locked') and self._is_locked and name in self._protected_names:
            raise RuntimeError(f"ë³´í˜¸ëœ í—¬í¼ í•¨ìˆ˜ '{name}' ìˆ˜ì • ì ˆëŒ€ ë¶ˆê°€!")
        super().__setattr__(name, value)
    
    def __delattr__(self, name):
        """ì†ì„± ì‚­ì œ ì°¨ë‹¨"""
        if hasattr(self, '_is_locked') and self._is_locked and name in self._protected_names:
            raise RuntimeError(f"ë³´í˜¸ëœ í—¬í¼ í•¨ìˆ˜ '{name}' ì‚­ì œ ì ˆëŒ€ ë¶ˆê°€!")
        super().__delattr__(name)
    
    def get_protection_status(self):
        """ë³´í˜¸ ìƒíƒœ í™•ì¸"""
        return {
            'version': 'v8.0-auto-tracking',
            'total_protected': len(self._protected_functions),
            'protected_names': list(self._protected_names),
            'is_locked': self._is_locked,
            'categories': dict(self._categories),
            'auto_tracking_enabled': self._auto_tracking_enabled,
            'call_statistics': self.get_call_statistics()
        }



# ============================================================================
# ğŸš© í—¬í¼ í•¨ìˆ˜ ì´ˆê¸°í™” ìƒíƒœ ê´€ë¦¬ (ì¤‘ë³µ ë°©ì§€)
# ============================================================================

_helper_initialization_status = {
    'initialized': False,
    'in_progress': False,
    'timestamp': None,
    'source': None  # 'main_loop' or 'lazy_import'
}


def register_all_helpers(force_overwrite=False):
    """
    ğŸ›¡ï¸ í—¬í¼ í•¨ìˆ˜ ì ˆëŒ€ ë³´í˜¸ ì‹œìŠ¤í…œ v9.0 - ì¤‘ì•™í™”ëœ ë˜í¼ ì‹œìŠ¤í…œ
    ëª¨ë“  í—¬í¼ í•¨ìˆ˜ëŠ” auto_tracking_wrapperë¥¼ í†µí•´ ë“±ë¡ë©ë‹ˆë‹¤.
    
    Args:
        force_overwrite (bool): ê¸°ì¡´ ë³´í˜¸ ì‹œìŠ¤í…œì´ ìˆì„ ê²½ìš° ê°•ì œë¡œ ìƒˆë¡œ ìƒì„±
    """
    try:
        debug_log("=== ğŸ›¡ï¸ í—¬í¼ í•¨ìˆ˜ ì¤‘ì•™ ì¶”ì  ë³´í˜¸ ì‹œìŠ¤í…œ v9.0 ì‹œì‘ ===")
        
        # ê¸°ì¡´ ë³´í˜¸ ì‹œìŠ¤í…œì´ ìˆëŠ”ì§€ í™•ì¸
        if 'protection_system' in repl_globals and not force_overwrite:
            debug_log("ë³´í˜¸ ì‹œìŠ¤í…œì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤. force_overwrite=Trueë¡œ ìƒˆë¡œ ìƒì„± ê°€ëŠ¥")
            existing_status = repl_globals['protection_system'].get_protection_status()
            debug_log(f"ê¸°ì¡´ ë³´í˜¸ ìƒíƒœ: {existing_status['total_protected']}ê°œ í•¨ìˆ˜ ë³´í˜¸ë¨")
            debug_log(f"ìë™ ì¶”ì : {'í™œì„±í™”' if existing_status.get('auto_tracking_enabled') else 'ë¹„í™œì„±í™”'}")
            return {
                "success": True,
                "message": "ê¸°ì¡´ ë³´í˜¸ ì‹œìŠ¤í…œ ì‚¬ìš©",
                "protected_count": existing_status['total_protected'],
                "categories": existing_status['categories'],
                "auto_tracking": existing_status.get('auto_tracking_enabled', False)
            }
        
        # ìƒˆë¡œìš´ ë³´í˜¸ ì‹œìŠ¤í…œ ìƒì„±
        protection_system = UltimateHelperProtection(repl_globals)
        
        registered_functions = []
        failed_functions = []
        
        # í˜„ì¬ ë””ë ‰í† ë¦¬ë¥¼ sys.pathì— ì¶”ê°€
        import sys
        import os
        current_dir = os.path.dirname(__file__)
        if current_dir not in sys.path:
            sys.path.insert(0, current_dir)
        
        # 1. ì¤‘ì•™í™”ëœ ë˜í¼ ëª¨ë“ˆì„ ì„í¬íŠ¸í•©ë‹ˆë‹¤.
        try:
            import auto_tracking_wrapper
            debug_log("âœ… auto_tracking_wrapper v2.0 ì„í¬íŠ¸ ì„±ê³µ")
            
            # 2. __all__ ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ ëª¨ë“  ë˜í•‘ëœ í•¨ìˆ˜ë¥¼ ë™ì ìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.
            if hasattr(auto_tracking_wrapper, '__all__'):
                debug_log(f"âœ… {len(auto_tracking_wrapper.__all__)}ê°œ í•¨ìˆ˜ ë°œê²¬")
                
                for func_name in auto_tracking_wrapper.__all__:
                    if hasattr(auto_tracking_wrapper, func_name):
                        func = getattr(auto_tracking_wrapper, func_name)
                        
                        # ì¹´í…Œê³ ë¦¬ ìë™ ë¶„ë¥˜
                        category = "GENERAL"
                        if any(kw in func_name for kw in ['create', 'read', 'backup', 'restore', 'find', 'replace', 'insert']):
                            category = "FILE"
                        elif any(kw in func_name for kw in ['parse', 'snippet', 'analyze']):
                            category = "AST"
                        
                        # Protection Systemì— ë“±ë¡
                        protection_system.register_helper(func_name, func, category)
                        registered_functions.append(func_name)
                        debug_log(f"âœ… {func_name} ({category}) ë“±ë¡ ì™„ë£Œ")
                    else:
                        failed_functions.append(f"{func_name} (auto_tracking_wrapper)")
                        debug_log(f"âŒ {func_name} ë“±ë¡ ì‹¤íŒ¨")
            else:
                debug_log("âš ï¸ auto_tracking_wrapperì— __all__ì´ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                
        except ImportError as e:
            debug_log(f"âŒ auto_tracking_wrapper import ì‹¤íŒ¨: {e}")
            failed_functions.append("auto_tracking_wrapper ëª¨ë“ˆ ì „ì²´")
        
        # 3. ì¶”ê°€ í—¬í¼ í•¨ìˆ˜ë“¤ (Context Manager ë“±)
        if CONTEXT_MANAGER_AVAILABLE:
            try:
                import context_manager
                
                # ì‘ì—… ì¶”ì  í•¨ìˆ˜ë“¤
                tracking_functions = {
                    'track_file_access': 'TRACKING',
                    'track_function_edit': 'TRACKING',
                    'track_code_analysis': 'TRACKING',
                    'get_current_work_context': 'TRACKING',
                    'get_work_history': 'TRACKING',
                    'get_work_tracking_summary': 'TRACKING',
                    'get_most_accessed_files': 'TRACKING',
                    'get_most_edited_functions': 'TRACKING'
                }
                
                for func_name, category in tracking_functions.items():
                    if hasattr(context_manager, func_name):
                        func = getattr(context_manager, func_name)
                        protection_system.register_helper(func_name, func, category)
                        registered_functions.append(func_name)
                    else:
                        failed_functions.append(f"{func_name} (context_manager)")
                        
                # ìºì‹œ í•¨ìˆ˜ë“¤
                cache_functions = {
                    'update_cache': 'CACHE',
                    'update_file_cache': 'CACHE',
                    'get_cached_analysis': 'CACHE',
                    'validate_cache_entry': 'CACHE',
                    'get_cache_statistics': 'CACHE',
                    ''save_project_cache': 'CACHE',  # save_context ëŒ€ìš©'
                }
                
                for func_name, category in cache_functions.items():
                    if hasattr(context_manager, func_name):
                        func = getattr(context_manager, func_name)
                        protection_system.register_helper(func_name, func, category)
                        registered_functions.append(func_name)
                    else:
                        failed_functions.append(f"{func_name} (context_manager)")
                
                debug_log(f"Context Manager í•¨ìˆ˜ ë“±ë¡ ì™„ë£Œ")
                
            except ImportError as e:
                debug_log(f"context_manager import ì‹¤íŒ¨: {e}")
        
        # 4. ê²€ìƒ‰ í•¨ìˆ˜ë“¤
        try:
            import search_helpers
            
            search_functions = {
                'search_files_advanced': 'SEARCH',
                'search_code_content': 'SEARCH'
            }
            
            for func_name, category in search_functions.items():
                if hasattr(search_helpers, func_name):
                    func = getattr(search_helpers, func_name)
                    protection_system.register_helper(func_name, func, category)
                    registered_functions.append(func_name)
                else:
                    failed_functions.append(f"{func_name} (search_helpers)")
                    
        except ImportError as e:
            debug_log(f"search_helpers import ì‹¤íŒ¨: {e}")
        
        # 5. integrated_search ëª¨ë“ˆ
        try:
            from integrated_search import integrated_search
            protection_system.register_helper('integrated_search', integrated_search, "SEARCH")
            registered_functions.append('integrated_search')
            debug_log("âœ… integrated_search ë“±ë¡")
        except ImportError:
            failed_functions.append("integrated_search (integrated_search module)")
        
        # 6. Claude Memory í•¨ìˆ˜ë“¤
        try:
            def save_coding_experience(data, project_context=None, tech_stack=None):
                """ê°œë°œ ê²½í—˜ ì €ì¥ í•¨ìˆ˜"""
                try:
                    import json
                    import datetime as dt
                    
                    if project_context is None and 'project_context' in repl_globals:
                        project_context = repl_globals['project_context']
                    
                    experience_data = {
                        'timestamp': dt.datetime.now().isoformat(),
                        'data': data,
                        'project_context': project_context,
                        'tech_stack': tech_stack,
                        'importance': data.get('importance', 0.5) if isinstance(data, dict) else 0.5,
                        'type': 'coding_experience',
                        'session_id': project_context.get('session_id') if project_context else None
                    }
                    
                    if project_context:
                        if 'coding_experiences' not in project_context:
                            project_context['coding_experiences'] = []
                        project_context['coding_experiences'].append(experience_data)
                    
                    debug_log(f"ê²½í—˜ ì €ì¥ ì™„ë£Œ")
                    return {"success": True, "saved_at": experience_data['timestamp']}
                    
                except Exception as e:
                    debug_log(f"ê²½í—˜ ì €ì¥ ì‹¤íŒ¨: {e}")
                    return {"success": False, "error": str(e)}
            
            def search_coding_solutions(query, project_context=None, tech_stack=None):
                """í•´ê²°ì±… ê²€ìƒ‰ í•¨ìˆ˜"""
                try:
                    results = []
                    
                    if project_context is None and 'project_context' in repl_globals:
                        project_context = repl_globals['project_context']
                    
                    if project_context and 'coding_experiences' in project_context:
                        experiences = project_context['coding_experiences']
                        for exp in experiences:
                            if isinstance(exp.get('data'), dict):
                                exp_str = str(exp['data']).lower()
                                if any(keyword.lower() in exp_str for keyword in query.split()):
                                    results.append(exp)
                    
                    return {"success": True, "results": results, "query": query, "count": len(results)}
                    
                except Exception as e:
                    debug_log(f"í•´ê²°ì±… ê²€ìƒ‰ ì‹¤íŒ¨: {e}")
                    return {"success": False, "error": str(e)}
            
            claude_functions = {
                'save_coding_experience': save_coding_experience,
                'search_coding_solutions': search_coding_solutions
            }
            
            for func_name, func_impl in claude_functions.items():
                protection_system.register_helper(func_name, func_impl, "CLAUDE_MEMORY")
                registered_functions.append(func_name)
                
            debug_log("Claude Memory í•¨ìˆ˜ ë“±ë¡ ì™„ë£Œ")
                
        except Exception as claude_error:
            debug_log(f"Claude Memory í•¨ìˆ˜ ë“±ë¡ ì‹¤íŒ¨: {claude_error}")
        
        # 7. Session Manager ê´€ë ¨ í•¨ìˆ˜
        try:
            if 'SimpleSessionManager' in globals():
                protection_system.register_helper('SimpleSessionManager', 
                                                globals()['SimpleSessionManager'], 
                                                "SESSION")
                registered_functions.append('SimpleSessionManager')
                
            if 'session_manager' in repl_globals:
                sm = repl_globals['session_manager']
                session_utils = {
                    'save_session': sm.save_session,
                    'get_latest_session': sm.get_latest_session,
                    'list_sessions': sm.get_all_sessions
                }
                
                for func_name, func in session_utils.items():
                    protection_system.register_helper(func_name, func, "SESSION")
                    registered_functions.append(func_name)
                    
                debug_log("Session Manager í—¬í¼ í•¨ìˆ˜ ë“±ë¡ ì™„ë£Œ")
                
        except Exception as e:
            debug_log(f"Session Manager í—¬í¼ ë“±ë¡ ì‹¤íŒ¨: {e}")
        
        # 8. ìë™ ì¶”ì  í™œì„±í™”
        protection_system.enable_auto_tracking(True)
        debug_log("ìë™ ì¶”ì  ê¸°ëŠ¥ í™œì„±í™”")
        
        # 9. ë³´í˜¸ ì‹œìŠ¤í…œ ì ê¸ˆ ë° ì§ì ‘ ì ‘ê·¼ í™œì„±í™”
        protection_system.lock_system(enable_direct_access=True)
        
        # 10. ë³´í˜¸ ì‹œìŠ¤í…œì„ ê¸€ë¡œë²Œì— ë“±ë¡
        repl_globals['protection_system'] = protection_system
        
        # 11. ìµœì¢… ê²°ê³¼ ë³´ê³ 
        protection_status = protection_system.get_protection_status()
        total_expected = 40  # ì˜ˆìƒ í•¨ìˆ˜ ìˆ˜
        success_rate = (len(registered_functions) / total_expected) * 100 if total_expected > 0 else 0
        
        debug_log(f"=== í—¬í¼ í•¨ìˆ˜ ì¤‘ì•™ ì¶”ì  ë³´í˜¸ ì‹œìŠ¤í…œ v9.0 ì™„ë£Œ ===")
        debug_log(f"ë³´í˜¸ë¨: {len(registered_functions)}/{total_expected}ê°œ ({success_rate:.1f}%)")
        debug_log(f"ì‹¤íŒ¨: {len(failed_functions)}ê°œ")
        debug_log(f"ì˜êµ¬ ì ê¸ˆ: í™œì„±í™”")
        debug_log(f"ìë™ ì¶”ì : í™œì„±í™”")
        debug_log(f"ì¹´í…Œê³ ë¦¬: {list(protection_status['categories'].keys())}")
        
        return {
            "success": True,
            "version": "9.0-centralized-wrapper",
            "protection_system": "UltimateHelperProtection",
            "registered_count": len(registered_functions),
            "failed_count": len(failed_functions),
            "success_rate": success_rate,
            "registered_functions": registered_functions,
            "failed_functions": failed_functions,
            "categories": protection_status['categories'],
            "is_locked": protection_status['is_locked'],
            "auto_tracking_enabled": protection_status['auto_tracking_enabled'],
            "total_expected": total_expected
        }
        
    except Exception as e:
        debug_log(f"âŒ í—¬í¼ í•¨ìˆ˜ ì¤‘ì•™ ì¶”ì  ë³´í˜¸ ì‹œìŠ¤í…œ v9.0 ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        import traceback
        debug_log(f"ìƒì„¸ ì—ëŸ¬: {traceback.format_exc()}")
        return {
            "success": False,
            "error": str(e),
            "version": "9.0-centralized-wrapper",
            "traceback": traceback.format_exc()
        }

# register_all_helpersë¥¼ repl_globalsì— ë“±ë¡
repl_globals['register_all_helpers'] = register_all_helpers


# ============================================================================
# ì´ˆê¸°í™” ë° ë©”ì¸ ì‹¤í–‰
# ============================================================================

if __name__ == "__main__":
    debug_log("=== í†µí•© JSON REPL v3.0 Final ì‹œì‘ ===")
    debug_log(f"Python ë²„ì „: {sys.version}")
    debug_log(f"ì‘ì—… ë””ë ‰í† ë¦¬: {os.getcwd()}")
    debug_log(f"ì¸ì½”ë”©: stdin={sys.stdin.encoding}, stdout={sys.stdout.encoding}")
    debug_log(f"ì´ˆê¸° ì „ì—­ ë³€ìˆ˜: {list(repl_globals.keys())}")
    
    # ìƒˆë¡œìš´ ë¶€íŠ¸ìŠ¤íŠ¸ë© í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
    # ì„±ê³µí•˜ë©´ ì™„ë²½í•˜ê²Œ ì„¤ì •ëœ ì»¨í…ìŠ¤íŠ¸ê°€, ì‹¤íŒ¨í•˜ë©´ Noneì´ ë°˜í™˜ë©ë‹ˆë‹¤.
    bootstrap_context = bootstrap_ai_brain_session({'verbose': True})
    
    # init_helpers_sync() í˜¸ì¶œì„ ì™„ì „íˆ ì œê±°í•˜ì—¬ ì¤‘ë³µì„ ì—†ì•±ë‹ˆë‹¤.
    
    if bootstrap_context:
        # bootstrapì´ ì„±ê³µí–ˆì„ ë•Œë§Œ ë©”ì¸ ë£¨í”„ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
        debug_log("âœ… Bootstrap ì™„ë£Œ - ë©”ì¸ ë£¨í”„ ì‹œì‘")
        try:
            main_loop()
        except Exception as e:
            debug_log(f"ë©”ì¸ ë£¨í”„ í¬ë¦¬í‹°ì»¬ ì—ëŸ¬: {e}")
            debug_log(f"íŠ¸ë ˆì´ìŠ¤ë°±: {traceback.format_exc()}")
    else:
        # bootstrap ë‚´ë¶€ì—ì„œ ì´ë¯¸ ìƒì„¸í•œ ì˜¤ë¥˜ ë¡œê·¸ë¥¼ ì¶œë ¥í–ˆìœ¼ë¯€ë¡œ ê°„ë‹¨íˆ ì¢…ë£Œí•©ë‹ˆë‹¤.
        debug_log("âŒ CRITICAL: AI ë¸Œë ˆì¸ ë¶€íŠ¸ìŠ¤íŠ¸ë©ì— ì‹¤íŒ¨í•˜ì—¬ ì„¸ì…˜ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    debug_log("=== JSON REPL ì„¸ì…˜ ì¢…ë£Œ ===")
